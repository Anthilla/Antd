flush ruleset;
table ip filter {
        chain input {
                type filter hook input priority 0;
                ct state @ipfilinstate accept
                ct state invalid counter log prefix "a=Ip4DroTfilCinRctinvalid " drop
                ip protocol @protoset accept
                icmp type echo-request accept
                udp dport @udpportset accept
                iif @ipfilinipiif accept
                tcp dport ssh accept
                tcp dport @tcpportset accept
                ip daddr @eifaddr ct state @ipfilinipdaddrstate accept
                ip saddr @iifaddr accept
                ip saddr @eifaddr accept
                ip saddr @ipfilinipdsaddrnetaccept accept
                ip daddr @ipfilinipddaddrnetaccep accept
                ip daddr @eifaddr tcp dport @pubsvcset accept
                ip saddr @wanifaddr ip daddr @ipfilinipdsaddripdrop drop
                counter log prefix "a=Ip4DroTfilCinRdef " drop
        }

        chain output {
                type filter hook output priority 0;
                ct state @ipfiloutstate accept
                ct state invalid counter log prefix "a=Ip4AccTfilCouRctinvalid " accept
                ip protocol @protoset accept
                icmp type echo-request accept
                udp dport @udpportset accept
                iif @ipfiloutipiif accept
                oif @ipfiloutipoif ct state new accept
                ip saddr @iifaddr accept
                ip saddr @eifaddr accept
                ip saddr @ipfiloutipdsaddrnetaccept accept
                ip daddr @ipfiloutipddaddrnetaccept accept
                counter log prefix "a=Ip4DroTfilCouRdef " drop
        }

        chain forward {
                type filter hook forward priority 0;
                ct state @ipfilfwstate accept
                ct state invalid counter log prefix "a=Ip4AccTfilCfwRctinvalid " accept
                ip protocol @protoset accept
                icmp type echo-request accept
                udp dport @udpportset accept
                iif @ipfilfwipiif accept
                iif @ipfilfwipiif oif @ipfilfwipoif accept
                ip saddr @iifaddr accept
                ip daddr @iifaddr tcp dport @tcpportset accept
                ip daddr @iifaddr udp dport @udpportset accept
                ip daddr @iifaddr iif @ipfilfwipiifdaddraccept accept
                iif @ipfilfwipiifaccept @ipfilfwipoifaccept accept
                iif @ipfilfwiptcpiif1 oif @ipfilfwiptcpoif1 ip daddr @ipfilfwiptcpdaddr1 tcp dport @ipfilfwiptcpport1 accept
                iif @ipfilfwiptcpiif2 oif @ipfilfwiptcpoif2 ip daddr @ipfilfwiptcpdaddr2 tcp dport @ipfilfwiptcpport2 accept
                iif @ipfilfwipoifdrop ct state new counter log prefix "a=DroTfilCfwRctnewwan " drop
                counter log prefix "a=Ip4DroTfilCfwRdef " drop
        }

}
table ip nat {
        chain prerouting {
                 type nat hook prerouting priority 0;
                 iif @ipnatpreiif1 tcp dport @ipnatpreport1 dnat @ipnatprednat1
                 iif @ipnatpreiif2 tcp dport @ipnatpreport2 dnat @ipnatprednat2
                 tcp dport @ipnatpreportredirect redirect to @ipnatpreportredirectto
                 accept
        }

        chain input {
                 type nat hook input priority 0;
                 accept
        }

        chain output {
                 type nat hook output priority 0;
                 accept
        }

        chain postrouting {
                 type nat hook postrouting priority 0;
                 ip saddr @ipnatpostnet1 oif @ipnatpostoif1 snat @ipnatpostip1
                 ip saddr @ipnatpostnet2 oif @ipnatpostoif2 snat @ipnatpostip2
                 masquerade
                 oif @ipnatpostoifmask ip saddr @ipnatpostnetmask masquerade
                 accept
        }
}

table ip6 filter6 {
        chain input {
                 type filter hook input priority 0;
                 ct state { established, related} accept
                 ct state invalid counter packets 0 bytes 0 log prefix "a=Ip6DroTfilCinRctinvalid " drop
                 ip6 nexthdr ipv6-icmp accept
                 icmpv6 type { echo-request, nd-neighbor-solicit} accept
                 iif { br1, br0, lo} accept
                 iif { br1, br0, lo} ct state new accept
                 iif { br1, br0} tcp sport { ftp, ftp-data} ct state new accept
                 tcp dport { ssh, http} accept
                 counter packets 0 bytes 0 log prefix "a=Ip6DroTfilCinRdef " drop
        }

        chain output {
                 type filter hook output priority 0;
                 ct state { established, related} accept
                 ct state invalid counter packets 0 bytes 0 log prefix "a=Ip4DroTfilCouRctinvalid " drop
                 iif { br0, br1, lo} accept
                 iif { br1, br0, lo} ct state new accept
                 oif { eth11, lo, eth10} accept
                 counter packets 0 bytes 0 log prefix "a=Ip6DroTfilCouRdef " drop
        }

        chain forward {
                 type filter hook forward priority 0;
                 counter log prefix "a=Ip6DroTfilCfwRdef " drop
        }
}
table ip6 nat6 {
        chain prerouting {
                 type nat hook prerouting priority 0;
                 accept
        }

        chain input {
                 type nat hook input priority 0;
                 accept
        }

        chain output {
                 type nat hook output priority 0;
                 accept
        }

        chain postrouting {
                 type nat hook postrouting priority 0;
                 accept
        }
}
