flush ruleset;
table ip filter {
        chain input {
                type filter hook input priority 0;
                ct state $ipfilinstate accept
                ct state invalid counter log prefix "a=Ip4DroTfilCinRctinvalid " drop
                ip protocol $ipfilinprotoset accept
                icmp type echo-request accept
                udp dport $ipfilinudpportset accept
                iif $ipfiliniif accept
                tcp dport ssh accept
                tcp dport $ipfilintcpportset accept
                ip daddr $ipfilineifaddr ct state $ipfilindaddrstate accept
                ip saddr $ipfiliniifaddr accept
                ip saddr $ipfilouteifaddr accept
                ip saddr $ipfilinsaddrnetaccept accept
                ip daddr $ipfilinipddaddrnetaccep accept
                ip daddr $ipfilineifaddr tcp dport $ipfilinpubsvcset accept
                ip saddr $ipfilinwanifaddr ip daddr $ipfilinsaddripdrop drop
                counter log prefix "a=Ip4DroTfilCinRdef " drop
        }

        chain output {
                type filter hook output priority 0;
                ct state $ipfiloutstate accept
                ct state invalid counter log prefix "a=Ip4AccTfilCouRctinvalid " accept
                ip protocol $ipfiloutprotoset accept
                icmp type echo-request accept
                udp dport $ipfiloutudpportset accept
                iif $ipfiloutiif accept
                oif $ipfiloutoif ct state new accept
                ip saddr $ipfiloutiifaddr accept
                ip saddr $ipfilouteifaddr accept
                ip saddr $ipfiloutsaddrnetaccept accept
                ip daddr $ipfiloutdaddrnetaccept accept
                counter log prefix "a=Ip4DroTfilCouRdef " drop
        }

        chain forward {
                type filter hook forward priority 0;
                ct state $ipfilfwstate accept
                ct state invalid counter log prefix "a=Ip4AccTfilCfwRctinvalid " accept
                ip protocol $ipfilfwprotoset accept
                icmp type echo-request accept
                udp dport $ipfilfwudpportset accept
                iif $ipfilfwiif accept
                iif $ipfilfwiif oif $ipfilfwoif accept
                ip saddr $ipfilfwiifaddr accept
                ip daddr $ipfilfwiifaddr tcp dport $ipfilfwtcpportset accept
                ip daddr $ipfilfwiifaddr udp dport $ipfilfwudpportset accept
                ip daddr $ipfilfwiifaddr iif $ipfiliniifdaddraccept accept
                iif $ipfilfwiifaccept $ipfilfwipoifaccept accept
                iif $ipfilfwiptcpiif1 oif $ipfilfwiptcpoif1 ip daddr $ipfilfwiptcpdaddr1 tcp dport $ipfilfwiptcpport1 accept
                iif $ipfilfwiptcpiif2 oif $ipfilfwiptcpoif2 ip daddr $ipfilfwiptcpdaddr2 tcp dport $ipfilfwiptcpport2 accept
                iif $ipfilfwoifdrop ct state new counter log prefix "a=DroTfilCfwRctnewwan " drop
                counter log prefix "a=Ip4DroTfilCfwRdef " drop
        }

}
table ip nat {
        chain prerouting {
                 type nat hook prerouting priority 0;
                 iif $ipnatpreiif1 tcp dport $ipnatpreport1 dnat $ipnatprednat1
                 iif $ipnatpreiif2 tcp dport $ipnatpreport2 dnat $ipnatprednat2
                 tcp dport $ipnatpreportredirect redirect to $ipnatpreportredirectto
                 accept
        }

        chain input {
                 type nat hook input priority 0;
                 accept
        }

        chain output {
                 type nat hook output priority 0;
                 accept
        }

        chain postrouting {
                 type nat hook postrouting priority 0;
                 ip saddr $ipnatpostnet1 oif $ipnatpostoif1 snat $ipnatpostip1
                 ip saddr $ipnatpostnet2 oif $ipnatpostoif2 snat $ipnatpostip2
                 masquerade
                 oif $ipnatpostoifmask ip saddr $ipnatpostnetmask masquerade
                 accept
        }
}

table ip6 filter6 {
        chain input {
                 type filter hook input priority 0;
                 ct state { established, related} accept
                 ct state invalid counter packets 0 bytes 0 log prefix "a=Ip6DroTfilCinRctinvalid " drop
                 ip6 nexthdr ipv6-icmp accept
                 icmpv6 type { echo-request, nd-neighbor-solicit} accept
                 iif { br1, br0, lo} accept
                 iif { br1, br0, lo} ct state new accept
                 iif { br1, br0} tcp sport { ftp, ftp-data} ct state new accept
                 tcp dport { ssh, http} accept
                 counter packets 0 bytes 0 log prefix "a=Ip6DroTfilCinRdef " drop
        }

        chain output {
                 type filter hook output priority 0;
                 ct state { established, related} accept
                 ct state invalid counter packets 0 bytes 0 log prefix "a=Ip4DroTfilCouRctinvalid " drop
                 iif { br0, br1, lo} accept
                 iif { br1, br0, lo} ct state new accept
                 oif { eth11, lo, eth10} accept
                 counter packets 0 bytes 0 log prefix "a=Ip6DroTfilCouRdef " drop
        }

        chain forward {
                 type filter hook forward priority 0;
                 counter log prefix "a=Ip6DroTfilCfwRdef " drop
        }
}
table ip6 nat6 {
        chain prerouting {
                 type nat hook prerouting priority 0;
                 accept
        }

        chain input {
                 type nat hook input priority 0;
                 accept
        }

        chain output {
                 type nat hook output priority 0;
                 accept
        }

        chain postrouting {
                 type nat hook postrouting priority 0;
                 accept
        }
}
