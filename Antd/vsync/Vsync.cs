// <copyright file="Vsync.cs" company="Kenneth P. Birman">
// Vsync System, V2.2.$Rev: 2032 $, Developed by Kenneth P. Birman, (c) 2010 - 2014. All rights reserved.
//       This code is subject to copyright and other intellectual property restrictions and
//       may be used only under license from Dr. Birman or his designated agents.
//
// It is a violation of international intellectual property protection laws to remove this notice.
//
// Dr. Birman has elected to grant Cornell University and other researchers the right to experiment with Vsync and
// to create a derived version Vsync V2.2.xxxx (and other future versions, using the same version numbering scheme)
//
// Dr. Birman and Cornell University intend to place Vsync V1.x.xxxx and V2.x.xxxx into the public domain, in the
// manner described below, and subject to licensing provisions intended to protect Dr. Birman and Cornell from
// any responsibility for consequences of the use of this technology, even when used precisely as intended.
//
// Vsync is a free research product, created at Cornell University by Dr. Birman with some help from his
// students.  It has not been subjected to a professional quality assurance or professional testing process
// of the kind normally used in life or safety-critical systems, although we have used it fairly extensively
// for several years now.  But this implies that if you intend to use Vsync in such a setting, you take on
// an obligation to do a stringent level of testing, to gain the maximum assurance feasible that the system,
// as it will be used in your target setting, achieves the properties required for safe and correct operations.
// Cornell can't warrant the appropriateness or correctness of Vsync for these kinds of very demanding uses.
// Only a high quality of analysis of the target setting, the proposed use, and then a very thorough quality
// assurance process can justify that sort of application.  Further, we recommend very strongly that you design
// for "fail safe" operations: if the application that uses Vsync shuts down (for example due to network
// partitioning failures of a kind Vsync can't handle automatically), your end-user should still be promised
// safety. 
//
// Vsync is a renamed version of Isis2, with the name changed intended to distance our work from any association
// with the terrorist group that uses the Isis name.  No other change was made: this code is just the Isis2 code
// with a global edit to rename everything called ISIS as VSYNC, Isis as Vsync, and Isis2 as Vsync.
//
// Licensing terms for Vsync v1.x.xxxx and v2.x.xxxx use freeBSD license language and include indemnification 
// whereby the end user holds Dr. Birman and Cornell harmless for any and all uses of this technology.  Dr.
// Birman and Cornell University are not aware of any external patents, copyrights or trademarks
// that might be required by users of the Vsync system, but have not conducted a
// thorough patent search and are not able to guarantee that no such licenses exist.  The end user accepts
// full responsibility to obtain any needed licenses required for the conduct of their work with this
// system, and holds Cornell harmless even in the event that Vsync itself is found to infringe some
// patent, copyright or trademark.  Cornell holds no patents that read on the Vsync technology and is not
// planning to seek patents on this work, nor is Dr. Birman personally.  Indeed, because of the extensive
// track record of publications in this area over a period of some 30 years, it seems unlikely that patents
// could be obtained on the technology by any party.  Nonetheless, Cornell (and Dr. Birman) cannot guarantee
// that this technology doesn't infringe any existing or future patent.  Should licenses be required on any
// existing or future technology, the user of Vsync, and not Dr. Birman or Cornell, has sole responsibility
// to negotiate such licenses and to pay any associated fees.
//
// Source code access may, in some cases, be granted to facilitate code maintanence.  Contact Dr. Birman
// for details.
//
// Dr. Birman and Cornell assert no ownership interest of any kind in applications developed using Vsync,
// as distinct from the Vsync system per-se.  Example applications included in the Vsync documentation may be
// copied, modified and incorporated into end-user applications without limitation or restriction: they are
// treated as public domain material.
//
// At the present time, Dr. Birman and his group at Cornell are providing support for this technology.  No
// committment, implied or explicit, is made to resolve any particular issue or to fix any particular bug.
// Like any complex technology, the user should expect Vsync to have some bugs, perhaps serious, and should
// be aware that precisely because this is a free technology, support may be slow, frustrating, and may
// not lead to a successful resolution of the issue.  Vsync is not a product, and there are no current plans
// to create a commercial product in this space.
//
// Dr. Birman reserves version numbers in the v1.x.xxxx range for versions of the system created by him
// privately, outside of his Cornell employment.  Vsync versions in the v2.x.xxxx range are reserved
// for binary and code releases by the Cornell group headed by Dr. Birman and Dr. Robbert van Renesse.
//
// Please contact Dr. Birman at 607-255-9199 if you have any questions about the use of this technology.
// His email is ken@cs.cornell.edu and his web site is http://www.cs.cornell.edu/ken
//
// *******************************************************************************************
// A few comments on coding conventions used here
//       First, this code is extremely multithreaded and the threading and protection logic is key to correctness
//             Don't understand that logic?  Don't touch this code!
//       The C# lock statement didn't mix well with my use of thread priorities; use 
//                                       using(LockAndElevate(lock-object)) { ... }
//       Vsync has its own locking infrastructure for coarse-grained long-lived locks; use these for that sort of thing
// ********************************************************************************************
// </copyright>

////#define PROTOCOL_BUFFERS // Enable Google's Protocol Buffers support via protobuf-net.

////#define __MonoCS__ // Similarly, should be automatically set, needed when compiling for C# on Linux via Mono

// The DEFINEs that follow are useful in debugging but not for production runs.  Some can be VERY slow
//#define TRACKLOCKINFO // If defined, tracks lock information, warns about apparent deadlocks or priority inversions
//#define TRACKLOCKINGORDER // If both are defined, watches for potential lock ordering issues (e.g. usually any single thread locks A before B, but now B was locked, then A).  Broken in .NET4
//#define EXTRACTCALLSTACKS // A risky and expensive .NET mechanism that can extract the call stack but sometimes seems to trigger deadlocks or other exceptions
//#define WARN_ON_LONG_DELAYS // Useful if locking problems are suspected in message handlers

// Because Debug is a constant, we disable what would otherwise be 1000s of warnings
#pragma warning disable 0162
#pragma warning disable 0429

namespace Vsync {
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.IO.MemoryMappedFiles;
    using System.Linq;
    using System.Linq.Expressions;
    using System.Net;
    using System.Net.NetworkInformation;
    using System.Net.Sockets;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Security;
    using System.Security.Cryptography;
    using System.Security.Permissions;
    using System.Text;
    using System.Threading;

#if PROTOCOL_BUFFERS
    using ProtoBuf;
    using ProtoBuf.Meta;
#endif

    /// <summary>
    /// General purpose exception
    /// </summary>
    /// <remarks>The fatal exceptions also cause Vsync to shut down</remarks>
    [Serializable]
    public class VsyncException : Exception {
        /// <summary>
        /// General purpose exception constructor
        /// </summary>
        /// <param name="s">Reason for the exception</param>
        public VsyncException(string s)
            : base(s) {
            if (!VsyncSystem.VsyncActive && VsyncSystem.VsyncWasActive) {
                return;
            }

            VsyncSystem.WriteAckInfo();
            VsyncSystem.Shutdown(s);
        }

        /// <summary>
        /// General purpose exception constructor
        /// </summary>
        /// <param name="s">String describing the problem</param>
        /// <param name="e">Ret exception</param>
        public VsyncException(string s, Exception e)
            : base(s, e) {
            if (!VsyncSystem.VsyncActive && VsyncSystem.VsyncWasActive) {
                return;
            }

            VsyncSystem.WriteAckInfo();
            VsyncSystem.Shutdown(s);
        }
    }

    /// <summary>
    /// General purpose Client exception
    /// </summary>
    [Serializable]
    public class VsyncClientException : Exception {
        /// <summary>
        /// General purpose exception constructor
        /// </summary>
        /// <param name="s">Reason for the exception</param>
        public VsyncClientException(string s)
            : base(s) {
        }
    }

    /// <summary>
    /// General purpose DHT exception
    /// </summary>
    [Serializable]
    public class VsyncDHTException : Exception {
        /// <summary>
        /// General purpose exception constructor
        /// </summary>
        /// <param name="s">Reason for the exception</param>
        public VsyncDHTException(string s)
            : base(s) {
        }
    }

    /// <summary>
    /// Thrown by disklogger when SafeSend is employed without first setting the SafeSendThreshold, or
    /// if the number of members of the group isn't at least SafeSendThreshold when multicasts are sent
    /// </summary>
    [Serializable]
    public class SafeSendException : Exception {
        /// <summary>
        /// General purpose exception constructor
        /// </summary>
        /// <param name="s">Reason for the exception</param>
        public SafeSendException(string s)
            : base(s) {
            VsyncSystem.WriteAckInfo();
            VsyncSystem.Shutdown(s);
        }
    }

    /// <summary>
    /// General purpose exception
    /// </summary>
    /// <remarks>The fatal exceptions also cause Vsync to shut down</remarks>
    [Serializable]
    public class RejectedMessageException : Exception {
        /// <summary>
        /// Message rejected by Vsync because of a signature problem
        /// </summary>
        /// <param name="s">Reason for the exception</param>
        public RejectedMessageException(string s)
            : base(s) {
        }
    }

    /// <summary>
    /// Aggregation failure exception
    /// </summary>
    [Serializable]
    public class AggregationFailedException : Exception {
        private readonly int reasonCode;

        /// <summary>
        /// Aggregaton failure exception constructor
        /// </summary>
        public AggregationFailedException(int reasonCode) {
            this.reasonCode = reasonCode;
        }

        /// <exclude></exclude>
        protected AggregationFailedException(SerializationInfo info, StreamingContext context)
            : base(info, context) {
            this.reasonCode = (int)info.GetValue("reasonCode", typeof(int));
        }

        /// <exclude></exclude>
        public int ReasonCode
        {
            get
            {
                return this.reasonCode;
            }
        }

        /// <exclude></exclude>
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            base.GetObjectData(info, context);
            info.AddValue("reasonCode", this.reasonCode);
        }
    }

    /// <summary>
    /// Thrown if an AbortReply is received
    /// </summary>
    [Serializable]
    public class VsyncAbortReplyException : Exception {
        /// <summary>
        /// Constructor for AbortReply exceptions
        /// </summary>
        /// <param name="s"></param>
        public VsyncAbortReplyException(string s)
            : base(s) {
        }
    }

    /// <summary>
    /// Thrown if a SafeSend can't complete because the group has fewer than SafeSendThreshold members
    /// </summary>
    [Serializable]
    public class VsyncSafeSendException : Exception {
        /// <summary>
        /// Constructor for AbortReply exceptions
        /// </summary>
        /// <param name="s"></param>
        public VsyncSafeSendException(string s)
            : base(s) {
        }
    }

    [Serializable]
    internal class MCMDException : Exception {
        public MCMDException(string s)
            : base(s) {
            VsyncSystem.Shutdown(s);
        }
    }

    /// <summary>
    /// Thrown if a Join-only operation can't find a preexisting group with the right name or address
    /// </summary>
    [Serializable]
    public class GroupNotFoundException : Exception {
        /// <summary>
        /// Constructor for GroupNotFoundException exceptions
        /// </summary>
        /// <param name="s">Reason for the problem</param>
        public GroupNotFoundException(string s)
            : base(s) {
            VsyncSystem.Shutdown(s);
        }
    }

    /// <summary>
    /// Thrown when Vsync is shutting down
    /// </summary>
    [Serializable]
    public class VsyncShutdownException : Exception {
        /// <summary>
        /// Constructor for VsyncShutdownException exceptions
        /// </summary>
        /// <param name="s">Reason Vsync shut itself down</param>
        public VsyncShutdownException(string s)
            : base(s) {
            if (VsyncSystem.shuttingDown) {
                VsyncSystem.AbandonShip();
            }

            VsyncSystem.Shutdown();
        }
    }

    /// <summary>
    /// Type signature for an Vsync ViewHandler callback method
    /// </summary>
    /// <param name="v"></param>
    public delegate void ViewHandler(View v);

    /// <summary>
    /// Type signature for an Vsync universal callback method
    /// </summary>
    /// <param name="objs"></param>
    public delegate void UCallback(object[] objs);

    /// <summary>
    /// Type signature for an Vsync CheckPtMaker callback method.  Creates new checkpoints
    /// </summary>
    /// <param name="v"></param>
    public delegate void ChkptMaker(View v);

    /// <summary>
    /// If defined, returns true if this member will send the checkpoint to the joiners, and false if not.
    /// </summary>
    /// <param name="v">The new view of the group</param>
    /// <param name="who">A specific joiner for whom the question is being posed</param>
    /// <returns>True if the member in which the call was done is responsible for sending the checkpoint for the specified joiner.</returns>
    /// <remarks>By default, when a new view is defined all members evaluate v.IAmLeader() and the (single) leader creates the checkpoint used to initialize (all) the joiners.
    /// That is, a single checkpoint is made, by a single member, and a copy is delivered to each joiner.  However, you can override this behavior if desired.
    /// When you do so, by defining the ChkptChoser(), Vsync does a parallel evaluation of this method in every current group member.  For each joiner, a single
    /// member will be picked to send a checkpoint to it.  All others must return false.  If nobody returns true, the joiner will hang waiting for
    /// a checkpoint that will never arrive.  If a failure disrupts the checkpoint transfer, the joiner will throw a "Join failed" exception.
    /// </remarks>
    public delegate bool ChkptChoser(View v, Address who);

    /// <summary>
    /// Type signature for an Vsync group initializer callback method
    /// </summary>
    public delegate void Initializer();

    /// <summary>
    /// Type signature for an Vsync Timer callback handler method
    /// </summary>
    public delegate void TimerCallback();

    /// <summary>
    /// Type signature for an Vsync Watch callback handler method
    /// </summary>
    /// <param name="ev">The event (W_JOIN or W_LEAVE)</param>
    public delegate void Watcher(int ev);

    /// <summary>
    /// Signature for the callback in a master when a new worker registers via RunAsWorker()
    /// </summary>
    /// <param name="who"></param>
    public delegate void NewWorker(Address who);

    /// <summary>
    /// Type signature for a SafeSend logging method, used to ensure the durability of SafeSend multicasts
    /// </summary>
    /// <param name="m">A pending SafeSend message, not yet committed for delivery</param>
    public delegate void durabilityMethod(Msg m);

    /// <summary>
    /// Callback on broken lock
    /// </summary>
    /// <param name="why">LOCK_TRANSFER (to rank 0 member) or LOCK_BROKEN</param>
    /// <param name="name">Lock name</param>
    /// <param name="holder">Previous lock holder</param>
    public delegate void LockBroken(int why, string name, Address holder);

    /// <summary>
    /// Signature for the Vsync logging callback
    /// </summary>
    /// <param name="LEvent">Event types, as defined in Group</param>
    /// <param name="StartorDone">IL_START or IL_DONE</param>
    /// <param name="sender">The process that initiated this operation</param>
    /// <param name="LId">An identifier to match START and DONE events and track queries</param>
    /// <param name="args">Parameters for this type of event</param>
    public delegate void ILFunc(int LEvent, int StartorDone, Address sender, long LId, params object[] args);

    internal class Callable {
        internal int nParams;

        internal Type[] ptypes;

        internal Delegate hisCb;

        internal Delegate cb;

        internal Callable(Delegate hisCb) {
            this.hisCb = hisCb;
            MethodInfo mi = hisCb.GetType().GetMethod("Invoke");
            ParameterInfo[] pi = mi.GetParameters();
            this.ptypes = pi.Select(p => p.ParameterType).ToArray();
            this.nParams = this.ptypes.Length;
#if !(__MonoCS__  || ___ANDROID__) // VN
            try {
                if (this.nParams == 0) {
                    this.cb = Delegate.CreateDelegate(typeof(Action), hisCb.Target, hisCb.Method, false);
                }
                else if (this.nParams <= 16) {
                    this.cb = Delegate.CreateDelegate(Expression.GetActionType(this.ptypes), hisCb.Target, hisCb.Method, false);
                    if (this.cb == null) {
                        Type rtype = hisCb.GetType().GetMethod("Invoke").ReturnType;

                        // Callback to a function method; used in the DHTPutCollisionResolver logic
                        Vsync.ArrayResize(ref this.ptypes, this.ptypes.Length + 1);
                        this.ptypes[this.ptypes.Length - 1] = rtype;
                        this.cb = Delegate.CreateDelegate(Expression.GetFuncType(this.ptypes), hisCb.Target, hisCb.Method, false);
                    }
                }
            }
            catch (ArgumentException e) {
                // If we get a "MethodInfo must be a runtime MethodInfo object." error, use old way, otherwise propegate exception
                if (e.ParamName == null || !e.ParamName.Equals("method", StringComparison.Ordinal)) {
                    throw;
                }
            }

#else
            this.cb = null;
#endif
        }

        internal void doUpcall(object[] args) {
            if (args.Length != this.nParams) {
                throw new ArgumentException("Argument count must match number of parameters");
            }

#if !(__MonoCS__ || ___ANDROID__) // VN
            if (this.cb != null) {
                switch (this.nParams) {
                    case 0:
                        ((dynamic)this.cb).Invoke();
                        break;
                    case 1:
                        ((dynamic)this.cb).Invoke((dynamic)args[0]);
                        break;
                    case 2:
                        ((dynamic)this.cb).Invoke((dynamic)args[0], (dynamic)args[1]);
                        break;
                    case 3:
                        ((dynamic)this.cb).Invoke((dynamic)args[0], (dynamic)args[1], (dynamic)args[2]);
                        break;
                    case 4:
                        ((dynamic)this.cb).Invoke((dynamic)args[0], (dynamic)args[1], (dynamic)args[2], (dynamic)args[3]);
                        break;
                    case 5:
                        ((dynamic)this.cb).Invoke((dynamic)args[0], (dynamic)args[1], (dynamic)args[2], (dynamic)args[3], (dynamic)args[4]);
                        break;
                    case 6:
                        ((dynamic)this.cb).Invoke((dynamic)args[0], (dynamic)args[1], (dynamic)args[2], (dynamic)args[3], (dynamic)args[4], (dynamic)args[5]);
                        break;
                    case 7:
                        ((dynamic)this.cb).Invoke((dynamic)args[0], (dynamic)args[1], (dynamic)args[2], (dynamic)args[3], (dynamic)args[4], (dynamic)args[5], (dynamic)args[6]);
                        break;
                    case 8:
                        ((dynamic)this.cb).Invoke((dynamic)args[0], (dynamic)args[1], (dynamic)args[2], (dynamic)args[3], (dynamic)args[4], (dynamic)args[5], (dynamic)args[6], (dynamic)args[7]);
                        break;
                    case 9:
                        ((dynamic)this.cb).Invoke((dynamic)args[0], (dynamic)args[1], (dynamic)args[2], (dynamic)args[3], (dynamic)args[4], (dynamic)args[5], (dynamic)args[6], (dynamic)args[7], (dynamic)args[8]);
                        break;
                    case 10:
                        ((dynamic)this.cb).Invoke((dynamic)args[0], (dynamic)args[1], (dynamic)args[2], (dynamic)args[3], (dynamic)args[4], (dynamic)args[5], (dynamic)args[6], (dynamic)args[7], (dynamic)args[8], (dynamic)args[9]);
                        break;
                    case 11:
                        ((dynamic)this.cb).Invoke((dynamic)args[0], (dynamic)args[1], (dynamic)args[2], (dynamic)args[3], (dynamic)args[4], (dynamic)args[5], (dynamic)args[6], (dynamic)args[7], (dynamic)args[8], (dynamic)args[9], (dynamic)args[10]);
                        break;
                    case 12:
                        ((dynamic)this.cb).Invoke((dynamic)args[0], (dynamic)args[1], (dynamic)args[2], (dynamic)args[3], (dynamic)args[4], (dynamic)args[5], (dynamic)args[6], (dynamic)args[7], (dynamic)args[8], (dynamic)args[9], (dynamic)args[10], (dynamic)args[11]);
                        break;
                    case 13:
                        ((dynamic)this.cb).Invoke((dynamic)args[0], (dynamic)args[1], (dynamic)args[2], (dynamic)args[3], (dynamic)args[4], (dynamic)args[5], (dynamic)args[6], (dynamic)args[7], (dynamic)args[8], (dynamic)args[9], (dynamic)args[10], (dynamic)args[11], (dynamic)args[12]);
                        break;
                    case 14:
                        ((dynamic)this.cb).Invoke((dynamic)args[0], (dynamic)args[1], (dynamic)args[2], (dynamic)args[3], (dynamic)args[4], (dynamic)args[5], (dynamic)args[6], (dynamic)args[7], (dynamic)args[8], (dynamic)args[9], (dynamic)args[10], (dynamic)args[11], (dynamic)args[12], (dynamic)args[13]);
                        break;
                    case 15:
                        ((dynamic)this.cb).Invoke((dynamic)args[0], (dynamic)args[1], (dynamic)args[2], (dynamic)args[3], (dynamic)args[4], (dynamic)args[5], (dynamic)args[6], (dynamic)args[7], (dynamic)args[8], (dynamic)args[9], (dynamic)args[10], (dynamic)args[11], (dynamic)args[12], (dynamic)args[13], (dynamic)args[14]);
                        break;
                }
            }
            else {
                MethodInfo mi = this.hisCb.GetType().GetMethod("Invoke");
                mi.Invoke(this.hisCb, args);
            }

#else
            this.hisCb.DynamicInvoke(args);
#endif
        }
    }

    /// <summary>
    /// Specifies the marshalling mechanism.
    /// </summary>
    internal enum MarshallingMechanism {
        /// <summary>
        /// None specified.
        /// </summary>
        None,

        /// <summary>
        /// Use auto marshalling.
        /// </summary>
        AutoMarshalled,

        /// <summary>
        /// Use self marshalling via the ISelfMarshalled interface.
        /// </summary>
        SelfMarshalled,

        /// <summary>
        /// Use protocol buffers for marshalling.
        /// </summary>
        ProtocolBuffers
    }

    /// <summary>
    /// Designates a class as suitable for automatic marshalling via Vsync.
    /// </summary>
    /// <remarks>
    /// When the <bf>AutoMarshalled</bf> attribute is specified, Vsync will automatically marshall the fields of 
    /// a class into a byte[] array, and create and initialize object instances from received byte[] arrays.
    /// </remarks>
    [AttributeUsage(AttributeTargets.Class)]
    public sealed class AutoMarshalledAttribute : Attribute {
    }

    /// <summary>
    /// Instructs Vsync that a class implements its own marshalling.
    /// </summary>
    /// <remarks>
    /// The class must implement a public constuctor accepting a single byte array to deserialize and initialize new instances.
    /// </remarks>
    public interface ISelfMarshalled {
        /// <summary>
        /// Serializes the instance to a byte array.
        /// </summary>
        /// <returns>The instance serialized to a byte array.</returns>
        byte[] toBArray();
    }

#if !PROTOCOL_BUFFERS
    /// <summary>
    /// Dummy attribute.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    internal sealed class ProtoMember : Attribute {
        internal ProtoMember(int index) {
        }
    }
#endif

    /// <summary>
    /// Interface defintion for Vsync aggregators
    /// </summary>
    /// <remarks>
    /// To define a custom Aggregator, implement the IAggregator interface, create an instance for each group in which you will use it,
    /// and register that instance via Group.RegisterAggregator.  If you need to have multiple instances of one aggregator
    /// for a single group, encode an instance identifier of some kind into the key; Vsync won't allow you to register more than one
    /// aggregator of a single type in a single group.
    /// </remarks>
    /// <typeparam name="KeyType">The KeyType must be a primitive C# base type, or must implement the IEqualityComparer interface</typeparam>
    /// <typeparam name="ValueType"></typeparam>
    public interface IAggregator<in KeyType, ValueType> {
        /// <summary>
        /// Combines two objects of type ValueType, which are associated with the given key.  Canned from an Vsync thread.
        /// </summary>
        /// <param name="key">The key associated with this aggregation operation</param>
        /// <param name="fromLeft">Value received from the node to my left on this token ring</param>
        /// <param name="fromBelow">Value coming up from below</param>
        /// <returns></returns>
        ValueType Aggregate(KeyType key, ValueType fromLeft, ValueType fromBelow);
    }

    /// <summary>
    /// AggregatorDel is a delegate type that can be used to do in-line anonymous declaration of Vsync aggregators in calls to Group.RegisterAggregator
    /// </summary>
    /// <typeparam name="KType">The associated KeyType</typeparam>
    /// <typeparam name="Vtype">The associated ValueType</typeparam>
    /// <param name="key">The key</param>
    /// <param name="fromLeft">A value received from the node to the left</param>
    /// <param name="fromBelow">A value received from the node below</param>
    /// <returns>An aggregator function should return a ValueType object computed as the aggregate of fromLeft and fromBelow</returns>
    public delegate Vtype Aggregator<in KType, Vtype>(KType key, Vtype fromLeft, Vtype fromBelow);

    // This is used to "trick" C# into doing subtyping on my derived IAggregator objects
    internal interface IAggregateEventHandler {
        // In fact, three of the events return null, but the fourth fetches the marshalled aggregate state and returns byte[]
        byte[] AggEvent(int eventType, int vid, object key, object value, int offset);

        byte[] AggEvent(int eventType);

        string AggName();

        string AggState();

        object GetDValues();

        void LoadDValues(object fromBelow);

        void GotSGAggInfo(bool fromBelow, int level, int vid, object key, object value);

        Type GetKeyType();

        Type GetValueType();
    }

    /// <summary>
    /// Specifies how long a Query should wait for results and the action to take on timeout
    /// </summary>
    /// <remarks>
    /// Vsync employs <bf>Timeout</bf> objects to specify desired actions when a Query has waited excessively long.
    /// These specify the delay until timeout (in milliseconds) and an action to take.
    /// </remarks>
    public class Timeout {
        internal int when;

        internal int action;

        internal string origin;

        /// <summary>
        /// <bf>TO_ABORTREPLY:</bf>  Abort this Query by simulating an <bf>AbortReply()</bf>
        /// </summary>
        public const int TO_ABORTREPLY = 0;

        /// <summary>
        /// <bf>TO_NULLREPLY:</bf>  Stop waiting for the slow group member by simulating a <bf>NullReply()</bf> from that member
        /// </summary>
        public const int TO_NULLREPLY = 1;

        /// <summary>
        /// <bf>TO_FAILURE:</bf>  Stop waiting for the slow group member by informing Vsync that the member has failed.  This is an extreme action
        /// and will cause Vsync to disconnect from that member and send it a poison pill, just in case it is still alive.  Use with care!
        /// </summary>
        public const int TO_FAILURE = 2;

        /// <summary>
        /// <bf>TO_AGGFAILURE:</bf>  For aggregations only, triggers an aggregation exception in the leader and, if the process responsible for the
        /// timeout can be identified, causes that process to be poisoned.
        /// </summary>
        public const int TO_AGGFAILURE = 4;

        /// <summary>
        /// Constructs a new member of the <bf>Timeout</bf> class
        /// </summary>
        /// <param name="to">Delay until timeout occurs, in ms</param>
        /// <param name="act">Action to take (for queries, one of TO_ABORTREPLY, TO_NULLREPLY, TO_FAILURE; for aggregation, TO_AGGFAILURE)</param>
        public Timeout(int to, int act) {
            this.when = to;
            this.action = act;
        }

        internal Timeout(int to, int act, string why) {
            this.when = to;
            this.action = act;
            this.origin = why;
        }
    }

    /// <summary>
    /// Various system constants.  Some accessible from outside users
    /// </summary>
    internal static class Vsync {
        /// <summary>
        /// Prints a very easily understood message if overloaded
        /// </summary>
        internal static bool VSYNC_SHUTDOWNIFOVERLOADED = true;

        /// <summary>
        /// Target size for ORACLE
        /// </summary>
        internal static int VSYNC_ORACLESIZE = 3;

        /// <summary>
        /// If a group view has 50 or more members, use OOB transfer to initialize joining members.  Value should be larger than ORACLESIZE
        /// </summary>
        internal static int VSYNC_INITVIAOOB = 50;

        /// <summary>
        /// Can be overridden by environment variables.  Becomes false if this process can't get the proper UDP port numbers
        /// </summary>
        internal static bool VSYNC_CANJOINORACLE = true;

        /// <summary>
        /// Maintain index if View members list is 16 or longer
        /// </summary>
        internal const int VSYNC_INDEXMEMBERS = 16;

        /// <summary>
        /// Largest configurations that have been tested reasonably carefully.  We'll make this bigger and bigger over time.
        /// </summary>
        internal static int VSYNC_MAXSYSTEMSIZE = 2048;

        /// <summary>
        /// Inhibit new sends if more than this many messages are known to Vsync.  Value adjusted each time view changes in VSYNCMEMBERS
        /// </summary>
        internal static int VSYNC_ASYNCMTOTALLIMIT = 100;

        /// <summary>
        /// MAXASYNCMTOTAL won't be allowed to become larger than this value
        /// </summary>
        internal static int VSYNC_MINASYNCMTOTAL = 50;

        internal static int VSYNC_MAXRBACKLOG = VSYNC_ASYNCMTOTALLIMIT;

        /// <summary>
        /// If a group has more than this many members, and a UDP-only multicast is attempted, Vsync switches to an overlay multicast
        /// </summary>
        internal static int VSYNC_MAXDIRECTSENDS = 16;

        /// <summary>
        /// We recommend keeping this fairly small to avoid excessive "memory pressure" on the kernel
        /// </summary>
        internal static long VSYNC_MAXMSGLEN = 32 * 1024;

        /// <summary>
        /// Used in the out of band transfer logic, initialized there
        /// </summary>
        internal static long VSYNC_OOBCHUNKSIZE;

        /// <summary>
        /// Vsync will round packets up to a multiple of this
        /// </summary>
        internal static int VSYNC_LEN_ROUNDUP = 1;

        /// <summary>
        /// Maximum packets to send per second, if non-zero
        /// </summary>
        internal static int VSYNC_RATELIM;

        /// <summary>
        /// Maximum size for data sent in an Send, OrderedSend or SafeSend, needed because Vsync flow control can malfunction with extremely large objects
        /// </summary>
        internal static long VSYNC_MAXMSGLENTOTAL = 256 * VSYNC_MAXMSGLEN;

        /// <summary>
        /// If true, Vsync uses SHA2/256 signatures to sign every marshalled object, and won't demarshall (hence won't accept) unsigned messages
        /// </summary>
        internal static bool VSYNC_SIGS = true;

        /// <summary>
        /// If provided, Vsync encrypts the SHA2/256 signatures with this key
        /// </summary>
        internal static byte[] VSYNC_AESKEY;

        /// <summary>
        /// How many acks to wait for when doing COMMIT in the ORACLE
        /// </summary>
        internal static int VSYNC_ACKTHRESHOLD = 2;

        internal static Aes VSYNC_AES;

        internal static LockObject VSYNC_AES_LOCK = new LockObject("VSYNC_AES_LOCK");

        /// <summary>
        /// Used to seed the initialization vector employed by AES
        /// </summary>
        internal static RNGCryptoServiceProvider VSYNC_AESSEED;

        /// <summary>
        /// If non-empty, the names of nodes where ORACLE instances can be found (if any are running)
        /// </summary>
        internal static string VSYNC_HOSTS = string.Empty;

        /// <summary>
        /// If true, Vsync uses no IPMC at all, even for startup.  (Value of MAXIPMCADDRS ignored in this case)
        /// </summary>
        internal static bool VSYNC_UNICAST_ONLY = false;

        /// <summary>
        /// Tells Vsync to use TCP rather than Vsync native communication (over UDP) for OOB UNICAST transfers
        /// </summary>
        internal static bool VSYNC_OOBVIATCP = true;

        /// <summary>
        /// Provides a form of user-level control over use of the new RDMA (verbs) mechanisms.  For internal/testing use only
        /// </summary>
        internal static bool VSYNC_USERDMA = false;

        internal static int VSYNC_GROUPPORT = 11002;

        /// <summary>
        /// Vsync allocates virtual IPMC addresses in this range; must be large enough to permit groups to have unique gaddrs.  
        /// </summary>
        internal static int VSYNC_MCRANGE_LOW = 5000;

        /// <summary>
        /// Physical ones use same range but are managed by Dr. Multicast
        /// </summary>
        internal static int VSYNC_MCRANGE_HIGH = VSYNC_MCRANGE_LOW + 500000;

        /// <summary>
        /// Listener port for incoming P2PSocket connection requests' AckSocket uses VSYNC_DEFAULT_PORTNOp+1
        /// </summary>
        internal static int VSYNC_DEFAULT_PORTNOp = 9753;

        /// <summary>
        /// Listener port for incoming AckSocket connection requests
        /// </summary>
        internal static int VSYNC_DEFAULT_PORTNOa = VSYNC_DEFAULT_PORTNOp + 1;

        /// <summary>
        /// Listener port for incoming OOB via TCP connection requests
        /// </summary>
        internal static int VSYNC_DEFAULT_PORTNOt = VSYNC_DEFAULT_PORTNOp + 2;

        /// <summary>
        /// Limit on how many IPMC addresses can be in use other than for OOB code.  WARNING: Can be temporarily exceeded while remapping.
        /// </summary>
        internal static int VSYNC_MAXIPMCADDRS = 25;

        /// <summary>
        /// Limit on how many IPMC addresses can be used for OOB code
        /// </summary>
        internal static int OOBMAXIPMCADDRS = 25;

        internal static byte[] VSYNC_HDR = Msg.StringToBytes("->VSYNC<-");

        internal static bool VSYNC_LOG_CREATED = false;

        internal static Address foundOracle;

        internal static Address my_address;

        internal static byte[] my_address_bytes;

        internal static List<Address> recent_inquiries = new List<Address>();

        internal static LockObject recent_inquiries_lock = new LockObject("recent_inquiries_lock");

        /// <summary>
        /// Result of applying IPExtractAddrs to VSYNC_HOSTS
        /// </summary>
        internal static IPAddress[] VSYNC_HOSTS_IPADDRS;

        internal static Thread receiveThread;

        internal static int CLASSD = 224 << 24;

        /// <summary>
        /// Padding added to the end of a serialized message to hold the signature, if any
        /// </summary>
        internal static int VSYNC_MSGPADDING = 0;

        /// <summary>
        /// How many are being used right now
        /// </summary>
        internal static int nPhysAddrsInUse = 0;

        /// <summary>
        /// Overhead for an Vsync ACK packet, which is just a byte array inside an enclosing byte array
        /// </summary>
        internal static int VSYNC_BAOVERHEAD = 100;

        /// <summary>
        /// How many bytes Vsync adds as overhead (quite a few, in the worst case)
        /// </summary>
        internal static int VSYNC_OVERHEAD = 900;

        /// <summary>
        /// Vsync will fragment objects this large or larger...
        /// </summary>
        internal static long VSYNC_MUSTFRAGMENT;

        /// <summary>
        /// ... into objects of this size.  
        /// </summary>
        internal static long VSYNC_FRAGLEN;

        internal static int VSYNC_MCMDBBSIZE = 512;

        /// <summary>
        /// Forces garbage collection every 2 seconds, if more than a very few messages are "active" in Vsync (currently, 10)
        /// </summary>
        internal static int VSYNC_GCFREQ = 2000;

        /// <summary>
        /// Report MCMD stats every 5 minutes of runtime
        /// </summary>
        internal static int VSYNC_MCMDREPORTRATE = 5 * 60;

        /// <summary>
        /// 20 second grace period during startup to deal with C# class loader locking I/O here and there
        /// </summary>
        internal static long GRACEPERIOD = 20000;

        internal static byte[] VSYNC_OK = { (byte)'O', (byte)'K' };

        /// <summary>
        /// True if Vsync shouldn't multicast on the first interface
        /// </summary>
        internal static bool VSYNC_SKIP_FIRSTINTERFACE = false;

        internal static bool VSYNC_DONT_COMPRESS = false;

        internal static string VSYNC_NETWORK_INTERFACES;

        internal static List<int> InterfaceIds;

        internal static List<IPAddress> VSYNC_MY_IPADDRS;

        /// <summary>
        /// After retransmitting, minimum delay before doing it a second time (hence the 3rd send)
        /// </summary>
        internal static int VSYNC_MIN2NDRTSEND = 500;

        /// <summary>
        /// Much fudging needed to get these right
        /// </summary>
        internal static int VSYNC_MAXRETRIES = 3;

        /// <summary>
        /// Much fudging needed to get these right.  My original theory was that this should be O(log(N)) but for now I've pegged it at 3
        /// </summary>
        internal static int VSYNC_MAXLGRETRIES = 3;

        /// <summary>
        /// 15 seconds
        /// </summary>
        internal static int VSYNC_DEFAULTTIMEOUT = 15000;

        /// <summary>
        /// Set to true if VSYNC_DEFAULTTIMEOUT has been doubled because the application is sending large objects
        /// </summary>
        internal static bool BigTimeouts = false;

        /// <summary>
        /// 5 seconds
        /// </summary>
        internal static int VSYNC_WARNAFTER = 5000;

        /// <summary>
        /// 15 minutes
        /// </summary>
        internal static int VSYNC_REMAPDELAY = 15 * 60 * 1000;

        /// <summary>
        /// Ticks per millisecond (one tick is 100 nanoseconds)
        /// </summary>
        internal static int MS = 10000;

        internal static int VSYNC_ISBIG = 5;

        /// <summary>
        /// 0: don't route; 1:LAN only.  Increase with care or you might DDoS the whole data center!
        /// </summary>
        internal static int VSYNC_TTL = 1;

        /// <summary>
        /// Pause between passing tokens in ms, 20x faster after recent activity.  Must be multiple of 20
        /// </summary>
        internal static int VSYNC_TOKEN_DELAY = 40;

        /// <summary>
        /// Set to true in RunAsWorker()
        /// </summary>
        internal static bool WORKER_MODE = false;

        /// <summary>
        /// Set to true when VsyncSystem.Start() is ready to wait
        /// </summary>
        internal static volatile bool OK_TO_SEND_WORKER_REQ = false;

        internal static volatile Address MY_MASTER = null;
        internal static volatile Address MY_OLD_MASTER = null;

        internal static volatile bool heardFromMaster;

        /// <summary>
        /// For message id's on one-to-one ping messages, which show up with gaddr=NULLADDRESS
        /// </summary>
        internal static int OneToOneCntr = 0;

        internal static bool VSYNC_UDPCHKSUM = false;

        internal static int my_pid = Process.GetCurrentProcess().Id;

        /// <summary>
        /// Address of this process
        /// </summary>
        internal static IPAddress my_IPaddress;

        internal static string my_host;

        internal static bool IAmOracle = false;

        internal static Group ORACLE;

        internal static Group VSYNCMEMBERS;

        /// <summary>
        /// Only active in the Oracle group
        /// </summary>
        internal static Thread OracleViewThread;

        internal static ViewDelta[] Proposed;

        internal static int LeaderId;

        /// <summary>
        /// True once this instance is running the "oracle leader" code
        /// </summary>
        internal static volatile bool RunningLeaderLogic;

        internal static Address NULLADDRESS = new Address();

        internal static Address ClientOf;

        internal static long OracleFailedAt;

        internal static int newClientOfCnt;

        /// <summary>
        /// False disables all logging by Vsync
        /// </summary>
        internal static bool VSYNC_LOGGED = true;

        /// <summary>
        /// True if you want Vsync to configure VSYNCMEMBERS as a "large" group
        /// </summary>
        internal static bool VSYNC_LARGE = false;

        internal static bool VSYNC_MUTE = false;

        internal static bool VSYNC_TRACKTHREADWAITS = true;

        internal static bool VSYNC_IGNORESMALLPARTITIONS = true;

        internal static bool VSYNC_IGNOREPARTITIONS = false;

        internal static bool VSYNC_INFINIBAND;

        internal static int VSYNC_LID;

        internal static string VSYNC_LOGDIR = "logs";

        internal static Stream my_logstream;

        internal static Semaphore lSema = new Semaphore(1, int.MaxValue);

        internal static int MapperEpochId;

        internal static string VSYNC_NETMASK = string.Empty;

        internal static IPAddress VSYNC_NETMASK_ADDR;

        internal static string VSYNC_SUBNET = string.Empty;

        internal static IPAddress VSYNC_SUBNET_ADDR;

        internal static bool VSYNC_GRACEFULSHUTDOWN = false;

        internal static Semaphore VSYNC_SLEEP = new Semaphore(0, int.MaxValue);

        internal static void Sleep(int howLong) {
            ILock.NoteThreadState("Sleep(" + howLong + ")");
            VSYNC_SLEEP.WaitOne(howLong);
            ILock.NoteThreadState(null);
        }

        internal static List<Address> RIPList = new List<Address>();

        internal static LockObject RIPLock = new LockObject("RIPLock");

        internal static string RIPListState() {
            string s;
            using (var tmpLockObj = new LockAndElevate(RIPLock)) {
                s = "RIPList = " + Address.VectorToString(RIPList.ToArray());
            }

            using (var tmpLockObj = new LockAndElevate(Group.GroupRIPLock)) {
                s += "; Group RIPList = " + Address.VectorToString(Group.GroupRIPList.ToArray()) + Environment.NewLine;
            }

            return s;
        }

        internal const int JOIN = -1;

        internal const int LEAVE = -2;

        internal const int FDETECTION = -3;

        internal const int PROPOSE = -4;

        internal const int INITIALVIEW = -5;

        internal const int INQUIRE = -6;

        internal const int COMMIT = -7;

        internal const int FANNOUNCE = -8;

        internal const int ORDEREDSEND = -9;

        internal const int SETORDER = -10;

        internal const int RELAYJOIN = -11;

        internal const int RELAYLEAVE = -12;

        internal const int STATEXFER = -13;

        internal const int TERMINATE = -14;

        internal const int RELAYTERM = -15;

        internal const int REMAP = -16;

        internal const int SAFESEND = -17;

        internal const int SAFEDELIVER = -18;

        internal const int JOINFAILED = -19;

        internal const int RELAYSEND = -20;

        internal const int DALDONE = -21;

        internal const int ISSTABLE = -22;

        internal const int BECLIENT = -23;

        internal const int ORACLERUNNING = -24;

        internal const int PARTITIONED = -25;

        internal const int RELAYREGISTERVG = -26;

        internal const int REGISTERVG = -27;

        internal const int IM_DHT_PUT = -28;

        internal const int IM_DHT_GET = -29;

        internal const int IM_UDP_TUNNEL = -30;

        internal const int IM_IPMC_TUNNEL = -31;

        internal const int IM_IPMC_VIEWS = -32;

        internal const int CRYPTOWRAPPED = -33;

        internal const int CLIENTWRAPPED = -34;

        internal const int FRAGMENT = -35;

        internal const int CAUSALSEND = -36;

        internal const int DISKLOGGER = -37;

        internal const int PING = -38;

        internal const int CANBEORACLE = -39;

        internal const int LOCKREQ = -40;

        internal const int SGAGGREGATE = -41;

        internal const int OUTOFBAND = -42;

        internal const int IBADDRS = -43;

        internal const int SYSTEMREQS = 43;

        internal static string rToString(object o) {
            string[] names = { "JOIN", "LEAVE", "FDETECTION", "PROPOSE", "INITIALVIEW", "INQUIRE", "COMMIT", "FANNOUNCE", "ORDEREDSEND", "SETORDER", "RELAYJOIN", "RELAYLEAVE", "STATEXFER", "TERMINATE", "RELAYTERM", "REMAP", "SAFESEND", "SAFEDELIVER", "JOINFAILED", "RELAYSEND", "DALDONE", "ISSTABLE", "BECLIENT", "ORACLERUNNING", "PARTITIONED", "RelayRegisterVG", "RegisterVG", "DHTPut", "DHTGet", "UDP Tunnel", "IPMC Tunnel", "IPMC Views", "CRYPTOWRAP", "CLIENT-TO-GROUP", "FRAGMENT", "CAUSAL SEND", "DISK LOGGER", "PING", "CAN BE ORACLE", "LOCKREQ", "Small Group AGGREGATE", "OutOfBand", "IBADDRS" };
            if (o is int) {
                int r = (-(int)o) - 1;
                if (r >= 0 && r < names.Length) {
                    return names[r];
                }

                return "Hander[" + (int)o + "]";
            }

            return o.GetType().ToString();
        }

        public static void WriteLine() {
            WriteLine(string.Empty);
        }

        public static void WriteLine(string what) {
            if (!VsyncSystem.VsyncActive && VsyncSystem.VsyncWasActive) {
                return;
            }

            if (VSYNC_LOGGED) {
                Write(what + Environment.NewLine);
            }
        }

        // This method is unsafe and should only be used internally in Vsync.cs for debugging purposes.
        internal static string ExtractStackTrace() {
            return ExtractStackTrace(Thread.CurrentThread, int.MaxValue);
        }

        // This method is unsafe and should only be used internally in Vsync.cs for debugging purposes.
        internal static string ExtractStackTrace(Thread targetThread, int depth) {
#if EXTRACTCALLSTACKS
            try
            {
                if (targetThread != Thread.CurrentThread && (targetThread.ThreadState & System.Threading.ThreadState.Running) != 0)
                {
                    return "(can't extract stack trace on a running thread)";
                }

                string st = "{ ";
                if (Thread.CurrentThread.Name != null)
                {
                    st = "Thread[" + Thread.CurrentThread.Name + "]{ ";
                }

                StackTrace stackTrace = new StackTrace(targetThread, false);
                StackFrame[] stackFrames = stackTrace.GetFrames();

                // write call stack method names
                int ignore = 2;
                foreach (StackFrame stackFrame in stackFrames)
                {
                    if (ignore-- <= 0 && depth-- >= 0)
                    {
                        st += stackFrame.GetMethod().Name + "... ";
                    }
                }

                return st + "}";
            }
            catch (ThreadStateException)
            {
                return "(attempt to trace thread triggered thread state exception)";
            }

#else // EXTRACTCALLSTACKS
            return "??";
#endif // EXTRACTCALLSTACKS
        }

        public static void Write(string what) {
            if (!VSYNC_MUTE) {
                if (VsyncSystem.noConsole) {
                    Debug.Write(what);
                }
                else {
                    Console.Write(what);
                }
            }

            ILock.NoteThreadState("lsema.WaitOne()");
            lSema.WaitOne();
            ILock.NoteThreadState(null);
            if (VSYNC_LOGGED && my_logstream != null) {
                byte[] buf = Msg.StringToBytes(what);
                my_logstream.Write(buf, 0, buf.Length);
                my_logstream.Flush();
            }

            lSema.Release();
        }

        internal static void WriteLineLog(string what) {
            WriteLog(what + Environment.NewLine);
        }

        internal static void WriteLog(string what) {
            if (!VsyncSystem.VsyncActive && VsyncSystem.VsyncWasActive) {
                return;
            }

            if (VSYNC_LOGGED) {
                byte[] buf = Msg.StringToBytes(what);
                my_logstream.Write(buf, 0, buf.Length);
                my_logstream.Flush();
            }
        }

        public static void CloseLog() {
            ILock.NoteThreadState("lsema.WaitOne()");
            lSema.WaitOne();
            ILock.NoteThreadState(null);
            if (VSYNC_LOGGED) {
                VSYNC_LOGGED = false;
                my_logstream.Flush();
                Vsync.my_logstream.Close();
                Vsync.my_logstream = null;
            }

            lSema.Release();
        }

        internal static void ArrayResize<T>(ref T[] oldArray, int len) {
            Array.Resize(ref oldArray, len);
        }

        internal class TCB {
            internal int id;

            internal long when;

            internal TimerCallback cb;

            internal TCB(int tid, long t, TimerCallback tcb) {
                this.id = tid;
                this.when = t;
                this.cb = tcb;
            }
        }

        private static readonly LinkedList<TCB> timer_list = new LinkedList<TCB>();

        private static readonly LockObject timer_lock = new LockObject("timer_lock");

        private static readonly int ENDOFTIME = timer_list.AddLast(new TCB(-1, long.MaxValue, () => { throw new VsyncException("end of time"); })).Value.id;

        private static readonly double DURATIONMS = 1000.0 / Stopwatch.Frequency;

        private static readonly double DURATIONTICK = 10000000.0 / Stopwatch.Frequency;

        private static readonly Semaphore timer_wait = new Semaphore(0, int.MaxValue);

        internal static Thread timer_thread;

        /// <summary>
        /// Gets the time since the system was started in milliseconds.
        /// </summary>
        /// <returns>The time since the system was started in milliseconds.</returns>
        internal static long NOW
        {
            get
            {
                return (long)(Stopwatch.GetTimestamp() * DURATIONMS - VsyncSystem.StartedAt);
            }
        }

        /// <summary>
        /// Gets the precise time since the system was started in ticks (100 nanoseconds).
        /// </summary>
        /// <returns>The precise time since the system was started in ticks (100 nanoseconds).</returns>
        /// <remarks>This is used when printing the times at which packets were sent/received.</remarks>
        internal static long TICKS
        {
            get
            {
                return (long)(Stopwatch.GetTimestamp() * DURATIONTICK);
            }
        }

        internal static int TID;

        /// <summary>
        /// Register for a callback from Vsync after a designated number of ms, using a new thread.
        /// </summary>
        /// <param name="ms">Delay in milliseconds</param>
        /// <param name="cb">Method to call, on a new thread</param>
        /// <returns></returns>
        public static int OnTimerThread(int ms, TimerCallback cb) {
            return OnTimer(ms, () => new Thread(() => {
                try {
                    cb();
                }
                catch (VsyncShutdownException) {
                    VsyncSystem.CheckLocksHeld();
                }

                VsyncSystem.ThreadTerminationMagic();
            }) { Name = "OnTimer callback: " + cb.Method, IsBackground = true }.Start());
        }

        /// <summary>
        /// Register for a callback from Vsync after a designated number of ms
        /// </summary>
        /// <param name="ms">Delay in milliseconds</param>
        /// <param name="cb">Method to call</param>
        /// <returns></returns>
        public static int OnTimer(long ms, TimerCallback cb) {
            ms += NOW;
            TCB newtcb = new TCB(++TID, ms, cb);
            return InsertOnTimerQueue(newtcb);
        }

        private static int InsertOnTimerQueue(TCB newtcb) {
            using (var tmpLockObj = new LockAndElevate(timer_lock)) {
                bool new_first = true;
                for (LinkedListNode<TCB> tcbnode = timer_list.First; tcbnode != null; tcbnode = tcbnode.Next) {
                    if (tcbnode.Value.when > newtcb.when) {
                        timer_list.AddBefore(tcbnode, newtcb);
                        if ((VsyncSystem.Debug & VsyncSystem.TIMERS) != 0) {
                            VsyncSystem.WriteLine("InsertOnTimerQueue add callback with id " + newtcb.id + " registered before id " + tcbnode.Value.id + " for time " + newtcb.when + " at time " + NOW);
                        }

                        timer_wait.Release();
                        return TID;
                    }

                    new_first = false;
                }

                timer_list.AddLast(newtcb);
                if ((VsyncSystem.Debug & VsyncSystem.TIMERS) != 0) {
                    VsyncSystem.WriteLine("InsertOnTimerQueue add callback with id " + newtcb.id + " registered at tail for time " + newtcb.when + " at time " + NOW);
                }

                if (new_first) {
                    timer_wait.Release();
                }

                return TID;
            }
        }

        /// <summary>
        /// Adjust a callback to occur at a new deadline time
        /// </summary>
        /// <param name="tid">Timer ID</param>
        /// <param name="newDeadline">new deadline, in ms relative to NOW</param>
        /// <returns></returns>
        public static void TimerReset(int tid, long newDeadline) {
            if (tid == ENDOFTIME) {
                return;
            }

            LinkedListNode<TCB> tcbnode;
            newDeadline += NOW;
            using (var tmpLockObj = new LockAndElevate(timer_lock)) {
                for (tcbnode = timer_list.First; tcbnode != null; tcbnode = tcbnode.Next) {
                    if (tcbnode.Value.id == tid) {
                        timer_list.Remove(tcbnode);
                        break;
                    }
                }
            }

            if (tcbnode != null) {
                tcbnode.Value.when = newDeadline;
                InsertOnTimerQueue(tcbnode.Value);
            }
        }

        public static void TimerCancel(int tid) {
            if (tid == ENDOFTIME) {
                return;
            }

            using (var tmpLockObj = new LockAndElevate(timer_lock)) {
                for (LinkedListNode<TCB> tcb = timer_list.First; tcb != null; tcb = tcb.Next) {
                    if (tcb.Value.id == tid) {
                        timer_list.Remove(tcb);
                        break;
                    }
                }
            }
        }

        internal static void TimerThread() {
            while (!VsyncSystem.VsyncActive) {
                Vsync.Sleep(250);
            }

            try {
                while (VsyncSystem.VsyncActive) {
                    VsyncSystem.RTS.ThreadCntrs[2]++;
                    List<TimerCallback> cbs = new List<TimerCallback>();
                    VsyncSystem.CheckParentThread();
                    using (var tmpLockObj = new LockAndElevate(timer_lock)) {
                        LinkedListNode<TCB> tcb;
                        while ((tcb = timer_list.First).Value.when <= NOW) {
                            if ((VsyncSystem.Debug & VsyncSystem.TIMERS) != 0) {
                                Vsync.WriteLine("TimerThread to call Timer Callback with id " + tcb.Value.id + " registered for time " + tcb.Value.when + " at time " + NOW);
                            }

                            long delta = NOW - tcb.Value.when;
                            if (delta > 10000) {
                                Vsync.WriteLine("WARNING: Vsync timer thread woke up " + delta + "ms late!");
                            }

                            timer_list.Remove(tcb);
                            cbs.Add(tcb.Value.cb);
                        }
                    }

                    foreach (TimerCallback cb in cbs) {
                        cb();
                    }

                    int delay;
                    using (var tmpLockObj = new LockAndElevate(timer_lock)) {
                        delay = (int)Math.Min(2500, timer_list.First.Value.when - NOW);
                    }

                    if (delay > 0) {
                        timer_wait.WaitOne(delay);
                    }
                }
            }
            catch (VsyncShutdownException) {
                VsyncSystem.CheckLocksHeld();
            }
        }

        internal static string GetTimerState() {
            string s = "Timer State: NOW = " + MsToSecs(NOW) + "... ";

            // Omit unless explictly requested: too verbose...
            if ((VsyncSystem.Debug & VsyncSystem.TIMERS) != 0) {
                using (var tmpLockObj = new LockAndElevate(timer_lock)) {
                    for (LinkedListNode<TCB> tcb = timer_list.First; tcb != null; tcb = tcb.Next) {
                        if (tcb.Value.when != long.MaxValue) {
                            s += Environment.NewLine + "     [" + tcb.Value.id + "] At " + MsToSecs(tcb.Value.when) + " do callback to " + tcb.Value.cb.Method;
                        }
                    }
                }
            }

            s += Environment.NewLine + ReliableSender.HeardFromState();
            return s;
        }

        /// Prints in s.xxx format
        internal static string MsToSecs(long when) {
            return (when / 1000L) + "." + (when % 1000L).ToString("D3");
        }

        // Prints in hr:min:sec.xxxxxx format
        internal static string TimeToString(long when) {
            return new TimeSpan(when * 10000L).ToString();
        }

        public static void NodeHasFailed(Address which, string howDiscovered, bool inhibitReport) {
            if (Vsync.VSYNCMEMBERS == null || !Vsync.VSYNCMEMBERS.HasFirstView) {
                throw new VsyncException("Lost connection to Vsync system during startup.");
            }

            using (var tmpLockObj = new LockAndElevate(Vsync.RIPLock)) {
                if (!Vsync.RIPList.Contains(which)) {
                    Vsync.RIPList.Add(which);
                }
                else {
                    return;
                }
            }

            if ((VsyncSystem.Debug & VsyncSystem.FAILURES) != 0) {
                Vsync.WriteLine("NodeHasFailed: " + which + " (" + howDiscovered + "), inhibitReport=" + inhibitReport);
            }

            if (Vsync.ClientOf != null && Vsync.ClientOf == which) {
                if (Vsync.VSYNC_ORACLESIZE == 1) {
                    throw new VsyncShutdownException("System shutdown: Vsync was configured with VSYNC_ORACLESIZE=1 and the Oracle has failed or terminated.");
                }

                if (Vsync.OracleFailedAt != 0 && (Vsync.NOW - Vsync.OracleFailedAt) > Vsync.VSYNC_DEFAULTTIMEOUT) {
                    throw new VsyncShutdownException("System shutdown: After Vsync ORACLE member " + Vsync.ClientOf + " failed, this client was unable to contact any other ORACLE member.");
                }

                Vsync.WriteLine("WARNING: Lost connection to the ORACLE; attempting to reconnect...");
                if (Vsync.OracleFailedAt == 0) {
                    Vsync.OracleFailedAt = Vsync.NOW;
                }

                Vsync.OnTimer(2500, () => {
                    if (Vsync.ClientOf != null && Vsync.ClientOf == which) {
                        throw new VsyncException("System shutdown: After Vsync ORACLE member " + Vsync.ClientOf + " failed, this client was unable to contact any other ORACLE member.");
                    }
                });
            }

            if (!ORACLE.HasFirstView || !VsyncSystem.VsyncActive || VsyncSystem.VsyncRestarting) {
                return;
            }

            // Clean up the CanBeOracleList to make sure we don't try to add a deceased process to the ORACLE
            using (var tmpLockObj = new LockAndElevate(CanBeOracleListLock)) {
                CanBeOracleList.Remove(which);
            }

            string name = Thread.CurrentThread.Name ?? "Unnamed thread";
            if (which.isMyAddress()) {
                throw new VsyncException("[" + name + "] Vsync node " + Vsync.my_address + " detected its own failure(" + howDiscovered + "); shutting down: " + VsyncSystem.GetState());
            }

            if ((VsyncSystem.Debug & VsyncSystem.FAILURES) != 0) {
                Vsync.WriteLine("[" + name + "] NodeHasFailed " + howDiscovered + " failure discovery event for " + which + ", " + VsyncSystem.GetState());
            }

            ReliableSender.NodeHasFailed(which);
            if (!inhibitReport) {
                int rank = ORACLE.theView.GetRankOf(which);
                if (rank != -1) {
                    ORACLE.theView.noteFailed(rank);
                }

                if (Vsync.ClientOf == null) {
                    ORACLE.doSend(false, false, Vsync.FDETECTION, which);
                }
                else if (Vsync.ClientOf != which) {
                    ORACLE.doP2PSend(Vsync.ClientOf, true, Vsync.FDETECTION, which);
                }
                else {
                    View v = Vsync.VSYNCMEMBERS.theView;
                    if (v != null) {
                        foreach (Address m in v.members) {
                            if (m.isMyAddress()) {
                                continue;
                            }

                            if (!Vsync.IsAlive(m)) {
                                continue;
                            }

                            if ((VsyncSystem.Debug & VsyncSystem.FAILURES) != 0) {
                                Vsync.WriteLine("[" + name + "] Sending FDETECTION notification in Vsync.VSYNCMEMBERS to " + m);
                            }

                            Vsync.VSYNCMEMBERS.doP2PSend(m, true, Vsync.FDETECTION, which);
                        }
                    }

                    // We need to give the new ORACLE leader time to take over and get back in touch
                    // This loop will run for 30 seconds, checking 4 times per second
                    for (int nt = 0; nt < 120; nt++) {
                        Vsync.Sleep(250);
                        if (ORACLE.theView.GetRankOf(which) == -1) {
                            return;
                        }
                    }

                    VsyncSystem.Shutdown("Client lost connectivity to core Vsync system");
                }
            }
        }

        private static bool IsAlive(Address m) {
            using (var tmpLockObj = new LockAndElevate(Vsync.RIPLock)) {
                if (Vsync.RIPList.Contains(m)) {
                    return false;
                }
            }
            return true;
        }

        public static void GroupHasFailed(string why) {
            throw new VsyncException(why);
        }

        internal static bool BVCompare(byte[] a, byte[] b) {
            if (a.Length != b.Length) {
                return false;
            }

            for (int i = 0; i < a.Length; i++) {
                if (a[i] != b[i]) {
                    return false;
                }
            }

            return true;
        }

        private static bool rentry;

        internal static IPAddress setMyAddress() {
            if (rentry) {
                return Vsync.my_IPaddress;
            }

            rentry = true;
            try {
                IDictionary environmentVariables = Environment.GetEnvironmentVariables();
                foreach (DictionaryEntry de in environmentVariables) {
                    switch ((string)de.Key) {
                        case "VSYNC_PORTNO":
                            VSYNC_GROUPPORT = int.Parse((string)de.Value);
                            break;
                        case "VSYNC_SKIP_FIRSTINTERFACE":
                            VSYNC_SKIP_FIRSTINTERFACE = bool.Parse((string)de.Value);
                            break;
                        case "VSYNC_DONT_COMPRESS":
                            VSYNC_DONT_COMPRESS = bool.Parse((string)de.Value);
                            break;
                        case "VSYNC_LOGGED":
                            VSYNC_LOGGED = bool.Parse((string)de.Value);
                            break;
                        case "VSYNC_LARGE":
                            VSYNC_LARGE = bool.Parse((string)de.Value);
                            break;
                        case "VSYNC_MUTE":
                            VSYNC_MUTE = bool.Parse((string)de.Value);
                            break;
                        case "VSYNC_IGNORESMALLPARTITIONS":
                            VSYNC_IGNORESMALLPARTITIONS = bool.Parse((string)de.Value);
                            break;
                        case "VSYNC_IGNOREPARTITIONS":
                            VSYNC_IGNOREPARTITIONS = bool.Parse((string)de.Value);
                            break;
                        case "VSYNC_GCFREQ":
                            VSYNC_GCFREQ = int.Parse((string)de.Value);
                            break;
                        case "VSYNC_MCRANGE_LOW":
                            VSYNC_MCRANGE_LOW = int.Parse((string)de.Value);
                            break;
                        case "VSYNC_MCRANGE_HIGH":
                            VSYNC_MCRANGE_HIGH = int.Parse((string)de.Value);
                            break;
                        case "VSYNC_MAXIPMCADDRS":
                            VSYNC_MAXIPMCADDRS = int.Parse((string)de.Value);
                            break;
                        case "VSYNC_MAXDIRECTSENDS":
                            VSYNC_MAXDIRECTSENDS = int.Parse((string)de.Value);
                            break;
                        case "VSYNC_UNICAST_ONLY":
                            VSYNC_UNICAST_ONLY = bool.Parse((string)de.Value);
                            break;
                        case "VSYNC_OOBVIATCP":
                            VSYNC_OOBVIATCP = bool.Parse((string)de.Value);
                            break;
                        case "VSYNC_UDPCHKSUM":
                            VSYNC_UDPCHKSUM = bool.Parse((string)de.Value);
                            break;
                        case "VSYNC_CANJOINORACLE":
                            VSYNC_CANJOINORACLE = bool.Parse((string)de.Value);
                            break;
                        case "VSYNC_MCMDREPORTRATE":
                            VSYNC_MCMDREPORTRATE = int.Parse((string)de.Value);
                            break;
                        case "VSYNC_LEN_ROUNDUP":
                            VSYNC_LEN_ROUNDUP = int.Parse((string)de.Value);
                            break;
                        case "VSYNC_RATELIM":
                            VSYNC_RATELIM = int.Parse((string)de.Value);
                            break;
                        case "VSYNC_TTL":
                            VSYNC_TTL = int.Parse((string)de.Value);
                            break;
                        case "VSYNC_TOKEN_DELAY":
                            VSYNC_TOKEN_DELAY = Math.Min(1000, Math.Max(1, int.Parse((string)de.Value)));
                            break;
                        case "VSYNC_LOGDIR":
                            VSYNC_LOGDIR = (string)de.Value;
                            break;
                        case "VSYNC_USERDMA":
                            VSYNC_USERDMA = bool.Parse((string)de.Value);
                            break;
                        case "VSYNC_NETWORK_INTERFACES":
                            VSYNC_NETWORK_INTERFACES = (string)de.Value;
                            if (VSYNC_NETWORK_INTERFACES.Length == 0) {
                                VSYNC_NETWORK_INTERFACES = null;
                            }

                            break;
                        case "VSYNC_HOSTS":
                            VSYNC_HOSTS = (string)de.Value;
                            break;
                        case "VSYNC_NETMASK":
                            VSYNC_NETMASK = (string)de.Value;
                            break;
                        case "VSYNC_SUBNET":
                            VSYNC_SUBNET = (string)de.Value;
                            break;
                        case "VSYNC_GRACEFULSHUTDOWN":
                            VSYNC_GRACEFULSHUTDOWN = bool.Parse((string)de.Value);
                            break;
                        case "VSYNC_PORTNOp":
                            VSYNC_DEFAULT_PORTNOp = int.Parse((string)de.Value);
                            VSYNC_DEFAULT_PORTNOa = VSYNC_DEFAULT_PORTNOp + 1;
                            VSYNC_DEFAULT_PORTNOt = VSYNC_DEFAULT_PORTNOp + 2;
                            break;
                        case "VSYNC_PORTNOa":
                            throw new VsyncException("VSYNC_PORTNOa is automatically determined from VSYNC_PORTNOp and cannot be directly changed");
                        case "VSYNC_AESKEY":
                            Group.doInitializeAes(out VSYNC_AES);
                            VSYNC_AESKEY = byteVecParse((string)de.Value);
                            VSYNC_SIGS = true;
                            break;
                        case "COMPUTERNAME":
                        case "HOSTNAME":
                            Vsync.my_host = (string)de.Value;
                            break;
                    }
                }

                if (!string.IsNullOrEmpty(VSYNC_SUBNET) && !string.IsNullOrEmpty(VSYNC_NETMASK)) {
                    if (!IPAddress.TryParse(VSYNC_SUBNET, out VSYNC_SUBNET_ADDR) || !IPAddress.TryParse(VSYNC_NETMASK, out VSYNC_NETMASK_ADDR)) {
                        throw new VsyncException("Unable to parse VSYNC_SUBSET or VSYNC_NETMASK");
                    }
                }

                if (VSYNC_AES != null) {
                    VSYNC_AESSEED = new RNGCryptoServiceProvider();
                }

                if (VSYNC_SIGS) {
                    VSYNC_MSGPADDING = VSYNC_AES == null ? 32 : 48;
                }

                VSYNC_TOKEN_DELAY = Math.Max(20, (VSYNC_TOKEN_DELAY / 20) * 20);
                VSYNC_HOSTS_IPADDRS = ExtractHostIPAddrs(VSYNC_HOSTS);

#if __MonoCS__
                Vsync.Sleep(my_pid % 1000); // Hack to avoid triggering some sort of Dns bug, observed only on Mono
#endif
                bool fndOne = false;
                for (int retry = 0; !fndOne && retry < 24; retry++) {
                    if (!VSYNC_UNICAST_ONLY || VSYNC_NETWORK_INTERFACES != null) {
                        string[] which = null;
                        if (VSYNC_NETWORK_INTERFACES != null) {
                            which = VSYNC_NETWORK_INTERFACES.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                        }

                        InterfaceIds = ReliableSender.getNetworkInterfaces(which);
                        if ((VsyncSystem.Debug & VsyncSystem.INTERFACES) != 0) {
                            Vsync.Write("VSYNC_NETWORK_INTERFACES = <");
                            for (int i = 0; i < InterfaceIds.Count; i++) {
                                if (i > 0) {
                                    Vsync.Write(" ");
                                }

                                if (i == 0 && VSYNC_SKIP_FIRSTINTERFACE && InterfaceIds.Count > 1) {
                                    Vsync.Write("SKIPPING[" + InterfaceIds[i] + "]");
                                }
                                else {
                                    Vsync.Write(InterfaceIds[i].ToString(CultureInfo.InvariantCulture));
                                }
                            }

                            Vsync.WriteLine(">");
                        }

                        if (VSYNC_SKIP_FIRSTINTERFACE && InterfaceIds.Count > 1) {
                            InterfaceIds.RemoveAt(0);
                        }
                    }
                    else {
                        ReliableSender.getNetworkInterfaces(null);
                    }

                    if (Vsync.my_IPaddress == null) {
                        if (retry < 24) {
                            Vsync.Sleep(5000);
                        }
                        else {
                            Vsync.WriteLine("WARNING: No network interface supports IPv4... using `localhost=127.0.0.1' for my IP address (network connectivity will be limited)");
                            Vsync.my_IPaddress = new IPAddress(new byte[] { 127, 0, 0, 1 });
                        }
                    }
                    else
                        fndOne = true;
                }

                if (VSYNC_HOSTS_IPADDRS != null) {
                    for (int i = 0; i < VSYNC_HOSTS_IPADDRS.Length; i++) {
                        if (VSYNC_HOSTS_IPADDRS[i].Equals(nullIPAddr)) {
                            VSYNC_HOSTS_IPADDRS[i] = Vsync.my_IPaddress;
                        }
                    }
                }

                // VN - change on Android - storing the log file in the external storage directory in the Android device.
                if (VSYNC_LOGGED && !VSYNC_LOG_CREATED) {
#if __MonoCS__
                    string directory = "./OUT";
                    string fname = "./OUT/VSYNC-" + Vsync.my_IPaddress.ToString() + "-" + my_pid + ".log";
#else
                    string directory = VSYNC_LOGDIR;
                    string fname = Path.Combine(VSYNC_LOGDIR, "VSYNC-" + my_pid + ".log");
#endif // !__MonoCS__
                    try {
                        Directory.CreateDirectory(directory);
                    }
                    catch (Exception) {
                    }

                    try {
                        File.Delete(fname);
                    }
                    catch (Exception) {
                    }

                    try {
                        my_logstream = new FileStream(fname, FileMode.CreateNew);
                        VSYNC_LOG_CREATED = true;
                        string rev = "$Rev: 2032 $";
                        rev = rev.Substring(rev.IndexOf(" ", StringComparison.Ordinal) + 1);
                        rev = "Vsync V2.2 Revision " + rev.Substring(0, rev.IndexOf(" ", StringComparison.Ordinal));
                        string settings = "<" + Vsync.my_host + ": " + Vsync.my_IPaddress + ">" + Environment.NewLine + "Major Vsync Runtime Settings: ORACLESIZE = " + VSYNC_ORACLESIZE + "; ";
                        if (VSYNC_UNICAST_ONLY) {
                            settings += "UNICAST_ONLY; ";
                        }

                        if (VSYNC_HOSTS.Length > 0) {
                            settings += "VSYNC_HOSTS = {" + VSYNC_HOSTS + "}; ";
                        }

                        settings += Environment.NewLine + "P2P/ACK port numbers = {" + VSYNC_DEFAULT_PORTNOp + "/" + VSYNC_DEFAULT_PORTNOa + "}; ";
                        if (!VSYNC_UNICAST_ONLY) {
                            settings += "IPMC base portno = " + VSYNC_GROUPPORT + Environment.NewLine + "IPMC address range = {" + MCMDSocket.PMCAddr(CLASSD + VSYNC_MCRANGE_LOW) + "-" + MCMDSocket.PMCAddr(CLASSD + VSYNC_MCRANGE_HIGH) + "}, MAXIPMCADDRS in use = " + VSYNC_MAXIPMCADDRS;
                        }

                        if (VSYNC_IGNOREPARTITIONS && VSYNC_ORACLESIZE > 1) {
                            settings += Environment.NewLine + "WARNING: You have configured Vsync to ignore network partitioning failures.";
                        }

                        if (VSYNC_INFINIBAND) {
                            settings += Environment.NewLine + " Using Infiniband.  Searching for ib.dll in LD_LIBRARY_PATH={" + Environment.GetEnvironmentVariable("LD_LIBRARY_PATH") + "}";
                        }

#if __MonoCS__
                        settings = "; Compiled for MONO; " + settings;
#endif
#if __ANDROID__
                        settings = "; Compiled for Android; " + settings;
#endif
                        DateTime localNow = DateTime.UtcNow.ToLocalTime();
                        TimeSpan uptime = new TimeSpan(Vsync.TICKS);
                        byte[] header = Msg.StringToBytes(rev + ": " + localNow.ToShortDateString() + " " + localNow.ToLongTimeString() + " (" + uptime + ") " + settings + Environment.NewLine + "---------------------------------------------------------------------------------------------" + Environment.NewLine);
                        my_logstream.Write(header, 0, header.Length);
                    }
                    catch (IOException e) {
                        VSYNC_LOGGED = false;
                        my_logstream = null;
                        if (VsyncSystem.noConsole) {
                            Debug.WriteLine("WARNING: Unable to create Vsync log file: " + fname + "(" + e + ")");
                        }
                        else {
                            Console.WriteLine("WARNING: Unable to create Vsync log file: " + fname + "(" + e + ")");
                        }
                    }
                }

                if (VSYNC_UNICAST_ONLY && VSYNC_HOSTS_IPADDRS == null) {
                    throw new VsyncException("VSYNC: UNICAST_ONLY mode but you didn't specify VSYNC_HOSTS for initial rendezvous!");
                }

                VSYNC_FRAGLEN = Vsync.VSYNC_MAXMSGLEN - (Vsync.VSYNC_OVERHEAD * 2);
                VSYNC_MUSTFRAGMENT = Vsync.VSYNC_MAXMSGLEN - Vsync.VSYNC_OVERHEAD;
                Msg.Initialize();
                my_address = new Address(Vsync.my_IPaddress, my_pid);
                Vsync.WriteLineLog("... MyAddress = " + Vsync.my_address);
                ReliableSender.Init();
                my_address_bytes = Msg.toBArray(my_address);
                Msg.doRegisterType<Vsync.ViewDelta>(Msg.VIEWDELTA);
                Msg.doRegisterType<Vsync.UnstableList>(Msg.UNSTABLE);
                Msg.doRegisterType<Group.tokenInfo>(Msg.TOKENINFO);
                Msg.doRegisterType<Group.FlushAggKey>(Msg.FLSHAGGKEY);
                Msg.doRegisterType<MCMDSocket.GRPair>(Msg.GRPAIR);
                Msg.doRegisterType<Group.LockInfo>(Msg.LOCKINFO);
                Msg.doRegisterType(typeof(QueryKey<>), Msg.QUERYKEY);
                Msg.doRegisterType<Group.DHTItem>(Msg.DHTITEM);
                Msg.doRegisterType<Group.osspq>(Msg.OSSPQ);
                Msg.doRegisterType<Group.OOBRepInfo>(Msg.OOBREPINFO);
                Msg.doRegisterType<Group.LockReq>(Msg.LOCKREQ);

                if (VSYNC_USERDMA == false) {
                    Vsync.VSYNC_INFINIBAND = false; // In this situation, the user told us not to use IB verbs (aka "RDMA")
                }

#if !__MonoCS__
                if (Vsync.VSYNC_INFINIBAND) {
                    Vsync.WriteLine("WARNING: Detected an INFINIBAND device, but will use IP on IB rather than verbs (ib.dll not yet tested on Windows)");
                }

                Vsync.VSYNC_INFINIBAND = false;
#endif

                if (Vsync.VSYNC_INFINIBAND && IB.init()) {
                    VSYNC_LID = IB.IB_getlid();
                    if (VSYNC_LID == 0) {
                        throw new VsyncException("Vsync on Infiniband: device lid was 0, but this value is not supported");
                    }

                    VSYNC_OOBCHUNKSIZE = 1024 * 1024 * 1024;
                    VSYNC_UNICAST_ONLY = true;
                }
                else {
                    VSYNC_OOBCHUNKSIZE = Math.Max(512, VSYNC_MAXMSGLEN - 2048);
                }

                new Thread(ReliableSender.TokenThread) { Name = "Vsync token-loop thread", IsBackground = true }.Start();

                /*
                 * The rather tortured logic that follows tries to deal with a wide range of startup scenarios including multicast supported or not,
                 * Oracle already running or not, several copies launched simultaneously as opposed to one by one, machines lightly or heavily loaded, etc.
                 * All of this makes for a "mess".  Sorry.
                 */
                ORACLE = new Group("ORACLE");
                SetupORACLE();
                if (Vsync.WORKER_MODE) {
                    return null;
                }

                int OracleTries = 0;
                bool again = true;
                while (again) {
                    again = false;
                    if (OracleTries > 0) {
                        Vsync.Sleep(OracleTries * 5000);
                    }

                    bool cantBeOracle = false;
                    int theDelay = 1000;
                    if (!VSYNC_CANJOINORACLE || (!string.IsNullOrEmpty(Vsync.VSYNC_HOSTS) && !IAmInHostList())) {
                        cantBeOracle = true;
                        VSYNC_CANJOINORACLE = false;
                        Vsync.WriteLineLog("Vsync: This instance can't be the ORACLE, joining as a client");
                    }

                    if (VsyncSystem.fastStart) {
                        Vsync.WriteLineLog("WARNING: FastStart (skipping search for the Vsync ORACLE)");
                    }

                    for (int retry = 0; Vsync.ClientOf == null && !VsyncSystem.fastStart && retry < (cantBeOracle ? 20 : 5) && Vsync.foundOracle == null; retry++) {
                        tryToJoin();
                        if (!cantBeOracle && Vsync.foundOracle == null && retry == 0) {
                            Vsync.WriteLineLog("Vsync: Searching for the Vsync ORACLE...");
                        }

                        Vsync.Sleep(theDelay);
                        if (Vsync.ClientOf != null || (ORACLE.theView != null && Vsync.ORACLE.theView.GetMyRank() != -1)) {
                            break;
                        }

                        Vsync.Sleep(theDelay);
                    }

                    if (Vsync.foundOracle != null && Vsync.ClientOf == null) {
                        int totalTryTime = 0;
                        Vsync.WriteLog("Vsync: Found the Vsync.ORACLE service, attempting to connect.");
                        for (int retry = 0; (!ORACLE.HasFirstView || ORACLE.theView.GetMyRank() == -1) && Vsync.ClientOf == null && (retry < 10 || totalTryTime < Vsync.VSYNC_DEFAULTTIMEOUT * 3); retry++) {
                            if (Vsync.ClientOf == null) {
                                tryToJoin();
                            }

                            theDelay = Math.Min(6000, theDelay);
                            if ((VsyncSystem.Debug & VsyncSystem.STARTSEQ) != 0) {
                                Vsync.WriteLineLog("WARNING: Found the ORACLE but it was still restarting... delaying " + theDelay + "ms before retrying join request... " + retry);
                            }

                            Vsync.Sleep(theDelay);
                            totalTryTime += theDelay;
                            Vsync.WriteLog(".");
                            theDelay += 500;
                        }

                        Vsync.WriteLog(string.Empty);
                        if (Vsync.ClientOf == null && (!ORACLE.HasFirstView || Vsync.ORACLE.theView.GetMyRank() == -1)) {
                            throw new VsyncException("Vsync ORACLE is " + Vsync.foundOracle + " but attempt to connect with it failed");
                        }
                    }

                    if (cantBeOracle && Vsync.ClientOf == null) {
                        if (++OracleTries < 2) {
                            again = true;
                            continue;
                        }

                        if (Vsync.foundOracle == null) {
                            throw new VsyncException("I can't be the ORACLE but was unable to contact the ORACLE in VSYNC_UNICAST_ONLY mode");
                        }

                        throw new VsyncException("ORACLE is " + Vsync.foundOracle + " but I was unable to connect with it in VSYNC_UNICAST_ONLY mode");
                    }
                }

                new Thread(Group.GroupMemberHeartBeat) { Name = "Vsync All-Groups HeartBeat thread", IsBackground = true }.Start();
                if (Vsync.ClientOf == null) {
                    new Thread(Vsync.ORACLE.OracleHeartBeat) { Name = "Vsync <ORACLE> HeartBeat thread", IsBackground = true }.Start();
                    if (!ORACLE.HasFirstView && (VsyncSystem.Debug & VsyncSystem.STARTSEQ) != 0) {
                        Vsync.WriteLine("Restarting the ORACLE in " + VsyncSystem.GetState());
                    }
                }

                return Vsync.my_IPaddress;
            }
            catch (Exception e) {
                Vsync.WriteLine("VsyncLib: Initialization error <" + e + ">");
                VsyncSystem.VsyncActive = false;
            }

            return null;
        }

        private const string hex = "0123456789ABCDEF";

        private static byte[] byteVecParse(string arg) {
            int idx = 0;
            if (arg.Length != (VSYNC_AES.KeySize * 2)) {
                throw new VsyncException("VSYNC_AESKEY: argument has incorrect length (should be a " + VSYNC_AES.KeySize + "-byte/" + (VSYNC_AES.KeySize * 8) + "-bit vector, encoded as a hexstring");
            }

            byte[] bvec = new byte[VSYNC_AES.KeySize];
            for (int off = 0; off < bvec.Length; off++) {
                char c1 = arg[idx++];
                char c2 = arg[idx++];
                bvec[off] = (byte)((hex.IndexOf(c1) << 8) | hex.IndexOf(c2));
            }

            return bvec;
        }

        private static readonly IPAddress nullIPAddr = new IPAddress(0L);

        private static IPAddress[] ExtractHostIPAddrs(string hlist) {
            if (string.IsNullOrEmpty(hlist)) {
                if (Vsync.VSYNC_UNICAST_ONLY) {
                    hlist = "localhost";
                }
                else {
                    return null;
                }
            }

            int nContacts = 0;
            hlist += ",";
            for (int i = 0; i < hlist.Length; i++) {
                if (hlist[i] == ',') {
                    nContacts++;
                }
            }

            IPAddress[] newVSYNC_HOSTS = new IPAddress[nContacts];
            nContacts = 0;
            for (int i = 0; i < hlist.Length; i++) {
                if (hlist[i] == ',') {
                    string hname = hlist.Substring(0, i);
                    if (hname.Equals("localhost", StringComparison.Ordinal) || hname.Equals("0.0.0.0", StringComparison.Ordinal)) {
                        newVSYNC_HOSTS[nContacts++] = nullIPAddr;
                    }
                    else {
                        newVSYNC_HOSTS[nContacts++] = LastIPv4(hname);
                    }

                    hlist = hlist.Substring(i + 1);
                    i = 0;
                }
            }

            return newVSYNC_HOSTS;
        }

        internal static bool IPv4AddressIsAllowed(IPAddress address) {
            if (Vsync.VSYNC_NETMASK_ADDR == null || Vsync.VSYNC_SUBNET_ADDR == null) {
                return true;
            }

            if (address.AddressFamily == AddressFamily.InterNetwork) {
                // IPv4
                byte[] addressOctets = address.GetAddressBytes();
                byte[] netmastOctets = Vsync.VSYNC_NETMASK_ADDR.GetAddressBytes();
                byte[] subnetOctets = Vsync.VSYNC_SUBNET_ADDR.GetAddressBytes();
                return (subnetOctets[0] == (addressOctets[0] & netmastOctets[0])) && (subnetOctets[1] == (addressOctets[1] & netmastOctets[1])) && (subnetOctets[2] == (addressOctets[2] & netmastOctets[2])) && (subnetOctets[3] == (addressOctets[3] & netmastOctets[3]));
            }

            // IPv6
            return false;
        }

        private static readonly Dictionary<string, IPAddress> IPv4Map = new Dictionary<string, IPAddress>();

        private static readonly LockObject IPv4MapLock = new LockObject("IPv4MapLock");

        internal static IPAddress LastIPv4(string hname) {
            IPAddress theIPAddr;
            using (var tmpLockObj = new LockAndElevate(IPv4MapLock)) {
                if (IPv4Map.ContainsKey(hname)) {
                    return IPv4Map[hname];
                }

                theIPAddr = _LastIPv4(hname);
                if (theIPAddr != null) {
                    IPv4Map.Add(hname, theIPAddr);
                }
            }

            return theIPAddr;
        }

        internal static IPAddress _LastIPv4(string hname) {
            IPAddress rval;
            IPAddress[] list;
            if (IPAddress.TryParse(hname, out rval)) {
                return rval;
            }

            try {
#if __MonoCS__
                Vsync.Sleep((Vsync.my_pid % 1000) * 3);
#endif
                list = Dns.GetHostAddresses(hname);
            }
            catch (SocketException) {
                Vsync.WriteLine("Warning: IP Address or hostname <" + hname + "> is unknown");
                return new IPAddress(0);
            }

            foreach (IPAddress a in list) {
                if (!string.IsNullOrEmpty(hname) && !IPAddress.TryParse(hname, out rval)) {
                    if (IPv4AddressIsAllowed(a)) {
                        rval = a;
                    }
                }
                else {
                    if (a.AddressFamily == AddressFamily.InterNetwork) {
                        rval = a; // Picks last in the list
                    }
                }
            }

            if (rval != null) {
                return rval;
            }

            throw new VsyncException("IPv6 support: not yet implemented");
        }

        private static int tryCount;

        private static void tryToJoin() {
            if ((VsyncSystem.Debug & VsyncSystem.STARTSEQ) != 0) {
                Vsync.WriteLine("Sending the Oracle a JOIN request -- myAddress " + Vsync.my_address + (Vsync.foundOracle == null ? string.Empty : ", Oracle is " + Vsync.foundOracle));
            }

            int mode = Group.CREATE | Group.JOIN;
            if (VSYNC_CANJOINORACLE) {
                mode |= Group.CANBEORACLE;
            }

            if (Vsync.foundOracle == null || ++tryCount % 2 == 0) {
                ORACLE.doSend(false, false, Vsync.JOIN, Vsync.my_address, mode, new[] { "ORACLE" }, new[] { ORACLE.gaddr }, 0L, new[] { 0L }, new[] { 0 }, ++VsyncSystem.VsyncJoinCounter);
            }
            else {
                ORACLE.doP2PSend(Vsync.foundOracle, true, Vsync.JOIN, Vsync.my_address, mode, new[] { "ORACLE" }, new[] { ORACLE.gaddr }, 0L, new[] { 0L }, new[] { 0 }, ++VsyncSystem.VsyncJoinCounter);
            }
        }

        private static bool IAmInHostList() {
            return VSYNC_HOSTS_IPADDRS == null || (VSYNC_MY_IPADDRS == null ? VSYNC_HOSTS_IPADDRS.Contains(my_address.home) : VSYNC_HOSTS_IPADDRS.Intersect(VSYNC_MY_IPADDRS).Any());
        }

        internal static int pingCntr;

        internal static bool IWasLeader = false;

        internal static void SetupIM() {
            Vsync.VSYNCMEMBERS = new Group("VSYNCMEMBERS");
            if (Vsync.VSYNC_LARGE) {
                Vsync.VSYNCMEMBERS.SetLarge();
            }

            MCMDSocket.Setup(Vsync.VSYNCMEMBERS);
            VSYNCMEMBERS.ViewHandlers *= v => {
                if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0) {
                    Vsync.WriteLine(v.ToString());
                }

                Vsync.VSYNC_ASYNCMTOTALLIMIT = Math.Min(Vsync.VSYNC_MINASYNCMTOTAL, Math.Max(2, 1250 / v.members.Length));
                List<Group> gc = Group.VsyncGroupsClone();
                foreach (Address who in v.leavers) {
                    ReliableSender.NodeHasFailed(who);
                    foreach (Group g in gc) {
                        Group.GroupNoteFailure(g, who);
                    }
                }

                if (v.IAmLeader()) {
                    if (v.viewid == 0) {
                        IWasLeader = true;
                    }
                    else if (!IWasLeader) {
                        IWasLeader = true;
                        AnnounceMCMDMapping();
                    }
                }

                VSYNCMEMBERS.OOBNewView(v);
            };
            VSYNCMEMBERS.doRegister(Vsync.FDETECTION, new Action<Address>(who => NodeHasFailed(who, "Informed by some remote caller", true)));
            VSYNCMEMBERS.doRegister(Vsync.INQUIRE, new Action(() => {
                while (!VsyncSystem.VsyncActive) {
                    Vsync.Sleep(250);
                }

                while (VsyncSystem.VsyncActive) {
                    if (VsyncSystem.waitForWorkerSetup.WaitOne(120000)) {
                        VsyncSystem.RTS.ThreadCntrs[3]++;
                        VSYNCMEMBERS.doNullReply();
                        return;
                    }
                }
            }));
            VSYNCMEMBERS.doRegister(Vsync.INQUIRE, new Action<Address, int>((gaddr, vid) => VSYNCMEMBERS.doReply(ReliableSender.getMinStable(gaddr, vid))));
            VSYNCMEMBERS.doRegister(Vsync.BECLIENT, new Action<string>(gname => VSYNCMEMBERS.doReply(Client.GetTSigs(gname))));
            VSYNCMEMBERS.doRegister(Vsync.BECLIENT, new Action<string, Address>(Client.ResetRep));
            VSYNCMEMBERS.doRegister(Vsync.PING, new Action<string>(message => {
                Vsync.WriteLine("PING: [" + Vsync.MsToSecs(Vsync.NOW) + "]: Received <" + message + "> in view " + Vsync.VSYNCMEMBERS.theView.viewid);
                pingCntr++;
            }));
            VSYNCMEMBERS.doRegister(Vsync.PING, new Action(() => { }));
            VSYNCMEMBERS.doRegister(Vsync.IBADDRS, new Action<Address, Address[], int[], int[], int>((who, rmembers, p2pqps, ackqps, lid) => {
                for (int r = 0; r < rmembers.Length; r++) {
                    if (rmembers[r].isMyAddress()) {
                        IB.noteRemoteIB(who, rmembers, p2pqps[r], ackqps[r], lid);
                        break;
                    }
                }
            }));
            VSYNCMEMBERS.doRegister(Vsync.IBADDRS, new Action<Address, bool>(IB.noteRemoteIB));
            VSYNCMEMBERS.SetupIMTunnels();
            if (Vsync.WORKER_MODE) {
                return;
            }

            if (Vsync.IAmOracle && ORACLE.theView.IAmLeader()) {
                VSYNCMEMBERS.Create();
            }
            else {
                VSYNCMEMBERS.Join();
            }
        }

        internal static void AnnounceMCMDMapping() {
            if (Vsync.VSYNCMEMBERS == null || !Vsync.VSYNCMEMBERS.HasFirstView || !Vsync.VSYNCMEMBERS.theView.IAmLeader()) {
                return;
            }

            if ((VsyncSystem.Debug & VsyncSystem.MCMDMAP) != 0) {
                Vsync.WriteLine("Broadcasting new MCMD Mapping!");
            }

            int[,] theMap = MCMDSocket.MCMDvirtual.GetMapAll();
            if (theMap != null) {
                Vsync.VSYNCMEMBERS.doSend(false, false, Vsync.REMAP, Vsync.MapperEpochId, MCMDSocket.nextPhysIPAddr, theMap);
            }
        }

        internal class PendingLeaderOps {
            // Note that depending on which constructor is used, the DAL logic can handle reliable message forwarding OR at-most-once execution by a leader
            // Important to keep track of which case we're dealing with in the DAL code or various havoc can ensue....
            internal Group group;

            internal Address Sender;

            internal Msg reqMsg;

            internal Msg replyMsg;

            internal int uid;

            internal ThreadStart doTheAction;

            internal PendingLeaderOps(Group g, Address s, int u, ThreadStart d) {
                this.group = g;
                this.Sender = s;
                this.uid = u;
                this.doTheAction = d;
                this.reqMsg = g.getReplyToAndClear();
            }

            internal PendingLeaderOps(Group g, Address s, int u, Msg rqmsg, Msg rep) {
                this.group = g;
                this.Sender = s;
                this.uid = u;
                this.reqMsg = rqmsg;
                this.replyMsg = rep;
            }
        }

        internal static LockObject PendingLeaderOpsLock = new LockObject("PendingLeanderOpsLock");

        internal static List<PendingLeaderOps> PendingLeaderOpsList = new List<PendingLeaderOps>();

        internal static string GetPLLState() {
            using (var tmpLockObj = new LockAndElevate(PendingLeaderOpsLock)) {
                if (PendingLeaderOpsList.Count == 0) {
                    return string.Empty;
                }

                string s = "List of callbacks for DoAsLeader requests:" + Environment.NewLine;
                foreach (PendingLeaderOps plo in PendingLeaderOpsList) {
                    s += "    Group <" + plo.group.gname + ">, Sender " + plo.Sender + ", uid=" + plo.uid + Environment.NewLine;
                }

                return s;
            }
        }

        internal static void PendingLeaderViewChange(View v) {
            if (!ORACLE.LeaderMode && v.IAmLeader()) {
                TakeOverAsOracle();
            }

            // If someone gets added to the ORACLE, make sure to delete them from the CanBeOracleList
            // Obviously the leader won't find them on the list, but the other group members will
            // This way when we look for a candidate to replace a departing ORACLE member, we won't get
            // confused (in the VUProtocol) by entries that aren't actually valid candidates
            if (v.joiners.Length > 0) {
                using (var tmpLockObj = new LockAndElevate(CanBeOracleListLock)) {
                    foreach (Address who in v.joiners) {
                        CanBeOracleList.Remove(who);
                    }
                }
            }

            if (!v.IAmLeader()) {
                return;
            }

            List<PendingLeaderOps> callbackList = new List<PendingLeaderOps>();
            using (var tmpLockObj = new LockAndElevate(PendingLeaderOpsLock)) {
                List<PendingLeaderOps> newPendingLeaderOpsList = new List<PendingLeaderOps>();
                foreach (PendingLeaderOps outerPlo in PendingLeaderOpsList) {
                    if (outerPlo.group.gaddr != v.gaddr) {
                        newPendingLeaderOpsList.Add(outerPlo);
                    }
                    else if (outerPlo.replyMsg != null) {
                        callbackList.Add(outerPlo);
                    }
                    else if (outerPlo.replyMsg != null) {
                        PendingLeaderOps plo = outerPlo;
                        new Thread(() => {
                            try {
                                Msg.InvokeFromBArray(plo.replyMsg.payload, new Action<Address, byte, Address, byte[], int, int>((gaddr, type, destProc, buffer, vid, MsgID) => {
                                    Group g = Group.doLookup(gaddr);
                                    if (g != null) {
                                        ReliableSender.doSend(false, ReliableSender.my_p2psocket, g, type, destProc, buffer, vid, MsgID, true, null);
                                    }

                                    plo.group.doSend(false, false, DALDONE, plo.group.gaddr, plo.Sender, plo.uid);
                                }));
                            }
                            catch (VsyncShutdownException) {
                                VsyncSystem.CheckLocksHeld();
                            }

                            VsyncSystem.ThreadTerminationMagic();
                        }) { Name = "DAL Worker thread spawned in PendingLeaderViewChange", IsBackground = true }.Start();
                    }
                }

                PendingLeaderOpsList = newPendingLeaderOpsList;
            }

            foreach (PendingLeaderOps outerPlo in callbackList) {
                PendingLeaderOps plo = outerPlo;
                new Thread(() => {
                    try {
                        Group g = Group.doLookup(plo.group.gaddr);
                        if (g == null) {
                            throw new VsyncException("DAL callback: group not found");
                        }

                        g.setReplyTo(plo.reqMsg);
                        if ((VsyncSystem.Debug & VsyncSystem.DALLOGIC) != 0) {
                            Msg replyTo = plo.reqMsg;
                            Vsync.WriteLine("DAL callback: In group <" + g.gname + ">, Thread DoAsLeaderCallback, setting theMsg=" + replyTo.vid + ":" + replyTo.msgid + ", needsreply=" + ((replyTo.flags & Msg.NEEDSREPLY) != 0));
                        }

                        if (plo.doTheAction != null) {
                            plo.doTheAction();
                        }

                        g.clearReplyTo();
                        g.doUnorderedSend(DALDONE, g.gaddr, plo.Sender, plo.uid);
                    }
                    catch (VsyncShutdownException) {
                        VsyncSystem.CheckLocksHeld();
                    }

                    VsyncSystem.ThreadTerminationMagic();
                }) { Name = "DoAsLeader Callback", IsBackground = true }.Start();
            }
        }

        internal static void DALReplyNotify(Group g, Msg rmsg, PendingLeaderOps plos, Msg replyTo) {
            using (var tmpLockObj = new LockAndElevate(g.groupLock)) {
                g.NotifyDALOnReply = null;
            }

            byte f = replyTo.flags;
            replyTo.flags |= Msg.NEEDSREPLY;
            if ((VsyncSystem.Debug & VsyncSystem.DALLOGIC) != 0) {
                Vsync.WriteLine("DALReplyNotify: Doing an unordered multicast to DALdone for " + plos.group.gname + ", rqsender=" + plos.Sender + ", uid=" + plos.uid + ", rmsg=" + rmsg.sender + "::" + rmsg.vid + ":" + rmsg.msgid);
            }

            if (g != ORACLE) {
                ORACLE.doUnorderedQueryToBA(Group.ALL, new Timeout(Vsync.VSYNC_DEFAULTTIMEOUT, Timeout.TO_FAILURE, "DALDONE"), DALDONE, Vsync.my_address, plos.group.gaddr, plos.Sender, plos.uid, replyTo, rmsg, true);
            }
            else {
                ORACLE.doSend(false, false, DALDONE, Vsync.my_address, plos.group.gaddr, plos.Sender, plos.uid, replyTo, rmsg, false);
            }

            replyTo.flags = f;
        }

        // Should be called by all members of a group upon receipt of a virtually synchronous multicast containing somne request
        private static void DoAsLeader(Group g, Address Sender, int uid, ThreadStart theAction) {
            if ((VsyncSystem.Debug & VsyncSystem.DALLOGIC) != 0) {
                Vsync.WriteLine("DoAsLeader(<" + g.gname + ">, IAmLeader=" + g.theView.IAmLeader() + ", sender=" + Sender + ", uid=" + uid + ", action=" + theAction.Method + ")");
            }

            PendingLeaderOps plos = new PendingLeaderOps(g, Sender, uid, theAction);
            if (!g.theView.IAmLeader()) {
                using (var tmpLockObj = new LockAndElevate(PendingLeaderOpsLock)) {
                    foreach (PendingLeaderOps plo in PendingLeaderOpsList) {
                        if (plo.group.gaddr == g.gaddr && plo.Sender == Sender && plo.uid == uid) {
                            if (plo.replyMsg != null) {
                                return;
                            }

                            Vsync.WriteLine("WARNING: DoAsLeader was called twice for the identical request!  Gaddr " + g.gaddr + ", Sender " + Sender + ", UID " + uid);
                        }
                    }

                    PendingLeaderOpsList.Add(plos);
                    return;
                }
            }

            using (var tmpLockObj = new LockAndElevate(ORACLE.groupLock)) {
                ORACLE.NotifyDALOnReply = plos;
            }

            if (plos.reqMsg != null) {
                g.setReplyTo(plos.reqMsg);
                if ((VsyncSystem.Debug & VsyncSystem.DALLOGIC) != 0) {
                    Vsync.WriteLine("DAL: In group <" + g.gname + ">, setting theMsg=" + plos.reqMsg.vid + ":" + plos.reqMsg.msgid + ", needsreply=" + ((plos.reqMsg.flags & Msg.NEEDSREPLY) != 0));
                }
            }

            plos.doTheAction();
            if (plos.reqMsg != null && (plos.reqMsg.flags & Msg.NEEDSREPLY) != 0 && g.getReplyTo() != null) {
                if ((VsyncSystem.Debug & VsyncSystem.DALLOGIC) != 0) {
                    Vsync.WriteLine("DoAsLeader: Sending NullReply() because the dal action routine failed to send a reply");
                }

                g.NullReply();
            }

            g.clearReplyTo();

            // Notice the (legitimate) race condition here.  If the DoAsLeader logic doesn't send a reply, and JOIN doesn't do so,
            // then if the leader finishes the operation but then fails before this next Send occurs, the request will be repeated
            // by the new leader.  JOIN happens to be idempotent, which solves this particular problem.  If a request isn't
            // idempotent it really MUST have a requested reply, even if the reply is just "OK" and will be ignored
            g.doUnorderedSend(DALDONE, g.gaddr, Sender, uid);
        }

        internal static int OracleJoinsUnderway;

        internal static LockObject CanBeOracleListLock = new LockObject("CanBeOracleListLock");

        internal static List<Address> CanBeOracleList = new List<Address>();

        internal static List<Address> FDRunning = new List<Address>();

        internal static void SetupORACLE() {
            ORACLE.RegisterViewHandler(PendingLeaderViewChange);
            ORACLE.doRegister(DALDONE, new Action<Address, Address, Address, int, Msg, Msg, bool>((sender, gaddr, rqInitiator, uid, rqmsg, rmsg, needsReply) => {
                if (sender.isMyAddress()) {
                    return;
                }

                if ((VsyncSystem.Debug & VsyncSystem.DALLOGIC) != 0) {
                    Vsync.WriteLine("DALdone: Received a DAL done(1) event from " + sender + " for " + gaddr + ", sender=" + rqInitiator + ", uid=" + uid);
                }

                using (var tmpLockObj = new LockAndElevate(PendingLeaderOpsLock)) {
                    bool fnd = false;
                    foreach (PendingLeaderOps plo in PendingLeaderOpsList) {
                        if (plo.group.gaddr == gaddr && plo.Sender == rqInitiator && plo.uid == uid) {
                            plo.replyMsg = rmsg;
                            fnd = true;
                            break;
                        }
                    }

                    if (!fnd) {
                        // Occurs if there is a race between the original request to the ORACLE and the Reply by the initial leader
                        if ((VsyncSystem.Debug & VsyncSystem.DALLOGIC) != 0) {
                            Vsync.WriteLine("DoAsLeader(<ORACLE>, sender=" + sender + ", uid=" + uid + "), got a DONE message but didn't find a PLOS record, create one");
                        }

                        PendingLeaderOpsList.Add(new PendingLeaderOps(ORACLE, rqInitiator, uid, rqmsg, rmsg));
                    }
                }

                if (needsReply) {
                    ORACLE.doReply("OK");
                }
            }));
            ORACLE.doRegister(DALDONE, new Action<Address, Address, int>((gaddr, sender, uid) => {
                if ((VsyncSystem.Debug & VsyncSystem.DALLOGIC) != 0) {
                    Vsync.WriteLine("DALdone(2): sender " + sender + " gaddr " + gaddr + ", uid=" + uid);
                }

                using (var tmpLockObj = new LockAndElevate(PendingLeaderOpsLock)) {
                    List<PendingLeaderOps> newPendingLeaderOpsList = new List<PendingLeaderOps>();
                    foreach (PendingLeaderOps plo in PendingLeaderOpsList) {
                        if (plo.group.gaddr != gaddr || plo.Sender != sender || plo.uid != uid) {
                            newPendingLeaderOpsList.Add(plo);
                        }
                        else if ((VsyncSystem.Debug & VsyncSystem.DALLOGIC) != 0) {
                            Vsync.WriteLine("DALdone(2): Remove DAL record for " + sender + " for " + gaddr + ", uid=" + uid);
                        }
                    }

                    PendingLeaderOpsList = newPendingLeaderOpsList;
                }
            }));

            ORACLE.doRegister(JOIN, new Action<Address>(who => {
                if ((VsyncSystem.Debug & VsyncSystem.STARTSEQ) != 0) {
                    Vsync.WriteLine("Heard from the ORACLE, his address is " + who);
                }

                Vsync.foundOracle = who;

                // This actually prevents ME from dinging HIM as faulty
                ReliableSender.nodeInStartup(who);
            }));

            ORACLE.doRegister(ORACLERUNNING, new Action<Address>(who => {
                Vsync.WriteLine("ORACLERUNNING: " + who);
                View theView;
                using (var tmpLockObj = new LockAndElevate(ORACLE.ViewLock))
                    theView = ORACLE.theView;
                if (!VsyncSystem.VsyncActive || !ORACLE.IAmLeader() || my_address.CompareTo(who) <= 0 || theView == null || theView.leavers.Contains(who)) {
                    return;
                }

                if (VSYNCMEMBERS.HasFirstView) {
                    VSYNCMEMBERS.doSend(false, false, PARTITIONED, who);
                    Vsync.Sleep(1000);
                    throw new VsyncException("ORACLE: Discovered I am in a minority partition" + VsyncSystem.GetState());
                }
            }));

            ORACLE.doRegister(JOIN, new Action<Address, int, string[], Address[], long, long[], int[], int>((who, mode, gnames, gaddrs, offset, tsigs, flags, uid) => {
                // JOIN actually uses a different scheme to ensure fault-tolerance, implemented by the VUProtocol
                // In future work I really should merge these into the DoAsLeader pattern but there are some subtle
                // issues because of the way that group view events in the ORACLE itself need to be handled
                if (gaddrs.Length == 1 && gaddrs[0] == ORACLE.gaddr && ORACLE.theView != null) {
                    if (ORACLE.theView.GetRawRankOf(who) != -1) {
                        // Ignore artifacts of the start sequence, which can involve asking to join multiple times
                        return;
                    }

                    if (ORACLE.theView.GetMyRank() != -1) {
                        // Inhibit creation of a second oracle, in case leader is slow to respond
                        if (!who.isMyAddress()) {
                            if ((VsyncSystem.Debug & VsyncSystem.STARTSEQ) != 0) {
                                Vsync.WriteLine("Received a JOIN inquiry in ORACLE, sending a message to inhibit creation of new ORACLEs to " + who);
                            }

                            Vsync.ORACLE.doPureP2PSend(who, true, Vsync.JOIN, Vsync.my_address);

                            // Deals with sluggish C# class loader, which can lock out I/O for many seconds at a time during startup
                            ReliableSender.nodeInStartup(who);
                        }
                    }
                }

                if ((VsyncSystem.Debug & (VsyncSystem.STARTSEQ | VsyncSystem.GROUPEVENTS | VsyncSystem.VIEWCHANGE)) != 0) {
                    string gns = string.Empty, isls = " ";
                    foreach (string s in gnames) {
                        gns += " " + s;
                    }

                    foreach (int f in flags) {
                        isls += f + " ";
                    }

                    Vsync.WriteLine("Oracle received a JOIN <" + gns + " >, gaddrs=" + Address.VectorToString(gaddrs) + ", flags={" + isls + "}, request... my_address " + Vsync.my_address + ", joiner address " + who);
                }

                if (gnames.Length == 1 && gnames[0].Equals("ORACLE", StringComparison.Ordinal)) {
                    if (who.isMyAddress()) {
                        return;
                    }

                    using (var tmpLockObj = new LockAndElevate(recent_inquiries_lock)) {
                        foreach (Address a in recent_inquiries) {
                            if (a == who) {
                                return;
                            }
                        }

                        recent_inquiries.Add(who);
                        {
                            // Using...
                            Address ri = who;
                            Vsync.OnTimer(5000, () => {
                                using (var tmpLockObj1 = new LockAndElevate(recent_inquiries_lock)) {
                                    recent_inquiries.Remove(ri);
                                }
                            });
                        }
                    }

                    bool coreOracleJoiner = false;
                    bool isACandidate = false;
                    using (var tmpLockObj = new LockAndElevate(Vsync.ORACLE.groupLock)) {
                        if (ORACLE.HasFirstView && (mode & Group.CANBEORACLE) != 0) {
                            if (ORACLE.theView.nLive() < VSYNC_ORACLESIZE - OracleJoinsUnderway) {
                                // If we get here, we're currently short on ORACLE members and had better do something about it
                                if (VSYNC_HOSTS_IPADDRS == null) {
                                    ++OracleJoinsUnderway;
                                    coreOracleJoiner = true;
                                }
                                else {
                                    foreach (IPAddress ipa in VSYNC_HOSTS_IPADDRS) {
                                        if (ipa.Equals(who.home)) {
                                            ++OracleJoinsUnderway;
                                            coreOracleJoiner = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            else if (ORACLE.IAmLeader()) {
                                isACandidate = true;
                            }
                        }
                    }

                    if (isACandidate) {
                        // Pass the word: this is a candidate to join the oracle if the need ever arises
                        ORACLE.Send(Vsync.CANBEORACLE, who);
                    }

                    if (!coreOracleJoiner) {
                        if (!ORACLE.IAmLeader()) {
                            return;
                        }

                        SendInitialOracleLeaderInfo(who, Vsync.my_address);
                        return;
                    }
                }

                if ((VsyncSystem.Debug & (VsyncSystem.STARTSEQ | VsyncSystem.GROUPEVENTS)) != 0) {
                    Vsync.WriteLine("Initiating VUProtocol in ORACLE.Join");
                }

                bool fnd = false;
                foreach (string gn in gnames) {
                    if (Group.TrackingProxyLookup(gn) != null) {
                        fnd = true;
                        break;
                    }
                }

                if (!fnd) {
                    foreach (Address ga in gaddrs) {
                        if (Group.TrackingProxyLookup(ga) != null) {
                            fnd = true;
                            break;
                        }
                    }
                }

                if (fnd) {
                    new Thread(() => {
                        try {
                            MCMDSocket.InitializeMap(who, gnames, gaddrs);
                        }
                        catch (VsyncShutdownException) {
                            VsyncSystem.CheckLocksHeld();
                        }

                        VsyncSystem.ThreadTerminationMagic();
                    }) { Name = "MCMDSocket.InitializeMap", IsBackground = true }.Start();
                }

                VUProtocol(JOIN, who, mode, gnames, gaddrs, offset, tsigs, flags, uid);
            }));

            ORACLE.RegisterHandler(Vsync.CANBEORACLE, new Action<Address>(who => {
                using (var tmpLockObj = new LockAndElevate(CanBeOracleListLock)) {
                    if (!CanBeOracleList.Contains(who)) {
                        CanBeOracleList.Add(who);
                    }
                }
            }));

            ORACLE.doRegister(LEAVE, new Action<Address, int, string[], Address[], int[], int>((who, mode, gnames, gaddrs, flags, uid) => {
                if ((VsyncSystem.Debug & VsyncSystem.GROUPEVENTS) != 0) {
                    Vsync.WriteLine("Initiating VUProtocol in ORACLE.Leave");
                }

                VUProtocol(LEAVE, who, mode, gnames, gaddrs, 0L, null, flags, uid);
            }));

            ORACLE.doRegister(TERMINATE, new Action<Address, int, Address[]>((who, uid, gaddrs) => {
                List<Group> glist = new List<Group>();
                List<Group> lglist = new List<Group>();
                foreach (Address a in gaddrs) {
                    Group g = Group.TrackingProxyLookup(a);
                    if (g == null) {
                        continue;
                    }

                    if ((g.flags & Group.G_ISLARGE) == 0) {
                        glist.Add(g);
                    }
                    else {
                        lglist.Add(g);
                    }
                }

                if (glist.Count != 0) {
                    Group.doMultiSend(glist, true, TERMINATE);
                }

                if (lglist.Count != 0) {
                    foreach (Group g in lglist) {
                        g.P2PSend(g.theView.members[0], Vsync.RELAYSEND, new Msg(TERMINATE));
                    }
                }

                foreach (Address a in gaddrs) {
                    Group g = Group.TrackingProxyLookup(a);
                    if (g == null) {
                        continue;
                    }

                    using (var tmpLockObj = new LockAndElevate(Group.TPGroupsLock)) {
                        Group.TPGroups.Remove(g.gaddr);
                    }
                }
            }));

            ORACLE.doRegister(Vsync.RELAYJOIN, new Action<Address, int, int, string[], Address[], long, long[], int[]>((joiner, uid, mode, gnames, gaddrs, offset, tsigs, flags) => Vsync.DoAsLeader(ORACLE, joiner, uid, () => {
                if ((VsyncSystem.Debug & VsyncSystem.RELAYLOGIC) != 0) {
                    Vsync.WriteLine("In DAL for Vsync.RELAYJOIN: sender " + joiner + " vectors of length " + gnames.Length);
                    for (int n = 0; n < gnames.Length; n++) {
                        Vsync.WriteLine("   gname " + gnames[n] + ", gaddrs " + gaddrs[n] + ", gsigs " + tsigs[n]);
                    }
                }

                ORACLE.doSend(false, false, Vsync.JOIN, joiner, mode, gnames, gaddrs, offset, tsigs, flags, ++VsyncSystem.VsyncJoinCounter);
                ORACLE.doReply("OK");
            })));

            ORACLE.doRegister(Vsync.RELAYLEAVE, new Action<Address, int, string[], Address[], int[]>((sender, uid, gnames, gaddrs, flags) => Vsync.DoAsLeader(ORACLE, sender, uid, () => {
                if ((VsyncSystem.Debug & VsyncSystem.RELAYLOGIC) != 0) {
                    Vsync.WriteLine("In Vsync.RELAYLEAVE: sender " + sender + " vectors of length " + gnames.Length);
                    for (int n = 0; n < gnames.Length; n++) {
                        Vsync.WriteLine("   gname " + gnames[n] + ", gaddrs " + gaddrs[n]);
                    }
                }

                ORACLE.doSend(false, false, Vsync.LEAVE, sender, 0, gnames, gaddrs, flags, ++VsyncSystem.VsyncJoinCounter);
                ORACLE.doReply("OK");
            })));

            ORACLE.doRegister(Vsync.RELAYTERM, new Action<Address, int, Address[]>((who, uid, gaddrs) => Vsync.DoAsLeader(ORACLE, who, uid, () => {
                ORACLE.doSend(false, false, Vsync.TERMINATE, Vsync.my_address, ORACLE.uids++, gaddrs);
                ORACLE.doReply("OK");
            })));

            ORACLE.doRegister(Vsync.ISSTABLE, new Action<Address, int>(Vsync.clearOldVDS));

            ORACLE.doRegister(FDETECTION, new Action<Address>(who => {
                // Another special situation since failure may have caused the prior leader to crash
                // Todo: Look for a way to fold this into the DoAsLeader pattern used above
                // For now the needed pattern is implemented separately in the VUProtocol logic
                List<Group> glist = new List<Group>(), theClone = Group.VsyncAllGroupsClone(false);
                bool OracleMemberFailed = false;
                bool IwasOldLeader = ORACLE.LeaderMode;
                bool IamNewLeader = false;
                if ((VsyncSystem.Debug & (VsyncSystem.GROUPEVENTS | VsyncSystem.FAILURES)) != 0) {
                    Vsync.WriteLine("FDETECTION message received for " + who + "(I was old leader: " + IwasOldLeader + ")");
                }

                if (who.isMyAddress()) {
                    VsyncSystem.GotPoison("Failure detection broadcast reported my demise");
                }

                if (!VsyncSystem.VsyncActive || VsyncSystem.VsyncRestarting || VSYNCMEMBERS == null || !VSYNCMEMBERS.HasFirstView) {
                    return;
                }

                ReliableSender.NodeHasFailed(who);
                foreach (Group g in theClone) {
                    using (new ILock(ILock.LLBRIEF, g.gaddr)) {
                        if (g.theView == null || g.theView.GetRawRankOf(who) == -1) {
                            continue;
                        }

                        if ((VsyncSystem.Debug & (VsyncSystem.GROUPEVENTS | VsyncSystem.FAILURES)) != 0) {
                            Vsync.WriteLine("FDETECTION(Vsync_Groups) calling View.NoteFailed in <" + g.gname + "> for " + who);
                        }

                        View.noteFailed(g, who);
                        if (g == ORACLE) {
                            OracleMemberFailed = true;
                            if (!IwasOldLeader && g.theView.IAmLeader()) {
                                if ((VsyncSystem.Debug & VsyncSystem.GROUPEVENTS) != 0) {
                                    Vsync.WriteLine("I am new leader!");
                                }

                                IamNewLeader = true;
                            }
                            else if ((VsyncSystem.Debug & VsyncSystem.GROUPEVENTS) != 0) {
                                Vsync.WriteLine("In scan of g.ORACLE I am NOT the new leader because IwasOldLeader=" + IwasOldLeader + " and g.theView.IAmLeader=" + g.theView.IAmLeader() + " in view " + g.theView);
                            }
                        }
                        else {
                            glist.Add(g);
                        }
                    }
                }

                if (Vsync.ClientOf == null && ORACLE.IAmLeader()) {
                    View v;
                    using (var tmpLockObj = new LockAndElevate(ORACLE.ViewLock)) {
                        v = ORACLE.theView;
                    }

                    // Break any wait states within the ORACLE itself.  This avoids deadlock
                    foreach (Address a in v.members) {
                        ORACLE.doP2PSend(a, true, FANNOUNCE, who);
                    }
                }

                // Now send a virtually synchronous announcement but do it in a separate thread
                new Thread(() => {
                    try {
                        VSYNCMEMBERS.Send(FANNOUNCE, who);
                    }
                    catch (VsyncShutdownException) {
                        VsyncSystem.CheckLocksHeld();
                    }

                    VsyncSystem.ThreadTerminationMagic();
                }) { Name = "Send FANNOUNCE " + who, IsBackground = true }.Start();
                if (Vsync.ClientOf != null) {
                    return;
                }

                // Code run only by members of the ORACLE group
                if (OracleMemberFailed) {
                    // Handled separately because it may trigger an immediate add of someone, and we don't want to add that same process
                    // to any other groups that might have failed and would be listed in glist.  So we break it into two events.
                    VUProtocol(LEAVE, who, 0, new string[1] { ORACLE.gname }, new Address[1] { ORACLE.gaddr }, 0L, null, null, -1);
                }

                if (glist.Count > 0) {
                    VUProtocol(LEAVE, who, 0, glist.Select(g => g.gname).Distinct(StringComparer.Ordinal).ToArray(), glist.Select(g => g.gaddr).Distinct().ToArray(), 0L, null, null, -1);
                }

                if (!IamNewLeader || OracleViewTaskRunning || Vsync.RunningLeaderLogic) {
                    return;
                }

                Vsync.RunningLeaderLogic = true;
                Vsync.LeaderId += ORACLE.theView.GetMyRank();
                ReliableSender.SendPoison(who, Vsync.my_address + " believes that you have failed");
                new Thread(() => {
                    try {
                        Dictionary<Address, bool> OnceAndFutureOracleMembers = new Dictionary<Address, bool>();
                        foreach (Address a in ORACLE.theView.members) {
                            OnceAndFutureOracleMembers.Add(a, false);
                        }

                        if ((VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                            Vsync.WriteLine("Sending INQUIRE message...");
                        }

                        ORACLE.theView.isFinal = false;
                        List<Address> mustContact = new List<Address>();
                        int scannedTo = -1;
                        ORACLE.doQueryInvoke(Group.ALL, new Timeout(Vsync.VSYNC_DEFAULTTIMEOUT * 20, Timeout.TO_FAILURE, "INQUIRE"), INQUIRE, my_address, new MergeProposals((from, hisLeader, vds) => doMergeProposals(from, hisLeader, vds, OnceAndFutureOracleMembers, mustContact, ref scannedTo)));
                        while (mustContact.Count > 0) {
                            List<Address> contacting = mustContact;
                            mustContact = new List<Address>();
                            foreach (Address a in contacting) {
                                List<Address> whoReplied = new List<Address>();
                                List<Address> hisLeader = new List<Address>();
                                List<ViewDelta[]> vds = new List<ViewDelta[]>();
                                VSYNCMEMBERS.doP2PQuery(a, new Timeout(Vsync.VSYNC_DEFAULTTIMEOUT * 20, Timeout.TO_FAILURE, "INQUIRE"), INQUIRE, my_address, Group.EOL, whoReplied, hisLeader, vds);
                                if (whoReplied.Count > 0) {
                                    doMergeProposals(whoReplied.ToArray(), hisLeader.ToArray(), vds.ToArray(), OnceAndFutureOracleMembers, mustContact, ref scannedTo);
                                }
                            }
                        }

                        int rCnt = 0;
                        foreach (KeyValuePair<Address, bool> kvp in OnceAndFutureOracleMembers) {
                            if (kvp.Value) {
                                ++rCnt;
                            }
                        }

                        if ((VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                            string resps = " ";
                            foreach (KeyValuePair<Address, bool> kvp in OnceAndFutureOracleMembers) {
                                resps += "<" + kvp.Key + "::" + kvp.Value + "> ";
                            }

                            Vsync.WriteLine("After INQUIRE: Contacted " + resps + " total of " + rCnt + " replies, needed " + ((OnceAndFutureOracleMembers.Count + 1) / 2));
                            Vsync.WriteLine("After INQUIRE proposed contains...");
                            if (Vsync.Proposed == null) {
                                Vsync.WriteLine(" ... Vsync.proposed is null");
                            }
                            else {
                                for (int p = 0; p < Vsync.Proposed.Length; p++) {
                                    Vsync.WriteLine("PROPOSAL[" + p + "]=" + Vsync.Proposed[p]);
                                }
                            }

                            Vsync.WriteLine("Starting the OracleViewTask thread");
                        }

                        if (rCnt < (OnceAndFutureOracleMembers.Count + 1) / 2) {
                            throw new VsyncException("New ORACLE leader was unable to contact a quorum of once and future ORACLE members");
                        }

                        // Runs only in the current leader... and now, that's me!
                        TakeOverAsOracle();
                    }
                    catch (VsyncShutdownException) {
                        VsyncSystem.CheckLocksHeld();
                    }

                    VsyncSystem.ThreadTerminationMagic();
                }) { IsBackground = true }.Start();
            }));
            ORACLE.doRegister(BECLIENT, new Action<string>(gname => ORACLE.doReply(Client.SelectHisRep(gname))));
            ORACLE.doRegister(RELAYREGISTERVG, new Action<Address, Address, Address[]>((sender, nVGA, members) => ORACLE.doSend(false, false, REGISTERVG, sender, nVGA, members)));
            ORACLE.doRegister(REGISTERVG, new Action<Address, Address, Address[]>(Group.noteVGMap));
            ORACLE.GroupOpen = ORACLE.WasOpen = true;
            ReliableSender.StartGroupReader(ORACLE);
        }

        private static void TakeOverAsOracle() {
            if (VSYNCMEMBERS == null) {
                return;
            }

            ORACLE.LeaderMode = true;
            ORACLE.TakingOver = true;
            Vsync.IAmOracle = true;
            Vsync.OracleViewThread = new Thread(Vsync.OracleViewTask) { Name = "Vsync <ORACLE> View Thread", IsBackground = true };
            Vsync.OracleViewThread.Start();
            MCMDSocket.RunMappingTask();
            VSYNCMEMBERS.Send(BECLIENT, Vsync.my_address);
        }

        // As we INQUIRE we learn about new proposals, which we merge into the existing list.  We may also encounter added group members
        // Handles the so-called "dueling leaders" situation, in which there are two proposals for the same slot
        internal static void doMergeProposals(Address[] from, Address[] hisLeader, ViewDelta[][] vds, Dictionary<Address, bool> OnceAndFutureOracleMembers, List<Address> mustContact, ref int scannedTo) {
            ViewDelta[] proposed = Vsync.Proposed ?? new ViewDelta[0];
            for (int v = 0; v < from.Length; v++) {
                if (OnceAndFutureOracleMembers.ContainsKey(from[v])) {
                    OnceAndFutureOracleMembers[from[v]] = true;
                }
                else {
                    throw new VsyncException("Unexpected ORACLE INQUIRY response: from " + from[v] + " but I didn't think I had contacted him!");
                }

                ViewDelta[] vd = vds[v];
                if ((VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                    Vsync.WriteLine("Recieved INQUIRE replies...");
                    for (int vv = 0; vv < vd.Length; vv++) {
                        Vsync.WriteLine("REPLY[" + v + ":" + vv + "]=" + vd[vv]);
                    }
                }

                bool useProposal = false;
                bool ignoreIt = false;
                int minLen = Math.Min(vd.Length, proposed.Length);
                for (int i = 0; i < minLen; i++) {
                    if (vd[i].leaderId > Vsync.Proposed[i].leaderId) {
                        // Dueling leaders (very rare): in this case we just encountered a "better" proposal
                        // We'll switch to it even if it is shorter
                        if ((VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                            Vsync.WriteLine("Dueling leaders!  Found a better proposal, switching to it");
                        }

                        useProposal = true;
                    }
                    else if (vd[i].leaderId < Vsync.Proposed[i].leaderId) {
                        // Dueling leaders (very rare): in this case wejust encountered an old "stale" proposal
                        // We'll switch to it even if it is shorter
                        if ((VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                            Vsync.WriteLine("Dueling leaders!  New proposal is inferior, ignoring it");
                        }

                        ignoreIt = true;
                        break;
                    }

                    if (i > scannedTo && vd[i].gaddr == ORACLE.gaddr && vd[i].joiners.Length > 0) {
                        scannedTo = i;
                        foreach (Address a in vd[i].joiners) {
                            if (!OnceAndFutureOracleMembers.ContainsKey(a)) {
                                OnceAndFutureOracleMembers.Add(a, false);
                                mustContact.Add(a);
                            }
                        }
                    }
                }

                if (!ignoreIt && (Vsync.Proposed == null || vd.Length > Vsync.Proposed.Length || useProposal)) {
                    Vsync.Proposed = vd;
                }
            }
        }

        internal static void SendInitialOracleLeaderInfo(Address who, Address OracleLeader) {
            if (who.isMyAddress() || Vsync.ORACLE.theView.GetRankOf(who) != -1) {
                return;
            }

            if ((VsyncSystem.Debug & (VsyncSystem.STARTSEQ | VsyncSystem.VIEWCHANGE | VsyncSystem.GROUPEVENTS)) != 0) {
                Vsync.WriteLine("Oracle leader sending a NULL INITIALVIEW message to a future CLIENT, my_address " + Vsync.my_address + ", new client is " + who + ", ORACLE view " + ORACLE.theView);
            }

            ORACLE.doP2PSend(who, true, INITIALVIEW, OracleLeader);
        }

        internal class GVEvent {
            internal int request;

            internal Address who;

            internal int mode;

            internal int uid;

            internal string[] gnames;

            internal Address[] gaddrs;

            internal long offset;

            internal long[] tsigs;

            internal int[] flags;

            internal GVEvent(int r, Address a, int m, string[] gns, Address[] gs, long off, long[] ts, int[] fl, int u) {
                this.request = r;
                this.who = a;
                this.mode = m;
                this.gnames = gns;
                this.gaddrs = gs;
                this.offset = off;
                this.tsigs = ts;
                this.flags = fl;
                this.uid = u;
            }

            public override string ToString() {
                string gs = " ";
                foreach (string s in this.gnames) {
                    gs += s + " ";
                }

                return "GVE: request=" + rToString(this.request) + ", who=" + this.who + ", mode=" + this.mode + ", gnames={" + gs + "}, gaddrs=" + Address.VectorToString(this.gaddrs) + ", flags=" + this.flags + ", uid=" + this.uid;
            }
        }

        internal static List<GVEvent> GVEList = new List<GVEvent>();

        internal static LockObject GVELock = new LockObject("GVELock");

        internal static List<GVEvent> AGVEList = new List<GVEvent>();

        internal static LockObject AGVELock = new LockObject("AGVELock");

        internal static string GetGVEState() {
            string s = "Group view events list:" + Environment.NewLine;
            using (var tmpLockObj = new LockAndElevate(GVELock)) {
                if (GVEList.Count > 0) {
                    foreach (GVEvent gve in GVEList) {
                        string gns = " ";
                        if (gve.gnames != null) {
                            foreach (string gs in gve.gnames) {
                                gns += "<" + gs + ">";
                            }
                        }

                        s += "  Action[" + gve.uid + "]: " + rToString(gve.request) + " " + gve.who + " on groups {" + gns + "}, gaddrs {" + Address.VectorToString(gve.gaddrs) + "}" + Environment.NewLine;
                    }
                }
            }

            // Omit unless debugging the GVE logic
            if ((VsyncSystem.Debug & VsyncSystem.GVELOGIC) != 0) {
                using (var tmpLockObj = new LockAndElevate(AGVELock)) {
                    if (AGVEList.Count > 0) {
                        foreach (GVEvent gve in AGVEList) {
                            string gns = " ";
                            if (gve.gnames != null) {
                                foreach (string gs in gve.gnames) {
                                    gns += gs;
                                }
                            }

                            s += "  Anti-action[" + gve.uid + "]: " + gve.who + Environment.NewLine;
                        }
                    }
                }
            }

            return s;
        }

        /// <exclude>
        /// <summary>
        /// Internal
        /// </summary>
        /// </exclude>
#if PROTOCOL_BUFFERS
        [ProtoContract(SkipConstructor = true)]
#else
        [AutoMarshalled]
#endif
        public class ViewDelta : IEquatable<ViewDelta> {
            [ProtoMember(1)]
            public string gname = string.Empty;

            [ProtoMember(2)]
            public readonly Address gaddr;

            [ProtoMember(3)]
            public long tsig;

            [ProtoMember(4)]
            public long leaderId;

            [ProtoMember(5)]
            public int[] mcmdmap;

            [ProtoMember(6)]
            public int prevVid;

            [ProtoMember(7)]
            public bool isLarge;

            [ProtoMember(8)]
            public int[] lastSeqns;

            // i'th element gives the final incoming message count from the i'th member of the previous view
            [ProtoMember(9)]
            public Address[] joiners;

            [ProtoMember(10)]
            public long offset;

            [ProtoMember(11)]
            public Address[] leavers;

#if PROTOCOL_BUFFERS
            [ProtoAfterDeserialization]
            private void AfterDeserialize()
            {
                if (this.gname == null)
                {
                    this.gname = string.Empty;
                }

                if (this.mcmdmap == null)
                {
                    this.mcmdmap = new int[0];
                }

                if (this.lastSeqns == null)
                {
                    this.lastSeqns = new int[0];
                }

                if (this.joiners == null)
                {
                    this.joiners = new Address[0];
                }

                if (this.leavers == null)
                {
                    this.leavers = new Address[0];
                }
            }
#else
            public ViewDelta() {
            }
#endif

            internal ViewDelta(string name, Address ga, long ts, int[] mm, int v, int nm, Address[] wantJoin, long off, Address[] wantLeave, bool lf) {
                this.leaderId = Vsync.LeaderId;
                this.gname = name;
                this.gaddr = ga;
                this.tsig = ts;
                this.mcmdmap = mm;
                this.prevVid = v;
                this.joiners = wantJoin;
                this.offset = off;
                this.leavers = wantLeave;
                this.isLarge = lf;
                this.lastSeqns = this.isLarge ? new int[0] : new int[nm];

                // Where not large, these won't be final until the COMMIT event.
            }

            internal ViewDelta(string name, Address g, long off, int[] mm, int v, int[] ls, bool lf) {
                this.leaderId = Vsync.LeaderId;
                this.gname = name;
                this.gaddr = g;
                this.mcmdmap = mm;
                this.prevVid = v;
                this.lastSeqns = ls;
                this.isLarge = lf;
                this.offset = off;
                this.joiners = this.leavers = new Address[0];
            }

            public static bool operator ==(ViewDelta first, ViewDelta second) {
                return Equals(first, second);
            }

            public static bool operator !=(ViewDelta first, ViewDelta second) {
                return !Equals(first, second);
            }

            public static bool Equals(ViewDelta first, ViewDelta second) {
                if (object.ReferenceEquals(first, second)) {
                    return true;
                }

                if (object.ReferenceEquals(first, null) || object.ReferenceEquals(second, null)) {
                    return false;
                }

                return first.gaddr == second.gaddr && first.prevVid == second.prevVid;
            }

            public override bool Equals(object other) {
                return Equals(this, other as ViewDelta);
            }

            public bool Equals(ViewDelta other) {
                return Equals(this, other);
            }

            public override int GetHashCode() {
                return this.gaddr.GetHashCode() ^ this.prevVid.GetHashCode();
            }

            public override string ToString() {
                return " LeaderId=" + this.leaderId + ", Group <" + this.gname + "> " + this.gaddr + " (mmap " + MCMDSocket.PMCAddr(this.mcmdmap[0]) + ":" + MCMDSocket.PMCAddr(this.mcmdmap[1]) + "), isLarge=" + this.isLarge + ", prevVid " + this.prevVid + this.idsToVec() + ", Joining: {" + Address.VectorToString(Expand(this.joiners)) + "}, Leaving: {" + Address.VectorToString(Expand(this.leavers)) + "}";
            }

            private string idsToVec() {
                if (this.lastSeqns == null || this.lastSeqns.Length == 0) {
                    return string.Empty;
                }

                string s = ", final msg counts: {";
                foreach (int i in this.lastSeqns) {
                    s = s + " " + i + " ";
                }

                return s + "}";
            }
        }

#if PROTOCOL_BUFFERS
        [ProtoContract(SkipConstructor = true)]
#else
        [AutoMarshalled]
#endif
        public class UnstableList : IEquatable<UnstableList> {
            [ProtoMember(1)]
            public readonly Address gaddr;

            [ProtoMember(2)]
            public Address flusher;

            [ProtoMember(3)]
            public readonly Address sender;

            [ProtoMember(4)]
            public readonly int vid;

            [ProtoMember(5)]
            public int mid_low;

            [ProtoMember(6)]
            public int mid_hi;

#if !PROTOCOL_BUFFERS
            public UnstableList() {
            }
#endif

            internal UnstableList(Address g, Address f, Address s, int v, int ml, int mh) {
                this.gaddr = g;
                this.flusher = f;
                this.sender = s;
                this.vid = v;
                this.mid_low = ml;
                this.mid_hi = mh;
            }

            public static bool operator ==(UnstableList first, UnstableList second) {
                return Equals(first, second);
            }

            public static bool operator !=(UnstableList first, UnstableList second) {
                return !Equals(first, second);
            }

            public static bool Equals(UnstableList first, UnstableList second) {
                if (object.ReferenceEquals(first, second)) {
                    return true;
                }

                if (object.ReferenceEquals(first, null) || object.ReferenceEquals(second, null)) {
                    return false;
                }

                return first.gaddr == second.gaddr && first.sender == second.sender && first.vid == second.vid && first.mid_low == second.mid_low && first.mid_hi == second.mid_hi;
            }

            public override bool Equals(object other) {
                return Equals(this, other as UnstableList);
            }

            public bool Equals(UnstableList other) {
                return Equals(this, other);
            }

            public override int GetHashCode() {
                return this.gaddr.GetHashCode() ^ this.sender.GetHashCode() ^ this.vid.GetHashCode() ^ this.mid_low.GetHashCode() ^ this.mid_hi.GetHashCode();
            }

            public override string ToString() {
                return " Group " + this.gaddr + ", Flusher " + this.flusher + ": MSG[sender " + this.sender + ", ID " + this.vid + ":(" + this.mid_low + "-" + this.mid_hi + ")]";
            }
        }

        private delegate void MergeProposals(Address[] who, Address[] hisLeader, ViewDelta[][] vds);

        internal static void VUProtocol(int request, Address who, int mode, string[] gnames, Address[] gaddrs, long offset, long[] tsigs, int[] flags, int uid) {
            if (uid != -1) {
                using (var tmpLockObj = new LockAndElevate(AGVELock)) {
                    foreach (GVEvent agve in AGVEList) {
                        if (agve.who == who && agve.uid == uid) {
                            if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.GVELOGIC)) != 0) {
                                Vsync.WriteLine("Found an old ANTI-GVE entry... ignoring this VUProtocol request");
                            }

                            AGVEList.Remove(agve);
                            return;
                        }
                    }
                }
            }

            if (gnames == null) {
                gnames = new string[0];
            }

            if (gaddrs == null) {
                gaddrs = new Address[0];
            }

            using (var tmpLockObj = new LockAndElevate(GVELock)) {
                bool fnd = false;
                GVEvent gve = new GVEvent(request, who, mode, gnames, gaddrs, offset, tsigs, flags, uid);
                foreach (GVEvent oldgve in GVEList) {
                    if (oldgve.who == who && oldgve.mode == mode && oldgve.gnames.Length == gnames.Length) {
                        for (int i = 0; i < gnames.Length; i++) {
                            if (oldgve.gnames[i].Equals(gnames[i], StringComparison.Ordinal) && oldgve.gaddrs[i] == gaddrs[i] && ((oldgve.tsigs == null || tsigs == null) ? oldgve.tsigs == tsigs : oldgve.tsigs[i] == tsigs[i])) {
                                fnd = true;
                                break;
                            }
                        }
                    }
                }

                if (!fnd) {
                    if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.GVELOGIC)) != 0) {
                        string gs = " ", tss = " ", fs = " ";
                        foreach (string s in gnames) {
                            gs += s + " ";
                        }

                        if (tsigs != null) {
                            foreach (long ts in tsigs) {
                                tss += ts + " ";
                            }
                        }

                        if (flags != null) {
                            foreach (int fl in flags) {
                                fs += fl + " ";
                            }
                        }

                        Vsync.WriteLine("Creating a GVE entry for request " + request + ", mode " + mode + ", address " + who + ", uid " + uid + ", gnames [" + gs + "], groups " + Address.VectorToString(gaddrs) + ", ts={" + tss + "}, fs={" + fs + "}");
                    }

                    GVEList.Add(gve);
                }
                else if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.GVELOGIC)) != 0) {
                    Vsync.WriteLine("Found an identical GVE entry... ignoring this VUProtocol request");
                }
            }

            if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.GVELOGIC)) != 0) {
                Vsync.WriteLine("VUProtocol: BarrierRelease for LLWAIT/LGVEUPDATE");
            }

            ILock.Barrier(ILock.LLWAIT, ILock.LGVEUPDATE).BarrierRelease(1);
        }

        internal static void PurgeGVE(Address who, int uid) {
            if (uid == -1 || ORACLE.theView.IAmLeader()) {
                return;
            }

            using (var tmpLockObj = new LockAndElevate(GVELock)) {
                foreach (GVEvent gve in GVEList) {
                    if (who == gve.who && uid == gve.uid) {
                        GVEList.Remove(gve);
                        return;
                    }
                }
            }

            if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.GVELOGIC)) != 0) {
                Vsync.WriteLine("... didn't find the GVE entry, creating an ANTI-GVE record");
            }

            GVEvent agve = new GVEvent(0, who, 0, null, null, 0L, null, null, uid);
            using (var tmpLockObj = new LockAndElevate(AGVELock)) {
                AGVEList.Add(agve);
            }

            Vsync.OnTimer(120000, () => {
                using (var tmpLockObj = new LockAndElevate(AGVELock)) {
                    foreach (GVEvent gve in AGVEList) {
                        if (gve == agve) {
                            if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.GVELOGIC)) != 0) {
                                Vsync.WriteLine("... after 120s delay, removing an ANTI-GVE record");
                            }

                            AGVEList.Remove(agve);
                            return;
                        }
                    }
                }
            });
        }

        // Only runs in the leader
        private static bool OracleViewTaskRunning;

        private static readonly Semaphore OracleBeaconTaskWait = new Semaphore(0, int.MaxValue);

        private static readonly LockObject OracleViewTaskLock = new LockObject("OracleViewTaskLock");

        internal static void OracleViewTask() {
            using (var tmpLockObj = new LockAndElevate(OracleViewTaskLock)) {
                if (OracleViewTaskRunning) {
                    return;
                }

                OracleViewTaskRunning = true;
            }

            new Thread(() => {
                while (!VsyncSystem.VsyncActive) {
                    Vsync.Sleep(250);
                }

                try {
                    while (VsyncSystem.VsyncActive) {
                        VsyncSystem.RTS.ThreadCntrs[4]++;

                        // Once every 10 seconds, announce that I am an Oracle leader
                        OracleBeaconTaskWait.WaitOne(10 * 1000);
                        ORACLE.doSendRaw(Vsync.ORACLERUNNING, Vsync.my_address);
                    }
                }
                catch (VsyncShutdownException) {
                    VsyncSystem.CheckLocksHeld();
                }

                VsyncSystem.ThreadTerminationMagic();
            }) { Name = "OracleBeaconTask", IsBackground = true }.Start();
            try {
                while (!VsyncSystem.VsyncActive || Vsync.VSYNCMEMBERS == null) {
                    Vsync.Sleep(250);
                }

                List<GVEvent> gveList = new List<GVEvent>();
                while (VsyncSystem.VsyncActive) {
                    VsyncSystem.RTS.ThreadCntrs[5]++;
                    GVEvent gve;
                    if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.GVELOGIC)) != 0) {
                        Vsync.WriteLine("OracleViewTask: Before BarrierWait for LLWAIT/LGVEUPDATE");
                    }

                    ILock.Barrier(ILock.LLWAIT, ILock.LGVEUPDATE).BarrierWait();
                    if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.GVELOGIC)) != 0) {
                        Vsync.WriteLine("OracleViewTask: After BarrierWait for LLWAIT/LGVEUPDATE");
                    }

                    using (var tmpLockObj = new LockAndElevate(GVELock)) {
                        if (GVEList.Count == 0) {
                            continue;
                        }

                        gve = GVEList.First();
                        GVEList.Remove(gve);
                        gveList.Add(gve);
                        bool alreadyExists = true;
                        foreach (Address gaddr in gve.gaddrs) {
                            Group tpg = Group.TrackingProxyLookup(gaddr);
                            if (tpg == null || !tpg.HasFirstView) {
                                alreadyExists = false;
                            }
                        }

                        if (alreadyExists) {
                            foreach (GVEvent gve2 in GVEList) {
                                if (Address.SameAddrs(gve.gaddrs, gve2.gaddrs) && Address.SameNames(gve.gnames, gve2.gnames)) {
                                    gveList.Add(gve2);
                                }
                            }

                            foreach (GVEvent gve2 in gveList) {
                                if (gve2 != gve) {
                                    GVEList.Remove(gve2);
                                }
                            }
                        }
                    }

                    if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.GVELOGIC)) != 0) {
                        string gns = " ";
                        if (gve.gnames != null) {
                            foreach (string gs in gve.gnames) {
                                gns += gs + " ";
                            }
                        }

                        Vsync.WriteLine("Request GVUpdate: gve=(mode:" + gve.mode + ", request:" + rToString(gve.request) + ", who: " + gve.who + ", uid:" + gve.uid + ", gnames:{" + gns + "}, gaddrs:[" + Address.VectorToString(gve.gaddrs) + "]");
                    }

                    if (!ORACLE.TakingOver || (gve.request == LEAVE && ORACLE.theView.GetRawRankOf(gve.who) == ORACLE.theView.GetRawRankOf(Vsync.my_address) - 1)) {
                        if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.GVELOGIC)) != 0) {
                            Vsync.WriteLine("Calling RequestGVUpdates, gve list contains " + gveList.Count + " gve items");
                        }

                        RequestGVUpdates(gveList);
                        gveList = new List<GVEvent>();
                        ORACLE.TakingOver = false;
                    }

                    bool sendIt = false;
                    using (var tmpLockObj = new LockAndElevate(GVELock)) {
                        if (GVEList.Count == 0 && Vsync.VSYNCMEMBERS.HasFirstView) {
                            sendIt = true;
                        }
                    }

                    if (sendIt) {
                        // Although the system also has a way to do this on a per-group basis, the volume of P2P traffic it caused was excessive
                        Group.IPMCViewCast(Vsync.VSYNCMEMBERS.theView.viewid, Vsync.VSYNCMEMBERS.gaddr, Vsync.my_address, Vsync.VSYNCMEMBERS.theView);
                    }
                }
            }
            catch (VsyncShutdownException) {
                VsyncSystem.CheckLocksHeld();
            }
            finally {
                OracleBeaconTaskWait.Release();
            }

            VsyncSystem.ThreadTerminationMagic();
        }

        // Core of the virtual synchrony implementation, runs only in the leader.  The list will only contain one element unless
        // there is a new leader taking over in the ORACLE and it discovers one or more proposed events that it needs to order ahead
        // of the ORACLE leader FAIL proposal
        internal static void RequestGVUpdates(List<GVEvent> gveList) {
            List<Group> AggLGWithNewOwner = new List<Group>();

            // Large groups that will have a new group owner as a result of this GVEUpdate
            List<Group> AggCreateList = new List<Group>();

            List<Group> AggProposeGlist = new List<Group>();

            // Don't participate in the 2PC (currently: regular groups being created by this action)
            List<Group> AggCommitGlist = new List<Group>();

            // Vsync groups, they participate in the 2PC, as does the ORACLE
            List<Group> AggLargeGlist = new List<Group>();

            // Large groups.  The ORACLE runs the 2PC and then unilaterally tells them to commit the new view
            List<ViewDelta> vdlist = new List<ViewDelta>();

            foreach (GVEvent gve in gveList) {
                if (gve.request == JOIN) {
                    for (int idx = 0; idx < gve.gnames.Length; idx++) {
                        string gn = gve.gnames[idx];
                        if (!gn.Equals("ORACLE", StringComparison.Ordinal) && !gn.Equals("VSYNCMEMBERS", StringComparison.Ordinal)) {
                            Group tpg = Group.TrackingProxyLookup(gn);
                            if (tpg != null && tpg.TypeSig != 0 && tpg.TypeSig != gve.tsigs[idx]) {
                                ReliableSender.SendPoison(gve.who, "TypeSignature mismatch in group <" + gn + ">");
                                Vsync.Sleep(50);
                                Vsync.NodeHasFailed(gve.who, "TypeSignature mismatch", false);
                                return;
                            }
                        }
                    }
                }
            }

            foreach (GVEvent gve in gveList) {
                List<Group> LGWithNewOwner = new List<Group>();

                // Large groups that will have a new group owner as a result of this GVEUpdate
                List<Group> CreateList = new List<Group>();

                List<Group> ProposeGlist = new List<Group>();

                // Don't participate in the 2PC (currently: regular groups being created by this action)
                List<Group> CommitGlist = new List<Group>();

                // Vsync groups, they participate in the 2PC, as does the ORACLE
                List<Group> LargeGlist = new List<Group>();

                // Large groups.  The ORACLE runs the 2PC and then unilaterally tells them to commit the new view
                if (gve.request == FDETECTION || gve.request == LEAVE) {
                    if ((VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                        Vsync.WriteLine("VUProtocol: FDETECTION/LEAVE event");
                    }

                    if (ORACLE.theView.GetRawRankOf(gve.who) != -1) {
                        CommitGlist.Add(ORACLE);
                        ProposeGlist.Add(ORACLE);
                    }

                    using (var tmpLockObj = new LockAndElevate(Group.TPGroupsLock)) {
                        foreach (KeyValuePair<Address, Group> kvp in Group.TPGroups) {
                            Group g = kvp.Value;
                            int r;
                            if ((gve.request == LEAVE && !gve.gnames.Contains(g.gname)) || (r = g.theView.GetRawRankOf(gve.who)) == -1) {
                                continue;
                            }

                            if ((g.flags & Group.G_ISLARGE) != 0) {
                                LargeGlist.Add(g);
                                if (r == 0) {
                                    LGWithNewOwner.Add(g);
                                }
                            }
                            else if (!CommitGlist.Contains(g)) {
                                CommitGlist.Add(g);
                                if ((g.flags & Group.G_ISRAW) == 0) {
                                    ProposeGlist.Add(g);
                                }
                            }
                        }
                    }
                }
                else {
                    if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.GVELOGIC)) != 0) {
                        string gs = " ", tss = " ", fs = " ";
                        foreach (string s in gve.gnames) {
                            gs += s + " ";
                        }

                        if (gve.tsigs != null) {
                            foreach (long ts in gve.tsigs) {
                                tss += ts + " ";
                            }
                        }

                        if (gve.flags != null) {
                            foreach (int fl in gve.flags) {
                                fs += fl + " ";
                            }
                        }

                        Vsync.WriteLine("VUProtocol: executing GVE event[" + gve.uid + "]: request " + Vsync.rToString(gve.request) + " mode " + gve.mode + " address " + gve.who + " gnames[" + gs + "] groups " + Address.VectorToString(gve.gaddrs) + "m ts={" + tss + "}, fs={" + fs + "}");
                    }

                    for (int i = 0; i < gve.gnames.Length; i++) {
                        Group g;
                        if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.GVELOGIC)) != 0) {
                            Vsync.WriteLine("VUProtocol: group name is " + gve.gnames[i]);
                        }

                        if (gve.gnames[i].Equals("ORACLE", StringComparison.Ordinal)) {
                            g = ORACLE;
                        }
                        else {
                            if ((g = Group.TrackingProxyLookup(gve.gaddrs[i])) == null || g.theView == null || g.theView.members.Length == 0) {
                                if ((gve.mode & Group.CREATE) == 0) {
                                    // Group.JOIN only but doesn't exist
                                    ORACLE.doP2PSend(gve.who, true, JOINFAILED, gve.gaddrs[i], "JoinExisting but group <" + gve.gnames[i] + "> didn't exist");
                                    return;
                                }

                                // Create tracking proxy for groups if needed
                                g = Group.TrackingProxy(gve.gnames[i], "VUP", gve.gaddrs[i], gve.tsigs[i], null, new View(gve.gnames[i], gve.gaddrs[i], new[] { gve.who }, -1, false), gve.flags[i], false);
                                CreateList.Add(g);
                                continue;
                            }

                            if ((gve.mode & Group.JOIN) == 0) {
                                // Group.JOIN only but doesn't exist
                                ORACLE.doP2PSend(gve.who, true, JOINFAILED, gve.gaddrs[i], "Create but group <" + gve.gnames[i] + "> already exists");
                                return;
                            }
                        }

                        if ((gve.flags[i] & Group.G_ISLARGE) != 0) {
                            LargeGlist.Add(g);
                        }
                        else {
                            CommitGlist.Add(g);
                            if (g.theView != null && g.theView.members.Length > 0 && (g.flags & Group.G_ISRAW) == 0) {
                                ProposeGlist.Add(g);
                            }
                        }
                    }
                }

                if ((VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                    foreach (Group g in CreateList) {
                        Vsync.WriteLine("+++[+] Create GroupList contains <" + g.gname + ">");
                    }

                    foreach (Group g in ProposeGlist) {
                        Vsync.WriteLine("+++[P] Proposed GroupList contains <" + g.gname + ">");
                    }

                    foreach (Group g in ProposeGlist) {
                        Vsync.WriteLine("+++[C] Commit GroupList contains <" + g.gname + ">");
                    }

                    foreach (Group g in LargeGlist) {
                        Vsync.WriteLine("+++[L] Large GroupList contains <" + g.gname + ">");
                    }
                }

                int nProposed = Vsync.Proposed == null ? 0 : Vsync.Proposed.Length;
                Address[] wantJoin = null;
                Address[] wantLeave = null;
                if (gve.request == JOIN) {
                    bool fnd = false;
                    foreach (ViewDelta vd in vdlist) {
                        if (vd.leavers.Length == 0 && vd.leaderId == LeaderId) {
                            foreach (Address ga in gve.gaddrs) {
                                if (ga == vd.gaddr) {
                                    fnd = true;
                                    Vsync.ArrayResize(ref vd.joiners, vd.joiners.Length + 1);
                                    vd.joiners[vd.joiners.Length - 1] = gve.who;
                                }
                            }
                        }
                    }

                    if (!fnd) {
                        foreach (ViewDelta vd in vdlist) {
                            if (gve.gaddrs.Contains(vd.gaddr) && vd.joiners.Contains(gve.who)) {
                                fnd = true;
                                break;
                            }
                        }

                        if (!fnd) {
                            wantJoin = new[] { gve.who };
                            wantLeave = new Address[0];
                        }
                    }
                }
                else {
                    bool fnd = false;
                    foreach (ViewDelta vd in vdlist) {
                        if (vd.joiners.Length == 0 && vd.leaderId == LeaderId) {
                            foreach (Address ga in gve.gaddrs) {
                                if (ga == vd.gaddr) {
                                    fnd = true;
                                    Vsync.ArrayResize(ref vd.leavers, vd.leavers.Length + 1);
                                    vd.leavers[vd.leavers.Length - 1] = gve.who;
                                }
                            }
                        }
                    }

                    if (!fnd) {
                        foreach (ViewDelta vd in vdlist) {
                            if (gve.gaddrs.Contains(vd.gaddr) && vd.leavers.Contains(gve.who)) {
                                fnd = true;
                                break;
                            }
                        }

                        if (!fnd) {
                            wantLeave = new[] { gve.who };
                            wantJoin = new Address[0];
                        }
                    }
                }

                // If ORACLE group has a failure that will take it below VSYNC_ORACLESIZE, see if we have any available candidates
                // that could replace the departing members(s) and if so, add them to a list of proposed joiners.
                if (gve.gaddrs.Length == 1 && gve.gaddrs[0] == ORACLE.gaddr && wantLeave != null && wantLeave.Length > 0) {
                    using (var tmpLockObj = new LockAndElevate(CanBeOracleListLock)) {
                        while (CanBeOracleList.Count > 0) {
                            Address a = CanBeOracleList.First();
                            CanBeOracleList.Remove(a);
                            using (var tmpLockObj1 = new LockAndElevate(RIPLock)) {
                                if (ORACLE.GetRankOf(a) != -1 || RIPList.Contains(a)) {
                                    continue;
                                }
                            }

                            wantJoin = new[] { a };
                            break;
                        }
                    }
                }

                if (nProposed > 0) {
                    // Pending stuff I know (or learned) about
                    foreach (ViewDelta vd in Vsync.Proposed) {
                        vdlist.Add(vd);
                    }
                }

                Vsync.Proposed = null;

                if (wantJoin != null && wantLeave != null) {
                    foreach (Group g in CommitGlist) {
                        AddVD(vdlist, wantJoin, wantLeave, g, gve.offset);
                    }

                    foreach (Group g in LargeGlist) {
                        AddVD(vdlist, wantJoin, wantLeave, g, gve.offset);
                    }

                    foreach (Group g in CreateList) {
                        AddVD(vdlist, wantJoin, wantLeave, g, gve.offset);
                    }
                }

                // Now sweep everything into the corresponding aggregated lists and repeat if there are more GVE entries, which happens only if
                // a new leader is taking over and needs to include one or more pending proposals with the LEAVE for the old ORACLE leader
                AddUnique(AggLGWithNewOwner, LGWithNewOwner);
                AddUnique(AggCreateList, CreateList);
                AddUnique(AggProposeGlist, ProposeGlist);
                AddUnique(AggCommitGlist, CommitGlist);
                AddUnique(AggLargeGlist, LargeGlist);
            }

            if (!AggCommitGlist.Contains(ORACLE)) {
                AggProposeGlist.Add(ORACLE);
                AggCommitGlist.Add(ORACLE);
            }

            if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.GVELOGIC)) != 0) {
                Vsync.WriteLine("VUProtocol: Lists [ " + AggCommitGlist.Count + " commit, " + AggProposeGlist.Count + " propose, " + AggLargeGlist.Count + " Large(SameOwner), " + AggLGWithNewOwner.Count + " Large(NewOwner) " + AggCreateList.Count + " create]");
            }

            ViewDelta[] vds = vdlist.ToArray();

            if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.GVELOGIC)) != 0) {
                Vsync.WriteLine("VUProtocol: About to Propose View Deltas:");
                foreach (ViewDelta vd in vds) {
                    Vsync.WriteLine("     " + vd);
                }
            }

            ////List<Address> whoFailed = new List<Address>();

            // For each group in glist, we'll get a reply from each member, in the form of a byte-vector
            List<byte[]>[] ba = null;

            // This will initialize whoFailed with the list of processes shown as failed 
            // for groups in glist.  No point in expecting them to reply to the PROPOSE solicitation
            bool must_loop = true;
            UnstableList[] usl = new UnstableList[0];
            int oldLen = 0;
            int nreplies = 0;
            int loopLimit = CountLive(AggProposeGlist);
            int nExpected = loopLimit++;
            while (must_loop) {
                if (loopLimit-- < 0) {
                    string gstr = " ", vdStr = string.Empty, rstr = " ";
                    foreach (Group g in AggProposeGlist) {
                        gstr += g.gname + " ";
                    }

                    foreach (ViewDelta vd in vds) {
                        vdStr += ">> " + vd + Environment.NewLine;
                    }

                    for (int gn = 0; gn < ba.Length; gn++) {
                        rstr += ba[gn].Count + " ";
                    }

                    throw new VsyncException("Trapped looping in PROPOSE to <" + gstr + ">! (nreplies " + nreplies + ", nExpected " + nExpected + " (" + rstr + "), usl.Length " + usl.Length + ", oldLen " + oldLen + ")" + Environment.NewLine + "ViewDeltas:" + Environment.NewLine + vdStr + VsyncSystem.GetState());
                }

                must_loop = false;
                oldLen = usl.Length;
                if ((VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                    string dests = " ";
                    foreach (Group g in AggProposeGlist) {
                        dests += g.gname + " ";
                    }

                    Vsync.WriteLine("Sending the PROPOSE messages to [" + dests + "]");
                }

                // Flush can take a long time, so disable the timeout
                ba = Group.doMultiQuery(AggProposeGlist, Group.ALL, true, new Timeout(int.MaxValue, Timeout.TO_FAILURE, "PROPOSE"), PROPOSE, vds, usl);
                nreplies = 0;
                for (int gn = 0; gn < ba.Length; gn++) {
                    nreplies += ba[gn].Count;
                }

                if ((VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                    Vsync.WriteLine("After multiquery tabulate results from " + ba.Length + " groups that were queried (total of " + nreplies + " distinct replies");
                }

                int threshold = 0;
                if (!VSYNC_IGNOREPARTITIONS && (ORACLE.theView.members.Length > 2 || !VSYNC_IGNORESMALLPARTITIONS)) {
                    threshold = ((ORACLE.theView.members.Length / 2) + 1);
                }

                if (Tabulate(AggProposeGlist, ba, vds, ref usl) < threshold) {
                    if (loopLimit > 0) {
                        List<Address> ag = new List<Address>();
                        foreach (Group g in AggProposeGlist) {
                            ag.Add(g.gaddr);
                        }

                        Vsync.WriteLine("After doMultiQuery to " + Address.VectorToString(ag.ToArray()) + " got fewer than " + ((ORACLE.theView.members.Length / 2) + 1) + " replies!!!");
                        Vsync.WriteLine("WARNING: ORACLE got " + nreplies + " replies, but was expecting at least " + ((ORACLE.theView.members.Length / 2) + 1) + "... retry proposal");
                        must_loop = true;
                        continue;
                    }
                    else {
                        List<Address> ag = new List<Address>();
                        foreach (Group g in AggProposeGlist) {
                            ag.Add(g.gaddr);
                        }

                        Vsync.WriteLine("After doMultiQuery to " + Address.VectorToString(ag.ToArray()) + " got fewer than " + ((ORACLE.theView.members.Length / 2) + 1) + " replies!!!");
                        throw new VsyncException("VSYNC experienced a loss of majority (expected " + nExpected + "), terminating.");
                    }
                }

                if (nreplies != nExpected || usl.Length > oldLen) {
                    int newExpected = CountLive(AggProposeGlist);
                    if (newExpected == nExpected) {
                        break;
                    }

                    must_loop = true;
                    nExpected = newExpected;
                }

                if ((VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                    Vsync.WriteLine("After tabulate must_loop " + must_loop + "(nreplies " + nreplies + ", nExpected " + nExpected + "; usl.Length " + usl.Length + ", oldLen " + oldLen + ")");
                }
            }

            if ((VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                Vsync.Write("Sending the COMMIT messages to ");
                foreach (Group g in AggCommitGlist) {
                    Vsync.Write("<" + g.gname + ">");
                }

                Vsync.WriteLine();
            }

            Address[] whos = new Address[gveList.Count];
            int[] uids = new int[gveList.Count];
            int n = 0;
            foreach (GVEvent gve in gveList) {
                whos[n] = gve.who;
                uids[n] = gve.uid;
                ++n;
            }

            foreach (ViewDelta vd in vds) {
                foreach (Address who in Expand(vd.leavers)) {
                    Group g = Group.TrackingProxyLookup(vd.gaddr);
                    if (g != null && g.theView != null) {
                        ReliableSender.SendP2P(Msg.ISGRPP2P, who, g, g.theView.viewid, ReliableSender.P2PSequencer.NextP2PSeqn("commit", who), Msg.toBArray(COMMIT, vds, whos, uids), true, null, null);
                    }
                }
            }

            // Now perform the COMMIT operations, first for groups other than the ORACLE, and then for the ORACLE itself
            List<Address> vdsg = new List<Address>();
            foreach (ViewDelta vd in vds) {
                if (!vdsg.Contains(vd.gaddr) && Vsync.ORACLE.gaddr != vd.gaddr) {
                    vdsg.Add(vd.gaddr);
                }
            }

            if (vdsg.Count > 0) {
                Group.doMultiSend(AggCommitGlist.Where(g => vdsg.Contains(g.gaddr)).ToList(), true, COMMIT, vds, whos, uids);
                foreach (Group g in AggCommitGlist) {
                    if (g != Vsync.ORACLE) {
                        g.Flush(Vsync.VSYNC_ACKTHRESHOLD);
                    }
                }
            }

            Vsync.ORACLE.doSend(true, false, COMMIT, vds, whos, uids);

            if (AggLargeGlist.Count > 0) {
                foreach (Group g in AggLargeGlist) {
                    sendVDS(g, vds, AggLGWithNewOwner.Contains(g));
                }
            }

            if ((VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                Vsync.WriteLine("Calling CommitWait");
            }

            ILock.Barrier(ILock.LLWAIT, ILock.LCOMMIT).BarrierWait();
            if ((VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                Vsync.WriteLine("After CommitWait");
            }
        }

        // This is actually called from the ORACLE commit logic and is called in each ORACLE member.  As a result we redundantly send
        // INITIALVIEW messages to the group members, but the advantage is that the scheme is tolerant of a crash of the ORACLE leader
        // during a group join.  Obviously one could clean this up using logic similar to the DoAsLeader scheme, but because the INITIALVIEW
        // is being sent to a process not currently in the group, there is no simple way to get around asking that joining process if it
        // has the INITIALVIEW yet or not.  That gets a bit tricky (given the asynchrony of the failure notification that breaks the connection
        // from the old leader to the joining member).  So we're paying a price in extra messages, which get ignored, and the benefit is
        // simpler code (assuming you call this simpler... you may disagree!)
        internal static void SendInitialView(ViewDelta[] vds) {
            if ((VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                Vsync.WriteLine("SendInitialView.... view deltas:");
                foreach (ViewDelta vd in vds) {
                    Vsync.WriteLine("++++++ " + vd);
                }
            }

            foreach (ViewDelta vd in vds) {
                Address[] joiners = Expand(vd.joiners);
                if (vd.gaddr == ORACLE.gaddr) {
                    foreach (Address who in joiners) {
                        SendOracleInitialView(vd, who);
                    }
                }
                else {
                    Group g = Group.TrackingProxyLookup(vd.gaddr);
                    View theView;
                    if (g == null) {
                        throw new VsyncException("Can't find the group in VUCommit");
                    }

                    using (var tmpLockObj = new LockAndElevate(g.ViewLock)) {
                        theView = g.theView;
                    }

                    if (theView == null) {
                        throw new VsyncException("View is null for " + g.gname + " in VUCommit: ViewDelta=" + vd + VsyncSystem.GetState());
                    }




                    if (!Vsync.VSYNC_UNICAST_ONLY && Vsync.VSYNCMEMBERS != null && theView.members.Length > Vsync.VSYNC_ORACLESIZE && !joiners.Contains(Vsync.my_address) &&
                        g != Vsync.VSYNCMEMBERS && joiners.Length > Vsync.VSYNC_INITVIAOOB / 10 || theView.members.Length > Vsync.VSYNC_INITVIAOOB) {
                        SendViewViaOOB(g, theView, joiners, vds, vd);
                    }
                    else {
                        foreach (Address who in joiners) {
                            SendNonOracleInitialView(vds, vd, who);
                        }
                    }
                }
            }
        }

        private static void SendOracleInitialView(ViewDelta vd, Address newOracleMember) {
            string[] names;
            Address[] gaddrs;
            long[] tsigs;
            View[] vs;
            bool[] isl;
            if ((VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                Vsync.WriteLine("+++ newOracleMember true.");
            }

            int n;
            using (var tmpLockObj = new LockAndElevate(Group.TPGroupsLock)) {
                int ng = Group.TPGroups.Count + 1;
                foreach (KeyValuePair<Address, Group> kvp in Group.TPGroups) {
                    if (!kvp.Value.HasFirstView) {
                        --ng;
                    }
                }

                names = new string[ng];
                gaddrs = new Address[ng];
                tsigs = new long[ng];
                vs = new View[ng];
                isl = new bool[ng];
                n = 0;
                foreach (KeyValuePair<Address, Group> kvp in Group.TPGroups) {
                    if (kvp.Value.HasFirstView) {
                        includeGroup(n++, names, gaddrs, tsigs, vs, isl, kvp.Value);
                    }
                }
            }

            includeGroup(n, names, gaddrs, tsigs, vs, isl, Vsync.ORACLE);
            MCMDSocket.SetMap("ORACLE:SendOracleInitialView", "ORACLE", false, MCMDSocket.GetMap(Vsync.ORACLE.gaddr, true));

            // This sends the list of groups and tracking proxies to a new oracle member
            // It also includes the view of the oracle itself
            if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.GVELOGIC | VsyncSystem.STARTSEQ)) != 0) {
                Vsync.WriteLine("ORACLE.P2PSend INITALVIEW for " + Address.VectorToString(gaddrs) + " from " + Vsync.my_address + " to " + newOracleMember + " MCMD STATE + " + MCMDSocket.GetState());
            }

            int[,] mms = MCMDSocket.GetMap(gaddrs);
            Address[] CBMs;
            using (var tmpLockObj = new LockAndElevate(Vsync.CanBeOracleListLock)) {
                CBMs = Vsync.CanBeOracleList.ToArray();
            }

            ORACLE.doP2PSend(newOracleMember, true, INITIALVIEW, Vsync.my_address, names, gaddrs, tsigs, vs, isl, MCMDSocket.nextPhysIPAddr, mms, CBMs);
        }

        private static void SendNonOracleInitialView(ViewDelta[] vds, ViewDelta vd, Address newGroupMember) {
            Group g = Group.TrackingProxyLookup(vd.gaddr);
            if (g == null) {
                throw new VsyncException("Can't find the group in VUCommit");
            }

            if (g.theView == null) {
                throw new VsyncException("View is null for " + g.gname + " in VUCommit: ViewDelta=" + vd + VsyncSystem.GetState());
            }

            if ((g.flags & Group.G_ISLARGE) == 0 || vd.prevVid == -1) {
                if ((VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                    Vsync.WriteLine("Group <" + g.gname + ">, sending INITIALVIEW to " + newGroupMember + ", VIEW = " + g.theView);
                }

                ReliableSender.SendP2P(Msg.ISGRPP2P, newGroupMember, g, g.theView.viewid, ReliableSender.P2PSequencer.NextP2PSeqn("intialview", newGroupMember), Msg.toBArray(INITIALVIEW, Vsync.my_address, g.theView, MCMDSocket.GetMap(g.gaddr, true), 0), true, null, null);
            }

            if ((g.flags & Group.G_ISLARGE) != 0) {
                Vsync.sendVDS(g, vds, vd.joiners.Length > 0);
            }
        }

        private static void SendViewViaOOB(Group g, View theView, Address[] joiners, ViewDelta[] vds, ViewDelta vd) {
            if ((VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                Vsync.WriteLine("Group <" + g.gname + ">, sending INITIALVIEW via OOB to " + Address.VectorToString(joiners) + ", VIEW = " + g.theView);
            }

            byte[] ba = theView.toBArray();
            string fname = g.gname;
            int lio = fname.LastIndexOfAny(new[] { '\\', '/' });
            if (lio != -1) {
                fname = fname.Substring(lio + 1);
            }

            fname += "-view" + theView.viewid + ".v" + Vsync.ORACLE.GetMyRank();
#if __MonoCS__
            fname = "/tmp/" + fname;
#endif
            bool redo = true;
            int retries = 0;
            MemoryMappedFile mmf = null;
            do {
                redo = false;
                mmf = null;
                try {
                    try {
                        try {
                            File.Delete(fname);
                        }
                        catch (IOException) {
                        }
                        mmf = Group.CreateNew(fname, ba.Length);
                        MemoryMappedViewAccessor mva = mmf.CreateViewAccessor();
                        mva.WriteArray(0, ba, 0, ba.Length);
                    }
                    catch (IOException) {
                        if (mmf != null) {
                            mmf.Dispose();
                        }

                        mmf = MemoryMappedFile.OpenExisting(fname);
                    }
                }
                catch (FileNotFoundException) {
                    if (++retries == 5)
                        throw new VsyncException("Tried and tried but SendViewViaOOB was unable to map " + fname);
                    redo = true;
                }
            }
            while (redo);

            Vsync.VSYNCMEMBERS.OOBRegister(true, fname, Vsync.VSYNCMEMBERS.gaddr, mmf, Vsync.ORACLE.theView.members.ToList());
            List<Address> replicas = new List<Address> { Vsync.my_address };
            foreach (Address j in joiners) {
                replicas.Add(j);
            }

            Vsync.VSYNCMEMBERS.OOBReReplicate(true, new List<Group.OOBRepInfo> { new Group.OOBRepInfo(fname, Vsync.VSYNCMEMBERS.gaddr, ba.Length, Group.OwnersToIPAddrs(replicas)) },
                (oobfname, mf) => {
                    Thread.Sleep(Vsync.VSYNC_DEFAULTTIMEOUT * 3 / 2); g.OOBDelete(oobfname);
                });
            foreach (Address newGroupMember in joiners) {
                ReliableSender.SendP2P(Msg.ISGRPP2P, newGroupMember, g, theView.viewid, ReliableSender.P2PSequencer.NextP2PSeqn("intialview", newGroupMember),
                    Msg.toBArray(INITIALVIEW, Vsync.my_address, fname, MCMDSocket.GetMap(g.gaddr, true), 0), true, null, null);
            }

            if ((g.flags & Group.G_ISLARGE) != 0) {
                Vsync.sendVDS(g, vds, vd.joiners.Length > 0);
            }

        }

        private static void AddUnique(List<Group> AggregatedList, List<Group> GroupsToAdd) {
            foreach (Group g in GroupsToAdd) {
                if (!AggregatedList.Contains(g)) {
                    AggregatedList.Add(g);
                }
            }
        }

        private static void AddVD(List<ViewDelta> vdlist, Address[] wantJoin, Address[] wantLeave, Group g, long offset) {
            View theView;
            using (var tmpLockObj = new LockAndElevate(g.ViewLock)) {
                theView = g.theView;
            }

            List<Address> prevMembers = theView == null ? new List<Address>() : theView.members.ToList();
            int prevVid = -1;
            foreach (ViewDelta vd in vdlist) {
                foreach (Address a in Expand(vd.leavers)) {
                    prevMembers.Remove(a);
                }

                foreach (Address a in Expand(vd.joiners)) {
                    prevMembers.Add(a);
                }

                if (prevMembers.Count == 0) {
                    prevVid = -1;
                }
                else if (vd.gaddr == g.gaddr && vd.prevVid >= prevVid) {
                    prevVid = vd.prevVid + 1;
                }
            }

            if (prevVid == -1) {
                prevVid = g.theView.viewid;
            }

            vdlist.Add(new ViewDelta(g.gname, g.gaddr, g.TypeSig, g.MCMDMAP(), prevVid, g.theView.members.Length, wantJoin, offset, wantLeave, (g.flags & Group.G_ISLARGE) != 0));
        }

        /*
         * Large group: Send the owner (only) the view deltas for that group 
         * If the new owner isn't the same as the previous owner, however, also send
         * previous view deltas that he might have missed (e.g. not yet known to be stable)
         */

        private static readonly LockObject oldVDSlock = new LockObject("oldVDSLock");

        private static ViewDelta[] oldVDS;

        private static long[] vdTimes;

        internal static void clearOldVDS(Address gaddr, int StableTo) {
            using (var tmpLockObj = new LockAndElevate(oldVDSlock)) {
                // First count the ones to keep
                int cnt = 0;
                if (oldVDS != null) {
                    for (int i = 0; i < oldVDS.Length; i++) {
                        if (oldVDS[i].gaddr == gaddr && oldVDS[i].prevVid > StableTo) {
                            ++cnt;
                        }
                    }
                }

                ViewDelta[] newVDS = new ViewDelta[cnt];
                if (oldVDS != null) {
                    cnt = 0;
                    foreach (ViewDelta oldVD in oldVDS) {
                        if (oldVD.gaddr == gaddr && oldVD.prevVid > StableTo) {
                            newVDS[cnt++] = oldVD;
                        }
                    }
                }

                oldVDS = newVDS;
            }
        }

        private static void sendVDS(Group g, ViewDelta[] vds, bool includePrev) {
            ViewDelta[] vdsToApply;
            int cnt = 0;
            using (var tmpLockObj = new LockAndElevate(oldVDSlock)) {
                // Count the number of ViewDeltas to send.  First any lingering old ones
                if (includePrev && oldVDS != null) {
                    cnt = oldVDS.Length;
                }

                foreach (ViewDelta vd in vds) {
                    if (vd.gaddr == g.gaddr) {
                        ++cnt;
                    }
                }

                if (cnt == 0) {
                    return;
                }

                vdsToApply = new ViewDelta[cnt];
                long[] times = new long[cnt];
                cnt = 0;
                if (includePrev && oldVDS != null) {
                    for (int i = 0; i < oldVDS.Length; i++) {
                        if ((Vsync.NOW - vdTimes[i]) < 180000L && !vdDup(vdsToApply, cnt, oldVDS[i])) {
                            // 3 minutes
                            times[cnt] = vdTimes[cnt];
                            vdsToApply[cnt++] = oldVDS[i];
                        }
                    }
                }

                foreach (ViewDelta vd in vds) {
                    if (vd.gaddr == g.gaddr && !vdDup(vdsToApply, cnt, vd)) {
                        times[cnt] = Vsync.NOW;
                        vdsToApply[cnt++] = vd;
                    }
                }

                if (cnt < vdsToApply.Length) {
                    Vsync.ArrayResize(ref vdsToApply, cnt);
                }

                oldVDS = vdsToApply;
                vdTimes = times;
            }

            g.gotNewViewDeltas(vdsToApply);
            int ownerRank = 0;
            while (ownerRank < g.theView.members.Length && (g.theView.hasFailed[ownerRank] || isLeaving(g.theView.members[ownerRank], vdsToApply))) {
                ++ownerRank;
            }

            if (ownerRank == g.theView.members.Length) {
                if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                    Vsync.WriteLine("SendVDS discovered that a large group experienced a total failure; terminating it");
                }

                g.Terminate();
                return;
            }

            Address sendTo = g.theView.members[ownerRank];
            if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                Vsync.WriteLine("Sending LgCOMMIT via RELAYSEND to LgOwner " + g.theView.members[ownerRank] + " for view deltas:");
                foreach (ViewDelta vd in vdsToApply) {
                    Vsync.WriteLine("   " + vd);
                }
            }

            g.doP2PSend(sendTo, true, RELAYSEND, vdsToApply);
        }

        private static bool vdDup(ViewDelta[] vds, int cnt, ViewDelta nvd) {
            if (nvd == null) {
                return true;
            }

            for (int n = 0; n < cnt; n++) {
                ViewDelta vd = vds[n];
                if (vd == null) {
                    break;
                }

                if (vd.gaddr == nvd.gaddr && vd.leaderId == nvd.leaderId && vd.prevVid == nvd.prevVid) {
                    return true;
                }
            }

            return false;
        }

        private static bool isLeaving(Address who, ViewDelta[] vds) {
            foreach (ViewDelta vd in vds) {
                foreach (Address l in vd.leavers) {
                    if (l == who) {
                        return true;
                    }
                }
            }

            return false;
        }

        private static void includeGroup(int n, string[] names, Address[] gaddrs, long[] tsigs, View[] vs, bool[] isl, Group g) {
            names[n] = g.gname;
            gaddrs[n] = g.gaddr;
            tsigs[n] = g.TypeSig;
            vs[n] = g.theView;
            isl[n] = (g.flags & Group.G_ISLARGE) != 0;
            if ((VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                Vsync.WriteLine("Including initial view info: <" + g.gname + ">, <" + g.gaddr + ">, view " + g.theView);
            }
        }

        private static int CountLive(List<Group> glist) {
            int nLive = 0;
            foreach (Group g in glist) {
                if (g.theView == null) {
                    throw new VsyncException("theView null for group " + g.gname + " in CountLive");
                }

                for (int m = 0; m < g.theView.members.Length; m++) {
                    if (!g.theView.hasFailed[m]) {
                        using (var tmpLockObj = new LockAndElevate(Vsync.RIPLock)) {
                            if (!Vsync.RIPList.Contains(g.theView.members[m])) {
                                if ((VsyncSystem.Debug & VsyncSystem.GROUPEVENTS) != 0) {
                                    Vsync.WriteLine("PROPOSE/CountLive: <" + g.gname + "> expecting a reply from " + g.theView.members[m]);
                                }

                                ++nLive;
                            }
                            else if ((VsyncSystem.Debug & VsyncSystem.GROUPEVENTS) != 0) {
                                Vsync.WriteLine("PROPOSE/CountLive: <" + g.gname + "> NOT expecting a reply from " + g.theView.members[m] + " (shown as dead in this view)");
                            }
                        }
                    }
                }
            }

            return nLive;
        }

        internal static int CountLive(List<Address> alist) {
            using (var tmpLockObj = new LockAndElevate(Vsync.RIPLock))
                return alist.Count(a => !Vsync.RIPList.Contains(a));
        }

        // Updates vds to list terminal message send counts, computes the flush vector,
        // and then returns the number of Oracle members who replied to the proposal
        private static int Tabulate(List<Group> glist, List<byte[]>[] bas, ViewDelta[] vds, ref UnstableList[] usl) {
            int gn;
            int ngroups = glist.Count;
            List<Address> GotResponseFrom = new List<Address>();
            Group[] garray = glist.ToArray();
            if (bas.Length != ngroups) {
                throw new VsyncException("Inconsistency in Tabulate: glist.Count was " + ngroups + ", but reply byte array contained " + bas.Length + " reply vectors!");
            }

            UnstableList[][] UnstableMsgs = new UnstableList[bas.Length][];
            for (gn = 0; gn < ngroups; gn++) {
                Group g = garray[gn];
                using (var tmpLockObj = new LockAndElevate(g.ViewLock)) {
                    UnstableMsgs[gn] = new UnstableList[g.theView.members.Length];
                    for (int who = 0; who < g.theView.members.Length; who++) {
                        UnstableMsgs[gn][who] = new UnstableList(g.gaddr, NULLADDRESS, g.theView.members[who], g.theView.viewid, -1, -1);
                    }
                }
            }

            int nOracleReplies = 0;
            foreach (List<byte[]> baGroup in bas) {
                for (int outerWho = 0; outerWho < baGroup.Count; outerWho++) {
                    int who = outerWho;
                    byte[] ba = baGroup[who];
                    object[] obs = Msg.BArrayToObjects(ba);

                    // Msg.InvokeFromBArray(ba, (tabulator)((sender, rvds) =>
                    if (obs.Length == 2 && obs[0].GetType() == typeof(Address) && obs[1].GetType() == typeof(ViewDelta[])) {
                        Address sender = (Address)obs[0];
                        GotResponseFrom.Add(sender);
                        ViewDelta[] rvds = (ViewDelta[])obs[1];
                        if (rvds.Length == 0) {
                            ++nOracleReplies;
                        }
                        else {
                            bool oFound = false;
                            for (int n = 0; n < vds.Length; n++) {
                                ViewDelta rvd = rvds[n];
                                Group g;

                                if (rvd.gaddr == ORACLE.gaddr) {
                                    g = ORACLE;
                                }
                                else if ((g = Group.TrackingProxyLookup(rvd.gaddr)) == null) {
                                    // Very rarely, I've seen this happen and am unclear how the race arises... 
                                    Vsync.Sleep(2500);
                                    if ((g = Group.TrackingProxyLookup(rvd.gaddr)) == null) {
                                        return 0;
                                    }
                                }

                                if (!oFound && g == ORACLE) {
                                    oFound = true;
                                    ++nOracleReplies;
                                }

                                if (rvd.prevVid == vds[n].prevVid) {
                                    gn = -1;
                                    if (rvd.lastSeqns.Length != vds[n].lastSeqns.Length) {
                                        Vsync.WriteLine("WARNING: In Vsync/Tabulate, rvd.lastSeqn length was " + rvd.lastSeqns.Length + ", should have been equal to vds[n].lastSeqns length " + vds[n].lastSeqns.Length);
                                        return 0;
                                    }

                                    for (int i = 0; i < vds[n].lastSeqns.Length; i++) {
                                        if (rvd.lastSeqns.Length > 0 && vds[n].lastSeqns[i] != rvd.lastSeqns[i]) {
                                            if (gn == -1) {
                                                for (gn = 0; gn < ngroups; gn++) {
                                                    if (glist[gn].gaddr == rvd.gaddr) {
                                                        break;
                                                    }
                                                }

                                                if (gn == ngroups) {
                                                    throw new VsyncException("Inconsistency in Tabulate: glist didn't contain group " + rvd.gaddr);
                                                }
                                            }

                                            if (vds[n].lastSeqns[i] < rvd.lastSeqns[i]) {
                                                UnstableMsgs[gn][i].flusher = sender;
                                                if (UnstableMsgs[gn][i].mid_low == -1) {
                                                    UnstableMsgs[gn][i].mid_low = rvd.lastSeqns[i];
                                                }
                                                else if (UnstableMsgs[gn][i].mid_hi != -1) {
                                                    UnstableMsgs[gn][i].mid_low = Math.Min(UnstableMsgs[gn][i].mid_low, UnstableMsgs[gn][i].mid_hi);
                                                }

                                                UnstableMsgs[gn][i].mid_hi = rvd.lastSeqns[i];
                                                vds[n].lastSeqns[i] = rvd.lastSeqns[i];
                                            }
                                            else {
                                                UnstableMsgs[gn][i].mid_low = rvd.lastSeqns[i];
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else {
                        throw new VsyncException("in Tabulate expected reply signature { Vsync.Address  Vsync.Vsync+ViewDelta[] }");
                    }
                }
            }

            int nUnstable = 0;
            for (gn = 0; gn < ngroups; gn++) {
                for (int who = 0; who < UnstableMsgs[gn].Length; who++) {
                    if (!GotResponseFrom.Contains(UnstableMsgs[gn][who].sender) && UnstableMsgs[gn][who].mid_hi != -1 && UnstableMsgs[gn][who].mid_low != -1) {
                        nUnstable++;
                    }
                }
            }

            usl = new UnstableList[nUnstable];
            nUnstable = 0;
            for (gn = 0; gn < ngroups; gn++) {
                for (int who = 0; who < UnstableMsgs[gn].Length; who++) {
                    if (!GotResponseFrom.Contains(UnstableMsgs[gn][who].sender) && UnstableMsgs[gn][who].mid_hi != -1 && UnstableMsgs[gn][who].mid_low != -1) {
                        usl[nUnstable++] = UnstableMsgs[gn][who];
                    }
                }
            }

            return nOracleReplies;
        }

        // Runs in all participants
        internal static void CommitGVUpdates(Group g, ViewDelta[] vds) {
            View v = null;
            CommitGVUpdates(g, vds, ref v);
        }

        internal static void CommitGVUpdates(Group g, ViewDelta[] vds, ref View newView) {
            bool IamOracle = g == ORACLE && g.theView.GetMyRank() != -1;
            if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.GVELOGIC)) != 0) {
                string vs = " ";
                foreach (ViewDelta vd in vds) {
                    vs += "    " + vd + Environment.NewLine;
                }

                Vsync.Write("CommitViewUpdates<" + g.gname + ">... IAmOracle=" + IAmOracle + ":" + Environment.NewLine + vs);
            }

            long before = Vsync.NOW;
            if (IamOracle) {
                List<ViewDelta> vdsApplied = new List<ViewDelta>();
                foreach (ViewDelta vd in vds) {
                    if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.GVELOGIC)) != 0) {
                        Vsync.WriteLine("... CommitGVUpdates(IAmOracle) now applying " + vd);
                    }

                    if (vd.gaddr != ORACLE.gaddr) {
                        Group tpg = Group.TrackingProxyLookup(vd.gaddr) ?? Group.TrackingProxy(vd.gname, "Commit GVUPdates", vd.gaddr, vd.tsig, vd.mcmdmap, new View(vd.gname, vd.gaddr, vd.joiners, vd.prevVid + 1, false), vd.isLarge ? Group.G_ISLARGE : 0, false);
                        UpdateGroupView(true, vd, tpg, "TrackingProxy", ref newView);
                    }
                    else {
                        UpdateGroupView(true, vd, g, "ORACLE:self-update", ref newView);
                    }

                    vdsApplied.Add(vd);
                }

                using (var tmpLockObj = new LockAndElevate(GVELock)) {
                    List<GVEvent> newGVEList = new List<GVEvent>();
                    foreach (GVEvent gve in GVEList) {
                        bool fnd_all = true;
                        foreach (Address gaddr in gve.gaddrs) {
                            bool fnd = false;
                            foreach (ViewDelta vd in vdsApplied) {
                                if (vd.gaddr == gaddr && (gve.request == JOIN ? vd.joiners.Contains(gve.who) : vd.leavers.Contains(gve.who))) {
                                    fnd = true;
                                    break;
                                }
                            }

                            if (!(fnd_all &= fnd)) {
                                break;
                            }
                        }

                        if (!fnd_all) {
                            newGVEList.Add(gve);
                        }
                    }

                    GVEList = newGVEList;
                }
            }
            else {
                foreach (ViewDelta vd in vds) {
                    if (vd.gaddr == g.gaddr) {
                        if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.GVELOGIC)) != 0) {
                            Vsync.WriteLine("... CommitGVUpdates now applying " + vd);
                        }

                        UpdateGroupView(true, vd, g, "VsyncGroups", ref newView);
                    }
                }
            }

            if ((VsyncSystem.Debug & VsyncSystem.DELAYS) != 0 && (Vsync.NOW - before) > Vsync.VSYNC_WARNAFTER) {
                Vsync.WriteLine("WARNING: LONG DELAY while calling UpdateGroupView (" + (Vsync.NOW - before) + "ms)");
            }
        }

        // Called with GroupIsReal from CommitGVUpdates
        // Called with GroupIsReal false when computing a "working view" in the token tree manager
        internal static void UpdateGroupView(bool GroupIsReal, ViewDelta vd, Group g, string queue) {
            View newView = null;
            UpdateGroupView(GroupIsReal, vd, g, queue, ref newView, false);
        }

        internal static void UpdateGroupView(bool GroupIsReal, ViewDelta vd, Group g, string queue, ref View nv) {
            UpdateGroupView(GroupIsReal, vd, g, queue, ref nv, false);
        }

        // Note that inhibitActions is only used with GroupIsReal set to false...
        internal static void UpdateGroupView(bool GroupIsReal, ViewDelta vd, Group g, string queue, ref View nv, bool inhibitActions) {
            if (g != Vsync.ORACLE && vd.gaddr != g.gaddr) {
                return;
            }

            if (GroupIsReal) {
                using (var tmpLockObj = new LockAndElevate(g.ViewLock)) {
                    nv = g.theView;
                }
            }

            Address[] joiners = Expand(vd.joiners);
            Address[] leavers = Expand(vd.leavers);
            if ((VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                Vsync.WriteLine("UpdateGroupView<" + g.gname + (GroupIsReal ? string.Empty : " TrackingProxy") + ">: viewdelta= " + vd + ", expanded joiners = " + Address.VectorToString(joiners) + "; leavers " + Address.VectorToString(leavers));
            }

            bool IAmLeaving = false;
            List<Address> newView = new List<Address>();
            if (g.theView == null) {
                throw new VsyncException("g.theView null in UpdateGroupView");
            }

            if (GroupIsReal) {
                if (g.theView.viewid > vd.prevVid) {
                    if (vd.prevVid != -1 && (VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                        Vsync.WriteLine("WARNING: UpdateGroupView ignoring a superfluous view update because <" + g.gname + "> is on view " + g.theView.viewid + ", but vd.prevVid is " + vd.prevVid + " in state " + VsyncSystem.GetState());
                    }

                    return;
                }

                if (g.theView.viewid != vd.prevVid) {
                    if ((g.flags & Group.G_ISLARGE) == 0 || g.theView.viewid <= vd.prevVid) {
                        if (g.theView.viewid > 0) {
                            // Viewid can "reset" if all members leave; this case arises if a concurrent join was underway...
                            Vsync.WriteLine("WARNING... in CommitGVUpdates: <" + g.gname + ">: updating wrong view! (Expected " + vd.prevVid + ", found " + g.theView.viewid + ")... group was on " + queue + Environment.NewLine + "View Delta:" + vd + Environment.NewLine);
                        }

                        g.GotLastSeqns(vd.prevVid, new int[g.theView.members.Length]);
                    }
                    else {
                        return;
                    }
                }
                else {
                    g.GotLastSeqns(vd.prevVid, vd.lastSeqns);
                }
            }

            int lcnt = 0;
            int jcnt = 0;
            int ntotal = g.theView.members.Length;
            Address[] validatedLeavers = new Address[leavers.Length];
            Address[] validatedJoiners = new Address[joiners.Length + ((g.myTargetGroupSize > 0 && ntotal > g.myTargetGroupSize) ? leavers.Length : 0)];
            for (int i = 0; i < ntotal; i++) {
                Address a = g.theView.members[i];
                if (leavers.Contains(a)) {
                    validatedLeavers[lcnt++] = a;
                    if (a.isMyAddress()) {
                        IAmLeaving = true;
                    }

                    if (g.myTargetGroupSize > 0 && ntotal > g.myTargetGroupSize) {
                        while (ntotal > i && leavers.Contains(g.theView.members[ntotal - 1])) {
                            --ntotal;
                        }

                        if (ntotal > g.myTargetGroupSize) {
                            Address who = g.theView.members[--ntotal];
                            newView.Add(who);
                            validatedJoiners[jcnt++] = who;
                        }
                    }
                }
                else {
                    newView.Add(a);
                }
            }

            foreach (Address a in joiners) {
                if (!newView.Contains(a)) {
                    newView.Add(a);
                    validatedJoiners[jcnt++] = a;
                }
            }

            if (vd.prevVid == -1 && !validatedJoiners.Contains(Vsync.my_address)) {
                validatedJoiners[jcnt++] = Vsync.my_address;
            }

            if (lcnt != validatedLeavers.Length) {
                Vsync.ArrayResize(ref validatedLeavers, lcnt);
            }

            if (jcnt != validatedJoiners.Length) {
                Vsync.ArrayResize(ref validatedJoiners, jcnt);
            }

            if (newView.Count == 0 && g.isTrackingProxy) {
                g.GroupClose();
                using (var tmpLockObj = new LockAndElevate(Group.TPGroupsLock)) {
                    Group.TPGroups.Remove(g.gaddr);
                }

                return;
            }

            View nextView = new View(vd.gname, vd.gaddr, newView.ToArray(), vd.prevVid + 1, (g.flags & Group.G_ISLARGE) != 0);
            if (!g.isTrackingProxy) {
                nextView.joiners = validatedJoiners;
                nextView.offset = vd.offset;
                nextView.leavers = validatedLeavers;
            }

            if ((VsyncSystem.Debug & VsyncSystem.VIEWCHANGE) != 0) {
                Vsync.WriteLine("UpdateGroupView<" + g.gname + (GroupIsReal ? string.Empty : " TrackingProxy") + ">: nextView = " + nextView + ", InhibitActions=" + inhibitActions);
            }

            if (inhibitActions) {
                nv = nextView;
                return;
            }

            if (GroupIsReal) {
                if ((g.flags & Group.G_ISLARGE) != 0 && g.theView != null) {
                    nextView.NextIncomingMsgID[1] = g.theView.NextIncomingMsgID[1];
                }

                long before = Vsync.NOW;
                g.NewView(nextView, queue, null, ref nv);
                if ((VsyncSystem.Debug & VsyncSystem.DELAYS) != 0 && (Vsync.NOW - before) > Vsync.VSYNC_WARNAFTER) {
                    Vsync.WriteLine("WARNING: g.NewView delayed for " + (Vsync.NOW - before) + "ms");
                }

                if (!IAmLeaving) {
                    g.ReplayToDo();
                }
            }
            else {
                // Tracking Proxy in the ORACLE
                using (var tmpLockObj = new LockAndElevate(g.ViewLock)) {
                    g.theView = nextView;
                    nv = nextView;

                    // Remember the value just in case we "later" need to use it to initialize a joining member
                    nv.nextMsgid = g.nextMsgid;
                }
            }

            if (nextView.leavers.Length > 0) {
                ReliableSender.PendingSendCleanup(g, nextView.leavers);
            }
        }

        internal static Address[] Expand(Address[] list) {
            Group.vGroup vg = null;
            bool mustRevise = false;
            int newLen = list.Length;
            foreach (Address a in list) {
                if (a.pid < 0 && (vg = Group.vGLookup(a)) != null) {
                    mustRevise = true;
                    newLen = newLen - 1 + vg.vGMembers.Length;
                }
            }

            if (!mustRevise) {
                return list;
            }

            Address[] newList = new Address[newLen];
            int idx = 0;
            foreach (Address address in list) {
                if (address.pid < 0 && ((vg != null && vg.vGroupAddr == address) || (vg = Group.vGLookup(address)) != null)) {
                    foreach (Address ma in vg.vGMembers) {
                        newList[idx++] = ma;
                    }
                }
                else {
                    newList[idx++] = address;
                }
            }

            return newList;
        }
    }

    /// <summary>
    /// A class containing various static definitions and methods used by the Vsync^2 system.
    /// </summary>
    public static class VsyncSystem {
        internal static bool VsyncActive = false;

        internal static long StartedAt;

        /// <summary>
        /// A getter method for VsyncActive
        /// </summary>
        /// <returns>True if the library is active, false if not</returns>
        public static bool VsyncIsActive() {
            return VsyncActive;
        }

        internal static bool VsyncWasActive = false;

        internal static bool VsyncAlreadyRan = false;

        internal static bool VsyncRestarting = false;

        internal static bool fastStart = false;

        internal static int VsyncJoinCounter = 0;

        internal const long GROUPEVENTS = 0x0000000000000001;

        internal const long MESSAGELAYER = 0x0000000000000002;

        internal const long REPLYWAIT = 0x0000000000000004;

        internal const long VIEWCHANGE = 0x0000000000000008;

        internal const long FRAGER = 0x0000000000000010;

        internal const long TYPESIGS = 0x0000000000000020;

        internal const long RELAYLOGIC = 0x0000000000000040;

        internal const long GVELOGIC = 0x0000000000000080;

        internal const long P2PLAYER = 0x0000000000000100;

        internal const long INTERFACES = 0x0000000000000200;

        internal const long LOCKSTATE = 0x0000000000000400;

        internal const long MCMD = 0x0000000000000800;

        internal const long STARTSEQ = 0x0000000000001000;

        internal const long VIEWWAIT = 0x0000000000002000;

        internal const long CALLBACKS = 0x000000000004000;

        internal const long FAILURES = 0x0000000000008000;

        internal const long DISCARDS = 0x0000000000010000;

        internal const long DALLOGIC = 0x0000000000020000;

        internal const long TOKENLOGIC = 0x0000000000040000;

        internal const long TOKENFLUSH = 0x0000000000080000;

        internal const long FLUSHING = 0x0000000000100000;

        internal const long VERBOSEADDRS = 0x0000000000200000;

        internal const long MSGIDS = 0x0000000000400000;

        internal const long AGGREGATION = 0x0000000000800000;

        internal const long LOCKCHECK = 0x0000000001000000;

        internal const long MCMDMAP = 0x0000000002000000;

        internal const long LOOPBACK = 0x0000000004000000;

        internal const long PPAYLOADS = 0x0000000008000000;

        internal const long DELIVERY = 0x0000000010000000;

        internal const long TUNNELING = 0x0000000040000000;

        internal const long TIMERS = 0x0000000080000000;

        internal const long FLOWCONTROL = 0x0000000100000000;

        internal const long CIPHER = 0x0000000200000000;

        internal const long DHTS = 0x0000000400000000;

        internal const long NACKS = 0x0000000800000000;

        internal const long DELAYS = 0x0000001000000000;

        internal const long LOWLEVELMSGS = 0x0000002000000000;

        /* Caution: very verbose, uses in-memory storage.  Must call VsyncSystem.WriteAckLog periodically or will leak memory */

        internal const long TOKENSTABILITY = 0x0000004000000000;

        internal const long CAUSALDELIVERY = 0x0000008000000000;

        internal const long DISKLOGGER = 0x0000010000000000;

        internal const long MSGQS = 0x0000020000000000;

        internal const long WARNIFSLOW = 0x0000040000000000;

        internal const long SPECIALDEBUG = 0x0000080000000000;

        internal const long LOCKS = 0x0000100000000000;

        internal const long SAFESEND = 0x0000200000000000;

        internal const long ORDEREDSEND = 0x0000400000000000;

        internal const long WARNABOUTSUBSETS = 0x0000800000000000;

        internal const long OOBXFERS = 0x0001000000000000;

        internal const long PENDINGSENDS = 0x0002000000000000;

        internal const long IBDB = 0x0004000000000000;

        internal const long TOKENLAYER = FLUSHING | TOKENFLUSH | TOKENLOGIC;

        internal const long Debug = 0L;

        /// <summary>
        /// Returns this process's address.  
        /// </summary>
        /// <returns></returns>
        public static Address GetMyAddress() {
            if (!VsyncActive) {
                throw new VsyncException("Vsync isn't running (did you forget to call Vsync.Start()?)");
            }

            return Vsync.my_address;
        }

        /// <summary>
        /// An interface for obtaining a copy of the NULLADDRESS object
        /// </summary>
        /// <returns></returns>
        public static Address GetNullAddress() {
            return Vsync.NULLADDRESS;
        }

        /// <summary>
        /// Returns a pretty-printable string giving the internal state of Vsync on this node.  
        /// </summary>
        /// <returns></returns>
        public static string GetState() {
            GC.Collect();
            if (!VsyncSystem.VsyncActive || Vsync.my_address == null) {
                return "VSYNC is inactive";
            }

            string state = Environment.NewLine + "----------------------- VSYNC state for " + Vsync.my_address.ToStringVerboseFormat() +
                (Vsync.ClientOf == null ? " [leaderId=" + Vsync.LeaderId + "]" : string.Empty) + ":" + Environment.NewLine;
            for (int sc = 0; sc < 14; sc++) {
                try {
                    switch (sc) {
                        case 0:
                            state += RunTimeStatsState();
                            break;
                        case 1:
                            state += Group.GetState();
                            break;
                        case 2:
                            if (Vsync.VSYNC_INFINIBAND) {
                                state += IB.GetState();
                            }

                            break;
                        case 3:
                            state += Vsync.GetTimerState();
                            break;
                        case 4:
                            state += Vsync.RIPListState();
                            break;
                        case 5:
                            state += Vsync.GetPLLState();
                            break;
                        case 6:
                            state += Vsync.GetGVEState();
                            break;
                        case 7:
                            state += AwaitReplies.GetState();
                            break;
                        case 8:
                            state += FlowControl.GetState();
                            break;
                        case 9:
                            state += ReliableSender.GetState();
                            break;
                        case 10:
                            state += Group.deFragState();
                            break;
                        case 11:
                            state += MCMDSocket.GetState();
                            break;
                        case 12:
                            state += ILock.GetThreadStates() + ILock.GetState();
                            break;
                        case 13:
                            state += BoundedBuffer.GetState();
                            break;
                    }
                }
                catch (Exception e) {
                    string[] what = { "RunTimeStates", "Group", "Timer", "RIPList", "PLL", "GVE", "Rdv", "FC", "ReliableSender", "deFrag", string.Empty, "Tunnels", "MCMDSocket", "Ilock", "BB" };
                    state += "Vsync threw an internal exception < " + e + "> while trying to perform " + what[sc] + ".GetState()";
                }
            }

            state += "-------------------------End of State Dump------------------------------------" + Environment.NewLine;
            return state;
        }

        /// <summary>
        /// Returns a string summarizing the state of the Vsync I/O subsystem
        /// </summary>
        /// <returns></returns>
        public static string GetIOState() {
            return RunTimeStatsState();
        }

        internal static void WriteAckInfo() {
            if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                using (var tmpLockObj = new LockAndElevate(ReliableSender.ackInfoLock)) {
                    foreach (string aks in ReliableSender.ackInfo) {
                        Vsync.Write(aks);
                    }

                    ReliableSender.ackInfo = new List<string>();
                }
            }
        }

        /// <summary>
        /// Runtime statistics for this version of Vsync
        /// </summary>
        public class RuntimeStats {
            /// <summary>
            /// UDP packets sent
            /// </summary>
            public long UDPsent;

            /// <summary>
            /// UDP bytes sent
            /// </summary>
            public long UDPBsent;

            /// <summary>
            /// UDP packets received
            /// </summary>
            public long UDPrcvd;

            /// <summary>
            /// UDP bytes received
            /// </summary>
            public long UDPBrcvd;

            /// <summary>
            /// IPMC packets sent
            /// </summary>
            public long IPMCsent;

            /// <summary>
            /// IPMC bytes sent
            /// </summary>
            public long IPMCBsent;

            /// <summary>
            /// IPMC packets received
            /// </summary>
            public long IPMCrcvd;

            /// <summary>
            /// IPMC bytes received
            /// </summary>
            public long IPMCBrcvd;

            /// <summary>
            /// IPMC packets sent
            /// </summary>
            public long IBsent;

            /// <summary>
            /// IPMC bytes sent
            /// </summary>
            public long IBBsent;

            /// <summary>
            /// IPMC packets received
            /// </summary>
            public long IBrcvd;

            /// <summary>
            /// IPMC bytes received
            /// </summary>
            public long IBBrcvd;

            /// <summary>
            /// Tokens sent
            /// </summary>
            public long TokensSent;

            /// <summary>
            /// Tokens received
            /// </summary>
            public long TokensRcvd;

            /// <summary>
            /// Acks sent
            /// </summary>
            public long ACKsent;

            /// <summary>
            /// Acks received
            /// </summary>
            public long ACKrcvd;

            /// <summary>
            /// Nacks sent
            /// </summary>
            public long NACKsent;

            /// <summary>
            /// Nacks received
            /// </summary>
            public long NACKrcvd;

            /// <summary>
            /// Stability IPMC sent
            /// </summary>
            public long StabilitySent;

            /// <summary>
            /// Stability IPMC received
            /// </summary>
            public long StabilityRcvd;

            /// <summary>
            /// Token-triggered retransmissions
            /// </summary>
            public long TTRet;

            /// <summary>
            /// Total packets discarded as dups or for having no local receiver
            /// </summary>
            public long Discarded;

            internal LockObject Lock = new LockObject(false, "RTS.Lock");

            internal long rcvProcessingBeganAt;

            internal long ackedAt;

            internal long ackProcessingBeganAt;

#if WARN_ON_LONG_DELAYS
            internal long checkedAt;
#endif

            internal int[] ThreadCntrs = new int[36];

            internal void check() {
#if WARN_ON_LONG_DELAYS
                if (Vsync.NOW - VsyncSystem.StartedAt < 20000 || Vsync.NOW - this.checkedAt < 1000)
                {
                    return;
                }

                this.checkedAt = Vsync.NOW;
                long rdelay = 0;
                long a0delay = 0;
                long a1delay = 0;
                using (var tmpLockObj = new LockAndElevate(this.Lock))
                {
                    if (RTS.rcvProcessingBeganAt > 0)
                    {
                        rdelay = Vsync.NOW - RTS.rcvProcessingBeganAt;
                    }

                    if (RTS.ackedAt > 0)
                    {
                        a0delay = Vsync.NOW - RTS.ackedAt;
                    }

                    if (RTS.ackProcessingBeganAt > 0)
                    {
                        a1delay = Vsync.NOW - RTS.ackProcessingBeganAt;
                    }
                }

                if (rdelay > Vsync.VSYNC_WARNAFTER)
                {
                    if (rdelay > Vsync.VSYNC_DEFAULTTIMEOUT * 3)
                    {
                        throw new VsyncException("EXCEPTION: receive thread has been processing a received message for " + rdelay);
                    }

                    if ((VsyncSystem.Debug & VsyncSystem.WARNIFSLOW) != 0)
                    {
                        Vsync.WriteLine("WARNING: receive thread has been processing a received message for " + rdelay);
                    }
                }

                if (a0delay > Vsync.VSYNC_WARNAFTER)
                {
                    if (a0delay > Vsync.VSYNC_DEFAULTTIMEOUT * 3)
                    {
                        throw new VsyncException("EXCEPTION: ACK socket-handler thread has been trying to put a received ack on the ACKBB for " + a0delay + "ms");
                    }

                    if ((VsyncSystem.Debug & VsyncSystem.WARNIFSLOW) != 0)
                    {
                        Vsync.WriteLine("WARNING: ACK socket-handler thread has been trying to put a received ack on the ACKBB for " + a0delay + "ms");
                    }
                }

                if (a1delay > Vsync.VSYNC_WARNAFTER)
                {
                    if (a1delay > Vsync.VSYNC_DEFAULTTIMEOUT * 3)
                    {
                        throw new VsyncException("EXCEPTION: ACK processing thread has been processing a received ack/nack for " + a1delay + "ms");
                    }

                    if ((VsyncSystem.Debug & VsyncSystem.WARNIFSLOW) != 0)
                    {
                        Vsync.WriteLine("WARNING: ACK processing thread has been processing a received ack/nack for " + a1delay);
                    }
                }

#endif
            }
        }

        internal static bool noConsole;

        /// <summary>
        /// System statistics
        /// </summary>
        public static RuntimeStats RTS = new RuntimeStats();

        internal static string RunTimeStatsState() {
            string s = "Summary of network statistics:" + Environment.NewLine + "    ";
            using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                s += "SENT: " + RTS.UDPsent + " UDP (" + RTS.UDPBsent + " non-duplicated bytes), " + RTS.TokensSent + " tokens, " + RTS.IPMCsent + " IPMC (" + RTS.IPMCBsent + " bytes; " + RTS.StabilitySent + " were stability packets), ";
                s += RTS.ACKsent + " Acks, " + RTS.NACKsent + " Nacks, " + RTS.Discarded + " Discards." + Environment.NewLine + "    ";
                s += "RECV: " + RTS.UDPrcvd + " UDP (" + RTS.Discarded + " were dups; " + RTS.UDPBrcvd + " bytes), " + RTS.TokensRcvd + " tokens, " + RTS.IPMCrcvd + " IPMC (" + RTS.IPMCBrcvd + " bytes; " + RTS.StabilityRcvd + " were stability packets), ";
                s += RTS.Discarded + " were dups, " + RTS.ACKrcvd + " Acks, " + RTS.NACKrcvd + " Nacks, " + RTS.TTRet + " token-triggered resends" + Environment.NewLine;
                if (Vsync.VSYNC_USERDMA) {
                    s += "    RDMA: " + RTS.IBsent + " RDMA sends (" + RTS.IBBsent + " bytes), " + RTS.IBrcvd + " receives (" + RTS.IBBrcvd + " bytes)" + Environment.NewLine;
                }
            }

            return s;
        }

        /// <summary>
        /// Prints a line to the console and to the log
        /// </summary>
        public static void WriteLine(string s) {
            Vsync.WriteLine(s);
        }

        /// <summary>
        /// Prints a word to the console and to the log
        /// </summary>
        public static void Write(string s) {
            Vsync.Write(s);
        }

        internal static Thread ParentThread;

        /// <summary>
        /// Called to the Vsync subsystem.  Must be your first call to Vsync.
        /// </summary>
        public static void Start() {
            Start(false, false);
        }

        /// <summary>
        /// Called to Start the Vsync subsystem.  Must be your first call to Vsync.
        /// </summary>
        /// <param name="fast">If true, starts without searching for an already active Vsync ORACLE</param>
        public static void Start(bool fast) {
            Start(false, fast);
        }

        /// <summary>
        /// Called to Start the Vsync subsystem.  Must be your first call to Vsync.
        /// </summary>
        /// <param name="fast">If true, starts without searching for an already active Vsync ORACLE</param>
        /// <param name="noConsole">If true, Vsync won't write to the Console (it will generate a log and will write to the debug stream, if needed)</param>
        public static void Start(bool noConsole, bool fast) {
            if (!Stopwatch.IsHighResolution) {
                throw new VsyncException("Vsync requires access to a high-resolution timer.");
            }

            if (VsyncActive && !Vsync.WORKER_MODE) {
                throw new VsyncException("Vsync can't be started multiple times.");
            }

            if (VsyncAlreadyRan) {
                throw new VsyncException("Can't restart Vsync after shutdown");
            }

            fastStart = fast;
            VsyncSystem.noConsole = noConsole;
            ParentThread = Thread.CurrentThread;

#if PROTOCOL_BUFFERS
            RuntimeTypeModel.Default.AllowParseableTypes = true;
#endif

            StartedAt = Vsync.NOW;

            Thread t = new Thread(() => {
                // .NET has a peculiar behavior when the class loader is still active: threads can be
                // created but they don't really run.  To work around that, Vsync Start() itself runs in
                // a separate thread.  If this thread can start, other threads can start too!
                try {
                    Vsync.VSYNC_DEFAULTTIMEOUT <<= 1;
                    VsyncWasActive = VsyncActive = true;
                    VsyncAlreadyRan = true;
                    VsyncRestarting = true;
                    Vsync.timer_thread = new Thread(Vsync.TimerThread) { Priority = ThreadPriority.Highest, Name = "Vsync timer callback thread", IsBackground = true };
                    Vsync.timer_thread.Start();
                    ReliableSender.ResenderThreadLaunch();
                    if (Vsync.my_IPaddress == null) {
                        Vsync.my_IPaddress = Vsync.setMyAddress();
                    }

                    if (!Vsync.WORKER_MODE) {
                        WaitUntilVsyncIsRunning(true);
                        if (VsyncRestarting || !VsyncActive) {
                            throw new VsyncException("Vsync Start Failed(VsyncRestarting=" + VsyncRestarting + ", VsyncActive=" + VsyncActive + ")");
                        }
                    }

                    if (Vsync.VSYNC_LOGGED) {
                        bool vsync_mute = Vsync.VSYNC_MUTE;
                        Vsync.VSYNC_MUTE = true;
                        Vsync.WriteLine("VSYNC process-id: " + Vsync.my_pid + ", my_address = " + Vsync.my_address);
                        Vsync.VSYNC_MUTE = vsync_mute;
                    }

                    Vsync.SetupIM();
                    WaitUntilVsyncIsRunning(false);
                    if (Vsync.VSYNC_INFINIBAND) {
                        IB.Setup();
                    }

                    Vsync.VSYNC_DEFAULTTIMEOUT >>= 1;
                    if (Vsync.WORKER_MODE) {
                        Vsync.VSYNCMEMBERS.Watch[Vsync.MY_MASTER] += ev => { throw new VsyncException("master termination"); };
                    }
                }
                catch (VsyncShutdownException) {
                    VsyncSystem.CheckLocksHeld();
                }

                VsyncSystem.ThreadTerminationMagic();
            }) { Name = "VsyncSystem.Start() initialization thread.", IsBackground = true };
            t.Start();
            t.Join();
            if (Vsync.VSYNCMEMBERS != null && Vsync.VSYNCMEMBERS.HasFirstView && Vsync.VSYNCMEMBERS.GetMyRank() > Vsync.VSYNC_MAXSYSTEMSIZE) {
                Vsync.WriteLine("WARNING: This version of Vsync has only been tested with up to " + Vsync.VSYNC_MAXSYSTEMSIZE + " members.  Exceeding this threshold may trigger bugs or performance anomalies!");
            }
        }

        /// <summary>
        /// Gets the time since the system was started in milliseconds.
        /// </summary>
        /// <returns>The time since the system was started in milliseconds.</returns>
        public static long NOW
        {
            get
            {
                return Vsync.NOW;
            }
        }

        /// <summary>
        /// Gets the time that VSYNC was started in milliseconds.
        /// </summary>
        /// <returns>The time that VSYNC was started in milliseconds.</returns>
        public static long STARTED
        {
            get
            {
                return StartedAt;
            }
        }

        /// <summary>
        /// Gets the precise time since the system was started in ticks (100 nanoseconds).
        /// </summary>
        /// <returns>The precise time since the system was started in ticks (100 nanoseconds).</returns>
        public static long TICKS
        {
            get
            {
                return Vsync.TICKS;
            }
        }

        private static int SafelyGetMyRank(Group g) {
            if (g == null || !g.HasFirstView) {
                return -1;
            }

            return g.theView.GetMyRank();
        }

        private static void WaitUntilVsyncIsRunning(bool justOracle) {
            int howLong = Vsync.WORKER_MODE ? (15 * 60) : (2 * 60); // Seconds: Worker will wait 15 minutes; others 2
            Vsync.OK_TO_SEND_WORKER_REQ = true;
            for (int n = 0; n < howLong && (VsyncActive || !VsyncWasActive); n++) {
                if (VsyncActive && (Vsync.ClientOf != null || SafelyGetMyRank(Vsync.ORACLE) != -1) && (justOracle || (SafelyGetMyRank(Vsync.VSYNCMEMBERS) != -1 && ReliableSender.ResenderThread != null))) {
                    return;
                }

                Vsync.Sleep(1000);
            }

            throw new VsyncException("Vsync Start Failed");
        }

        /// <summary>
        /// Declares to Vsync that this process will run as a "worker" to a master process elsewhere in the datacenter.
        /// </summary>
        /// <param name="myMaster">Address of the "master" process that will call BatchStart(), in a verbose-format string (<see cref="Address.ToStringVerboseFormat()"/>, 
        /// or IP Address of the machine the master is on, in standard IPv4 notation: xxxx.xx.xxx.xxx</param>
        /// <param name="timeoutms">Timeout in ms (VSYNCDEFAULTTIMEOUT if not specified)</param>
        /// <returns>The address the master should use to activate the worker, via a call to BatchStart().</returns>
        /// <remarks>When using RunAsWorker(), the workers will typically be launched on some large number of nodes, passing the Address of their
        /// master in as an argument to RunAsWorker().  The workers then call Vsync.Start() and block until the master activates them by calling BatchStart().
        /// The master, in contrast, calls Vsync.Start() and then RegisterAsMaster().  It launches the workers, giving them its Vsync Address as an argument, and
        /// then waits until all the workers have started up; as each one calls RunAsWorker() the master receives an upcall providing the Address of that worker.
        /// When the master believes that all workers are running, it calls BatchStart() and this releases the workers, which will be waiting in Vsync.Start().
        /// 
        /// If 60 seconds pass and the worker has not yet been "BatchStarted" by the master, it calls Shutdown.
        /// 
        /// Notice that there are some apparent race conditions here.  Vsync handles them automatically: if calls to RunAsWorker() occur before the master
        /// calls RegisterAsMaster(), the incoming worker addresses are held and then upcalls occur once the RegisterAsWorker() method is finally called.
        /// 
        /// Vsync provides no help on "how long to wait" for workers to start, but beware of problems in which you try to launch 1000 workers but somehow, only 992
        /// launch successfully.  The master won't receive 1000 callbacks no matter how long it waits and in such cases, your code just needs to handle the
        /// situation.  On most data centers, a 30 second wait should be long enough: if a worker hasn't registered by then, it probably won't.  The master
        /// can call RejectWorker() if it gets an upcall to its NewWorker callback after it no longer wants to receive additional such calls.
        /// </remarks>
        public static void RunAsWorker(string myMaster, int timeoutms) {
            Vsync.WORKER_MODE = true;
            VsyncSystem.VsyncActive = true;
            Vsync.MY_MASTER = new Address(myMaster);
            Vsync.my_IPaddress = Vsync.setMyAddress();
            new Thread(() => {
                while (!Vsync.OK_TO_SEND_WORKER_REQ) {
                    Vsync.Sleep(250);
                }

                ReliableSender.SendP2P(Msg.RUNASWORKER, Vsync.MY_MASTER, null, new byte[0], true);
                Vsync.OnTimer(timeoutms, () => {
                    if (Vsync.VSYNCMEMBERS == null || !Vsync.VSYNCMEMBERS.HasFirstView || Vsync.VSYNCMEMBERS.theView.GetMyRank() == -1) {
                        Shutdown("RunAsWorker: taking too long");
                    }
                });
            }) { Name = "RunAsWorker launcher thread", IsBackground = true }.Start();
        }

        /// <summary>
        /// Overload for RunAsWorker(string myMaster, int timeoutms)
        /// </summary>
        /// <param name="myMaster">Vsync.Address of leader, or IP Address of machine the leader is on in standard xxxx.xx.xxx.xxx notation</param>
        public static void RunAsWorker(string myMaster) {
            RunAsWorker(myMaster, Vsync.VSYNC_DEFAULTTIMEOUT * 10);
        }

        internal static NewWorker MasterCallBack;

        /// <summary>
        /// The master uses this to register a callback that will be invoked once for each worker that calls RunAsWorker(), giving the Address of that worker
        /// Later when the master terminates, all its workers throw VsyncException("Master has terminated").
        /// </summary>
        /// <param name="del"></param>
        public static void RegisterAsMaster(NewWorker del) {
            MasterCallBack = del;
            ReliableSender.ReplaySavedWorkers();
        }

        /// <summary>
        /// Rejects a RunAsWorker() request.  The worker will throw an VsyncException("received poison");
        /// </summary>
        /// <param name="who">The rejected worker's Address</param>
        public static void RejectWorker(Address who) {
            ReliableSender.SendPoison(who, Vsync.my_address + " has rejected you as a worker");
        }

        /// <summary>
        /// Blocks until Vsync terminates on this node, then throws an exception.  Used mostly in a dedicated ORACLE process:
        /// such a process calls Vsync.Start() and then Vsync.WaitForever().
        /// </summary>
        /// <remarks>When Vsync terminates this will throw an exception, probably just VsyncException("Shutdown") but perhaps something
        /// more colorful.  Until then, sits here, perhaps forever.</remarks>
        public static void WaitForever() {
            while (VsyncSystem.VsyncActive) {
                Vsync.Sleep(15000);
            }
        }

        /// <summary>
        /// Used by a master process to activate a potentially long list of worker processes, which should call RunAsWorker(), pass their addresses to the master, and then block on calls to Vsync.Start().
        /// The master process itself should first call Vsync.Start() and only calls BatchStart() after collecting the addresses of the workers, usually via SendP2P().
        /// </summary>
        /// <remarks>When using RunAsWorker(), the workers will typically be launched on some large number of nodes, obtaining their addresses via RunAsWorker() and then
        /// passing these to the Master(), for example by appending them to a file that the master will read, passing them over a TCP link, or using the Vsync SendP2P() API.
        /// The workers then call Vsync.Start() and block until the master activates them by calling BatchStart().</remarks>
        public static void BatchStart(Address[] workers) {
            Address OracleLeader = Vsync.ClientOf;
            OracleLeader = OracleLeader ?? Vsync.ORACLE.theView.members[0];
            foreach (Address worker in workers) {
                Vsync.SendInitialOracleLeaderInfo(worker, OracleLeader);
            }

            Group.multiJoin(workers, new[] { Vsync.VSYNCMEMBERS });

            // Just in case, make sure all are listed in VSYNCMEMBERS before returning
            foreach (Address worker in workers) {
                int stry = 0;
                while (stry++ < 5 && Vsync.VSYNCMEMBERS.GetRankOf(worker) == -1) {
                    Vsync.Sleep(1000);
                }

                if (stry == 5) {
                    throw new VsyncException("BatchStart: Even after 5 seconds, worker " + worker + " wasn't listed in VSYNCMEMBERS");
                }
            }
        }

        /// <summary>
        /// Master calls this to wait for workers to call WorkerSetupDone
        /// </summary>
        /// <param name="workers">worker processes</param>
        public static void WaitForWorkerSetup(List<Address> workers) {
            WaitForWorkerSetup(workers.ToArray());
        }

        /// <summary>
        /// Master calls this to wait for workers to call WorkerSetupDone
        /// </summary>
        /// <param name="workers">worker processes</param>
        public static void WaitForWorkerSetup(Address[] workers) {
            foreach (Address worker in workers) {
                try {
                    Vsync.VSYNCMEMBERS.P2PQuery(worker, new Timeout(120000, Timeout.TO_ABORTREPLY, "INQUIRE"), Vsync.INQUIRE);
                }
                catch (VsyncAbortReplyException e) {
                    throw new VsyncException("Timeout on during WaitForWorkerSetup for worker " + worker, e);
                }
            }
        }

        internal static Semaphore waitForWorkerSetup = new Semaphore(0, 1);

        /// <summary>
        /// Worker calls this when any setup that needed to occur after Vsync.Start is completed
        /// </summary>
        public static void WorkerSetupDone() {
            waitForWorkerSetup.Release();
        }

        /// <summary>
        /// Used by a master process to activate a potentially long list of worker processes, which should call RunAsWorker(), pass their addresses to the master, and then block on calls to Vsync.Start().
        /// The master process itself should first call Vsync.Start() and only calls BatchStart() after collecting the addresses of the workers, usually via SendP2P().
        /// </summary>
        /// <remarks>When using RunAsWorker(), the workers will typically be launched on some large number of nodes, obtaining their addresses via RunAsWorker() and then
        /// passing these to the Master(), for example by appending them to a file that the master will read, passing them over a TCP link, or using the Vsync SendP2P() API.
        /// The workers then call Vsync.Start() and block until the master activates them by calling BatchStart().</remarks>
        public static void BatchStart(List<Address> workers) {
            BatchStart(workers.ToArray());
        }

        internal static void CheckParentThread() {
            if (VsyncActive && !ParentThread.IsAlive) {
                Shutdown("Vsync Shutdown: Parent thread has exited");
            }
        }

        /// <summary>
        /// Shuts Vsync down.  In this release, restarting Vsync is not supported.  Sorry!
        /// </summary>
        public static void Shutdown() {
            Shutdown(null);
        }

        /// <summary>
        /// Allows you to tell Vsync that some process is dead.  Ignored if the caller isn't a member of some group
        /// to which that process belongs
        /// </summary>
        /// <param name="who"></param>
        public static void ProcessFailed(Address who) {
            List<Group> theGroups = Group.VsyncGroupsClone();
            foreach (Group g in theGroups) {
                if (g.GetRankOf(who) != -1) {
                    Vsync.NodeHasFailed(who, "application logic sensed failure", false);
                    return;
                }
            }
        }

        internal static volatile bool shuttingDown = false;

        internal static object shutdownLock = new object();

        /// <summary>
        /// Shuts Vsync down.  In this release, restarting Vsync is not supported.  Sorry!
        /// Calls AppDomain.Unload(AppDomain.CurrentDomain);  unless you set VSYNC_GRACEFULSHUTDOWN to true.
        /// </summary>
        /// <param name="s"></param>
        public static void Shutdown(string s) {
            lock (shutdownLock) {
                if (shuttingDown) {
                    return;
                }

                shuttingDown = true;
                if (!VsyncSystem.VsyncActive && VsyncSystem.VsyncWasActive) {
                    return;
                }
            }

            if (s != null) {
                Vsync.WriteLine(s);
            }

            Dictionary<Address, Group> GClone = new Dictionary<Address, Group>();
            using (var tmpLockObj = new LockAndElevate(Group.VsyncGroupsLock)) {
                foreach (KeyValuePair<Address, Group> kvp in Group.VsyncGroups) {
                    GClone.Add(kvp.Key, kvp.Value);
                }
            }

            if (Vsync.ClientOf != null) {
                FDInform(Vsync.ClientOf);
            }
            else if (Vsync.ORACLE != null && Vsync.ORACLE.HasFirstView) {
                foreach (Address a in Vsync.ORACLE.theView.members) {
                    if (!a.isMyAddress()) {
                        FDInform(a);
                        break;
                    }
                }
            }

            VsyncActive = false;
            if (!Vsync.VSYNC_GRACEFULSHUTDOWN) {
                AbandonShip();
            }
            else {
                /*  The code that follows tries to do a graceful shutdown of Vsync, but has chronic "issues"... */
                try {
                    try {
                        foreach (KeyValuePair<Address, Group> kvp in GClone) {
                            Group g = kvp.Value;
                            AwaitReplies.InterruptReplyWaits(g);
                            g.InterruptAggregationWaits();
                        }
                    }
                    catch (VsyncShutdownException) {
                        VsyncSystem.CheckLocksHeld();
                    }

                    try {
                        BoundedBuffer.ShutDown();
                    }
                    catch (VsyncShutdownException) {
                        VsyncSystem.CheckLocksHeld();
                    }

                    try {
                        ReliableSender.Shutdown();
                    }
                    catch (VsyncShutdownException) {
                        VsyncSystem.CheckLocksHeld();
                    }

                    LockAndElevate.Disable(true);
                    try {
                        MCMDSocket.Shutdown();
                    }
                    catch (VsyncShutdownException) {
                        VsyncSystem.CheckLocksHeld();
                    }

                    try {
                        ReliableSender.toResendSema.Release();
                    }
                    catch (VsyncShutdownException) {
                        VsyncSystem.CheckLocksHeld();
                    }

                    try {
                        ILock.Shutdown();
                    }
                    catch (VsyncShutdownException) {
                        VsyncSystem.CheckLocksHeld();
                    }

                    try {
                        Vsync.my_logstream.Flush();
                    }
                    catch (IOException) {
                    }
                }
                catch (Exception e) {
                    if (VsyncSystem.noConsole) {
                        System.Diagnostics.Debug.WriteLine("While attempting to shut down Vsync, threw " + e);
                    }
                    else {
                        Console.WriteLine("While attempting to shut down Vsync, threw " + e);
                    }
                }
            }
        }

        internal static void AbandonShip() {
            try {
                AppDomain.Unload(AppDomain.CurrentDomain);
            }
            catch (CannotUnloadAppDomainException) {
                Environment.Exit(0);
            }
        }

        internal static void CheckLocksHeld() {
            GC.WaitForPendingFinalizers();
            if ((VsyncSystem.Debug & VsyncSystem.LOCKSTATE) != 0) {
                string s = LockObject.LocksIHold();
                if (s.Equals(" ", StringComparison.Ordinal)) {
                    return;
                }
            }
        }

        internal static void ThreadTerminationMagic() {
            LockObject.ThreadIsTerminating();
        }

        // Attempt to trigger a very rapid failure notification
        internal static void FDInform(Address who) {
            if (Vsync.ClientOf != null) {
                Vsync.ORACLE.doP2PSend(who, true, Vsync.FDETECTION, Vsync.my_address);
            }
            else {
                Vsync.ORACLE.doSend(false, false, Vsync.FDETECTION, Vsync.my_address);
            }
        }

        internal static void GotPoison(string why) {
            if (shuttingDown) {
                return;
            }

            VsyncSystem.WriteAckInfo();
            Shutdown("Got poison (reason=\"" + why + "\") in " + VsyncSystem.GetState());
            throw new VsyncShutdownException("poison");
        }
    }

    /// <summary>
    /// Appears in a Query argument list to separate the by-ref "results" parameters from the arguments to the
    /// Query method that will be invoked
    /// </summary>
    public class EOLMarker {
    }

    /// <summary>
    /// The Client class permits a non-member of a Group to relay requests through a "representative".
    /// </summary>
    public class Client {
        internal LockObject myRepLock;

        internal string gname;

        internal long[][] tsigs;

        internal Address myRep;

        internal static List<Client> Clients = new List<Client>();

        internal static LockObject ClientsLock = new LockObject("ClientsLock");

        /// <summary>
        /// Constructor for a Client stub object associated with the specified group name.  
        /// </summary>
        /// <remarks>
        /// A Client request will be satisfied even if the
        /// client process would not be allowed to join the actual group due to access control limits, so the group members must protect themselves
        /// against access by clients who are not authorized to access the group data.
        /// </remarks>
        /// <param name="gname">Group name</param>
        public Client(string gname) {
            if (!VsyncSystem.VsyncActive || VsyncSystem.VsyncRestarting) {
                throw new VsyncException(" New Client operation was requested but Vsync wasn't running yet");
            }

            using (var tmpLockObj = new LockAndElevate(ClientsLock)) {
                foreach (Client cl in Clients) {
                    if (cl.gname.Equals(gname, StringComparison.Ordinal)) {
                        throw new VsyncClientException("Attempted to created two Client objects with the same group name");
                    }
                }
            }

            this.gname = gname;
            this.myRepLock = new LockObject(gname + ".ClientLock");
            if (!this.refreshRep()) {
                throw new VsyncClientException("Client(" + gname + "): Group not found");
            }

            // Disables checking of types on RPC vectored via VSYNCMEMBERS: a hack for the client of a group mode
            // This won't cause harm: VSYNCMEMBERS is only called from the Vsync library and usually in type-checked mode
            // and the client's actual RPC call is type-checked in the Client class library
            Vsync.VSYNCMEMBERS.isClientProxy = true;
            using (var tmpLockObj = new LockAndElevate(ClientsLock)) {
                Clients.Add(this);
            }
        }

        /// <summary>
        /// Check to see if there is an existing Client object for this group, return it if found
        /// </summary>
        /// <param name="gname">Group name</param>
        /// <returns>Client object if any, null if not known</returns>
        public static Client Lookup(string gname) {
            using (var tmpLockObj = new LockAndElevate(ClientsLock)) {
                foreach (Client cl in Clients) {
                    if (cl.gname.Equals(gname, StringComparison.Ordinal)) {
                        return cl;
                    }
                }
            }

            return null;
        }

        internal static void ResetRep(string gname, Address newRep) {
            using (var tmpLockObj = new LockAndElevate(ClientsLock)) {
                foreach (Client cg in Clients) {
                    if (cg.gname.Equals(gname, StringComparison.Ordinal)) {
                        using (var tmpLockObj1 = new LockAndElevate(cg.myRepLock)) {
                            cg.myRep = newRep;
                        }

                        return;
                    }
                }
            }
        }

        private bool refreshRep() {
            byte[] ba;
            using (var tmpLockObj = new LockAndElevate(this.myRepLock)) {
                this.myRep = null;
            }

            if (Vsync.ClientOf != null) {
                ba = Vsync.ORACLE.doP2PQuery(Vsync.ClientOf, new Timeout(Vsync.VSYNC_DEFAULTTIMEOUT, Timeout.TO_FAILURE, "BECLIENT"), Vsync.BECLIENT, this.gname);
                if (ba.Length > 0) {
                    using (var tmpLockObj = new LockAndElevate(this.myRepLock)) {
                        this.myRep = (Address)Msg.BArrayToObjects(ba, typeof(Address))[0];
                    }
                }
            }
            else {
                using (var tmpLockObj = new LockAndElevate(this.myRepLock)) {
                    this.myRep = SelectHisRep(this.gname);
                    this.tsigs = GetTSigs(this.gname);
                }
            }

            if (this.myRep != null) {
                ba = Vsync.VSYNCMEMBERS.doP2PQuery(this.myRep, Vsync.BECLIENT, this.gname);
                if (ba.Length > 0) {
                    this.tsigs = (long[][])Msg.BArrayToObjects(ba, typeof(long[][]))[0];
                }
                else {
                    using (var tmpLockObj = new LockAndElevate(this.myRepLock)) {
                        this.myRep = null;
                    }
                }
            }

            return this.myRep != null;
        }

        internal static int beClientCounter;

        internal static Address SelectHisRep(string gname) {
            Address hisRep = Vsync.NULLADDRESS;
            Group g = Group.TrackingProxyLookup(gname);
            if (g != null && g.HasFirstView) {
                int rank = beClientCounter++ % g.theView.members.Length;
                while (rank < g.theView.hasFailed.Length && g.theView.hasFailed[rank]) {
                    ++rank;
                }

                if (rank != g.theView.hasFailed.Length) {
                    hisRep = g.theView.members[rank];
                }
            }

            return hisRep;
        }

        internal static long[][] GetTSigs(string gname) {
            Group g = Group.Lookup(gname);
            if (g == null && Vsync.ClientOf == null) {
                g = Group.TrackingProxyLookup(gname);
            }

            if (g == null) {
                return new long[0][];
            }

            long[][] tsvec = new long[g.Handlers.ListofhLists.Length][];
            for (int t = 0; t < tsvec.Length; t++) {
                if (g.Handlers.ListofhLists[t] != null && g.allowsClientRequests[t]) {
                    tsvec[t] = ComputeTSig(g.Handlers.ListofhLists[t]);
                }
                else {
                    tsvec[t] = new long[0];
                }
            }

            return tsvec;
        }

        internal static long[] ComputeTSig(Group.myHandlers mh) {
            long[] rv = new long[mh.hList.Count];
            int idx = 0;
            foreach (Group.CallBack cb in mh.hList) {
                ParameterInfo[] pi = cb.cbProc.hisCb.GetType().GetMethod("Invoke").GetParameters();
                string s = string.Empty;
                foreach (ParameterInfo pinfo in pi) {
                    s += pinfo.ParameterType + ":";
                }

                rv[idx++] = TSHash(s);
            }

            return rv;
        }

        /// <summary>
        /// Issues a peer-to-peer query to the group representative for this client, returns the result as a byte[] array.
        /// </summary>
        /// <remarks>
        /// P2PQueryToBA issues a peer-to-peer query to the group representative for this client, returns the result as a byte[] array.
        /// Normally, one would pass this array to Msg.BArrayToObjects or Msg.InvokeFromBArray.  The first argument must be
        /// the request identifier and the second argument an Vsync.Timeout() object specifying how long to wait for a reply
        /// and what action to take if a timeout occurs.
        /// </remarks>
        /// <param name="given">Variable-length list specifying request, timeout, parameters.</param>
        /// <returns>byte[] vector encoding results, null if unsuccessful</returns>
        public byte[] P2PQueryToBA(params object[] given) {
            Timeout timeout;
            Group.splitObs(null, out timeout, ref given);
            this.CheckTypeSig(given);
            byte[] ba = null;
            Address rep = null;
            int ntries = 0;
            while (this.findRep(ref rep, ref ntries) && (ba = Vsync.VSYNCMEMBERS.doP2PQuery(rep, timeout, Vsync.CLIENTWRAPPED, this.gname, (int)given[0], Msg.toBArray(given))).Length == 0) {
            }

            return ba;
        }

        /// <summary>
        /// Issues a peer-to-peer query to the group representative for this client, returns 0 on failure, 1 if successful
        /// indicating how many replies were received. 
        /// </summary>
        /// <remarks>
        /// P2PQuery issues a peer-to-peer query to the group representative for this client, returns an integer value 
        /// indicating how many replies were received. The first argument must be
        /// the request identifier and the second argument an Vsync.Timeout() object specifying how long to wait for a reply
        /// and what action to take if a timeout occurs. The replies themselves are stored into variables specified
        /// by reference in a list of by-ref reply objects that are separated from the argument list for the request handler
        /// by a special EOLMarker
        /// </remarks>
        /// <param name="given">Variable-length list specifying request, timeout, parameters, then an EOLMarker, then vectors in which to store results.</param>
        /// <returns>0 if unsuccessful, 1 on success</returns>
        public int P2PQuery(params object[] given) {
            Timeout timeout;
            object[] resRefs;
            Group.splitObs(null, out timeout, ref given, out resRefs);
            this.CheckTypeSig(given);
            byte[] ba = null;
            Address rep = null;
            int ntries = 0;
            while (this.findRep(ref rep, ref ntries) && (ba = Vsync.VSYNCMEMBERS.doP2PQuery(rep, timeout, Vsync.CLIENTWRAPPED, this.gname, (int)given[0], Msg.toBArray(given))).Length == 0) {
            }

            if (ba.Length == 0) {
                return 0;
            }

            List<byte[]> bas = new List<byte[]> { ba };
            Msg.BArraysToLists(resRefs, bas);
            return 1;
        }

        /// <summary>
        /// Issues a multicast query to the group representative for this client, then invokes a delegate specified by the caller 
        /// in which received replies are proved as vectors of the corresponding object types, one entry per reply received. 
        /// </summary>
        /// <remarks>
        /// P2PQueryInvoke issues a multicast query to the group representative for this client, then invokes a delegate specified by the caller 
        /// in which received replies are proved as vectors of the corresponding object types, one entry per reply received. 
        /// The first argument must be
        /// the request identifier and the second argument an Vsync.Timeout() object specifying how long to wait for a reply
        /// and what action to take if a timeout occurs. The delegate that will handle the replies is separated from the argument list for the request handler
        /// by a special EOLMarker</remarks>
        /// <param name="given">Variable-length list specifying request, timeout, parameters, then an EOLMarker, then vectors in which to store results.</param>
        public void P2PQueryInvoke(params object[] given) {
            Timeout timeout;
            Group.splitObs(null, out timeout, ref given);
            this.CheckTypeSig(given);
            Delegate del = (Delegate)given[given.Length - 1];
            Vsync.ArrayResize(ref given, given.Length - 1);
            byte[] ba = null;
            Address rep = null;
            int ntries = 0;
            while (this.findRep(ref rep, ref ntries) && (ba = Vsync.VSYNCMEMBERS.doP2PQuery(rep, timeout, Vsync.CLIENTWRAPPED, this.gname, (int)given[0], Msg.toBArray(given))).Length == 0) {
            }

            if (ba.Length == 0) {
                return;
            }

            Msg.InvokeFromBArray(ba, del);
        }

        // In this code we need to deal with the annoyance that NullReply causes us to get no replies, but so also would the failure of the
        // the selected representative.  So if findRep is called a second time or more times, it checks to see if the representative is
        // the same one.  If so, we return a NullReply to the user.  If not -- if we were assigned a new representative -- we reissue the
        // request.  But we do this no more than twice.
        internal bool findRep(ref Address rep, ref int ntries) {
            Address oldRep = rep;
            using (var tmpLockObj = new LockAndElevate(this.myRepLock)) {
                rep = this.myRep;
            }

            if (oldRep != null && rep != null && oldRep == rep) {
                // NullReply case
                return false;
            }

            if (rep == null) {
                if (!this.refreshRep()) {
                    // Group isn't running
                    return false;
                }

                using (var tmpLockObj = new LockAndElevate(this.myRepLock)) {
                    rep = this.myRep;
                }

                if (oldRep != null && oldRep == rep) {
                    // Not likely to occur, but call this another instance of the NullReply scenario
                    return false;
                }
            }

            if (ntries++ == 2) {
                throw new VsyncAbortReplyException("This request is apparently causing group members to crash!");
            }

            FlowControl.FCBarrierCheck();
            return true;
        }

        internal void CheckTypeSig(object[] obs) {
            int req = rcode(obs) + Vsync.SYSTEMREQS;
            long mySig = this.ComputeTypeSig(obs);
            if (this.tsigs == null || this.myRep == null) {
                throw new ArgumentException("Client intializer hasn't completed");
            }

            if (req > this.tsigs.Length || this.tsigs[req].Length == 0) {
                throw new ArgumentException("Group doesn't allow client calls to request code=" + rcode(obs));
            }

            bool fnd = false;
            foreach (long ts in this.tsigs[req]) {
                if (ts == mySig) {
                    fnd = true;
                    break;
                }
            }

            if (!fnd) {
                string ts = " ";
                for (int i = 1; i < obs.Length; i++) {
                    if (i > 1) {
                        ts += ", ";
                    }

                    ts += obs[i].GetType().ToString();
                }

                throw new ArgumentException("Group doesn't have a handler for request code=" + req + " matching type signature (" + ts + " )");
            }
        }

        internal long ComputeTypeSig(object[] obs) {
            string sig = string.Empty;
            for (int i = 1; i < obs.Length; i++) {
                sig += obs[i].GetType() + ":";
            }

            return TSHash(sig);
        }

        private static long TSHash(string sig) {
            using (MemoryStream ms = new MemoryStream(Msg.StringToBytes(sig))) {
                using (HMAC hm = new HMACSHA256(new byte[] { 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11 }))
                using (var tmpLockObj = new LockAndElevate(Msg.VerifyLock)) {
                    byte[] ba = hm.ComputeHash(ms);
                    long rval = 0;
                    for (int i = 0; i < ba.Length; i++) {
                        rval ^= (((long)ba[i]) & 0xFF) << ((i & 3) << 3);
                    }

                    return rval;
                }
            }
        }

        private static int rcode(object[] obs) {
            int rval;
            if (obs[0] is byte) {
                rval = (byte)obs[0];
            }
            else if (obs[0] is int) {
                rval = (int)obs[0];
            }
            else {
                throw new ArgumentException("Client-to-group request: can't identify the request code");
            }

            return rval;
        }
    }

    /// <exclude></exclude>
    public interface QKD {
        /// <exclude></exclude>
        Address[] GetDestsToArray(Group dht, int vid);

        /// <exclude></exclude>
        List<Address> GetDests(Group dht);

        /// <exclude></exclude>
        byte[] ToBArray();
    }

    /// <summary>
    /// Aggregation key for use when aggregating a DHT query
    /// </summary>
#if PROTOCOL_BUFFERS
        [ProtoContract(SkipConstructor = true)]
#else
    [AutoMarshalled]
#endif
    public class QueryKey<KT> : IComparable, IComparable<QueryKey<KT>>, IEquatable<QueryKey<KT>>, QKD {
        /// <exclude></exclude>
        [ProtoMember(1)]
        public readonly Address initiator;

        /// <exclude></exclude>
        [ProtoMember(2)]
        public readonly int uid;

        /// <exclude></exclude>
        [ProtoMember(3)]
        public List<KT> keys;

        /// <exclude></exclude>
        [ProtoMember(4)]
        public readonly bool includeInitiator = true;

        private static int nextid;

#if PROTOCOL_BUFFERS
        [ProtoAfterDeserialization]
        private void AfterDeserialize()
        {
            if (this.keys == null)
            {
                this.keys = new List<KT>(0);
            }
        }
#else
        /// <exclude></exclude>
        public QueryKey() {
        }
#endif

        /// <summary>
        /// Constructor takes a list of keys
        /// </summary>
        /// <param name="keys">the keys used in this query</param>
        public QueryKey(IEnumerable<KT> keys)
            : this(Vsync.my_address, keys, true) {
        }

        internal QueryKey(Address initiator, IEnumerable<KT> keys)
            : this(initiator, keys, true) {
        }

        internal QueryKey(Address initiator, IEnumerable<KT> keys, bool includeInitiator) {
            // We need to copy it into a form the Vsync marshaller can represent...
            this.keys = new List<KT>();
            foreach (KT k in keys) {
                this.keys.Add(k);
            }

            if (this.keys.Count == 0) {
                throw new VsyncException("QueryKey: key-list can't be empty");
            }

            this.initiator = initiator;
            this.includeInitiator = includeInitiator;
            this.uid = ++nextid;
        }

        /// <exclude></exclude>
        public byte[] ToBArray() {
            return Msg.toBArray(this.keys, this.initiator, this.uid, this.includeInitiator);
        }

        /// <exclude></exclude>
        public QueryKey(List<KT> keys, Address initiator, int uid, bool includeInitiator) {
            this.keys = keys;
            this.initiator = initiator;
            this.uid = uid;
            this.includeInitiator = includeInitiator;
        }

        private int oldVid = -1;

        private List<Address> oldParticipants;

        private Address[] oldParticipantsAsArray;

        private readonly LockObject opLock = new LockObject("opLock");

        /// <exclude></exclude>
        public Address[] GetDestsToArray(Group dht, int vid) {
            while (true) {
                using (var tmpLockObj = new LockAndElevate(this.opLock)) {
                    if (vid == this.oldVid && this.oldParticipants != null) {
                        return this.oldParticipantsAsArray ?? (this.oldParticipantsAsArray = this.oldParticipants.ToArray());
                    }

                    if (vid < this.oldVid) {
                        return null;
                    }
                }

                return this.GetDests(dht).ToArray();
            }
        }

        /// <exclude></exclude>
        public List<Address> GetDests(Group dht) {
            View theView;
            using (var tmpLockObj = new LockAndElevate(dht.ViewLock)) {
                theView = dht.theView;
            }

            using (var tmpLockObj = new LockAndElevate(this.opLock)) {
                if (theView.viewid == this.oldVid && this.oldParticipants != null) {
                    return this.oldParticipants;
                }
            }

            List<Address> dests = new List<Address>();
            if (this.includeInitiator) {
                dests.Add(this.initiator);
            }

            int iAg = dht.GetAffinityGroup(theView, this.initiator);
            int khash = this.initiator.GetHashCode();
            foreach (KT key in this.keys) {
                khash ^= key.GetHashCode();
            }

            khash = Math.Abs(khash >> 3);
            foreach (KT key in this.keys) {
                int kAg = dht.GetAffinityGroup(dht.DHTKeyHash(key));
                if (kAg != iAg || !this.includeInitiator) {
                    int offset = (khash % dht.myDHTBinSize) * dht.myDHTnShards;
                    if (offset + kAg >= theView.members.Length) {
                        offset = 0;
                    }

                    if (offset + kAg < theView.members.Length) {
                        Address dest = theView.members[offset + kAg];
                        if (!dests.Contains(dest)) {
                            dests.Add(dest);
                        }
                    }
                    else if ((VsyncSystem.Debug & VsyncSystem.DHTS) != 0) {
                        Vsync.WriteLine("WARNING: GetDests encountered a depopulated affinity group for key=" + key);
                    }
                }
            }

            using (var tmpLockObj = new LockAndElevate(this.opLock)) {
                this.oldVid = theView.viewid;
                this.oldParticipants = dests;
                this.oldParticipantsAsArray = null;
            }

            return dests;
        }

        /// <exclude></exclude>
        public static bool operator <(QueryKey<KT> first, QueryKey<KT> second) {
            return Compare(first, second) < 0;
        }

        /// <exclude></exclude>
        public static bool operator >(QueryKey<KT> first, QueryKey<KT> second) {
            return Compare(first, second) > 0;
        }

        /// <exclude></exclude>
        public static bool operator <=(QueryKey<KT> first, QueryKey<KT> second) {
            return Compare(first, second) <= 0;
        }

        /// <exclude></exclude>
        public static bool operator >=(QueryKey<KT> first, QueryKey<KT> second) {
            return Compare(first, second) >= 0;
        }

        /// <exclude></exclude>
        public static bool operator ==(QueryKey<KT> first, QueryKey<KT> second) {
            return Compare(first, second) == 0;
        }

        /// <exclude></exclude>
        public static bool operator !=(QueryKey<KT> first, QueryKey<KT> second) {
            return Compare(first, second) != 0;
        }

        /// <exclude></exclude>
        public static int Compare(QueryKey<KT> first, QueryKey<KT> second) {
            if (object.ReferenceEquals(first, second)) {
                return 0;
            }

            if (object.ReferenceEquals(first, null)) {
                return -1;
            }

            if (object.ReferenceEquals(second, null)) {
                return 1;
            }

            int comparison = first.uid.CompareTo(second.uid);
            if (comparison != 0) {
                return comparison;
            }

            comparison = first.initiator.CompareTo(second.initiator);
            return comparison;
        }

        /// <exclude></exclude>
        public int CompareTo(object other) {
            return Compare(this, other as QueryKey<KT>);
        }

        /// <exclude></exclude>
        public int CompareTo(QueryKey<KT> other) {
            return Compare(this, other);
        }

        /// <exclude></exclude>
        public override bool Equals(object other) {
            return Compare(this, other as QueryKey<KT>) == 0;
        }

        /// <exclude></exclude>
        public bool Equals(QueryKey<KT> other) {
            return Compare(this, other) == 0;
        }

        /// <exclude></exclude>
        public override int GetHashCode() {
            int hc = this.initiator.GetHashCode() + (this.uid * 77077);
            foreach (KT key in this.keys) {
                hc ^= key.GetHashCode();
            }

            return hc;
        }

        /// <exclude></exclude>
        public override string ToString() {
            string ks = " ";
            foreach (KT k in this.keys) {
                ks += "<" + k + "> ";
            }

            return "QueryKey{" + ks + ", initator=" + this.initiator + (this.includeInitiator ? "(included)" : "(not included)") + (this.oldVid == -1 ? " (haven't yet computed participants)" : ".... participants for vid=" + this.oldVid + " are " + (this.oldParticipants == null ? "<<unknown>>" : Address.VectorToString(this.oldParticipantsAsArray ?? this.oldParticipants.ToArray()) + "}"));
        }
    }

    /// <summary>
    /// The class corresponding to Vsync process groups, which is a central feature of the Vsync <it>virtual synchrony model</it>.
    /// </summary>
    public class Group : IComparable, IComparable<Group>, IEquatable<Group>, IDisposable {
        internal static Dictionary<Address, Group> VsyncGroups = new Dictionary<Address, Group>(100);

        // Groups this node either belongs to, or is joining (theView is null while joining!)
        internal static LockObject VsyncGroupsLock = new LockObject("VsyncGroupsLock", ThreadPriority.Highest);

        internal static Dictionary<Address, Group> TPGroups = new Dictionary<Address, Group>(100);

        // Tracking Proxy groups.  A kind of shadow used by the ORACLE to track membership info
        internal static LockObject TPGroupsLock = new LockObject("TPGroupsLock", ThreadPriority.Highest);

        internal static List<Address> GroupRIPList = new List<Address>();

        internal static LockObject GroupRIPLock = new LockObject("GroupRIPLock");

        // Tracked by all Vsync nodes, for all groups
        internal LockObject groupLock; // Use to lock/unlock entire group on entry from user 

        internal LockObject ViewLock = new LockObject("ViewLock", ThreadPriority.Highest); // Protects g.theView

        internal LockObject TokenLock = new LockObject("TokenLock", ThreadPriority.Highest);

        // Protects g.theToken, in large groups
        internal volatile bool interesting = true; // Send a token asap

        internal LockObject GroupFlagsLock = new LockObject("GroupFlagsLock"); // Touched often; hold very briefly!

        internal LockObject SIFLock = new LockObject("SIFLock", ThreadPriority.Highest);

        // Held while sending a message in fragments
        internal LockObject SIFListLock = new LockObject("SIFListLock", ThreadPriority.Highest);

        internal List<object[]> SIFList = null; // Non-null while fragmenting a big message

        internal Semaphore CPSSema; // If waiting on a flush

        internal volatile View theView; // Current 

        internal View nextView; // Non-null during the state transfer logic

        internal Initializer theInitializer = null;

        internal volatile bool initializationDone = false;

        internal string gname;

        internal string where;

        internal Address gaddr;

        // Fields active only when groupClosed is false
        internal Thread groupReaderThread;

        internal Thread groupP2PReaderThread;

        internal Thread groupIPMCReaderThread;

        internal volatile bool GroupOpen = false; // Becomes false once group.leave()/group.Terminate() is called

        internal bool TermSent = false;

        internal bool WasOpen = false; // True if the group has ever been open

        internal bool isTrackingProxy = false;

        internal bool isClientProxy = false;

        internal bool HasFirstView = false; // Becomes true when I get my very first view

        internal bool CallbacksDone = false; // Becomes true after the NEWVIEW callbacks (if any) for the first view

        internal int myVirtIPAddr = MCMDSocket.UNKNOWN; // IP address for this group as a long int

        internal bool hasPhysMapping = false; // Used only for tracking proxies: group has an assigned IPMC address

        internal int myPhysIPAddr = MCMDSocket.UNKNOWN;

        // Again, used in tracking proxy to represent the assigned IPMC address
        internal MCMDSocket my_socket;

        internal volatile int nextMsgid = 0; // Sequential for group multicasts on a per-group basis

        internal volatile int nRaw = 0; // Counts raw messages sent in a row

        internal int lastLgAckID = -1;

        internal int rcvdMcastsCnt = 0; // Incremented on received multicasts, zeroed every five minutes

        internal int rcvdMcastsRate = 0; // Running average: newAvg = (newRate + oldAvg)/2;

        internal bool getsMCADDR;

        // True in a tracking proxy at the MCMD deamon if we're allocating a true IPMC address to this group
        internal Group sameAs;

        // If non-null in a tracking proxy at the MCMD deamon, tells us to use the same IPMC address as the sameAs group
        internal bool LeaderMode = false; // Becomes true once this node is the active leader for the ORACLE

        internal bool TakingOver = false;

        // True when the old leader fails and I'm in the process of taking over from him
        internal int myFirstLeadershipView; // ViewID when I first took over as large group owner (else 0)

        internal int safeSendThreshold = ALL;

        // The number of nodes that must ack a SafeSend before it will be delivered
        internal durabilityMethod safeSendDurabilityMethod;

        // The method to use for making a SafeSend durable.  If none is specified, in-memory caching is used
        internal List<KeyValuePair<Thread, Msg>> curMsgList = new List<KeyValuePair<Thread, Msg>>();

        internal LockObject curMsgListLock = new LockObject("curMsgListLock", ThreadPriority.Highest);

        internal List<Msg> Unstable = new List<Msg>();

        // Lists messages that aren't yet stable because not yet fully acknowledged
        internal volatile int UnstableCount;

        internal LockObject UnstableLock = new LockObject("UnstableLock"); // Protects Unstable list

        internal long RequestedMinStableAt;

        // Vsync.NOW the last time this member sent a P2P inquiry requesting minStable from a sender
        internal long SentStableAt; // Vsync.NOW the last time a stability message of some sort was sent

        internal long LastSendAt; // Vsync.NOW when the last multicast to this group occured

        internal int CurrentBacklog; // Largest value of LocalBacklog sent since last STABILITYINFO multicast

        internal volatile int PreviousBacklog; // Value of CurrentBacklog when last sent

        internal BoundedBuffer incomingSends;

        internal BoundedBuffer incomingP2P;

        internal Semaphore Wedged = new Semaphore(1, int.MaxValue); // Used to wedge group during membership changes

        internal ILFunc myLoggingFcn; // If logged, routine to call back to on events of interest

        internal long myLoggingId;

        internal const int IL_SEND = 0;

        internal const int IL_SAFESEND = 1;

        internal const int IL_ORDEREDSEND = 2;

        internal const int IL_QUERY = 3;

        internal const int IL_DELIVERY = 4;

        internal const int IL_AGGWAIT = 5;

        internal const int IL_AGGDVALUE = 6;

        internal const int IL_AGGLVALUE = 7;

        internal const int IL_AGGREGATE = 8;

        internal const int IL_START = 0;

        internal const int IL_DONE = 1;

        internal volatile int flags; // Flags associated with this group

        internal LockObject quiesceLock = new LockObject("quiesceLock");

        internal int quiesceCnt;

        internal Semaphore quiesceWait = new Semaphore(0, int.MaxValue);

        // These flags come in two flavors.  Some are "set once", when the group is first created and for those we don't need to worry about locking before testing.
        // But the others are turned on and off and on them, you must obtain the right kind of lock before modifying or reading.  
        internal const int G_ISLARGE = 0x01; // [set once, no lock needed] Group is large

        internal const int G_USEUNICAST = 0x02; // [set once, no lock needed] Unicast only

        internal const int G_USEIPMC = 0x04; // [set once, no lock needed] Use IPMC if possible

        internal const int G_HASUAGG = 0x08;

        // [set once, no lock needed] Contains one or more user defined aggregators, run tokens faster
        internal const int G_TRACE = 0x10; // [set once, no lock needed] Trace events in this group

        internal const int G_SECURE = 0x20; // [set once, no lock needed] True for a secure group

        internal const int G_ISRAW = 0x40; // [set once, no lock needed] Disables vsync flush

        internal const int G_TERMINATING = 0x80; // [needs quiesceLock] Preparing to close/terminate this group

        internal const int G_WEDGED = 0x100; // [needs GroupFlagsLock] True while group is wedged for membership changes

        internal const int G_SENDINGSTABILITY = 0x0200;

        // [needs GroupFlagsLock] True if the group is in the process of sending its stability report
        internal const int G_NEEDSTATEXFER = 0x400;

        // [needs GroupFlagsLock] Wait until state xfer completes before delivering first message
        internal const int G_USESOOB = 0x800; // Uses OOB subsystem

        internal const int G_GETTINGMINSTABLE = 0x1000; // Checking minstable

        internal static string[] flagNames = { "islarge", "useunicast", "useIPMC", "hasuagg", "trace", "secure", "raw", "terminating", "wedged", "sendingstability", "needstatexfer", "usesOOB", "getting-minstable" };

        internal ManualResetEvent interruptLockWaits = new ManualResetEvent(false);

        internal Vsync.PendingLeaderOps NotifyDALOnReply = null; // Non-null if the "do as leader" code is running

        internal int uids; // Unique ids used in connection with the DAL logic

        internal List<Msg> ToDo = new List<Msg>(); // Received and already acked, but had a future view-id

        internal volatile int ToDoCount;

        internal LockObject ToDoLock = new LockObject("ToDoLock");

        internal List<byte[]> IPMCArrivedEarly = new List<byte[]>();

        // Received and not acked; arrived during the first stages of group join
        internal List<ReliableSender.MReplayMe> MsgArrivedEarly = new List<ReliableSender.MReplayMe>();

        internal List<Msg> OutOfOrderQueue = new List<Msg>();

        internal volatile int OutOfOrderQueueCount;

        internal LockObject OutOfOrderQueueLock = new LockObject("outOfOrderQueueLock");

        internal List<IPMCVinfo> stashedIPMCviews = new List<IPMCVinfo>();

        internal LinkedList<object>[] AggList;

        // For small-group aggregation: for each level, a list of the associated aggregations
        internal LockObject AggListLock = new LockObject("AggListLock");

        internal class svi {
            internal Address sender;

            internal int vid;

            internal int msgid;

            internal svi(Address s, int v, int m) {
                this.sender = s;
                this.vid = v;
                this.msgid = m;
            }
        }

        internal List<svi> desiredOrderQueue = new List<svi>();

        internal volatile tokenInfo theToken; // My representation of this group's token

        internal int gcollectedTo = -1; // Last value of aggstable used in garbage collecting lgPendingSendBuffer

        internal long TypeSig;

        internal string TypeSigStr = "<undef>";

        internal bool joinFailed = false; // Relays info about join failure

        internal string reason = string.Empty; // If join fails, this will give the reason

        internal string myCheckpointFile; // If non-null, the file name into which checkpoints should be saved

        internal int CheckpointFrequency = -1;

        // If greater than 0, an interval, in ms, at which checkpoints should be made
        internal FileStream myChkptStream = null;

        // While checkpointing, the temporary file into which the checkpoint is being written
        internal byte[] myAESkey = null; // A secret key for this group, if the group uses AES security

        internal bool userSpecifiedKey = false; // True if the end-user specified the key

        internal Aes myAes = null;

        internal LockObject myAesLock = new LockObject("myAESLock");

        internal ICryptoTransform myDecryptor = null;

        /// <exclude>
        /// <summary>
        /// Internal Aggregation structure
        /// </summary>
        /// </exclude>
        public class AggInfo : IComparable, IComparable<AggInfo>, IEquatable<AggInfo> {
            internal readonly Type KT;

            internal readonly Type VT;

            internal readonly string KVT;

            // This is tricky.  The following is actually a reference to an object of type 
            // Aggregator<KeyType,ValueType> that implements the IAggregateEventHandler interface
            internal readonly ConstructorInfo myFactory;

            // to pass into the factory
            internal readonly object theGroup;

            internal readonly object theDel;

            // And the "last resort" action to take...
            internal readonly Timeout theTimeout;

            internal AggInfo(Type kt, Type vt, ConstructorInfo mc, object g, object d, Timeout theTO) {
                this.KT = kt;
                this.VT = vt;
                this.KVT = kt + ":" + vt;
                this.myFactory = mc;
                this.theGroup = g;
                this.theDel = d;
                this.theTimeout = theTO;
            }

            /// <exclude>
            /// <summary>
            /// Required public constructor
            /// </summary>
            /// </exclude>
            public AggInfo() {
            }

            /// <exclude></exclude>
            public static bool operator <(AggInfo first, AggInfo second) {
                return Compare(first, second) < 0;
            }

            /// <exclude></exclude>
            public static bool operator >(AggInfo first, AggInfo second) {
                return Compare(first, second) > 0;
            }

            /// <exclude></exclude>
            public static bool operator <=(AggInfo first, AggInfo second) {
                return Compare(first, second) <= 0;
            }

            /// <exclude></exclude>
            public static bool operator >=(AggInfo first, AggInfo second) {
                return Compare(first, second) >= 0;
            }

            /// <exclude></exclude>
            public static bool operator ==(AggInfo first, AggInfo second) {
                return Equals(first, second);
            }

            /// <exclude></exclude>
            public static bool operator !=(AggInfo first, AggInfo second) {
                return !Equals(first, second);
            }

            /// <exclude></exclude>
            public static int Compare(AggInfo first, AggInfo second) {
                if (object.ReferenceEquals(first, second)) {
                    return 0;
                }

                if (object.ReferenceEquals(first, null)) {
                    return -1;
                }

                if (object.ReferenceEquals(second, null)) {
                    return 1;
                }

                return string.CompareOrdinal(first.KVT, second.KVT);
            }

            /// <exclude></exclude>
            public static bool Equals(AggInfo first, AggInfo second) {
                if (object.ReferenceEquals(first, second)) {
                    return true;
                }

                if (object.ReferenceEquals(first, null) || object.ReferenceEquals(second, null)) {
                    return false;
                }

                return first.VT == second.VT && first.KT == second.KT;
            }

            /// <exclude>
            /// <summary>
            /// Required equality test
            /// </summary>
            /// </exclude>
            public override bool Equals(object other) {
                return Equals(this, other as AggInfo);
            }

            /// <exclude>
            /// <summary>
            /// Required equality test
            /// </summary>
            /// </exclude>
            public bool Equals(AggInfo other) {
                return Equals(this, other);
            }

            /// <exclude>
            /// <summary>
            /// Required comparator
            /// </summary>
            /// </exclude>
            public int CompareTo(object other) {
                return Compare(this, other as AggInfo);
            }

            /// <exclude>
            /// <summary>
            /// Required comparator
            /// </summary>
            /// </exclude>
            public int CompareTo(AggInfo other) {
                return Compare(this, other);
            }

            /// <exclude>
            /// <summary>
            /// Required hash code computation
            /// </summary>
            /// </exclude>
            public override int GetHashCode() {
                return (this.VT.GetHashCode() * 37) + this.KT.GetHashCode();
            }
        }

        internal List<AggInfo> AggTypes = new List<AggInfo>(); // Aggregator types registered in this group

        internal Address[] Dying = new Address[0]; // Leaving the Group

        internal Address[] Joining = new Address[0]; // Joining the Group

        /// <summary>
        /// ALL members must reply
        /// </summary>
        public const int ALL = -1;

        /// <summary>
        /// At least a majority must reply
        /// </summary>
        public const int MAJORITY = -2;

        /// <summary>
        /// End of the list of arguments, start of the list of reply variables
        /// </summary>
        public static EOLMarker EOL = new EOLMarker();

        // Used as a marker between arguments and reply variables list in Query

        /// <exclude></exclude>
        public static int Compare(Group first, Group second) {
            if (object.ReferenceEquals(first, second)) {
                return 0;
            }

            if (object.ReferenceEquals(first, null)) {
                return -1;
            }

            if (object.ReferenceEquals(second, null)) {
                return 1;
            }

            return first.gaddr.CompareTo(second.gaddr);
        }

        /// <exclude></exclude>
        public static bool operator <(Group first, Group second) {
            return Compare(first, second) < 0;
        }

        /// <exclude></exclude>
        public static bool operator >(Group first, Group second) {
            return Compare(first, second) > 0;
        }

        /// <exclude></exclude>
        public static bool operator <=(Group first, Group second) {
            return Compare(first, second) <= 0;
        }

        /// <exclude></exclude>
        public static bool operator >=(Group first, Group second) {
            return Compare(first, second) >= 0;
        }

        /// <exclude></exclude>
        public static bool operator ==(Group first, Group second) {
            return Compare(first, second) == 0;
        }

        /// <exclude></exclude>
        public static bool operator !=(Group first, Group second) {
            return Compare(first, second) != 0;
        }

        /// <exclude>
        /// <summary>
        /// Internal to Vsync; public to comply with C# scope rules
        /// </summary>
        /// </exclude>
        public int CompareTo(object other) {
            return Compare(this, other as Group);
        }

        /// <exclude>
        /// <summary>
        /// Internal to Vsync; public to comply with C# scope rules
        /// </summary>
        /// </exclude>
        public int CompareTo(Group other) {
            return Compare(this, other);
        }

        /// <exclude>
        /// <summary>
        /// Internal to Vsync; public to comply with C# scope rules
        /// </summary>
        /// </exclude>
        public override bool Equals(object other) {
            return Compare(this, other as Group) == 0;
        }

        /// <exclude>
        /// <summary>
        /// Internal to Vsync; public to comply with C# scope rules
        /// </summary>
        /// </exclude>
        public bool Equals(Group other) {
            return Compare(this, other) == 0;
        }

        /// <exclude>
        /// <summary>
        /// Callback class, internal
        /// </summary>
        /// </exclude>
        public class CallBack {
            internal bool withLock;

            internal Callable cbProc;

            /// <exclude>
            /// <summary>
            /// Callback constructor, internal
            /// </summary>
            /// </exclude>
            public CallBack(bool wl, Delegate d) {
                this.withLock = wl;
                this.cbProc = new Callable(d);
            }
        }

        internal class VHCallBack {
            internal bool withLock;

            internal ViewHandler vhProc;

            // Has ability to obtain the LLENTRY lock on gaddr before calling back but currently Vsync isn't
            // using that feature because it was provoking deadlocks.  But must worry now about vsync violations
            internal VHCallBack(bool wl, ViewHandler vh) {
                this.withLock = wl;
                this.vhProc = vh;
            }
        }

        internal class UHCallBack {
            internal bool withLock;

            internal UCallback uhProc;

            // Has ability to obtain the LLENTRY lock on gaddr before calling back but currently Vsync isn't
            // using that feature because it was provoking deadlocks.  But must worry now about vsync violations
            internal UHCallBack(bool wl, UCallback vh) {
                this.withLock = wl;
                this.uhProc = vh;
            }
        }

        /// <exclude>
        /// <summary>
        /// Internal to Vsync; public to comply with C# scope rules
        /// </summary>
        /// </exclude>
        public class myHandlers {
            internal List<CallBack> hList = new List<CallBack>();

            /// <exclude>
            /// <summary>
            /// Internal to Vsync; public to comply with C# scope rules
            /// </summary>
            /// </exclude>
            public static myHandlers operator +(myHandlers a, Delegate b) {
                if (a == null) {
                    a = new myHandlers();
                }

                a.hList.Add(new CallBack(false, b));
                return a;
            }

            /// <exclude>
            /// <summary>
            /// Internal to Vsync; public to comply with C# scope rules.  This is for the doRegister case
            /// </summary>
            /// </exclude>
            public static myHandlers operator +(myHandlers a, CallBack b) {
                if (a == null) {
                    a = new myHandlers();
                }

                a.hList.Add(b);
                return a;
            }

            /// <exclude>
            /// <summary>
            /// Internal to Vsync; public to comply with C# scope rules.  This is for the doRegister case
            /// </summary>
            /// </exclude>
            public static myHandlers operator -(myHandlers a, object b) {
                throw new VsyncException("Error: attempt to unregister a handler (instead, Dispose of the group, then create a new handle)");
            }
        }

        /// <exclude>
        /// <summary>
        /// Internal to Vsync; public to comply with C# scope rules
        /// </summary>
        /// </exclude>
        public class myWatches {
            internal List<Watcher> hList = new List<Watcher>();

            /// <exclude>
            /// <summary>
            /// Internal to Vsync; public to comply with C# scope rules
            /// </summary>
            /// </exclude>
            public static myWatches operator +(myWatches a, Watcher b) {
                if (a == null) {
                    a = new myWatches();
                }

                a.hList.Add(b);
                return a;
            }

            /// <exclude>
            /// <summary>
            /// Internal to Vsync; public to comply with C# scope rules
            /// </summary>
            /// </exclude>
            public static myWatches operator -(myWatches a, Watcher b) {
                if (a == null) {
                    a = new myWatches();
                }

                a.hList.Remove(b);
                return a;
            }
        }

        /// <exclude>
        /// <summary>
        /// Internal to Vsync; public to comply with C# scope rules
        /// </summary>
        /// </exclude>
        public class myVHandlers {
            internal List<VHCallBack> vhList = new List<VHCallBack>();

            internal LockObject vhListLock = new LockObject("vhListLock");

            /// <exclude>
            /// <summary>
            /// Internal to Vsync; public to comply with C# scope rules
            /// </summary>
            /// </exclude>
            public static myVHandlers operator +(myVHandlers a, ViewHandler b) {
                using (var tmpLockObj = new LockAndElevate(a.vhListLock)) {
                    a.vhList.Add(new VHCallBack(false, b));
                }

                return a;
            }

            /// <exclude>
            /// <summary>
            /// Internal to Vsync; public to comply with C# scope rules
            /// </summary>
            /// </exclude>
            public static myVHandlers operator -(myVHandlers a, ViewHandler b) {
                using (var tmpLockObj = new LockAndElevate(a.vhListLock)) {
                    foreach (VHCallBack v in a.vhList) {
                        if (v.vhProc.Equals(b)) {
                            a.vhList.Remove(v);
                            return a;
                        }
                    }
                }

                return a;
            }

            /// <exclude>
            /// <summary>
            /// Internal to Vsync; public to comply with C# scope rules
            /// </summary>
            /// <remarks>Puts handler at the front of the queue.  For internal use only!</remarks>
            /// </exclude>
            public static myVHandlers operator *(myVHandlers a, ViewHandler b) {
                List<VHCallBack> newList = new List<VHCallBack> { new VHCallBack(false, b) };
                foreach (VHCallBack vhcb in a.vhList) {
                    newList.Add(vhcb);
                }

                using (var tmpLockObj = new LockAndElevate(a.vhListLock)) {
                    a.vhList = newList;
                }

                return a;
            }
        }

        /// <exclude>
        /// <summary>
        /// Internal to Vsync; public to comply with C# scope rules
        /// </summary>
        /// </exclude>
        public class myUMHandlers {
            internal bool locked;

            internal List<UHCallBack> uhList = new List<UHCallBack>();

            internal LockObject uhListLock = new LockObject("uhListLock");

            /// <exclude>
            /// <summary>
            /// Internal to Vsync; public to comply with C# scope rules
            /// </summary>
            /// </exclude>
            public static myUMHandlers operator +(myUMHandlers a, UCallback b) {
                if (a.locked) {
                    throw new VsyncException("Illegal attempt to register a handler after calling Group.Join()");
                }

                using (var tmpLockObj = new LockAndElevate(a.uhListLock)) {
                    a.uhList.Add(new UHCallBack(false, b));
                }

                return a;
            }

            /// <exclude>
            /// <summary>
            /// Internal to Vsync; public to comply with C# scope rules
            /// </summary>
            /// </exclude>
            public static myUMHandlers operator -(myUMHandlers a, UCallback b) {
                throw new VsyncException("Error: attempt to unregister a handler (instead, Dispose of the group, then create a new handle)");
            }
        }

        /// <exclude>
        /// <summary>
        /// Internal to Vsync; public to comply with C# scope rules
        /// </summary>
        /// </exclude>
        public class myUP2PHandlers {
            internal bool locked;

            internal List<UHCallBack> uhList = new List<UHCallBack>();

            internal LockObject uhListLock = new LockObject("uhListLock");

            /// <exclude>
            /// <summary>
            /// Internal to Vsync; public to comply with C# scope rules
            /// </summary>
            /// </exclude>
            public static myUP2PHandlers operator +(myUP2PHandlers a, UCallback b) {
                if (a.locked) {
                    throw new VsyncException("Illegal attempt to register a handler after calling Group.Join()");
                }

                using (var tmpLockObj = new LockAndElevate(a.uhListLock)) {
                    a.uhList.Add(new UHCallBack(false, b));
                }

                return a;
            }

            /// <exclude>
            /// <summary>
            /// Internal to Vsync; public to comply with C# scope rules
            /// </summary>
            /// </exclude>
            public static myUP2PHandlers operator -(myUP2PHandlers a, UCallback b) {
                throw new VsyncException("Error: attempt to unregister a handler (instead, Dispose of the group, then create a new handle)");
            }
        }

        /// <exclude>
        /// <summary>
        /// Internal to Vsync; public to comply with C# scope rules
        /// </summary>
        /// </exclude>
        public class mimicVector {
            internal bool locked;

            /// <exclude>
            /// <summary>
            /// Internal to Vsync; public to comply with C# scope rules
            /// </summary>
            /// </exclude>
            public myHandlers[] ListofhLists = new myHandlers[0];

            /// <exclude>
            /// <summary>
            /// Internal to Vsync; public to comply with C# scope rules
            /// </summary>
            /// <param name="i"></param>
            /// <returns></returns>
            /// </exclude>
            public myHandlers this[int i]
            {
                get
                {
                    i += Vsync.SYSTEMREQS;
                    if (i >= this.ListofhLists.Length) {
                        Vsync.ArrayResize(ref this.ListofhLists, i + 1);
                    }

                    return this.ListofhLists[i];
                }

                set
                {
                    if (this.locked) {
                        throw new VsyncException("Illegal attempt to register a handler after calling Group.Join()");
                    }

                    i += Vsync.SYSTEMREQS;
                    this.ListofhLists[i] = value;
                }
            }
        }

        /// <exclude>
        /// <summary>
        /// Internal to Vsync; public to comply with C# scope rules
        /// </summary>
        /// </exclude>
        public class mimicWVector {
            /// <exclude>
            /// <summary>
            /// Internal to Vsync; public to comply with C# scope rules
            /// </summary>
            /// </exclude>
            public Dictionary<Address, myWatches> ListofwLists = new Dictionary<Address, myWatches>(8);

            private readonly LockObject ListofwListsLock = new LockObject("ListofwListsLock");

            /// <exclude>
            /// <summary>
            /// Internal to Vsync; public to comply with C# scope rules
            /// </summary>
            /// <param name="who"></param>
            /// <returns></returns>
            /// </exclude>
            public myWatches this[Address who]
            {
                get
                {
                    using (var tmpLockObj = new LockAndElevate(this.ListofwListsLock)) {
                        myWatches mw;
                        if (this.ListofwLists.TryGetValue(who, out mw)) {
                            return mw;
                        }

                        this.ListofwLists.Add(who, new myWatches());
                        return this.ListofwLists[who];
                    }
                }

                set
                {
                    using (var tmpLockObj = new LockAndElevate(this.ListofwListsLock)) {
                        if (this.ListofwLists.ContainsKey(who)) {
                            this.ListofwLists[who] = value;
                        }
                        else {
                            this.ListofwLists.Add(who, value);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// A vector of handlers for incoming requests and updates, to which users attach additional handlers for requests defined by their code.
        /// </summary>
        /// <remarks>
        /// To register a request handler, one can call the explicit RegisterHandler method, but it is also possible (and
        /// more elegant) to write code like this:  Handlers[request-id] += (myHandler)delegate(... args ...) { ..... code to handle requests with matching type signature .... };
        /// Your code will be invoked later, each time a new message to the group is received and matches the request-id and type signature of your handler.
        /// </remarks>
        public mimicVector Handlers = new mimicVector();

        /// <summary>
        /// A vector of handlers for watched processes.
        /// </summary>
        /// <remarks>
        /// To register a watch on a group member, write code like this:  <c>Watch[who] += (Vsync.Watcher)delegate(int event) { };</c>  
        /// If you may need to cancel the watch, create a method and register it as follows: <c>Watch[who] += myWatcherMethod; </c>
        /// In this case, you can use  <c>Watch[who] -= myWatcherMethod; </c> to cancel the watch.
        /// The event indicates whether the watched process joined the group (W_JOIN) or left the group (W_LEAVE).
        /// </remarks>
        /// 
        public mimicWVector Watch = new mimicWVector();

        internal SortedList<long, Msg>[] PendingQueue;

        internal volatile int PendingQueueCount;

        internal LockObject PendingQueueLock = new LockObject("PendingQueueLock", ThreadPriority.Highest);

        internal ChkptChoser theChkptChoser;

        internal List<ChkptMaker> theChkptMakers = new List<ChkptMaker>();

        internal LockObject theChkptMakersLock = new LockObject("ChkptMakers");

        internal volatile bool inhibitEOC = false;

        /// <summary>
        /// New view callback handlers.
        /// </summary>
        /// <remarks>
        /// To register a ViewHandler, one can call the explicit RegisterViewCB method, but it is also possible (and
        /// more elegant) to write code like this:  ViewHandlers += (VHandler)delegate(View v) { ..... code to handle new views .... };
        /// </remarks>
        public myVHandlers ViewHandlers = new myVHandlers();

        // The FlushHandler callback is for internal use only; an upcall occurs during PROPOSE but the code needs to be live
        // or group view updates will wedge.  Thus I don't consider this to be a safe call to expose to Vsync users
        internal myVHandlers FlushHandlers = new myVHandlers();

        internal LockObject ViewHandlersLock = new LockObject("ViewHandlersLock");

        internal bool hasUniversalHandlers;

        internal bool isP2PThread;

        internal myUMHandlers UniversalMHandlers = new myUMHandlers();

        internal myUP2PHandlers UniversalP2PHandlers = new myUP2PHandlers();

        internal Group(string gname, Address gaddr, View v) {
            if (!VsyncSystem.VsyncActive) {
                throw new VsyncException("Must call VsyncSystem.Start() first");
            }

            this.MakeChkpt = new ChkptMkr(this);
            this.LoadChkpt = new ChkptLdr(this);
            this.Initializer = new Initer(this);
            this.gname = gname ?? "<unknown>";
            this.gaddr = gaddr;
            using (var tmpLockObj = new LockAndElevate(Group.GroupRIPLock)) {
                if (Group.GroupRIPList.Contains(gaddr)) {
                    throw new VsyncException("Must not rejoin/recreate a group immediately after leave/terminate");
                }
            }

            this.AddToGroupsList(gname, gaddr);
            this.Setup();
            this.NewView(v, "VsyncGroup create", null);
        }

        private void AddToGroupsList(string gname, Address gaddr) {
            using (var tmpLockObj = new LockAndElevate(VsyncGroupsLock)) {
                foreach (KeyValuePair<Address, Group> kvp in VsyncGroups) {
                    Group g = kvp.Value;
                    if (g.gname.Equals(gname, StringComparison.Ordinal) || g.gaddr == gaddr || g == this) {
                        throw new VsyncException("AddToGroupsList(" + gname + "/" + gaddr + "): but this group name or gaddr already exists (" + g.gname + "/" + g.gaddr + ")");
                    }
                }

                // These need to be big enough to deal with arriving fragmented messages, and totally ordered multicasts, which can both create big bursty loads
                this.incomingSends = new BoundedBuffer(gname + ":DeliverInOrder(IPMC)", 5120, ILock.LLDELIVERY, -1, -1);
                this.incomingP2P = new BoundedBuffer(gname + ":DeliverInOrder(P2P)", 1024, ILock.LLDELIVERY, -1, -1);
                if (VsyncGroups.ContainsKey(gaddr)) {
                    throw new VsyncException("AddToGroupsList: already listed");
                }

                VsyncGroups.Add(gaddr, this);
            }
        }

        /// <summary>
        /// The most standard way of constructing a new Group object: the user specifies the name and let's Vsync fill in other data.
        /// Once the Group handle is obtained, it is important to register handlers, data types, aggregators, etc, prior to calling Join or Create.
        /// </summary>
        /// <param name="name">Group name</param>
        public Group(string name) {
            if (!name.Equals("ORACLE", StringComparison.Ordinal) && !name.Equals("VSYNCMEMBERS", StringComparison.Ordinal) && (!VsyncSystem.VsyncActive || VsyncSystem.VsyncRestarting)) {
                throw new VsyncException("Group Join/Create operation was requested but Vsync wasn't running yet");
            }

            this.MakeChkpt = new ChkptMkr(this);
            this.LoadChkpt = new ChkptLdr(this);
            this.Initializer = new Initer(this);
            this.groupLock = new LockObject("<" + name + ">.GroupLock", ThreadPriority.Highest);
            this.Bind(name);

            // Group is uniquely named by hashing its name to a virtual IPMC address, but won't use IPMC unless
            // we have permission, and even then, only if Dr. Multicast (the MCMD) assigns a physical IP address 
            // to this group (or to some set of groups that includes this one)
            long addr = (Vsync.CLASSD + Vsync.VSYNC_MCRANGE_LOW + Address.GroupNameHash(this.gname)) & 0xFFFFFFFFL;
            this.gaddr = new Address(Vsync.LastIPv4(MCMDSocket.PMCAddr((int)addr)), 0);
            using (var tmpLockObj = new LockAndElevate(Group.GroupRIPLock)) {
                if (Group.GroupRIPList.Contains(this.gaddr)) {
                    throw new VsyncException("Must not rejoin/recreate a group immediately after leave/terminate");
                }
            }

            this.AddToGroupsList(this.gname, this.gaddr);
            this.Setup();
        }

        private Group() {
            this.MakeChkpt = new ChkptMkr(this);
            this.LoadChkpt = new ChkptLdr(this);
            this.Initializer = new Initer(this);
            this.groupLock = new LockObject("<anonymous group>.Lock");
        }

        internal volatile bool[] allowsClientRequests = new bool[512];

        /// <summary>
        /// Enables a handler to accept P2PQuery requests from group clients
        /// </summary>
        /// <param name="request">The request code</param>
        public void AllowClientRequests(int request) {
            request += Vsync.SYSTEMREQS;
            if (request >= 0 && request <= 511) {
                this.allowsClientRequests[request] = true;
            }
            else {
                throw new VsyncException("illegal request code");
            }
        }

        /// <summary>
        /// Redirects the role of representating this client to the specified new representative.  Pending requests will be reissued.
        /// </summary>
        /// <param name="Client">A client of the group currently bound to the caller</param>
        /// <param name="newRepresentative">A group member that will handle this client's requests in the future</param>
        public void RedirectClient(Address Client, Address newRepresentative) {
            if (this.GetRankOf(newRepresentative) == -1 || this.GetRankOf(Client) != -1 || Vsync.VSYNCMEMBERS.GetRankOf(Client) == -1) {
                throw new ArgumentException("Illegal argument to Vsync.RedirectClient");
            }

            Vsync.VSYNCMEMBERS.doP2PSend(Client, true, Vsync.BECLIENT, this.gname, newRepresentative);
        }

        /// <exclude>
        /// <summary>
        /// Internal, pretty-prints information about tracking proxies in ORACLE members
        /// </summary>
        /// <param name="tpg">Tracking proxy</param>
        /// <returns>Group state as a string</returns>
        /// </exclude>
        public static string TPtoString(Group tpg) {
            string s = ((tpg.flags & G_ISLARGE) != 0 ? "Large: " : string.Empty) + "<" + tpg.gname + "/" + tpg.gaddr + "/" + tpg.where + "> " + "[VIP: " + MCMDSocket.PMCAddr(tpg.myVirtIPAddr) + ", PIP: " + MCMDSocket.PMCAddr(tpg.myPhysIPAddr) + "] ";
            if (tpg.theView != null) {
                return s + " vid " + tpg.theView.viewid + ": next mid=" + tpg.theView.viewid + ":" + tpg.nextMsgid + ", rate " + tpg.rcvdMcastsRate + ",  {" + Address.VectorToString(tpg.theView.members) + "}";
            }

            return s + " view unknown";
        }

        // Called only in the ORACLE, to create a new Tracking Proxy
        internal static Group TrackingProxy(string gname, string where, Address gaddr, long tsig, int[] mm, View v, int flags, bool MapAddr) {
            Group g = new Group { isTrackingProxy = true, flags = flags & (G_ISLARGE | G_USEIPMC | G_USEUNICAST), where = where, gaddr = gaddr, gname = gname, TypeSig = tsig };
            if (mm != null && mm[MCMDSocket.VIRTUAL] != MCMDSocket.UNKNOWN) {
                g.myVirtIPAddr = mm[MCMDSocket.VIRTUAL];
                g.myPhysIPAddr = mm[MCMDSocket.PHYSICAL];
            }

            using (var tmpLockObj = new LockAndElevate(g.ViewLock)) {
                g.theView = v;
            }

            g.GroupOpen = g.WasOpen = true;
            using (var tmpLockObj = new LockAndElevate(TPGroupsLock)) {
                if (TPGroups.ContainsKey(g.gaddr)) {
                    Group oldGroup = TPGroups[g.gaddr];
                    if (oldGroup.theView == null || (v != null && v.viewid > oldGroup.theView.viewid)) {
                        using (var tmpLockObj1 = new LockAndElevate(oldGroup.ViewLock)) {
                            oldGroup.theView = v;
                        }
                    }

                    g = oldGroup;
                }
                else {
                    TPGroups.Add(g.gaddr, g);
                }
            }

            if (MapAddr) {
                MCMDSocket.SetMap("create TrackingProxy", gname, true, MCMDSocket.GetMap(g.gaddr, false));
            }

            ReliableSender.StartGroupReader(g);
            return g;
        }

        internal static Group TrackingProxyLookup(string gname) {
            using (var tmpLockObj = new LockAndElevate(TPGroupsLock)) {
                foreach (KeyValuePair<Address, Group> kvp in TPGroups) {
                    if (kvp.Value.gname.Equals(gname, StringComparison.Ordinal)) {
                        return kvp.Value;
                    }
                }
            }

            return null;
        }

        internal static Group TrackingProxyLookup(Address gaddr) {
            using (var tmpLockObj = new LockAndElevate(TPGroupsLock)) {
                Group g;
                if (TPGroups.TryGetValue(gaddr, out g)) {
                    return g;
                }
            }

            return null;
        }

        internal static void TrackingProxyDelete(Address gaddr) {
            using (var tmpLockObj = new LockAndElevate(TPGroupsLock)) {
                TPGroups.Remove(gaddr);
            }
        }

        internal void TPGroupsLearnedMM(int[] mm) {
            using (var tmpLockObj = new LockAndElevate(TPGroupsLock)) {
                foreach (KeyValuePair<Address, Group> kvp in TPGroups) {
                    if (kvp.Value.myVirtIPAddr == mm[MCMDSocket.VIRTUAL]) {
                        kvp.Value.myPhysIPAddr = mm[MCMDSocket.PHYSICAL];
                        return;
                    }
                }
            }
        }

        internal int[] MCMDMAP() {
            return new[] { this.myVirtIPAddr, this.myPhysIPAddr };
        }

        internal static int[] MCMDMAP(Address gaddr) {
            Group tpg = TrackingProxyLookup(gaddr);
            if (tpg != null) {
                return tpg.MCMDMAP();
            }

            return new[] { MCMDSocket.UNKNOWN, MCMDSocket.UNKNOWN };
        }

        internal static List<Group> VsyncGroupsClone() {
            List<Group> theClone = new List<Group>();
            using (var tmpLockObj = new LockAndElevate(VsyncGroupsLock)) {
                foreach (KeyValuePair<Address, Group> kvp in VsyncGroups) {
                    theClone.Add(kvp.Value);
                }
            }

            return theClone;
        }

        internal static List<Group> VsyncAllGroupsClone(bool removeDups) {
            List<Group> theClone = new List<Group>();
            using (var tmpLockObj = new LockAndElevate(TPGroupsLock)) {
                foreach (KeyValuePair<Address, Group> kvp in TPGroups) {
                    theClone.Add(kvp.Value);
                }
            }

            using (var tmpLockObj = new LockAndElevate(VsyncGroupsLock)) {
                foreach (KeyValuePair<Address, Group> kvp in VsyncGroups) {
                    Group ig = kvp.Value;
                    bool fnd = false;
                    if (removeDups) {
                        foreach (Group cg in theClone) {
                            if (ig.gaddr == cg.gaddr) {
                                fnd = true;
                                break;
                            }
                        }
                    }

                    if (!fnd) {
                        theClone.Add(ig);
                    }
                }
            }

            return theClone;
        }

        private void CheckState() {
            if (this.theView != null) {
                throw new VsyncException("Can't change attributes on an open group");
            }

            if ((this.flags & (G_USEIPMC | G_USEUNICAST)) != 0) {
                throw new VsyncException("Can't request both useUnicast and useIPMC on same group");
            }
        }

        /// <summary>
        /// Specifies that the user wishes this group to use the large group protocols.  
        /// </summary>
        /// <remarks>
        /// Specifies that the user wishes this group to use the large group protocols.  Recommended if a group may have 
        /// more than about 10 members, although in fact the normal protocols should be stable up to at least 100 members.
        /// </remarks>
        public void SetLarge() {
            if (Vsync.VSYNC_UNICAST_ONLY) {
                Vsync.WriteLine("WARNING: g.SetLarge is not supported with VSYNC_UNICAST_ONLY for this version of Vsync; ignored.");
                return;
            }

            this.CheckState();
            this.flags |= G_ISLARGE;
            this.LGSetup();
        }

        /// <summary>
        /// Group that will only be used with RawSend and other Raw IPC primitives.  No need for the "flush" virtual synchrony step
        /// </summary>
        public void SetRaw() {
            this.flags |= G_ISRAW;
        }

        /// <summary>
        /// Specifies a logging function for this group
        /// </summary>
        /// <param name="lfunc">The function</param>
        public void SetLogged(ILFunc lfunc) {
            this.myLoggingFcn = lfunc;
        }

        /// <summary>
        /// Enable or disable a per-group trace of events, which prints to the console and also to the Vsync log file
        /// </summary>
        /// <param name="onOff">True to enable trace, false to disable trace</param>
        public void Trace(bool onOff) {
            if (onOff) {
                this.flags |= G_TRACE;
            }
            else {
                this.flags &= G_TRACE;
            }
        }

        /// <summary>
        /// Specifies that the user wishes this group to use only unicast (point to point via UDP) messaging.  
        /// </summary>
        /// <remarks>
        /// Removes this group from the ones considered for the Dr. Multicast optimal resource allocation by claiming that the received messages rate is 0
        /// </remarks>
        public void UseUnicast() {
            this.flags |= G_USEUNICAST;
            this.CheckState();
        }

        /// <summary>
        /// Specifies that the user wishes this group to use an IP multicast address if possible
        /// </summary>
        /// <remarks>
        /// Forces this group to the top of the sort order used in the Dr. Multicast resource allocation scheme by claiming the
        /// received message rate is infinitely high
        /// </remarks>
        public void UseIPMC() {
            this.flags |= G_USEIPMC;
            this.CheckState();
        }

        /// <summary>
        /// Returns a list of the failed members of the current group, if any
        /// </summary>
        /// <returns>List of members that have failed (should quickly be reported as leaving in a new view)</returns>
        public Address[] GetFailedMembers() {
            this.ConfirmJoined();
            return this.theView.GetFailedMembers();
        }

        /// <summary>
        /// Returns a list of the live members of the current group, normally all members of the current view
        /// </summary>
        /// <returns>List of members thatare live.  Normally this will be the full membership since new views are reported quickly. </returns>
        public Address[] GetLiveMembers() {
            this.ConfirmJoined();
            return this.theView.GetLiveMembers();
        }

        private void ConfirmJoined() {
            if (this.theView == null) {
                throw new VsyncException("Must Join before accessing membership data");
            }
        }

        /// <summary>
        /// Returns a list of the full membership of this view, including members that have just been noted as faulty but not yet reported via a new view
        /// </summary>
        /// <returns>Membership list</returns>
        public Address[] GetMembers() {
            this.ConfirmJoined();
            return this.theView.members;
        }

        /// <summary>
        /// Returns the caller's rank in the group view
        /// </summary>
        /// <returns>Rank from 0..(N-1) as an offset into the full membership list of the group</returns>
        public int GetMyRank() {
            this.ConfirmJoined();
            return this.theView.GetMyRank();
        }

        /// <summary>
        /// Returns the rank of a designated process in the group view
        /// </summary>
        /// <param name="who"></param>
        /// <returns>Rank from 0..(N-1) as an offset into the full membership list of the group, or -1 if the process is not a group member.</returns>
        public int GetRankOf(Address who) {
            this.ConfirmJoined();
            return this.theView.GetRankOf(who);
        }

        /// <summary>
        /// Gets the length of the membership list
        /// </summary>
        /// <returns>N, where the membership consists of N members ranked 0..(N-1)</returns>
        public int GetSize() {
            this.ConfirmJoined();
            return this.theView.GetSize();
        }

        internal class SUTW : IComparable, IComparable<SUTW>, IEquatable<SUTW> {
            // Unique ID is Sender::Uid; it "names" this SafeSend.  Current ordering is Who::TS, order is final when committed flag is true
            internal Address Sender;

            internal Address Who;

            internal int Uid;

            internal int TS;

            internal bool commitFlag = false;

            internal SUTW(Address s, int u, int t, Address w) {
                this.Sender = s;
                this.Uid = u;
                this.TS = t;
                this.Who = w;
            }

            public static bool operator <(SUTW first, SUTW second) {
                return Compare(first, second) < 0;
            }

            public static bool operator >(SUTW first, SUTW second) {
                return Compare(first, second) > 0;
            }

            public static bool operator <=(SUTW first, SUTW second) {
                return Compare(first, second) <= 0;
            }

            public static bool operator >=(SUTW first, SUTW second) {
                return Compare(first, second) >= 0;
            }

            public static bool operator ==(SUTW first, SUTW second) {
                return Compare(first, second) == 0;
            }

            public static bool operator !=(SUTW first, SUTW second) {
                return Compare(first, second) != 0;
            }

            public static int Compare(SUTW first, SUTW second) {
                if (object.ReferenceEquals(first, second)) {
                    return 0;
                }

                if (object.ReferenceEquals(first, null)) {
                    return -1;
                }

                if (object.ReferenceEquals(second, null)) {
                    return 1;
                }

                int comparison = first.TS.CompareTo(second.TS);
                if (comparison != 0) {
                    return comparison;
                }

                comparison = first.Who.CompareTo(second.Who);
                return comparison;
            }

            public int CompareTo(object other) {
                return Compare(this, other as SUTW);
            }

            public int CompareTo(SUTW other) {
                return Compare(this, other);
            }

            public override bool Equals(object other) {
                return Compare(this, other as SUTW) == 0;
            }

            public bool Equals(SUTW other) {
                return Compare(this, other) == 0;
            }

            public override int GetHashCode() {
                return this.Who.GetHashCode() ^ this.TS * 11;
            }
        }

        private SortedList<SUTW, Msg> SSList = new SortedList<SUTW, Msg>();

        internal LockObject SSLock = new LockObject("SSLock");

        internal int logicalTS;

        internal LockObject CommitLock = new LockObject("CommitLock");

        internal LockObject ProposeLock = new LockObject("ProposeLock");

        internal class ctuple {
            internal int senderRank;

            internal int[] theVT;

            internal Msg theMsg;

            internal long whenEnqueued;

            internal ctuple(int sr, int[] vt, Msg m) {
                this.senderRank = sr;
                this.theVT = vt;
                this.theMsg = m;
                this.whenEnqueued = Vsync.NOW;
            }
        }

        internal LockObject CausalOrderListLock = new LockObject("CausalOrderListLock");

        internal List<ctuple> CausalOrderList = new List<ctuple>();

        internal volatile int CausalOrderListCount;

        internal LockObject OrderedSubsetListLock = new LockObject("OrderedSubsetListLock");

        internal SortedList<osspq, Msg> OrderedSubsetPQ = new SortedList<osspq, Msg>();

        internal volatile int OrderedSubsetPQCount = 0;

        internal LockObject RecentOpqNodesLock = new LockObject("RecentOpqNodesLock");

        internal List<osspq> RecentOpqNodes = new List<osspq>();

        internal long myTS;

        /// <exclude></exclude>
#if PROTOCOL_BUFFERS
        [ProtoContract(SkipConstructor = true)]
#else
        [AutoMarshalled]
#endif
        public class osspq : IComparable, IComparable<osspq>, IEquatable<osspq> {
            /// <exclude></exclude>
            [ProtoMember(1)]
            public bool cflag = false;

            /// <exclude></exclude>
            [ProtoMember(2)]
            public long proposedTS;

            /// <exclude></exclude>
            [ProtoMember(3)]
            public Address proposedWho;

            /// <exclude></exclude>
            [ProtoMember(4)]
            public List<Address> dests;

            /// <exclude></exclude>
            [ProtoMember(5)]
            public readonly Address sender;

            /// <exclude></exclude>
            [ProtoMember(6)]
            public readonly int vid;

            /// <exclude></exclude>
            [ProtoMember(7)]
            public readonly int msgid;

            internal long gtime;

#if PROTOCOL_BUFFERS
            [ProtoAfterDeserialization]
            private void AfterDeserialize()
            {
                if (this.dests == null)
                {
                    this.dests = new List<Address>(0);
                }
            }
#else
            /// <exclude></exclude>
            public osspq() {
            }
#endif

            internal osspq(long ts, Address who, List<Address> dests, Address sender, int vid, int msgid) {
                this.proposedTS = ts;
                this.proposedWho = who;
                this.dests = dests;
                this.sender = sender;
                this.vid = vid;
                this.msgid = msgid;
            }

            /// <exclude></exclude>
            public override string ToString() {
                return "OPQ[" + this.proposedTS + "::" + this.proposedWho + (this.cflag ? "** committed ** " : string.Empty) + ">; for msg " + this.sender + "::" + this.vid + ":" + this.msgid + "]";
            }

            internal void commit(long ts, Address who) {
                this.proposedTS = ts;
                this.proposedWho = who;
                this.cflag = true;
            }

            /// <exclude></exclude>
            public static bool operator <(osspq first, osspq second) {
                return Compare(first, second) < 0;
            }

            /// <exclude></exclude>
            public static bool operator >(osspq first, osspq second) {
                return Compare(first, second) > 0;
            }

            /// <exclude></exclude>
            public static bool operator <=(osspq first, osspq second) {
                return Compare(first, second) <= 0;
            }

            /// <exclude></exclude>
            public static bool operator >=(osspq first, osspq second) {
                return Compare(first, second) >= 0;
            }

            /// <exclude></exclude>
            public static bool operator ==(osspq first, osspq second) {
                return Equals(first, second);
            }

            /// <exclude></exclude>
            public static bool operator !=(osspq first, osspq second) {
                return !Equals(first, second);
            }

            /// <exclude></exclude>
            public static int Compare(osspq first, osspq second) {
                if (object.ReferenceEquals(first, second)) {
                    return 0;
                }

                if (object.ReferenceEquals(first, null)) {
                    return -1;
                }

                if (object.ReferenceEquals(second, null)) {
                    return 1;
                }

                int comparison = first.proposedTS.CompareTo(second.proposedTS);
                if (comparison != 0) {
                    return comparison;
                }

                comparison = first.proposedWho.CompareTo(second.proposedWho);
                return comparison;
            }

            /// <exclude></exclude>
            public static bool Equals(osspq first, osspq second) {
                if (object.ReferenceEquals(first, second)) {
                    return true;
                }

                if (object.ReferenceEquals(first, null) || object.ReferenceEquals(second, null)) {
                    return false;
                }

                return first.sender == second.sender && first.vid == second.vid && first.msgid == second.msgid;
            }

            /// <exclude></exclude>
            public int CompareTo(object other) {
                return Compare(this, other as osspq);
            }

            /// <exclude></exclude>
            public int CompareTo(osspq other) {
                return Compare(this, other);
            }

            /// <exclude></exclude>
            public override bool Equals(object other) {
                return Equals(this, other as osspq);
            }

            /// <exclude></exclude>
            public bool Equals(osspq other) {
                return Equals(this, other);
            }

            /// <exclude></exclude>
            public override int GetHashCode() {
                return (this.vid * 771) + (this.msgid * 33033) + this.sender.GetHashCode();
            }
        }

        private void Setup() {
            // None of these procedures are permitted to block, hence we fork new threads for any that might require a long-term
            this.doRegister(Vsync.PARTITIONED, new Action<Address>(obj => {
                if (!VsyncSystem.VsyncRestarting) {
                    throw new VsyncException("Partitioning event, this node was in the minority partition");
                }
            }));

            this.doRegister(Vsync.PROPOSE, new Action<Vsync.ViewDelta[], Vsync.UnstableList[]>((vds, usl) => {
                if (!this.HasFirstView || this.theView.GetMyRank() == -1) {
                    throw new VsyncException("Got Vsync.PROPOSED in ORACLE before receiving the first ORACLE view");
                }

                using (var tmpLockObj = new LockAndElevate(this.ProposeLock)) {
                    bool mustWait = false;

                    // We ddon't wedge the ORACLE since its only role is membership consensus and the scheme is our
                    // home-brew version of the leader-based paxos.  If the ORACLE had any other kind of multicasts
                    // that would be a different story, but it doesn't and we're not going to add any
                    if (this != Vsync.ORACLE) {
                        using (var tmpLockObj1 = new LockAndElevate(this.GroupFlagsLock)) {
                            if ((this.flags & G_WEDGED) == 0) {
                                mustWait = true;
                                this.flags |= G_WEDGED;
                            }
                        }
                    }

                    if (mustWait) {
                        ILock.NoteThreadState("Wedged(ORACLE).WaitOne()");
                        this.Wedged.WaitOne();
                        ILock.NoteThreadState(null); ;
                    }

                    if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.VIEWWAIT)) != 0) {
                        string us = " ";
                        foreach (Vsync.UnstableList ul in usl) {
                            us += ul.gaddr + "::" + ul.sender + ":" + ul.vid + "[" + ul.mid_low + "-" + ul.mid_hi + "] ";
                        }

                        Vsync.WriteLine("=== W E D G E D < " + this.gname + "> vid " + this.theView.viewid + ", initial UNSTABLE LIST = { " + us + "} ===");
                    }

                    if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.VIEWWAIT | VsyncSystem.GROUPEVENTS)) != 0) {
                        foreach (Vsync.ViewDelta vd in vds) {
                            Vsync.WriteLine("   " + vd);
                        }
                    }

                    // Creating a new thread this way may seem risky: it eliminates the risk of a deadlock associated with doing a reply
                    // but now we have to worry about event ordering relative to other incoming messages.  This is safe because the
                    // group is wedged and flushing.  Under these conditions, nothing much can happen and we can use our new thread
                    // and thus avoid running into problems like deadlock if the limit on pending asynchronous p2p messages is reached.
                    Thread t = new Thread(() => {
                        try {
                            // This do loop is here purely to avoid a "goto"
                            do {
                                if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.VIEWWAIT | VsyncSystem.GROUPEVENTS)) != 0) {
                                    foreach (Vsync.ViewDelta vd in vds) {
                                        Vsync.WriteLine("   " + vd);
                                    }
                                }

                                // This next line is safe only because there is a single dispatch thread doing both the PROPOSE and INITIALVIEW callbacks!
                                if (!this.HasFirstView) {
                                    if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.VIEWWAIT)) != 0) {
                                        Vsync.WriteLine("PROPOSE handler Waiting on LLINITV barrier lock for gaddr " + this.gaddr + "(Lock [" + ILock.LLINITV + "][" + ILock.GetLockId(ILock.LLINITV, this.gaddr.GetHashCode()) + "])");
                                    }

                                    ILock.Barrier(ILock.LLINITV, this.gaddr).BarrierWait();
                                    if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.VIEWWAIT)) != 0) {
                                        Vsync.WriteLine("PROPOSE handler After LLINITV barrier lock for gaddr " + this.gaddr + "(Lock [" + ILock.LLINITV + "][" + ILock.GetLockId(ILock.LLINITV, this.gaddr.GetHashCode()) + "])");
                                    }
                                }

                                Vsync.ViewDelta[] rvds = new Vsync.ViewDelta[vds.Length];
                                bool involvesOracle = false;
                                bool involvesMe = false;
                                Address[] leaving = new Address[0];
                                foreach (Vsync.ViewDelta vd in vds) {
                                    if (vd.gaddr == Vsync.ORACLE.gaddr) {
                                        involvesOracle = true;
                                    }

                                    if (vd.gaddr == this.gaddr) {
                                        involvesMe = true;
                                    }

                                    int len = vd.leavers.Length;
                                    if (len > 0) {
                                        int oldlen = leaving.Length;
                                        Vsync.ArrayResize(ref leaving, oldlen + len);
                                        Array.Copy(vd.leavers, 0, leaving, oldlen, len);
                                    }
                                }

                                Vsync.Proposed = vds;

                                if (!involvesMe || (this == Vsync.ORACLE && !involvesOracle)) {
                                    // Special case: Oracle was "cc'ed" and should ack, but has no actual role
                                    if ((VsyncSystem.Debug & VsyncSystem.GROUPEVENTS) != 0) {
                                        Vsync.WriteLine("PROPOSE: doReply special case (ORACLE acks)");
                                    }

                                    this.doReply(Vsync.my_address, new Vsync.ViewDelta[0]);
                                    break;
                                }

                                // Give the application a chance to flush, if using the new FlushHandler upcalls
                                using (var tmpLockObj1 = new LockAndElevate(this.FlushHandlers.vhListLock)) {
                                    if (this.FlushHandlers.vhList.Count > 0) {
                                        View v;
                                        using (var tmpLockObj2 = new LockAndElevate(this.ViewLock)) {
                                            v = new View(this.theView.gname, this.theView.gaddr, this.theView.members, this.theView.viewid, this.theView.isLarge);
                                        }

                                        // Tinker with the View to report who will join or leave without actually modifying the list of members
                                        foreach (Vsync.ViewDelta vd in vds) {
                                            if (vd.gaddr == this.gaddr && vd.prevVid == v.viewid) {
                                                Vsync.UpdateGroupView(false, vd, this, "PROPOSE:FLushUpcall", ref v, true);
                                                foreach (VHCallBack vhcb in this.FlushHandlers.vhList) {
                                                    vhcb.vhProc(v);
                                                }
                                            }
                                        }
                                    }
                                }

                                // Flush those I've been asked to forward.  Code takes advantage of the group being in a WEDGED state: no new traffic allowed in...
                                using (Semaphore CPSSema = new Semaphore(0, int.MaxValue)) {
                                    int cpscnt;
                                    List<Msg> mustSend;
                                    this.startFlush(int.MaxValue, usl, out mustSend, out cpscnt, CPSSema);
                                    this.endFlush(leaving, mustSend, cpscnt, CPSSema);
                                }

                                // Now look up the groups, again, and this time note the final Msgids
                                // for those vds corresponding to "my" group
                                for (int idx = 0; idx < vds.Length; idx++) {
                                    Vsync.ViewDelta vd = vds[idx];
                                    rvds[idx] = new Vsync.ViewDelta(vd.gname, vd.gaddr, 0L, Group.MCMDMAP(vd.gaddr), -1, new int[0], false);
                                    if (vd.gaddr != this.gaddr) {
                                        continue;
                                    }

                                    if ((this.flags & G_ISLARGE) != 0) {
                                        throw new VsyncException("PROPOSE: vd applied to a LARGE group!");
                                    }

                                    if (this != Vsync.ORACLE || !this.IAmLeader()) {
                                        this.theView.isFinal = true;
                                    }

                                    rvds[idx].prevVid = this.theView.viewid;
                                    rvds[idx].lastSeqns = new int[this.theView.NextIncomingMsgID.Length - 1];

                                    ////string ls = " ";
                                    for (int i = 0; i < this.theView.NextIncomingMsgID.Length - 1; i++) {
                                        ////ls += this.theView.NextIncomingMsgID[i + 1] + " ";
                                        rvds[idx].lastSeqns[i] = this.theView.NextIncomingMsgID[i + 1];
                                    }

                                    foreach (Address d in vd.leavers) {
                                        int r = this.theView.GetRankOf(d);
                                        if (r != -1) {
                                            View.noteFailed(this, d);
                                        }
                                    }
                                }

                                if ((VsyncSystem.Debug & VsyncSystem.GROUPEVENTS) != 0) {
                                    Vsync.WriteLine("PROPOSE: doReply normal case (processed " + rvds.Length + " view deltas), curMsg=" + this.getReplyTo());
                                }

                                this.doReply(Vsync.my_address, this == Vsync.ORACLE ? new Vsync.ViewDelta[0] : rvds);
                            }
                            while (false);
                        }
                        catch (VsyncShutdownException) {
                            VsyncSystem.CheckLocksHeld();
                        }

                        VsyncSystem.ThreadTerminationMagic();
                    }) { Name = "PROPOSED:DOFLUSH", Priority = ThreadPriority.Highest, IsBackground = true };
                    this.SetReplyThread(t);
                    t.Start();
                }
            }));

            this.doRegister(Vsync.COMMIT, new Action<Vsync.ViewDelta[], Address[], int[]>((vds, who, uid) => {
                if (!this.HasFirstView || this.theView.GetMyRank() == -1) {
                    throw new VsyncException("Got Vsync.PROPOSED in ORACLE before receiving the first ORACLE view");
                }

                using (var tmpLockObj = new LockAndElevate(this.groupLock))
                using (var tmpLockObj1 = new LockAndElevate(this.CommitLock)) {
                    if ((VsyncSystem.Debug & VsyncSystem.GROUPEVENTS) != 0) {
                        string s = "Received a new COMMIT message in group <" + this.gname + "> ViewDelta vector has " + vds.Length + " updates:" + Environment.NewLine;
                        foreach (Vsync.ViewDelta vd in vds) {
                            s += "  " + vd + Environment.NewLine;
                        }

                        Vsync.Write(s);
                    }

                    Vsync.ViewDelta[] nextvds = null;
                    do {
                        if (this == Vsync.ORACLE) {
                            // Look at "chunks" of the vds vector that end with an ORACLE join event.
                            int n;
                            for (n = 0; n < vds.Length - 1; n++) {
                                if (vds[n].gaddr == Vsync.ORACLE.gaddr && vds[n].joiners.Length > 0) {
                                    break;
                                }
                            }

                            ++n; // n is now the length of the chunk
                            if (n < vds.Length) {
                                nextvds = new Vsync.ViewDelta[vds.Length - n];
                                for (int i = n; i < vds.Length; i++) {
                                    nextvds[i - n] = vds[i];
                                }

                                Vsync.ArrayResize(ref vds, n);
                            }
                            else {
                                nextvds = null;
                            }

                            // Now there is a chunk in vds, and perhaps more work to do later in nextvds
                            // Ignore the current chunk if I've already seen it, or it predates my joining the ORACLE
                            if ((n = vds.Length - 1) < 0) {
                                return;
                            }

                            if (vds[n].gaddr == Vsync.ORACLE.gaddr && vds[n].joiners.Length > 0) {
                                using (var tmpLockObj2 = new LockAndElevate(this.ViewLock)) {
                                    if (this.theView != null) {
                                        if (vds[n].prevVid < this.theView.viewid) {
                                            if ((VsyncSystem.Debug & VsyncSystem.GROUPEVENTS) != 0) {
                                                string s = "IGNORING STALE COMMIT actions in group <" + this.gname + "> (theView.viewid=" + this.theView.viewid + "), Ignored part of ViewDelta vector has " + vds.Length + " updates:";
                                                foreach (Vsync.ViewDelta vd in vds) {
                                                    s += "  " + vd + Environment.NewLine;
                                                }

                                                Vsync.Write(s);
                                            }

                                            continue;
                                        }
                                    }
                                }
                            }
                        }

                        if ((VsyncSystem.Debug & VsyncSystem.GROUPEVENTS) != 0) {
                            string s = "APPLYING COMMIT actions in group <" + this.gname + "> (theView.viewid=" + this.theView.viewid + "), this chunk of ViewDelta vector has " + vds.Length + " updates:";
                            foreach (Vsync.ViewDelta vd in vds) {
                                s += "  " + vd + Environment.NewLine;
                            }

                            Vsync.Write(s);
                        }

                        if (this != Vsync.ORACLE) {
                            int myVid = 0;
                            using (var tmpLockObj2 = new LockAndElevate(this.ViewLock)) {
                                if (this.theView != null) {
                                    myVid = this.theView.viewid;
                                }
                            }

                            vds = vds.Where(vd => vd.gaddr == this.gaddr && vd.prevVid >= myVid).ToArray();
                            if (vds.Length == 0) {
                                return;
                            }
                        }

                        this.gotNewViewDeltas(vds);
                        Vsync.CommitGVUpdates(this, vds);
                        if (this == Vsync.ORACLE) {
                            for (int i = 0; i < who.Length; i++) {
                                Vsync.PurgeGVE(who[i], uid[i]);
                            }
                        }

                        Vsync.Proposed = null;
                        if (this == Vsync.ORACLE) {
                            using (var tmpLockObj2 = new LockAndElevate(Vsync.ORACLE.groupLock)) {
                                foreach (Vsync.ViewDelta vd in vds) {
                                    if (vd.gaddr == Vsync.ORACLE.gaddr) {
                                        Vsync.OracleJoinsUnderway -= vd.joiners.Length;
                                    }
                                }

                                if (Vsync.OracleJoinsUnderway < 0) {
                                    Vsync.OracleJoinsUnderway = 0;
                                }
                            }

                            if (Vsync.ORACLE.IAmLeader()) {
                                ILock.Barrier(ILock.LLWAIT, ILock.LCOMMIT).BarrierRelease(1);
                            }

                            Vsync.SendInitialView(vds);
                        }

                        if (this != Vsync.ORACLE) {
                            using (var tmpLockObj2 = new LockAndElevate(this.GroupFlagsLock)) {
                                if ((this.flags & G_WEDGED) != 0) {
                                    this.Wedged.Release();
                                    this.flags &= ~G_WEDGED;
                                }
                            }
                        }
                    }
                    while ((vds = nextvds) != null);
                }

                List<Address> ripdup = new List<Address>();
                using (var tmpLockObj = new LockAndElevate(Vsync.RIPLock)) {
                    foreach (Address rip in Vsync.RIPList) {
                        ripdup.Add(rip);
                    }
                }

                foreach (Address rip in ripdup) {
                    int rank = this.theView.GetRankOf(rip);
                    if (rank != -1) {
                        View.noteFailed(this, rip);
                    }
                }

                if ((VsyncSystem.Debug & VsyncSystem.GROUPEVENTS) != 0) {
                    Vsync.WriteLine("Done with the COMMIT message in group  " + this.gname);
                }

                if (this.theView.GetMyRank() == -1) {
                    this.GroupClose();
                }
            }));

            this.doRegister(Vsync.COMMIT, new Action<Vsync.ViewDelta[]>(vds => {
                View theView;
                using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                    theView = this.theView;
                }

                vds = vds.Select(vd => vd).Where(vd => vd.gaddr == this.gaddr && vd.prevVid >= (theView == null ? -1 : theView.viewid)).ToArray();
                if (vds.Length == 0) {
                    return;
                }

                int initialSeqn = this.curMsgId();
                if ((VsyncSystem.Debug & (VsyncSystem.GROUPEVENTS | VsyncSystem.TOKENLOGIC)) != 0) {
                    Vsync.WriteLine("Received a new LGCOMMIT message in group <" + this.gname + "> ViewDelta vector has " + vds.Length + " updates:");
                    foreach (Vsync.ViewDelta vd in vds) {
                        Vsync.WriteLine("  " + vd);
                    }
                }

                if (vds.Length > 0) {
                    this.gotNewViewDeltas(vds);
                }

                if (this.theToken != null) {
                    this.theToken.logicalClock++;
                    this.theToken.resetStableByLevel(this);
                }

                using (var tmpLockObj = new LockAndElevate(this.CommitLock)) {
                    Vsync.CommitGVUpdates(this, vds, ref theView);
                }

                foreach (Vsync.ViewDelta vd in vds) {
                    if (vd.joiners.Length > 0) {
                        if (vd.prevVid == -1) {
                            Vsync.WriteLine("Calling GetMap(" + this.gname + ", true) in Vsync.COMMIT");
                            MCMDSocket.GetMap(this.gaddr, true);
                        }

                        if (this.IAmRank0()) {
                            Address[] AllJoiners = Vsync.Expand(vd.joiners);
                            foreach (Address who in AllJoiners) {
                                byte[] ba = Msg.toBArray(Vsync.INITIALVIEW, Vsync.my_address, theView, MCMDSocket.GetMap(this.gaddr, false), initialSeqn);
                                if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.TOKENLOGIC)) != 0) {
                                    Vsync.WriteLine("LargeGroup owner for <" + this.gname + "> sending INITIALVIEW with initialSeqn=" + initialSeqn + " to " + who + "(view = " + theView + ")");
                                }

                                ReliableSender.SendP2P(Msg.ISGRPP2P, who, this, theView.viewid, ReliableSender.P2PSequencer.NextP2PSeqn("initialview/lg", who), ba, true, null, null);
                            }
                        }
                    }
                }

                Vsync.Proposed = null;
                if ((VsyncSystem.Debug & (VsyncSystem.GROUPEVENTS | VsyncSystem.TOKENLOGIC)) != 0) {
                    Vsync.WriteLine("Done with the LGCOMMIT message in group  " + this.gname);
                }
            }));

            this.doRegister(Vsync.INQUIRE, new Action<Address>(newLeader => {
                // This runs only in the ORACLE and uses a separate thread just because it sends a reply and we were worried about
                // some obscure deadlock risks involving waiting because of too many asynchronous p2p messages in the reliable sender
                // subsystem.  In fact the ORACLE only runs the leader-based 2pc/3pc protocol (this is the 1st phase message in the 3pc case
                // when a new leader takes over) and the group is otherwise "idle", so whether we use a new thread or not makes
                // no difference to event ordering
                Thread t = new Thread(() => {
                    try {
                        if ((VsyncSystem.Debug & VsyncSystem.GROUPEVENTS) != 0) {
                            Vsync.WriteLine("Received a new INQUIRE request in group  " + this.gname + "  from " + newLeader);
                        }

                        int hisRank = this.theView.GetRankOf(newLeader);
                        if (hisRank == -1) {
                            throw new VsyncException("INQUIRE from a new leader who isn't in the group (or isn't alive)!" + VsyncSystem.GetState());
                        }

                        for (int i = 0; i < hisRank - 1; i++) {
                            if (!this.theView.hasFailed[i]) {
                                Vsync.NodeHasFailed(this.theView.members[i], "(from INQUIRE)", true);
                            }
                        }

                        Vsync.ViewDelta[] proposed = Vsync.Proposed ?? new Vsync.ViewDelta[0];
                        if ((VsyncSystem.Debug & VsyncSystem.GROUPEVENTS) != 0) {
                            Vsync.WriteLine("Reply to INQUIRE request in group  " + this.gname + "  with " + proposed.Length + " events");
                        }

                        this.doReply(Vsync.my_address, Vsync.ORACLE.theView.members[0], proposed);
                    }
                    catch (VsyncShutdownException) {
                        VsyncSystem.CheckLocksHeld();
                    }

                    VsyncSystem.ThreadTerminationMagic();
                }) { Name = "Receive INQUIRE about existing known view updates", IsBackground = true };
                this.SetReplyThread(t);
                t.Start();
            }));

            this.doRegister(Vsync.INITIALVIEW, new Action<Address, string[], Address[], long[], View[], bool[], int, int[,], Address[]>((sender, names, gaddrs, tsigs, vs, isl, curPhysIPA, mms, CBMs) => {
                VsyncSystem.VsyncRestarting = false;
                if ((VsyncSystem.Debug & (VsyncSystem.GROUPEVENTS | VsyncSystem.STARTSEQ | VsyncSystem.MCMDMAP)) != 0) {
                    Vsync.WriteLine("Received a new ORACLE-member INITIALVIEW event in group " + this.gname + ", Vsync.ClientOf is " + (Vsync.ClientOf == null ? "null" : "non-null (" + Vsync.ClientOf + ")")
                        + ", CanBeOracleList=" + Address.VectorToString(CBMs));
                    for (int i = 0; i < names.Length; i++) {
                        Vsync.WriteLine("   .... <" + names[i] + ">: " + (isl[i] ? "(long) " : string.Empty) + gaddrs[i] + ", View=" + vs[i]);
                    }

                    Vsync.WriteLine("New ORACLE-member initial MCMD Mapping information:");
                    for (int i = 0; i < mms.GetLength(0); i++) {
                        Vsync.WriteLine("    Map virtual address " + MCMDSocket.PMCAddr(mms[i, MCMDSocket.VIRTUAL]) + " to " + MCMDSocket.PMCAddr(mms[i, MCMDSocket.PHYSICAL]));
                    }
                }

                if (Vsync.ClientOf != null) {
                    throw new VsyncException("ORACLE initial-view event unexpected when in client-of mode");
                }

                using (var tmpLockObj = new LockAndElevate(Vsync.CanBeOracleListLock)) {
                    foreach (Address a in CBMs) {
                        Vsync.CanBeOracleList.Add(a);
                    }
                }

                MCMDSocket.nextPhysIPAddr = curPhysIPA;
                for (int i = 0; i < names.Length; i++) {
                    if (names[i].Equals("ORACLE", StringComparison.Ordinal)) {
                        Group g = Vsync.ORACLE;
                        Vsync.LeaderId = vs[i].leaderId;
                        if (!g.HasFirstView || g.theView.viewid < vs[i].viewid) {
                            g.NewView(vs[i], "ORACLE", new[] { mms[i, MCMDSocket.VIRTUAL], mms[i, MCMDSocket.PHYSICAL] });
                            g.ReplayToDo();
                        }

                        if (g.theView.GetRankOf(Vsync.my_address) == -1) {
                            throw new VsyncException("ORACLE initial-view GROUP LIST: oracle didn't list me" + Environment.NewLine + VsyncSystem.GetState());
                        }
                    }
                    else {
                        Group tpg = Group.TrackingProxyLookup(gaddrs[i]) ?? Group.TrackingProxy(names[i], "INITIALVIEW[]", gaddrs[i], tsigs[i], null, vs[i], isl[i] ? G_ISLARGE : 0, false);
                        if (tpg != null && (!tpg.HasFirstView || tpg.theView.members.Length == 0 || tpg.theView.viewid <= vs[i].viewid)) {
                            tpg.NewView(vs[i], "view[] initializer", new[] { mms[i, MCMDSocket.VIRTUAL], mms[i, MCMDSocket.PHYSICAL] });
                        }

                        if (!tpg.hasPhysMapping && mms[i, MCMDSocket.PHYSICAL] != MCMDSocket.UNKNOWN) {
                            tpg.hasPhysMapping = true;
                            MCMDSocket.SetMap("ORACLE initializer", tpg.gname, true, new[] { mms[i, MCMDSocket.VIRTUAL], mms[i, MCMDSocket.PHYSICAL] });
                        }
                    }
                }

                MCMDSocket.AssignMapInfo(mms);
                if ((VsyncSystem.Debug & (VsyncSystem.GROUPEVENTS | VsyncSystem.STARTSEQ | VsyncSystem.MCMDMAP)) != 0) {
                    Vsync.WriteLine("Finished in ORACLE-member Vsync.INITIALVIEW: my state is " + VsyncSystem.GetState());
                }
            }));

            this.doRegister(Vsync.INITIALVIEW, new Action<Address, View, int[], int>(this.AcceptInitialView));

            this.doRegister(Vsync.INITIALVIEW, new Action<Address, string, int[], int>((sender, OOBFname, mm, initialseqn) => {
                if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                    Vsync.WriteLine("INITIALVIEW via OOB: calling OOBFetch for <" + OOBFname + ">");
                }

                new Thread(() => {
                    MemoryMappedFile mmf = this.OOBFetch(OOBFname);
                    if (mmf != null) {
                        MemoryMappedViewAccessor mmva = mmf.CreateViewAccessor();
                        byte[] ba = new byte[mmva.Capacity];
                        mmva.ReadArray(0, ba, 0, (int)mmva.Capacity);
                        this.AcceptInitialView(sender, new View(ba), mm, initialseqn);
                        if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                            Vsync.WriteLine("INITIALVIEW via OOB: after accepting initial view for <" + OOBFname + ">");
                        }
                    }
                    else {
                        throw new VsyncException("OOBFetch failed for " + OOBFname);
                    }
                }) { Name = "Fetch INITIALVIEW", IsBackground = true }.Start();
            }));

            this.doRegister(Vsync.JOINFAILED, new Action<Address, string>((gaddr, reason) => {
                Group g = Group.doLookup(gaddr);
                g.joinFailed = true;
                g.reason = reason;
                ILock.Barrier(ILock.LLINITV, gaddr).BarrierReleaseAll();
            }));

            this.doRegister(Vsync.INITIALVIEW, new Action<Address>(sender => {
                if ((VsyncSystem.Debug & (VsyncSystem.GROUPEVENTS | VsyncSystem.STARTSEQ)) != 0) {
                    Vsync.WriteLine("Received a new client-of INITIALVIEW event in group " + this.gname + ", and Vsync.ClientOf is " + (Vsync.ClientOf == null ? "null" : "non-null (" + Vsync.ClientOf + ")") + " and <ORACLE>=" + Vsync.ORACLE);
                }

                if (sender.isMyAddress()) {
                    throw new VsyncException("Client-of myself!" + Environment.NewLine + VsyncSystem.GetState());
                }

                if (Vsync.ORACLE.theView != null && Vsync.ORACLE.theView.GetMyRank() != -1) {
                    Vsync.WriteLine("ORACLE owner told me to be a client, then changed his mind (WARNING only)");
                    return;
                }

                VsyncSystem.VsyncRestarting = false;
                Group g;
                if ((g = Group.doLookup("ORACLE")) != null && g.HasFirstView) {
                    g.Leave();
                }
                else if (g != null) {
                    g.GroupClose();
                }

                Vsync.ClientOf = sender;
                Vsync.OracleFailedAt = 0;
                Vsync.ORACLE = TrackingProxy("ORACLE", "Client-Of initializer", Vsync.ORACLE.gaddr, 0, null, new View("ORACLE", Vsync.ORACLE.gaddr, new[] { sender }, 0, (this.flags & G_ISLARGE) != 0), this.flags, false);
                ILock.Barrier(ILock.LLWAIT, ILock.LCLIENTOF).BarrierRelease(1);
                if ((VsyncSystem.Debug & VsyncSystem.STARTSEQ) != 0) {
                    Vsync.WriteLine("Finished in Vsync.INITIALVIEW (client-of case): my state is " + VsyncSystem.GetState());
                }
            }));

            this.doRegister(Vsync.STATEXFER, new Action(() => {
                if ((VsyncSystem.Debug & VsyncSystem.GROUPEVENTS) != 0) {
                    Vsync.WriteLine("Received end-of-statexfer (EndXFER) in group " + this.gname);
                }

                this.EndStateXfer();
            }));

            this.doRegister(Vsync.CRYPTOWRAPPED, new Action<byte[]>(ciphered => {
                // A crypto-wrapped message is a p2p message with an enciphered body.  Decrypt it, then redeliver using the "true" body
                if (this.myAes == null) {
                    throw new VsyncException("Received an enciphered object but this group member didn't know the key!");
                }

                byte[] buffer = this.decipherBuf(ciphered);
                if (buffer != null && buffer.Length > 0) {
                    this.Redeliver(buffer);
                }
                else {
                    using (var tmpLockObj = new LockAndElevate(this.GroupFlagsLock)) {
                        if ((this.flags & G_NEEDSTATEXFER) != 0) {
                            this.EndStateXfer();
                        }
                    }
                }
            }));
            this.doRegister(Vsync.CLIENTWRAPPED, new Action<string, int, byte[]>((gname, rcode, clientreq) => {
                // A client-wrapped message is one sent from the Vsync "Client of a group" API; it arrives in Vsync.VSYNCMEMBERS but needs to be redelivered in the
                // actual target group, which involves moving the true "reply-to" message from VSYNCMEMBERS to the target group, and also getting the redeliver API
                // to check for redelivery information on the redelivery queue of VSYNCMEMBERS rather than the one associated with the target group
                Group g = Group.Lookup(gname);
                if (g != null) {
                    Msg rmsg = this.getReplyToAndClear();
                    if (rmsg != null) {
                        rmsg.gaddr = this.gaddr;
                        g.setReplyTo(rmsg);
                    }

                    if (g.allowsClientRequests[rcode + Vsync.SYSTEMREQS]) {
                        g.Redeliver(clientreq, this.rdiLock, this.rdiList);
                    }
                    else {
                        g.AbortReply("Group has not enabled client requests to request code " + rcode + " (did you forget to call g.AllowClientRequests?)");
                    }
                }
                else {
                    this.AbortReply("Group <" + gname + "> not found");
                }
            }));

            this.doRegister(Vsync.FRAGMENT, new Action<Address, int, long, int, int, byte, byte[]>((sender, fid, tl, nf, fn, fflags, frag) => deFragGotFrag(this, sender, fid, tl, nf, fn, fflags, frag)));

            this.doRegister(Vsync.REMAP, new Action<int, MCMDSocket.GRPair[]>((id, grps) => {
                if ((VsyncSystem.Debug & VsyncSystem.MCMDMAP) != 0) {
                    Vsync.WriteLine("Recomputing MCMD Mapping!");
                }

                MCMDSocket.ComputeMCMDMapping(id, grps);
            }));

            this.doRegister(Vsync.REMAP, new Action<int, int, int[,]>((epochId, nip, ma) => {
                MCMDSocket.nextPhysIPAddr = nip;
                Vsync.MapperEpochId = Math.Max(Vsync.MapperEpochId, epochId + 1);
                MCMDSocket.ReMap(epochId, ma);
            }));

            this.doRegister(Vsync.REMAP, new Action<int[,]>(ma => {
                using (var tmpLockObj = new LockAndElevate(Group.VsyncGroupsLock)) {
                    foreach (KeyValuePair<Address, Group> kvp in VsyncGroups) {
                        Group g = kvp.Value;
                        int virtIPAddr = g.myVirtIPAddr;
                        if (virtIPAddr == MCMDSocket.UNKNOWN) {
                            virtIPAddr = g.myVirtIPAddr = Vsync.CLASSD + Vsync.VSYNC_MCRANGE_LOW + Address.GroupNameHash(g.gname);
                        }

                        if (g.myPhysIPAddr == MCMDSocket.UNKNOWN) {
                            for (int i = 0; i < ma.GetLength(0); i++) {
                                if (ma[i, MCMDSocket.VIRTUAL] == virtIPAddr) {
                                    g.myVirtIPAddr = virtIPAddr;
                                    g.myPhysIPAddr = ma[i, MCMDSocket.PHYSICAL];
                                }
                            }
                        }
                    }
                }
            }));

            this.doRegister(Vsync.TERMINATE, new Action(() => {
                if ((VsyncSystem.Debug & VsyncSystem.GROUPEVENTS) != 0) {
                    Vsync.WriteLine("Group <" + this.gname + "> received TERMINATE event" + VsyncSystem.GetState());
                }

                if ((this.flags & G_ISLARGE) != 0 && !this.TermSent && this.IAmLeader()) {
                    this.TermSent = true;
                    this.doSendNotFromOracle(Vsync.TERMINATE);
                }

                this.GroupClose();
            }));

            this.doRegister(Vsync.TERMINATE, new Action<Address>(obj => {
                this.PrepareForTermination();
                this.doNullReply();
            }));

            this.doRegister(Vsync.FANNOUNCE, new Action<Address>(which => {
                ReliableSender.NodeHasFailed(which);
                GroupNoteFailure(this, which);
            }));

            this.doRegister(Vsync.OUTOFBAND, new Action<string, Address, long, List<Address>>(this.doOOBUpdateRegistry));

            this.doRegister(Vsync.OUTOFBAND, new Action<List<OOBRepInfo>>(this.doOOBUpdateRegistry));

            this.doRegister(Vsync.OUTOFBAND, new Action<string, long, long, byte[], bool>(doOOBGotChunk));

            this.doRegister(Vsync.OUTOFBAND, new Action(doOOBSetupTCPListener));

            this.doRegister(Vsync.OUTOFBAND, new Action<string, string, Address, int, long, List<IPAddress>, Address, Address[], int[], int>(this.doOOBPrepare));

            this.doRegister(Vsync.OUTOFBAND, new Action<string, int>(this.doReportChunkStatus));

            this.doRegister(Vsync.OUTOFBAND, new Action<string>(this.doOOBDone));

            this.doRegister(Vsync.OUTOFBAND, new Action<string, bool>(this.doOOBDone));

            this.doRegister(Vsync.OUTOFBAND, new Action<IPAddress, string>((ipa, fname) => { this.reportWhenXferDone(ipa, fname); }));

            this.doRegister(Vsync.CAUSALSEND, new Action<int, int[], Msg>((vid, theVT, theMsg) => {
                View theView;
                using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                    theView = this.theView;
                }

                if (vid != theView.viewid) {
                    // If CausalSend shows up in a different view than the one in which it was sent, the prior messages will
                    // have been delivered by virtue of the group flush protocol having run to completion during the view change
                    this.incomingSends.put(new Msg(theMsg));
                    return;
                }

                Msg cm = this.curMsg();
                if (cm == null) {
                    throw new VsyncException("CausalSend: curMsg null");
                }

                int senderRank = theView.GetRankOf(cm.sender);
                if ((VsyncSystem.Debug & VsyncSystem.CAUSALDELIVERY) != 0) {
                    Vsync.WriteLine("Got new CausalSend with viewid=" + vid + ", VT=" + VTtoString(theVT) + " from sender with rank " + senderRank + ", my VT=" + VTtoString(theView.myVT));
                }

                List<ctuple> newCList = new List<ctuple>();
                List<ctuple> toDeliver = new List<ctuple>();
                ctuple myCT = new ctuple(senderRank, theVT, theMsg);
                using (var tmpLockObj = new LockAndElevate(this.CausalOrderListLock)) {
                    bool inserted = false;
                    foreach (ctuple ct in this.CausalOrderList) {
                        if (myCT != null && this.happensBefore(theVT, ct.theVT)) {
                            inserted = true;
                            newCList.Add(myCT);
                            myCT = null;
                        }

                        newCList.Add(ct);
                    }

                    if (!inserted) {
                        newCList.Add(myCT);
                    }

                    this.CausalOrderList = newCList;
                    this.CausalOrderListCount = this.CausalOrderList.Count;
                    bool fnd;
                    do {
                        fnd = false;
                        List<ctuple> oldClist = this.CausalOrderList;
                        this.CausalOrderList = new List<ctuple>();
                        this.CausalOrderListCount = 0;
                        foreach (ctuple ct in oldClist) {
                            if (this.isDeliverable(ct.senderRank, ct.theVT)) {
                                fnd = true;
                                if ((VsyncSystem.Debug & VsyncSystem.CAUSALDELIVERY) != 0) {
                                    Vsync.WriteLine("Causal delivery with viewid=" + theView.viewid + ", VT=" + VTtoString(ct.theVT) + " of " + ct.theMsg + ", my VT=" + VTtoString(theView.myVT));
                                }

                                toDeliver.Add(ct);
                            }
                            else {
                                this.CausalOrderList.Add(ct);
                                this.CausalOrderListCount++;
                            }
                        }
                    }
                    while (fnd);
                }

                bool dme = false;
                foreach (ctuple ct in toDeliver) {
                    if (ct == myCT) {
                        dme = true;
                    }

                    this.incomingSends.put(new Msg(ct.theMsg));
                }

                if (!dme && (VsyncSystem.Debug & VsyncSystem.CAUSALDELIVERY) != 0) {
                    Vsync.WriteLine("Needed to delay CausalSend with viewid=" + vid + ", VT=" + VTtoString(theVT) + " from sender with rank " + senderRank + ", my VT=" + VTtoString(theView.myVT));
                }
            }));

            this.doRegister(Vsync.ORDEREDSEND, new Action<Msg>(theMsg => {
                this.receivedOrderedSends = true;
                if ((VsyncSystem.Debug & VsyncSystem.ORDEREDSEND) != 0) {
                    Vsync.WriteLine("Vsync.ORDEREDSEND[" + this.curMsg().sender + "::" + this.curMsg().vid + ":" + this.curMsg().msgid + "]: Request to establish ordering for  " + theMsg.sender + "::" + theMsg.vid + ":" + theMsg.msgid);
                }

                using (var tmpLockObj = new LockAndElevate(this.OutOfOrderQueueLock)) {
                    this.OutOfOrderQueue.Add(theMsg);
                    ++this.OutOfOrderQueueCount;
                }

                if (this.theView.IAmRank0() && !this.onDOQ(theMsg) && (this.flags & G_WEDGED) == 0) {
                    Address[] senders;
                    int[] vids, msgids;
                    this.GenerateOrdering(out senders, out vids, out msgids, false);

                    // By using Send instead of doSend, this code deliberately allows the Send to be blocked if the group
                    // is wedged for a membership change (doSend ignores that kind of wedging).  In such cases upon receipt,
                    // the corresponding message will already have been delivered. But this also forces creation of a new task
                    // to avoid blocking the group's multicast delivery thread
                    if ((VsyncSystem.Debug & VsyncSystem.ORDEREDSEND) != 0) {
                        Vsync.WriteLine("Vsync.ORDEREDSEND: GeneratedOrdering<" + this.gname + ">=" + this.OrderToString(senders, vids, msgids));
                    }

                    if (senders.Length > 0) {
                        this.NonFlowControlledSend(Vsync.SETORDER, Vsync.my_address, senders, vids, msgids);
                    }
                }
                else {
                    // This may be what we were waiting for, deliver whatever we now can deliver without a new SETORDER
                    this.DeliverInOrder("Vsync.ORDEREDSEND(nulls)", new Address[0], new int[0], new int[0]);
                }
            }));

            // These versions are for the Ordered subset multicast.
            this.doRegister(Vsync.ORDEREDSEND, new Action<List<Address>, long, Msg>((dests, hisTS, m) => {
                osspq opq;
                if ((VsyncSystem.Debug & VsyncSystem.ORDEREDSEND) != 0) {
                    Vsync.WriteLine("ORDEREDSEND==> Got dests=" + Address.VectorToString(dests.ToArray()) + ", id=" + m.sender + "::" + m.vid + ":" + m.msgid + ", m=" + m);
                }

                using (var tmpLockObj = new LockAndElevate(this.OrderedSubsetListLock)) {
                    if (hisTS > this.myTS) {
                        this.myTS = hisTS;
                    }

                    opq = new osspq(++this.myTS, Vsync.my_address, dests, m.sender, m.vid, m.msgid);
                    this.OrderedSubsetPQ.Add(opq, m);
                    ++this.OrderedSubsetPQCount;
                }

                if ((VsyncSystem.Debug & VsyncSystem.ORDEREDSEND) != 0) {
                    Vsync.WriteLine("ORDEREDSEND==> doReply(" + opq.proposedTS + "::" + opq.proposedWho + ")");
                }

                this.doReply(opq.proposedTS, opq.proposedWho);
            }));

            // Learned the commit time.  No need for locks: this runs only on the P2P delivery thread
            this.doRegister(Vsync.ORDEREDSEND, new Action<Address, int, int, long, Address>((sentBy, vid, msgid, cts, ctwho) => {
                if ((VsyncSystem.Debug & VsyncSystem.ORDEREDSEND) != 0) {
                    Vsync.WriteLine("ORDEREDSEND==>COMMIT (" + sentBy + "::" + vid + ":" + msgid + ") at (" + cts + "::" + ctwho + ")");
                }

                this.opqDeliver(sentBy, vid, msgid, cts, ctwho);
            }));

            this.doRegister(Vsync.ORDEREDSEND, new Action<List<osspq>>(recentOpqNds => {
                if ((VsyncSystem.Debug & VsyncSystem.ORDEREDSEND) != 0) {
                    foreach (osspq opq in recentOpqNds) {
                        Vsync.WriteLine("ORDEREDSEND==>COMMIT (" + opq.sender + "::" + opq.vid + ":" + opq.msgid + ") at (" + opq.proposedTS + "::" + opq.proposedWho + ")");
                    }

                    Vsync.WriteLine("ORDEREDSEND==>got flush finalizer containing");
                }

                foreach (osspq opq in recentOpqNds) {
                    this.opqDeliver(opq.sender, opq.vid, opq.msgid, opq.proposedTS, opq.proposedWho);
                }
            }));

            this.FlushHandlers += view => {
                Dictionary<Address, List<osspq>> toSend = new Dictionary<Address, List<osspq>>(100);
                using (var tmpLockObj = new LockAndElevate(this.RecentOpqNodesLock)) {
                    foreach (osspq opq in this.RecentOpqNodes) {
                        if (!opq.cflag) {
                            throw new VsyncException("Found an uncommitted opq node on the RecentOpqNodes list");
                        }

                        List<osspq> theList;
                        if (!toSend.TryGetValue(opq.sender, out theList)) {
                            toSend.Add(opq.sender, new List<osspq> { opq });
                        }
                        else {
                            theList.Add(opq);
                        }
                    }
                }

                foreach (KeyValuePair<Address, List<osspq>> kvp in toSend) {
                    this.P2PSend(kvp.Key, Vsync.ORDEREDSEND, kvp.Value);
                }

                this.Flush();
            };

            this.doRegister(Vsync.SETORDER, new Action<Address, Address[], int[], int[]>((orderedBy, senders, vids, msgids) => {
                if ((VsyncSystem.Debug & VsyncSystem.ORDEREDSEND) != 0) {
                    Msg theMsg = this.curMsg();
                    Vsync.WriteLine("Vsync.SETORDER: Received " + theMsg.sender + "::" + theMsg.vid + ":" + theMsg.msgid + ", containing " + this.OrderToString(senders, vids, msgids));
                }

                this.DeliverInOrder("Vsync.SETORDER", senders, vids, msgids);
            }));

            this.doRegister(Vsync.SAFESEND, new Action<Address, int, Msg>((sender, Uid, sMsg) => {
                int myTS;
                using (var tmpLockObj = new LockAndElevate(this.SSLock)) {
                    myTS = ++this.logicalTS;
                    this.SSList.Add(new SUTW(sender, Uid, myTS, Vsync.my_address), sMsg);
                }

                if ((VsyncSystem.Debug & VsyncSystem.SAFESEND) != 0) {
                    Vsync.WriteLine("Vsync.SAFESEND: Got " + sender + "::" + Uid + " for pending message " + sMsg.sender + "::" + sMsg.vid + ":" + sMsg.msgid + ", my proposal: " + Vsync.my_address + "::" + myTS);
                }

                if (this.durabilityMethod != null) {
                    sMsg.ct = this.durabilityMethod.LogMsg(sMsg);
                }

                if (this.safeSendThreshold == ALL || this.theView.GetMyRank() < this.safeSendThreshold) {
                    this.doReply(myTS, Vsync.my_address);
                }
                else {
                    this.NoReply();
                }
            }));

            this.doRegister(Vsync.SAFEDELIVER, new Action<Address, int, int, Address>((sender, Uid, TS, who) => {
                if ((VsyncSystem.Debug & VsyncSystem.SAFESEND) != 0) {
                    Vsync.WriteLine("Vsync.SAFEDELIVER: Got final TS " + who + "::" + TS + " for pending message " + sender + "::" + Uid);
                }

                bool fnd = false;
                using (var tmpLockObj = new LockAndElevate(this.SSLock)) {
                    foreach (KeyValuePair<SUTW, Msg> kvp in this.SSList) {
                        SUTW suw = kvp.Key;
                        Msg sMsg = kvp.Value;
                        if (suw.Sender == sender && suw.Uid == Uid) {
                            this.SSList.Remove(suw);
                            suw.TS = TS;
                            suw.Who = who;
                            suw.commitFlag = true;
                            this.SSList.Add(suw, sMsg);
                            if (TS > this.logicalTS) {
                                this.logicalTS = TS;
                            }

                            fnd = true;
                            break;
                        }
                    }

                    if (fnd) {
                        this.deliverSSItems();
                    }
                }
            }));

            this.doRegister(Vsync.LOCKREQ, new Action<int, string, Address, int, int>((action, lockName, who, cntr, locktype) => {
                LockInfo lstate;
                bool grantIt = false;
                bool cancelIt = false;
                using (var tmpLockObj = new LockAndElevate(this.LocksListLock)) {
                    if (!this.LocksList.TryGetValue(lockName, out lstate)) {
                        lstate = new LockInfo(lockName);
                        this.LocksList[lockName] = lstate;
                    }

                    Msg cm = this.curMsg();
                    string minfo = "[" + (cm == null ? "<<null msg>>" : (cm.sender + "::" + cm.vid + ":" + cm.msgid)) + "]";
                    if (cm.vid != this.lockCurrentViewid) {
                        throw new VsyncException(minfo + ": ERROR in LOCKREQ -- message has vid " + cm.vid + ", but LockViewId = " + this.lockCurrentViewid);
                    }

                    switch (action) {
                        case LOCKIT:
                            if ((VsyncSystem.Debug & VsyncSystem.LOCKS) != 0) {
                                Vsync.WriteLine(minfo + "; LOCKIT<" + (cntr / 10000) + "." + (cntr % 1000) + ">: " + lockName + ", who=" + who);
                            }

                            LockReq lr = new LockReq(who, locktype);
                            foreach (LockReq wl in lstate.wantLock) {
                                if (wl.who == who) {
                                    // Only one request is permitted at a time
                                    if ((VsyncSystem.Debug & VsyncSystem.LOCKS) != 0) {
                                        Vsync.WriteLine("Only a single Lock request is permitted at a time.  Ignoring request " + who + "::" + ltype[locktype]);
                                    }

                                    break;
                                }
                            }

                            lstate.wantLock.Add(lr);
                            if (!lstate.islocked || (lstate.locktype == READLOCK && lr.how == READLOCK)) {
                                grantIt = true;
                            }

                            break;
                        case RELEASEIT:
                            if ((VsyncSystem.Debug & VsyncSystem.LOCKS) != 0) {
                                Vsync.WriteLine(minfo + "; RELEASEIT<" + (cntr / 10000) + "." + (cntr % 1000) + ">: " + lockName + ", who=" + who);
                            }

                            if (!lstate.holders.Contains(who)) {
                                throw new VsyncException("Locking package exception: RELEASE by " + who + " of " + lockName + (lstate.islocked ? (" held by " + Address.VectorToString(lstate.holders.ToArray())) : " but it wasn't locked"));
                            }

                            lstate.holders.Remove(who);
                            if (lstate.holders.Count == 0) {
                                lstate.islocked = false;
                                grantIt = true;
                            }
                            break;
                        case CANCEL:
                            if ((VsyncSystem.Debug & VsyncSystem.LOCKS) != 0) {
                                Vsync.WriteLine(minfo + "; CANCEL<" + (cntr / 10000) + "." + (cntr % 1000) + ">: " + lockName + ", who=" + who);
                            }

                            foreach (LockReq wl in lstate.wantLock) {
                                if (wl.who == who) {
                                    cancelIt = true;
                                    lstate.wantLock.Remove(wl);
                                    break;
                                }
                            }

                            break;
                    }
                }

                if (grantIt && lstate.wantLock.Count > 0) {
                    this.GrantLock(lockName, lstate);
                }
                else if (cancelIt) {
                    this.CancelLockRequest(lockName, who, lstate);
                }
            }));

            this.doRegister(Vsync.SGAGGREGATE, new Action<Address, bool, int, int, byte[]>((from, fromBelow, level, vid, ba) => {
                object[] objs = Msg.BArrayToObjects(ba);
                object key = objs[0];
                object value = objs[1];
                int thevid;
                int lcnt = 0;
                do {
                    if (lcnt++ > 0) {
                        // The issue here is that when a new view is delivered it takes time to reinitialize the aggregation structures and to
                        // unwind existing aggregation waits and meanwhile, an early SGAGGREGATE message could sneak through.  This clumsy 
                        // mechanism will wait as much as 10 secs for that to finish.
                        Vsync.Sleep(1000);
                    }

                    using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                        thevid = this.theView.viewid;
                    }
                }
                while (vid > thevid && lcnt < 10);
                if (vid > thevid) {
                    throw new VsyncException("SAGGREGATE: received a p2p message for view " + vid + " but I seem to be stuck in view " + thevid);
                }

                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                    Vsync.WriteLine("SGAGGREGATE from " + from + ": level=" + level + ", " + (fromBelow ? "DValue" : "RValue") + ", vid=" + vid + " (current vid " + thevid + "), key=" + key + ", value=" + value);
                }

                IAggregateEventHandler callme = null;
                using (var tmpLockObj = new LockAndElevate(this.AggListLock)) {
                    if (level > this.AggList.Length) {
                        return;
                    }

                    foreach (IAggregateEventHandler iae in this.AggList[level]) {
                        if (iae.GetKeyType() == key.GetType() && iae.GetValueType() == value.GetType()) {
                            callme = iae;
                            break;
                        }
                    }
                }

                if (callme != null) {
                    callme.GotSGAggInfo(fromBelow, level, vid, key, value);
                }
                else if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                    Vsync.WriteLine("SGAGGREGATE: WARNING.... couldn't find the callback handler");
                }
            }));

            this.RegisterMakeChkpt(view => {
                if (!this.LockingInUse) {
                    return;
                }

                string[] lnames, wnames = null;
                LockInfo[] linfo = null;
                LockReq[] reqs = null;
                using (var tmpLockObj = new LockAndElevate(this.LocksListLock)) {
                    lnames = this.LocksList.Keys.ToArray();
                    if (lnames != null) {
                        linfo = this.LocksList.Values.ToArray();
                        int wcnt = 0;
                        foreach (LockInfo li in linfo) {
                            wcnt += li.wantLock.Count;
                        }

                        wnames = new string[wcnt];
                        reqs = new LockReq[wcnt];
                        wcnt = 0;
                        foreach (LockInfo li in linfo) {
                            foreach (LockReq a in li.wantLock) {
                                wnames[wcnt] = li.name;
                                reqs[wcnt++] = a;
                            }
                        }
                    }
                }

                if ((VsyncSystem.Debug & VsyncSystem.LOCKS) != 0) {
                    Vsync.WriteLine("Sending lock state<" + this.gname + ">:" + Environment.NewLine + this.GetLockState());
                }

                if (lnames != null) {
                    this.SendChkpt(lnames, linfo, wnames, reqs);
                }
            });

            this.RegisterLoadChkpt(new Action<string[], LockInfo[], string[], LockReq[]>((keys, linfo, names, reqs) => {
                this.LockingInUse = true;
                using (var tmpLockObj = new LockAndElevate(this.LocksListLock)) {
                    for (int n = 0; n < keys.Length; n++) {
                        this.LocksList[keys[n]] = linfo[n];
                    }

                    for (int n = 0; n < names.Length; n++) {
                        this.LocksList[names[n]].wantLock.Add(reqs[n]);
                    }
                }

                if ((VsyncSystem.Debug & VsyncSystem.LOCKS) != 0) {
                    Vsync.WriteLine("After loading lock state<" + this.gname + ">:" + Environment.NewLine + this.GetLockState());
                }
            }));

            // This client-of-a-group to group-representative relaying logic
            this.doRegister(Vsync.RELAYSEND, new Action<Msg>(m => {
                if ((VsyncSystem.Debug & VsyncSystem.RELAYLOGIC) != 0) {
                    Vsync.WriteLine("Group owner relaying multicast(" + m + ")");
                }

                this.doSend(false, false, Vsync.RELAYSEND, Vsync.my_address, new Msg(m));
            }));

            this.doRegister(Vsync.RELAYSEND, new Action<Address, Msg>((leader, m) => {
                // Runs in all the members
                if ((VsyncSystem.Debug & VsyncSystem.RELAYLOGIC) != 0) {
                    Vsync.WriteLine("Large Group owner delivering relayed multicast(" + m + ")");
                }

                List<Msg> newRelayedLGSends = new List<Msg>();
                using (var tmpLockObj = new LockAndElevate(this.RelayedLGSendsLock)) {
                    foreach (Msg rm in this.RelayedLGSends) {
                        if (rm != m && rm.vid != -1 && rm.msgid != -1) {
                            newRelayedLGSends.Add(rm);
                        }
                    }

                    this.RelayedLGSends = newRelayedLGSends;
                }

                if ((VsyncSystem.Debug & VsyncSystem.DELIVERY) != 0) {
                    Vsync.WriteLine("<" + this.gname + ">: UnpackAndDeliver delivering " + m);
                }

                this.doDeliveryCallbacks(m, "from UnpackAndDeliver (for relayed large-group sends)", Msg.MULTICAST);
            }));

            if ((this.flags & G_ISLARGE) != 0) {
                this.RegisterViewHandler(view => {
                    tokenInfo theToken;
                    using (var tmpLockObj = new LockAndElevate(this.TokenLock)) {
                        theToken = this.theToken;
                    }

                    if (theToken != null) {
                        if (this.prevLGOwner != null && theToken.groupOwner == this.prevLGOwner) {
                            return;
                        }

                        this.prevLGOwner = theToken.groupOwner;
                        List<Msg> LGResendList = new List<Msg>();
                        using (var tmpLockObj = new LockAndElevate(this.RelayedLGSendsLock)) {
                            foreach (Msg rm in this.RelayedLGSends) {
                                LGResendList.Add(rm);
                            }
                        }

                        foreach (Msg m in LGResendList) {
                            this.P2PSend(theToken.groupOwner, Vsync.RELAYSEND, m);
                        }
                    }
                });
            }

            this.ViewHandlers += this.LockNewView;

            this.groupP2PReaderThread = new Thread(() => {
                try {
                    this.isP2PThread = true;
                    this.doDelivery(this.incomingP2P, "incomingP2P");
                }
                catch (VsyncShutdownException) {
                    VsyncSystem.CheckLocksHeld();
                }

                VsyncSystem.ThreadTerminationMagic();
            }) { Name = "<" + this.gname + "> incoming p2p delivery thread", IsBackground = true };
            this.groupP2PReaderThread.Start();

            this.groupIPMCReaderThread = new Thread(() => {
                try {
                    this.doDelivery(this.incomingSends, "incomingSends");
                }
                catch (VsyncShutdownException) {
                    VsyncSystem.CheckLocksHeld();
                }

                VsyncSystem.ThreadTerminationMagic();
            }) { Name = "<" + this.gname + "> incoming multicasts delivery thread", IsBackground = true };
            this.groupIPMCReaderThread.Start();
        }

        private void AcceptInitialView(Address sender, View theView, int[] mm, int initialSeqn) {
            if (this.HasFirstView) {
                return;
            }

            VsyncSystem.VsyncRestarting = false;
            if ((this.flags & G_ISLARGE) != 0) {
                theView.NextIncomingMsgID[1] = initialSeqn;
            }

            if (this == Vsync.VSYNCMEMBERS) {
                IPMCNewView(this.gaddr, theView);
            }

            if ((VsyncSystem.Debug & VsyncSystem.GROUPEVENTS) != 0) {
                Vsync.WriteLine("Received a new single-group INITIALVIEW event in group " + this.gname + " from " + sender + ", View " + theView + ", with initialSeqn = " + initialSeqn);
            }

            if (Vsync.WORKER_MODE) {
                this.TypeSig = TypeSignature(this);
                this.GroupOpen = true;
            }

            if (theView.viewid == 0) {
                if (this.myCheckpointFile != null && this.CheckPointFileExists()) {
                    this.LoadCheckpointFromFile();
                }
                else if (this.theInitializer != null && !this.initializationDone) {
                    this.InitializeGroup(theView);
                }

                using (var tmpLockObj = new LockAndElevate(this.GroupFlagsLock)) {
                    if ((this.flags & G_NEEDSTATEXFER) != 0) {
                        this.xferWait.Release();
                    }

                    this.flags &= ~G_NEEDSTATEXFER;
                }
            }

            if (!theView.joiners.Contains(Vsync.my_address)) {
                theView.joiners = new[] { Vsync.my_address };
            }

            this.NewView(theView, "single-view initializer", mm);
            this.TPGroupsLearnedMM(mm);
        }

        private void opqDrain() {
            this.opqDeliver(Vsync.NULLADDRESS, 0, 0, 0, Vsync.NULLADDRESS, true);
            using (var tmpLockObj = new LockAndElevate(this.OrderedSubsetListLock)) {
                this.OrderedSubsetPQ = new SortedList<osspq, Msg>();
                this.OrderedSubsetPQCount = 0;
            }

            using (var tmpLockObj = new LockAndElevate(this.RecentOpqNodesLock)) {
                this.RecentOpqNodes = new List<osspq>();
            }
        }

        private void opqDeliver(Address sentBy, int vid, int msgid, long cts, Address ctwho, bool drainOPQ = false) {
            osspq opq = null;
            Msg m = null;
            this.myTS = Math.Max(this.myTS, cts);
            List<Msg> msgs = new List<Msg>();
            List<osspq> keys = new List<osspq>();
            using (var tmpLockObj = new LockAndElevate(this.OrderedSubsetListLock)) {
                if (!sentBy.isNull()) {
                    foreach (KeyValuePair<osspq, Msg> kvp in this.OrderedSubsetPQ) {
                        if (kvp.Value.sender == sentBy && kvp.Value.vid == vid && kvp.Value.msgid == msgid) {
                            opq = kvp.Key;
                            m = kvp.Value;
                            break;
                        }
                    }

                    if (opq != null) {
                        this.OrderedSubsetPQ.Remove(opq);
                        --this.OrderedSubsetPQCount;
                        opq.commit(cts, ctwho);
                        if (!this.OrderedSubsetPQ.ContainsKey(opq)) {
                            this.OrderedSubsetPQ.Add(opq, m);
                            this.OrderedSubsetPQCount++;
                        }
                    }
                    else if ((VsyncSystem.Debug & VsyncSystem.ORDEREDSEND) != 0) {
                        Vsync.WriteLine("opqDeliver CAN'T FIND (" + sentBy + "::" + vid + ":" + msgid + ", cts=" + cts + "::" + ctwho + ")");
                    }
                }

                while (this.OrderedSubsetPQ.Count > 0 && (drainOPQ || this.OrderedSubsetPQ.ElementAt(0).Key.cflag)) {
                    KeyValuePair<osspq, Msg> first = this.OrderedSubsetPQ.ElementAt(0);
                    this.OrderedSubsetPQ.Remove(first.Key);
                    this.OrderedSubsetPQCount--;
                    if (first.Key.cflag && first.Value != null) {
                        if ((VsyncSystem.Debug & VsyncSystem.ORDEREDSEND) != 0) {
                            Vsync.WriteLine("ORDERED SUBSET CAST: " + (drainOPQ ? "[DRAIN during flush] " : string.Empty) + "Delivery of " + first.Value);
                        }

                        first.Value.type = Msg.REDELIVERY;
                        msgs.Add(first.Value);
                    }
                    else if ((VsyncSystem.Debug & (VsyncSystem.ORDEREDSEND | VsyncSystem.DISCARDS)) != 0) {
                        Vsync.WriteLine("ORDERED SUBSET CAST: " + (drainOPQ ? "[DISCARD during flush] " : string.Empty) + "Delivery of " + first.Value);
                    }

                    if (!drainOPQ) {
                        keys.Add(first.Key);
                    }
                }
            }

            foreach (Msg msg in msgs) {
                this.incomingP2P.put(msg);
            }

            using (var tmpLockObj = new LockAndElevate(this.RecentOpqNodesLock)) {
                foreach (osspq key in keys) {
                    this.RecentOpqNodes.Add(key);
                }
            }
        }

        private void InitializeGroup(View theView) {
            if (this.initializationDone) {
                return;
            }

            this.initializationDone = true;
            if (this.theInitializer != null) {
                this.theInitializer();
            }

            if (this.myCheckpointFile != null && theView.IAmLeader()) {
                this.MakeCheckpoint(theView);
            }
        }

        private string OrderToString(Address[] senders, int[] vids, int[] msgids) {
            string s = "{ ";
            for (int n = 0; n < senders.Length; n++) {
                s += senders[n] + "::" + vids[n] + ":" + msgids[n] + " ";
            }

            return s + "}";
        }

        // Caller must hold the SSLock
        private void deliverSSItems() {
            List<Msg> toDeliver = new List<Msg>();
            KeyValuePair<SUTW, Msg> ssItem;
            while ((ssItem = this.SSList.ElementAtOrDefault(0)).Value != null && ssItem.Key.commitFlag) {
                if (!this.SSList.Remove(ssItem.Key)) {
                    throw new VsyncException("SSList.Remove failed");
                }

                if (this.durabilityMethod != null) {
                    this.durabilityMethod.SetOrder(ssItem.Value);
                }

                Msg m = ssItem.Value;
                m.type = Msg.REDELIVERY;
                toDeliver.Add(m);
                if ((VsyncSystem.Debug & VsyncSystem.SAFESEND) != 0) {
                    Vsync.WriteLine("deliverSSItems: delivering " + m.sender + "::" + m.vid + ":" + m.msgid);
                }

                if (this.incomingSends.LastPushedVID != 0 && m.vid != this.incomingSends.LastPushedVID) {
                    throw new VsyncException("Msg.REDELIVERY/SAFESEND pushing " + m.sender + "::" + m.vid + ":" + m.msgid + " while incomingSends.viewid=" + this.incomingSends.LastPushedVID);
                }
            }

            this.incomingSends.putFront(toDeliver);
        }

        internal void CheckRetainedOpqINodes() {
            List<osspq> newropq = new List<osspq>();
            using (var tmpLockObj = new LockAndElevate(this.RecentOpqNodesLock)) {
                foreach (osspq opq in this.RecentOpqNodes) {
                    if (opq.gtime == 0) {
                        // This worries me; better would be a more explicit garbage collection based on
                        // tracking the completion of pending sends of the ORDEREDSEND commit times and then
                        // disseminating that information using the same background gossip mechanisms that
                        // we use to check rates.  In fact this is probably pretty safe but as a purist,
                        // it bugs me that coded in this manner, the system would potentially violate its
                        // properties if a crash disrupts sending of the ORDEREDSEND commits, and then the
                        // associated flush doesn't start "soon enough".  A further issue is that the list
                        // itself could get long.
                        opq.gtime = Vsync.NOW + 60000;
                        newropq.Add(opq);
                    }
                    else if (Vsync.NOW < opq.gtime) {
                        newropq.Add(opq);
                    }
                }

                this.RecentOpqNodes = newropq;
            }
        }

        private void EndStateXfer() {
            using (var tmpLockObj = new LockAndElevate(this.GroupFlagsLock)) {
                if ((this.flags & G_NEEDSTATEXFER) != 0) {
                    this.xferWait.Release();
                }

                this.flags &= ~G_NEEDSTATEXFER;
            }

            this.ReplayToDo();
        }

        internal static void GroupNoteFailure(Group g, Address which) {
            int r = -1;
            using (var tmpLockObj = new LockAndElevate(g.ViewLock)) {
                if (g.theView != null) {
                    r = g.theView.GetRankOf(which);
                }
            }

            if (r != -1) {
                bool doCB = false;
                using (var tmpLockObj = new LockAndElevate(Vsync.RIPLock)) {
                    if (!Vsync.RIPList.Contains(which)) {
                        Vsync.RIPList.Add(which);
                        doCB = true;
                    }
                }

                if (doCB) {
                    ILock.NoteFailed(g.gaddr, which);
                    ReliableSender.P2PSequencer.remoteFailed(which);
                    ReliableSender.AckNoteFailure(which);
                    View.noteFailed(g, which);
                    AwaitReplies.doNoteFailure(which);
                    Group.deFragNoteFailure(which);
                }
            }
        }

        // VTa happens before VTb iff
        // For all i: VTa[i] <= VTb[i]
        // For some i: VTa[i] < VTb[i]
        internal bool happensBefore(int[] VTa, int[] VTb) {
            bool rv = this._happensBefore(VTa, VTb);
            if ((VsyncSystem.Debug & VsyncSystem.CAUSALDELIVERY) != 0) {
                string vta = VTtoString(VTa);
                string vtb = VTtoString(VTb);
                Vsync.WriteLine("happensBefore(" + vta + ", " + vtb + ")=" + rv);
            }

            return rv;
        }

        private static string VTtoString(int[] VT) {
            string vt = "[ ";
            foreach (int i in VT) {
                vt += i.ToString("D3") + " ";
            }

            return vt + "]";
        }

        internal bool _happensBefore(int[] VTa, int[] VTb) {
            bool res = false;
            if (VTa.Length != VTb.Length) {
                throw new VsyncException("happensBefore: VT lengths don't match");
            }

            for (int i = 0; i < VTa.Length; i++) {
                if (VTa[i] > VTb[i]) {
                    return false;
                }

                if (VTa[i] < VTb[i]) {
                    res = true;
                }
            }

            return res;
        }

        // Incoming causal send is deliverable if next from this sender
        // and all causally prior messages have been delivered
        internal bool isDeliverable(int senderRank, int[] VT) {
            using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                if (VT.Length != this.theView.myVT.Length || (senderRank < 0 || senderRank >= this.theView.myVT.Length)) {
                    throw new VsyncException("causal send: isDeliverable fault");
                }

                // Optimistically assume delivery will be possible
                ++this.theView.myVT[senderRank];
                for (int i = 0; i < VT.Length; i++) {
                    if (VT[i] > this.theView.myVT[i]) {
                        // No luck, back out of optimistic pre-increment
                        --this.theView.myVT[senderRank];
                        return false;
                    }
                }
            }

            return true;
        }

        internal void PrepareForTermination() {
            using (var tmpLockObj = new LockAndElevate(this.quiesceLock)) {
                if ((this.flags & G_TERMINATING) != 0) {
                    return;
                }

                this.flags |= G_TERMINATING;
            }

            this.interruptLockWaits.Set();
            AwaitReplies.InterruptReplyWaits(this);
            this.InterruptAggregationWaits();
            while (this.quiesceCnt-- > 0) {
                ILock.NoteThreadState("quiesceWait.WaitOne()");
                this.quiesceWait.WaitOne();
                ILock.NoteThreadState(null);
            }
        }

        private bool warnedHim;

        internal bool VsyncCallStart() {
            if (Thread.CurrentThread != VsyncSystem.ParentThread && VsyncSystem.ParentThread != null) {
                Thread.CurrentThread.IsBackground = true;
            }

            using (var tmpLockObj = new LockAndElevate(this.quiesceLock)) {
                if ((this.flags & G_TERMINATING) != 0) {
                    if (!this.warnedHim) {
                        Vsync.WriteLine("WARNING: <" + this.gname + "> was closing/terminating but user-code attempted to issue Vsync system calls on it");
                    }

                    this.warnedHim = true;
                    return false;
                }

                ++this.quiesceCnt;
            }

            return true;
        }

        internal void VsyncCallDone() {
            using (var tmpLockObj = new LockAndElevate(this.quiesceLock)) {
                if ((this.flags & G_TERMINATING) != 0) {
                    this.quiesceWait.Release();
                }
                else {
                    --this.quiesceCnt;
                }
            }
        }

        internal void GroupClose() {
            if (this.isTrackingProxy) {
                using (var tmpLockObj = new LockAndElevate(TPGroupsLock)) {
                    TPGroups.Remove(this.gaddr);
                }

                return;
            }

            if (VsyncSystem.VsyncActive && (this.gname.Equals("VSYNCMEMBERS", StringComparison.Ordinal) || !this.GroupOpen)) {
                return;
            }

            using (var tmpLockObj = new LockAndElevate(ReliableSender.PendingSendBufferLock)) {
                this.GroupOpen = false;
                this.WasOpen = true;
            }

            if (this.durabilityMethod != null) {
                this.durabilityMethod.Shutdown();
            }

            using (var tmpLockObj = new LockAndElevate(VsyncGroupsLock)) {
                VsyncGroups.Remove(this.gaddr);
            }

            if (this.theView != null) {
                this.theView.viewid++;
                this.theView.leavers = this.theView.members;
                this.theView.members = new Address[0];
                this.theView.joiners = new Address[0];

                // This will cause IPMC delivery thread to deliver a final view and then terminate itself
                if (this.incomingSends != null) {
                    this.incomingSends.put(this.theView);
                    this.incomingSends.put(null);
                }

                if (this.incomingP2P != null) {
                    this.incomingP2P.put(this.theView);
                    this.incomingP2P.put(null);
                }
            }

            if (!this.gname.Equals("ORACLE", StringComparison.Ordinal)) {
                using (var tmpLockObj = new LockAndElevate(Group.GroupRIPLock)) {
                    if (!Group.GroupRIPList.Contains(this.gaddr)) {
                        Group.GroupRIPList.Add(this.gaddr);
                        Vsync.OnTimer(Vsync.VSYNC_DEFAULTTIMEOUT * ((this.flags & G_ISLARGE) != 0 ? 10 : 2), () => {
                            using (var tmpLockObj1 = new LockAndElevate(Group.GroupRIPLock)) {
                                Group.GroupRIPList.Remove(this.gaddr);
                            }
                        });
                    }
                }
            }

            if ((this.flags & G_ISLARGE) != 0) {
                ReliableSender.lgPendingSendCleanup(this);
            }
            else {
                ReliableSender.PendingSendCleanup(this, null);
            }

            this.xferWait.Release();
            Semaphore s = this.CPSSema;
            if (s != null) {
                s.Release(1000);
            }

            MCMDSocket.UnMap(new[] { this.gaddr });
            if (this.theView != null && this.incomingSends != null && this.groupIPMCReaderThread != Thread.CurrentThread) {
                this.groupIPMCReaderThread.Join();
            }

            if (this.theView != null && this.incomingP2P != null && this.groupP2PReaderThread != Thread.CurrentThread) {
                this.groupP2PReaderThread.Join();
            }

            fiCleanup(this.gaddr);
        }

        // Locking package
        internal int LockPackageConfig; // Overall policy control for the package

        internal const int LOCK_INTERNAL = 0; // Used purely "internally" within a group

        internal const int LOCK_EPHEMERAL_EXTERN = 1;

        // Used with some form of "external" resource but state not recovered (ephemeral) after a total failure
        internal const int LOCK_RECOVER_EXTERN = 2;

        // Used with an external resource and must be recovered after group crashes, then restarts
        internal const int LOCK_RELEASE = 0; // Lock is released if the member holding it exits.

        internal const int LOCK_TRANSFER = 1;

        // By default, if a member holding a lock crashes, the lock is retained and ownership transfers to the rank-zero member
        internal const int LOCKIT = 0; // Request to obtain a lock

        internal const int RELEASEIT = 1; // Release it to a new holder

        internal const int CANCEL = 2; // Cancel a pending request

        internal const int UNLOCK = 0;

        internal const int WRITELOCK = 1;

        internal const int READLOCK = 2;

        internal static string[] ltype = { "unlocked", "writelock", "readlock" };

        internal LockBroken DefaultCallback;

        /// <exclude></exclude>
#if PROTOCOL_BUFFERS
        [ProtoContract(SkipConstructor = true)]
#else
        [AutoMarshalled]
#endif
        public class LockReq {
            /// <exclude></exclude>
            [ProtoMember(1)]
            public Address who;

            /// <exclude></exclude>
            [ProtoMember(2)]
            public int how;

#if !PROTOCOL_BUFFERS
            /// <exclude></exclude>
            public LockReq() {
            }
#endif

            /// <exclude></exclude>
            public LockReq(Address who, int how) {
                this.who = who;
                this.how = how;
            }

            /// <exclude></exclude>
            public override string ToString() {
                return this.who + "::" + ltype[this.how];
            }
        }

        /// <exclude></exclude>
        internal sealed class LockInfo : IDisposable, ISelfMarshalled {
            internal string name;

            internal bool islocked = false;

            internal int policy;

            internal int locktype;

            // If the locktype is WRITE there will be exactly one holder 
            // For locktype READ there could be a list
            internal List<Address> holders = new List<Address>();

            internal bool requestPending = false;

            internal LockBroken Notify;

            internal List<LockReq> wantLock = new List<LockReq>();

            internal Semaphore wait = new Semaphore(0, int.MaxValue);

            public byte[] toBArray() {
                return Msg.toBArray(this.islocked, this.policy, this.holders, this.locktype);
            }

            public LockInfo(byte[] ba) {
                object[] objs = Msg.BArrayToObjects(ba, typeof(bool), typeof(int), typeof(List<Address>), typeof(int));
                int idx = 0;
                this.islocked = (bool)objs[idx++];
                this.policy = (int)objs[idx++];
                this.holders = (List<Address>)objs[idx++];
                this.locktype = (int)objs[idx];
            }

            internal LockInfo(string name) {
                this.name = name;
                this.locktype = UNLOCK;
            }

            /// <summary>
            /// To dispose of wait semaphore
            /// </summary>
            public void Dispose() {
                this.Dispose(true);
            }

            private bool disposed;

            private void Dispose(bool disposing) {
                lock (this) {
                    if (this.disposed) {
                        return;
                    }

                    this.disposed = true;
                }

                if (this.wait != null) {
                    this.wait.Dispose();
                }
            }
        }

        internal Dictionary<string, LockInfo> LocksList = new Dictionary<string, LockInfo>(100);

        internal LockObject LocksListLock = new LockObject("LocksListLock");

        internal delegate void LockDel(int action, string lockName, Address who, int counter);

        internal bool LockingInUse = false;

        internal int lockCurrentViewid;

        internal void LockNewView(View v) {
            this.lockCurrentViewid = v.viewid;
            if (v.leavers.Length == 0 || !this.LockingInUse || v.members.Length == 0) {
                return;
            }

            if ((VsyncSystem.Debug & VsyncSystem.LOCKS) != 0) {
                Vsync.WriteLine("LockNewView " + v);
            }

            List<LockInfo> toGrant = new List<LockInfo>();
            using (var tmpLockObj = new LockAndElevate(this.LocksListLock)) {
                foreach (KeyValuePair<string, LockInfo> kvp in this.LocksList) {
                    LockInfo li = kvp.Value;
                    List<LockReq> newWantLock = new List<LockReq>();
                    foreach (LockReq lr in li.wantLock) {
                        if (v.GetRankOf(lr.who) != -1) {
                            newWantLock.Add(lr);
                        }
                    }

                    li.wantLock = newWantLock;
                    if (li.islocked && li.locktype == READLOCK) {
                        // Readlocks always break if the holder fails
                        List<Address> newHolders = new List<Address>();
                        foreach (Address who in li.holders) {
                            if (v.GetRankOf(who) != -1) {
                                newHolders.Add(who);
                            }
                        }

                        li.holders = newHolders;
                        li.islocked = li.holders.Count > 0;
                    }
                    else if (li.islocked && li.locktype == WRITELOCK) {
                        // For Writelocks the policy determines the action to take
                        if (v.GetRankOf(li.holders[0]) == -1) {
                            switch (li.policy) {
                                case LOCK_TRANSFER:
                                    LockBroken lb = li.Notify ?? this.DefaultCallback;
                                    if (lb != null) {
                                        lb(LOCK_TRANSFER, li.name, li.holders[0]);
                                    }

                                    li.holders = new List<Address> { v.members[0] };
                                    continue;

                                case LOCK_RELEASE:
                                    lb = li.Notify ?? this.DefaultCallback;
                                    if (lb != null) {
                                        lb(LOCK_RELEASE, li.name, li.holders[0]);
                                    }

                                    li.holders = new List<Address>();
                                    li.islocked = false;
                                    if (li.wantLock.Count > 0) {
                                        toGrant.Add(li);
                                    }

                                    continue;
                            }
                        }
                    }

                    if ((VsyncSystem.Debug & VsyncSystem.LOCKS) != 0) {
                        Vsync.WriteLine("After NEWVIEW state=" + Environment.NewLine + this.GetLockState());
                    }

                    foreach (LockInfo tg in toGrant) {
                        if ((VsyncSystem.Debug & VsyncSystem.LOCKS) != 0) {
                            Vsync.WriteLine("After NEWVIEW GrantLock " + tg.name);
                        }

                        if (tg.wantLock.Count > 0) {
                            this.GrantLock("Name not known", tg);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Obtains a lock within a group on a resource, given a string naming that resource
        /// </summary>
        /// <param name="lockName">Name of the lock; any string will do</param>
        /// <returns>True if successful, false for failure</returns>
        /// <remarks>Lock(x) can fail in two ways: by timing out, or (if LOCK_EXTERN_EPHEMERAL was specified) in the event
        /// that the group being used drops below the SafeSendThreshold, which causes SafeSend to fail.</remarks>
        public bool Lock(string lockName) {
            return this.Lock(lockName, int.MaxValue, WRITELOCK);
        }

        /// <summary>
        /// Obtains a lock within a group on a resource, given a string naming that resource
        /// </summary>
        /// <param name="lockName">Name of the lock; any string will do</param>
        /// <returns>True if successful, false for failure</returns>
        /// <remarks>Lock(x) can fail in two ways: by timing out, or (if LOCK_EXTERN_EPHEMERAL was specified) in the event
        /// that the group being used drops below the SafeSendThreshold, which causes SafeSend to fail.</remarks>
        public bool ReadLock(string lockName) {
            return this.Lock(lockName, int.MaxValue, READLOCK);
        }

        /// <summary>
        /// Obtains a lock within a group on a resource, given a string naming that resource
        /// </summary>
        /// <param name="lockName">Name of the lock; any string will do</param>
        /// <returns>True if successful, false for failure</returns>
        /// <remarks>Lock(x) can fail in two ways: by timing out, or (if LOCK_EXTERN_EPHEMERAL was specified) in the event
        /// that the group being used drops below the SafeSendThreshold, which causes SafeSend to fail.</remarks>
        public bool WriteLock(string lockName) {
            return this.Lock(lockName, int.MaxValue, WRITELOCK);
        }

        /// <summary>
        /// Obtains a lock; gives up if the timeout expires
        /// </summary>
        /// <param name="lockName">Name of the lock; any string will do</param>
        /// <param name="timeout">Timeout in ms</param>
        /// <returns>True if successful, false for failure</returns>
        /// <remarks>Lock(x) can fail in two ways: by timing out, or (if LOCK_EXTERN_EPHEMERAL was specified) in the event
        /// that the group being used drops below the SafeSendThreshold, which causes SafeSend to fail.</remarks>
        public bool Lock(string lockName, int timeout) {
            return this.Lock(lockName, int.MaxValue, WRITELOCK);
        }

        /// <summary>
        /// Obtains a lock; gives up if the timeout expires
        /// </summary>
        /// <param name="lockName">Name of the lock; any string will do</param>
        /// <param name="timeout">Timeout in ms</param>
        /// <returns>True if successful, false for failure</returns>
        /// <remarks>Lock(x) can fail in two ways: by timing out, or (if LOCK_EXTERN_EPHEMERAL was specified) in the event
        /// that the group being used drops below the SafeSendThreshold, which causes SafeSend to fail.</remarks>
        public bool ReadLock(string lockName, int timeout) {
            return this.Lock(lockName, int.MaxValue, READLOCK);
        }

        /// <summary>
        /// Obtains a lock; gives up if the timeout expires
        /// </summary>
        /// <param name="lockName">Name of the lock; any string will do</param>
        /// <param name="timeout">Timeout in ms</param>
        /// <returns>True if successful, false for failure</returns>
        /// <remarks>Lock(x) can fail in two ways: by timing out, or (if LOCK_EXTERN_EPHEMERAL was specified) in the event
        /// that the group being used drops below the SafeSendThreshold, which causes SafeSend to fail.</remarks>
        public bool WriteLock(string lockName, int timeout) {
            return this.Lock(lockName, int.MaxValue, WRITELOCK);
        }

        internal bool Lock(string lockName, int timeout, int locktype) {
            if (!this.VsyncCallStart()) {
                return false;
            }

            if ((VsyncSystem.Debug & VsyncSystem.LOCKS) != 0) {
                Vsync.WriteLine("Lock[" + this.gname + "](" + lockName + "::" + ltype[locktype] + "; timeout=" + ((timeout == int.MaxValue) ? "*" : timeout.ToString(CultureInfo.InvariantCulture)) + ")" + Environment.NewLine + this.GetLockState());
            }

            if ((this.flags & G_ISLARGE) != 0) {
                throw new VsyncException("Locking: Not support in large groups");
            }

            if ((this.flags & G_TERMINATING) != 0) {
                return false;
            }

            this.LockingInUse = true;
            int tid = -1;
            LockInfo lstate;
            using (var tmpLockObj = new LockAndElevate(this.LocksListLock)) {
                if (!this.LocksList.TryGetValue(lockName, out lstate)) {
                    lstate = new LockInfo(lockName);
                    this.LocksList[lockName] = lstate;
                }

                if (!lstate.requestPending) {
                    lstate.requestPending = true;
                }
                else {
                    throw new VsyncException("g.Lock(" + lockName + "): Reentrancy not currently supported");
                }
            }

            bool LockSendFailed = false;
            try {
                this.LockSend(LOCKIT, lockName, Vsync.my_address, locktype);
            }
            catch (VsyncSafeSendException) {
                // Occurs in a group where SafeSendThreshold isn't set to ALL and where
                // LOCK_EXTERN_EPHEMERAL was specified if the group size drops below SafeSendThreshold
                LockSendFailed = true;
            }

            if (timeout < int.MaxValue) {
                tid = Vsync.OnTimerThread(Math.Max(100, timeout), () => this.LockSend(CANCEL, lockName, Vsync.my_address, locktype));
            }

            if (!LockSendFailed) {
                // Wait for the lock, but give up if the group starts to Terminate.
                if (WaitHandle.WaitAny(new WaitHandle[] { lstate.wait, interruptLockWaits }) == 1) {
                    this.VsyncCallDone();
                    return false;
                }
            }

            if ((VsyncSystem.Debug & VsyncSystem.LOCKS) != 0) {
                Vsync.WriteLine("After Lock(" + lockName + "): got-lock=" + (lstate.islocked && lstate.holders.Contains(Vsync.my_address)) + ":" + Environment.NewLine + this.GetLockState());
            }

            using (var tmpLockObj = new LockAndElevate(this.LocksListLock)) {
                if (tid != -1) {
                    Vsync.TimerCancel(tid);
                }

                lstate.requestPending = false;
                this.VsyncCallDone();
                return lstate.islocked && lstate.holders.Contains(Vsync.my_address);
            }
        }

        /// <summary>
        /// Releases a lock
        /// </summary>
        /// <param name="lockName">Name of the lock to be released</param>
        public void Unlock(string lockName) {
            if (!this.VsyncCallStart()) {
                return;
            }

            if ((this.flags & G_ISLARGE) != 0) {
                throw new VsyncException("Locking: Not support in large groups");
            }

            if ((this.flags & G_TERMINATING) != 0) {
                return;
            }

            this.LockingInUse = true;
            if ((VsyncSystem.Debug & VsyncSystem.LOCKS) != 0) {
                Vsync.WriteLine("UnLock[" + this.gname + "](" + lockName + ")");
            }

            using (var tmpLockObj = new LockAndElevate(this.LocksListLock)) {
                LockInfo lstate;
                if (!this.LocksList.TryGetValue(lockName, out lstate) || !lstate.islocked) {
                    throw new VsyncException("g.Unlock(" + lockName + "), but it wasn't locked in:" + Environment.NewLine + this.GetLockState());
                }
            }

            this.LockSend(RELEASEIT, lockName, Vsync.my_address, UNLOCK);
            if ((VsyncSystem.Debug & VsyncSystem.LOCKS) != 0) {
                Vsync.WriteLine("After Unlock(" + lockName + "):" + Environment.NewLine + this.GetLockState());
            }

            this.VsyncCallDone();
        }

        private static int COUNTER;

        internal void LockSend(int command, string lname, Address who, int locktype) {
            COUNTER++;
            switch (this.LockPackageConfig) {
                case LOCK_INTERNAL:
                    this.OrderedSend(Vsync.LOCKREQ, command, lname, who, (Vsync.my_pid * 10000) + COUNTER, locktype);
                    return;
                case LOCK_EPHEMERAL_EXTERN:
                    this.SafeSend(Vsync.LOCKREQ, command, lname, who, (Vsync.my_pid * 10000) + COUNTER, locktype);
                    return;
                case LOCK_RECOVER_EXTERN:
                    this.SafeSend(Vsync.LOCKREQ, command, lname, who, (Vsync.my_pid * 10000) + COUNTER, locktype);
                    return;
            }
        }

        internal void GrantLock(string lockName, LockInfo lstate) {
            string toWhom;

            using (var tmpLockObj = new LockAndElevate(this.LocksListLock)) {
                LockReq lr = lstate.wantLock.First();
                if (!lstate.wantLock.Remove(lr)) {
                    throw new VsyncException("GrantLock: unable to remove " + lr);
                }

                lstate.islocked = true;
                lstate.locktype = lr.how;
                lstate.holders.Add(lr.who);
                if (lr.who.isMyAddress()) {
                    toWhom = " GRANTED TO ME!";
                    lstate.wait.Release();
                }
                else {
                    toWhom = " to " + lr;
                }
            }

            if ((VsyncSystem.Debug & VsyncSystem.LOCKS) != 0) {
                Vsync.WriteLine("-------LOCK " + lockName + toWhom);
            }

            if (this.LockPackageConfig == LOCK_RECOVER_EXTERN) {
                this.MakeCheckpoint(this.theView);
            }
        }

        internal void CancelLockRequest(string LockName, Address who, LockInfo lstate) {
            if ((VsyncSystem.Debug & VsyncSystem.LOCKS) != 0) {
                Vsync.WriteLine("-------CANCEL " + LockName + " request by " + who);
            }

            using (var tmpLockObj = new LockAndElevate(this.LocksListLock)) {
                foreach (LockReq wl in lstate.wantLock) {
                    if (wl.who == who) {
                        if (!lstate.wantLock.Remove(wl)) {
                            throw new VsyncException("CancelLockRequest: unable to remove " + who);
                        }

                        break;
                    }
                }

                if (who.isMyAddress()) {
                    lstate.wait.Release();
                }
            }

            if (this.LockPackageConfig == LOCK_RECOVER_EXTERN) {
                this.MakeCheckpoint(this.theView);
            }
        }

        /// <summary>
        /// Given the name of a lock, returns the current holders if the lock is locked.  Returns null if unlocked.
        /// There will be at most one holder if locked for writing, but could be multiple holders if locked for reading
        /// </summary>
        /// <param name="lockName"></param>
        /// <returns>Addresses of the current holders, if any</returns>
        public List<Address> Holder(string lockName) {
            if ((this.flags & G_ISLARGE) != 0) {
                throw new VsyncException("Locking: Not support in large groups");
            }

            using (var tmpLockObj = new LockAndElevate(this.LocksListLock)) {
                LockInfo state;
                if (this.LocksList.TryGetValue(lockName, out state) && state.islocked) {
                    return state.holders;
                }
            }

            return null;
        }

        internal string GetLockState() {
            int cnt = 0;
            string s = string.Empty;
            using (var tmpLockObj = new LockAndElevate(this.LocksListLock)) {
                foreach (KeyValuePair<string, LockInfo> kvp in this.LocksList) {
                    string llist = string.Empty;
                    if (kvp.Value.wantLock != null) {
                        foreach (LockReq wl in kvp.Value.wantLock) {
                            llist += wl + " ";
                        }
                    }

                    s += "      USER-DEFINED LOCK: {" + kvp.Key + "::" + (kvp.Value.islocked ? ("Locked by " + Address.VectorToString(kvp.Value.holders.ToArray())) : "Not locked") + (llist.Length > 0 ? (", wanted-by: " + llist) : ", no waiting requests") + "}" + Environment.NewLine;
                    ++cnt;
                }
            }

            return cnt > 0 ? s : string.Empty;
        }

        /// <summary>
        /// Specifies the desired handling for write locks in the event that a crash occurs while someone is holding the lock.
        /// Note that read locks are not affected by the policy and are always released if a crash occurs while someone holds the lock
        /// </summary>
        /// <param name="lockName">Name of the lock</param>
        /// <param name="lockPolicy">LOCK_TRANSFER transfers write locks to the rank0 member, LOCK_RELEASE releases write locks </param>
        /// <remarks>It doesn't make sense to use the LOCK_RELEASE policy if the service as a whole is running in the slow,
        /// very conservative, LOCK_RECOVER_EXTERN mode. </remarks>
        public void SetLockPolicy(string lockName, int lockPolicy) {
            this.SetLockPolicy(lockName, lockPolicy, null);
        }

        /// <summary>
        /// Specifies the desired handling for write locks in the event that a crash occurs while someone is holding the lock.
        /// Note that read locks are not affected by the policy and are always released if a crash occurs while someone holds the lock
        /// </summary>
        /// <param name="lockName">Lock name</param>
        /// <param name="lockPolicy">LOCK_TRANSFER transfers write locks to the rank0 member, LOCK_RELEASE releases write locks </param>
        /// <param name="del">Method to notify in the event of an event</param>
        /// <remarks>It doesn't make sense to use the LOCK_RELEASE policy if the service as a whole is running in the slow,
        /// very conservative, LOCK_RECOVER_EXTERN mode. </remarks>
        public void SetLockPolicy(string lockName, int lockPolicy, LockBroken del) {
            if ((this.flags & G_ISLARGE) != 0) {
                throw new VsyncException("Locking: Not support in large groups");
            }

            this.LockingInUse = true;
            if (lockPolicy == LOCK_RELEASE && this.LockPackageConfig == LOCK_RECOVER_EXTERN) {
                Vsync.WriteLine("WARNING: Lock policy inconsistency: LOCK_RELEASE for lock " + lockName + " in LOCK_RECOVER_EXTERN mode!");
            }

            using (var tmpLockObj = new LockAndElevate(this.LocksListLock)) {
                LockInfo lstate;
                if (!this.LocksList.TryGetValue(lockName, out lstate)) {
                    lstate = new LockInfo(lockName);
                    this.LocksList[lockName] = lstate;
                }

                lstate.policy = lockPolicy;
                lstate.Notify = del;
            }
        }

        /// <summary>
        /// Parameters controlling the overall package
        /// </summary>
        /// <param name="config">LOCK_INTERNAL, LOCK_EPHEMERAL_EXTERN, LOCK_RECOVER_EXTERN</param>
        /// <remarks>The SetLockPolicies control API allows the lock package user to indicate to Vsync how the locking system is being
        /// used.  With configuration parameter LOCK_INTERN, locking is understood to run on a "soft state" resource with purely in-memory
        /// state.  This is fastest, but is safe only if you have good reason to know that your group won't need to tolerate failures
        /// in which all members fail.  We recommend it for groups that have some "internal" synchronization need, but there may be
        /// cloud settings in which this is a safe choice based in information you might have about the likelihood of a total failure.
        /// 
        /// With the LOCK_EPHEMERAL_EXTERN policy, the locking package is configured to deal with an external resource but still forgets
        /// the lock state in the event of a total failure.  This is slower than LOCK_INTERNAL but not dramatically so, and has the advantage
        /// that it can safely be used if the goal is to lock access to, say, a printer.  Locks are released if the service crashes but if you
        /// know that the external resource won't be accessed during those periods, you may be safe with this choice.
        /// 
        /// The slowest but safest option is LOCK_REOVER_EXTERN.  Here we are pretty obssessive about logging state and can restore the service
        /// after any possible failure with the same lock state it was in prior to the failure.  Costs are high, and this makes sense only with the
        /// LOCK_TRANSFER option for handling of failures, since ALL the old members will have crashed.  If you would use LOCK_RELEASE as a policy,
        /// you definitely don't need LOCK_RECOVER_EXTERN as a configuration state. </remarks>
        public void SetLockPolicies(int config) {
            this.SetLockPolicies(config, null);
        }

        /// <summary>
        /// Parameters controlling the overall packageParameters controlling the overall package
        /// </summary>
        /// <param name="config">LOCK_INTERNAL, LOCK_EPHEMERAL_EXTERN, LOCK_RECOVER_EXTERN</param>
        /// <param name="del">Default callback for lock transfer or broken events</param>
        /// <remarks>The SetLockPolicies control API allows the lock package user to indicate to Vsync how the locking system is being
        /// used.  With configuration parameter LOCK_INTERN, locking is understood to run on a "soft state" resource with purely in-memory
        /// state.  This is fastest, but is safe only if you have good reason to know that your group won't need to tolerate failures
        /// in which all members fail.  We recommend it for groups that have some "internal" synchronization need, but there may be
        /// cloud settings in which this is a safe choice based in information you might have about the likelihood of a total failure.
        /// 
        /// With the LOCK_EPHEMERAL_EXTERN policy, the locking package is configured to deal with an external resource but still forgets
        /// the lock state in the event of a total failure.  This is slower than LOCK_INTERNAL but not dramatically so, and has the advantage
        /// that it can safely be used if the goal is to lock access to, say, a printer.  Locks are released if the service crashes but if you
        /// know that the external resource won't be accessed during those periods, you may be safe with this choice.
        /// 
        /// The slowest but safest option is LOCK_REOVER_EXTERN.  Here we are pretty obssessive about logging state and can restore the service
        /// after any possible failure with the same lock state it was in prior to the failure.  Costs are high, and this makes sense only with the
        /// LOCK_TRANSFER option for handling of failures, since ALL the old members will have crashed.  If you would use LOCK_RELEASE as a policy,
        /// you definitely don't need LOCK_RECOVER_EXTERN as a configuration state. </remarks>
        public void SetLockPolicies(int config, LockBroken del) {
            if ((this.flags & G_ISLARGE) != 0) {
                throw new VsyncException("Locking: Not support in large groups");
            }

            this.LockingInUse = true;
            this.LockPackageConfig = config;
            this.DefaultCallback = del;
            switch (config) {
                case LOCK_INTERNAL:

                    // This is the default
                    return;
                case LOCK_EPHEMERAL_EXTERN:

                    // Forces use of SafeSend
                    return;
                case LOCK_RECOVER_EXTERN:

                    // Uses SafeSend+Logging
                    if (this.safeSendDurabilityMethod == null) {
                        throw new VsyncException("Recoverable mode for lock package requires SafeSend DiskDurabilityMode");
                    }

                    return;
                default:
                    throw new VsyncException("Unrecognized lock policy configuration value: " + config);
            }
        }

        /// <exclude></exclude>
#if PROTOCOL_BUFFERS
        [ProtoContract(SkipConstructor = true)]
#else
        [AutoMarshalled]
#endif
        public class DHTItem {
            /// <exclude></exclude>
            [ProtoMember(1)]
            public readonly object value;

            /// <exclude></exclude>
            [ProtoMember(2)]
            public readonly Address createdBy;

            /// <exclude></exclude>
            [ProtoMember(3)]
            public readonly long createTimestamp;

#if !PROTOCOL_BUFFERS
            /// <exclude></exclude>
            public DHTItem() {
            }
#endif

            internal DHTItem(object value) {
                this.value = value;
                this.createdBy = Vsync.my_address;
                this.createTimestamp = DateTime.UtcNow.Ticks;
            }

            internal DHTItem(DHTItem existingItem, object newValue) {
                this.value = newValue;
                this.createdBy = existingItem.createdBy;
                this.createTimestamp = existingItem.createTimestamp;
            }
        }

        internal Dictionary<object, DHTItem> DHTContents = new Dictionary<object, DHTItem>(1000);

        /// <summary>
        /// Returns a clone containing only those (key,value) tuples that have the specified key and value types, or the full set if
        /// the type is specified as "object".   The result is a copy: changes to it won't be reflected into 
        /// the "original". which is maintained internally by Vsync and not directly accessible to the user.
        /// <typeparam name="KT">Key type</typeparam>
        /// <typeparam name="VT">Value type</typeparam>
        /// </summary>
        public IEnumerable<KeyValuePair<KT, VT>> DHT<KT, VT>() {
            List<KeyValuePair<KT, VT>> rval = new List<KeyValuePair<KT, VT>>();
            if (!this.VsyncCallStart()) {
                return rval;
            }

            using (var tmpLockObj = new LockAndElevate(this.DHTDictLock)) {
                foreach (KeyValuePair<object, DHTItem> kvp in this.DHTContents) {
                    if (kvp.Key.GetType() == typeof(KT) && kvp.Value.value.GetType() == typeof(VT)) {
                        rval.Add(new KeyValuePair<KT, VT>((KT)kvp.Key, (VT)kvp.Value.value));
                    }
                }
            }

            this.VsyncCallDone();
            return rval;
        }

        /// <summary>
        /// Returns a clone containing of the Vsync DHT
        /// </summary>
        public IEnumerable<KeyValuePair<object, object>> DHT() {
            List<KeyValuePair<object, object>> rval = new List<KeyValuePair<object, object>>();
            if (!this.VsyncCallStart()) {
                return rval;
            }

            using (var tmpLockObj = new LockAndElevate(this.DHTDictLock)) {
                foreach (KeyValuePair<object, DHTItem> kvp in this.DHTContents) {
                    rval.Add(new KeyValuePair<object, object>(kvp.Key, kvp.Value.value));
                }
            }

            this.VsyncCallDone();
            return rval;
        }

        /// <summary>
        /// Returns an integer (small non-negative numbers 0... nmembers/replication factor) indicating which DHT partition this member belongs to
        /// </summary>
        /// <returns></returns>
        public int DHTGetPartition() {
            return this.GetAffinityGroup(this.GetMyRank());
        }

        /// <summary>
        /// Returns an integer (small non-negative numbers 0... nmembers/replication factor) indicating my rank within my partition
        /// </summary>
        /// <returns></returns>
        public int DHTGetPartitionRank() {
            View theView;
            using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                theView = this.theView;
            }

            int rank = 0;
            int myAg = this.GetAffinityGroup(this.GetMyRank());
            if (myAg >= 0) {
                for (int i = 0; i < theView.members.Length; i++) {
                    if (theView.members[i].isMyAddress()) {
                        return rank;
                    }

                    if (this.GetAffinityGroup(i) == myAg) {
                        ++rank;
                    }
                }
            }

            return -1;
        }

        internal LockObject DHTDictLock = new LockObject("DHTLock");

        internal int myDHTBinSize;

        internal int myDHTMinSize;

        internal int myDHTnShards;

        internal Func<object, object, object, object> myResolver;

        internal View curDHTView;

        internal LockObject DHTViewLock = new LockObject("DHTViewLock");

        internal bool myDHTInDebugMode = false;

        internal bool[,] DHTHMaps;

        internal bool[] DHTAgNonEmpty;

        internal int myTargetGroupSize;

        internal const int DHTRedundancyFactor = 2;

        // How many existing members push DHT content to you when membership shuffles due to churn
        internal long myDHTItemTimeout;

        // Caller holds the lock, so no need to acquire it here
        internal void DHTWriter(object key, DHTItem item) {
            DHTItem dhi = null;
            bool collision = this.DHTContents.ContainsKey(key);
            if (collision) {
                dhi = this.DHTContents[key];
            }

            if ((VsyncSystem.Debug & VsyncSystem.DHTS) != 0) {
                Vsync.WriteLine("DHT_PUT: kvp=<" + key + "::" + item.value + "(AG=" + this.GetAffinityGroup(DHTKeyHash(key)) + ", myAG=" + this.GetAffinityGroup(this.GetMyRank()) + ")>" + (collision ? " ** COLLISION **" : string.Empty));
            }

            if (collision) {
                bool resolved = false;
                object newValue = null;

                // If the resolver was specified, let it decide what to do
                if (this.theResolvers.hList.Count > 0) {
                    object[] obs = { key, dhi.value, item.value };
                    foreach (CallBack del in this.theResolvers.hList) {
                        if (DHTTypeMatch(obs, del) && del.cbProc.nParams == 3) {
#if !(__MonoCS__)
                            if (del.cbProc.cb != null) {
                                newValue = ((dynamic)del.cbProc.cb).Invoke((dynamic)obs[0], (dynamic)obs[1], (dynamic)obs[2]);
                            }
                            else {
                                MethodInfo mi = del.cbProc.hisCb.GetType().GetMethod("Invoke");
                                newValue = mi.Invoke(del.cbProc.hisCb, obs);
                            }

#else
                            newValue = del.cbProc.hisCb.DynamicInvoke(obs);
#endif
                            resolved = true;
                            break;
                        }
                    }
                }

                if (!resolved && this.myResolver != null) {
                    newValue = this.myResolver(key, dhi.value, item.value);
                    resolved = true;
                }

                if (resolved) {
                    this.DHTContents.Remove(key);
                    if (!this.usesDHTDefaults) {
                        this.DHTExtWriter(key, null);
                    }

                    if (newValue == null) {
                        return;
                    }

                    DHTItem dhtItem = this.usesDHTDefaults ? new DHTItem(item, newValue) : new DHTItem(item, this.DHTExtWriter(key, newValue));
                    this.DHTContents.Add(key, dhtItem);
                    return;
                }

                // If two puts are done on the same key, keep the Put with the larger create time.  This is a wall-clock time of day
                // In the whole of Vsync, this is the only line of code sensitive to the quality of clock synchronization....
                if (dhi.createTimestamp >= item.createTimestamp) {
                    return;
                }

                if (!this.DHTContents.Remove(key)) {
                    Vsync.WriteLine("WARNING: unexpected failure to remove " + key);
                }

                if (!this.usesDHTDefaults) {
                    this.DHTExtWriter(key, null);
                }
            }

            DHTItem dhtItem2 = this.usesDHTDefaults ? item : new DHTItem(item, this.DHTExtWriter(key, item.value));
            this.DHTContents.Add(key, dhtItem2);
        }

        internal object DHTReader(object key) {
            DHTItem dhi;
            using (var tmpLockObj = new LockAndElevate(this.DHTDictLock)) {
                this.DHTContents.TryGetValue(key, out dhi);
            }

            if ((VsyncSystem.Debug & VsyncSystem.DHTS) != 0) {
                Vsync.WriteLine("DHT_GET: key=<" + key + ">" + (dhi != null ? " found (value=" + dhi.value + ")" : " not found"));
            }

            if (dhi != null) {
                if (this.usesDHTDefaults) {
                    return dhi.value;
                }

                return this.DHTExtReader(key, (string)dhi.value);
            }

            return null;
        }

        internal bool usesDHTDefaults = true;

        /// <summary>
        /// By specifying a DHTPutMethod, the user can provide a method that stores the actual value objects
        /// For example, they could be stored in external files.  The PutMethod returns a locator string
        /// </summary>
        /// <param name="Key">The key of the object to be stored.  If reused, the object is being overwritten</param>
        /// <param name="Value">The value of the object to be stored.  Null if the object is being deleted</param>
        /// <returns></returns>
        public delegate string DHTPutMethod(object Key, object Value);

        /// <summary>
        /// Called when fetching a value for an externally stored object
        /// </summary>
        /// <param name="Key">Key of the externally stored object</param>
        /// <param name="locator">string that was provided by the DHTPutMethod when it was last saved</param>
        /// <returns></returns>
        public delegate object DHTGetMethod(object Key, string locator);

        internal DHTPutMethod DHTExtWriter;

        internal DHTGetMethod DHTExtReader;

        /// <summary>
        /// Allows a developer to create a DHT that stores its data in a non-standard way.  The default methods keep the DHT data in memory
        /// This API is mostly intended to support DHTs in which the actual values are stored in the local file system by the group members
        /// </summary>
        /// <param name="writerMethod"></param>
        /// <param name="readerMethod"></param>
        public void SetDHTPersistenceMethods(DHTPutMethod writerMethod, DHTGetMethod readerMethod) {
            this.usesDHTDefaults = false;
            this.DHTExtWriter = writerMethod;
            this.DHTExtReader = readerMethod;
        }

        /// <summary>
        /// Puts the current group into DHT mode, but without specifying a target size and without setting aside extra members. 
        /// </summary>
        /// <param name="ReplicationFactor">Requested data replication factor</param>
        /// <param name="ExpectedGroupSize">Your estimate of the typical size of this group (N); a multiple of the replication factor</param>
        /// <param name="MinimumGroupSize">The smallest group size at which the DHT will accept DHTPut/DHTGet commands</param>
        /// <remarks>If the replication factor is too small, you run the risk that our random hashing scheme could leave some affinity
        /// group with too few, or too many members.  Too many is not a problem, but if an affinity group has too few members you can see
        /// failures that cause data to be completely lost (e.g. if the only replica fails).  Thus when you ask for a replication factor of,
        /// say, 3 this is a <it>target</it>, not the minimum that might be used.  We haven't had problems with factors of 5 or more in groups of 25 or more members.
        /// 
        /// In the event of membership changes, the group will automatically recompute the DHT hash partitioning function and ship (key,value) pairs around
        /// to ensure that each member has the correct items.  This can be a substantial overhead in heavily populated DHTs with large numbers of members.
        /// In such cases, use the full DHTEnable API and indicate to the system a size you are targetting for the active DHT, and a number of "spare"
        /// members that the system can leave out of the DHT (for example, you might target 1000 members, and allow 5 spares; if the group were to have
        /// 1005 members (or more), N-5 will run the DHT, while the remaining 5 play a backup role.
        /// 
        /// With spares, if a member fails, one of the spares will be dropped in to replace it.  This limits the amount of reinitialization and
        /// "churning" of (key,value) tuples: that spare needs to be initialized, but other members retain their roles and no large-scale churn occurs.
        /// Then you can launch extra spares if the number starts to drop towards your specified target.  
        /// 
        /// When the group has fewer than the ExpectedGroupSize members, the spare mechanism is disabled.  So, continuing our example above, with 950 members, no spares
        /// would be available and the DHT would indeed churn if a failure or join changed the DHT hash-based partitioning of the members.
        /// 
        /// To put the DHT into debug mode for developing your application, you can use ReplicationFactor, ExpectedGroupSize and MinimumGroupSize all set to 1,
        /// and then test with just 1 or 2 members in the group,
        /// but remember to use reasonable values later when your group will have more than 1 member.</remarks>
        public void DHTEnable(int ReplicationFactor, int ExpectedGroupSize, int MinimumGroupSize) {
            this.DHTEnable(ReplicationFactor, ExpectedGroupSize, MinimumGroupSize, int.MaxValue);
        }

        /// <summary>
        /// Puts the current group into DHT mode, but without specifying a target size and without setting aside extra members. 
        /// </summary>
        /// <param name="ReplicationFactor">Requested data replication factor</param>
        /// <param name="ExpectedGroupSize">Your estimate of the typical size of this group (N); a multiple of the replication factor</param>
        /// <param name="MinimumGroupSize">The smallest group size at which the DHT will accept DHTPut/DHTGet commands</param>
        /// <param name="timeout">Timeout, after which the (Key,Value) pair is automatically discarded.</param>
        /// <remarks>If the replication factor is too small, you run the risk that our random hashing scheme could leave some affinity
        /// group with too few, or too many members.  Too many is not a problem, but if an affinity group has too few members you can see
        /// failures that cause data to be completely lost (e.g. if the only replica fails).  Thus when you ask for a replication factor of,
        /// say, 3 this is a <it>target</it>, not the minimum that might be used.  We haven't had problems with factors of 5 or more in groups of 25 or more members.
        /// 
        /// In the event of membership changes, the group will automatically recompute the DHT hash partitioning function and ship (key,value) pairs around
        /// to ensure that each member has the correct items.  This can be a substantial overhead in heavily populated DHTs with large numbers of members.
        /// In such cases, use the full DHTEnable API and indicate to the system a size you are targetting for the active DHT, and a number of "spare"
        /// members that the system can leave out of the DHT (for example, you might target 1000 members, and allow 5 spares; if the group were to have
        /// 1005 members (or more), N-5 will run the DHT, while the remaining 5 play a backup role.
        /// 
        /// With spares, if a member fails, one of the spares will be dropped in to replace it.  This limits the amount of reinitialization and
        /// "churning" of (key,value) tuples: that spare needs to be initialized, but other members retain their roles and no large-scale churn occurs.
        /// Then you can launch extra spares if the number starts to drop towards your specified target.  
        /// 
        /// When the group has fewer than the ExpectedGroupSize members, the spare mechanism is disabled.  So, continuing our example above, with 950 members, no spares
        /// would be available and the DHT would indeed churn if a failure or join changed the DHT hash-based partitioning of the members.
        /// 
        /// To put the DHT into debug mode for developing your application, you can use ReplicationFactor, ExpectedGroupSize and MinimumGroupSize all set to 1,
        /// and then test with just 1 or 2 members in the group,
        /// but remember to use reasonable values later when your group will have more than 1 member.</remarks>
        public void DHTEnable(int ReplicationFactor, int ExpectedGroupSize, int MinimumGroupSize, int timeout) {
            if (!this.VsyncCallStart()) {
                return;
            }

            if (timeout > 0 && timeout < int.MaxValue) {
                this.myDHTItemTimeout = Math.Max(timeout, 2500);
                Vsync.OnTimer(this.myDHTItemTimeout, this.DHTCleanup);
            }

            if (this.myDHTBinSize != 0) {
                throw new VsyncDHTException("Can't call DHTEnable more than once for the same group");
            }

            if (ExpectedGroupSize % ReplicationFactor != 0) {
                throw new VsyncDHTException("Target Vsync DHT group size isn't a multiple of the replication factor");
            }

            this.myDHTMinSize = MinimumGroupSize;
            this.myDHTBinSize = ReplicationFactor;
            this.myDHTnShards = ExpectedGroupSize / ReplicationFactor;
            this.lastVersionId = new int[this.myDHTnShards];
            this.retainedKVPS = new List<object[]>[this.myDHTnShards];
            for (int n = 0; n < this.myDHTnShards; n++) {
                this.retainedKVPS[n] = new List<object[]>();
            }

            if (MinimumGroupSize < this.myDHTnShards) {
                throw new VsyncDHTException("DHTEnable: the minimum size must be at least ExpectedGroupSize/ReplicationFactor");
            }

            this.myTargetGroupSize = ExpectedGroupSize;
            if (ReplicationFactor == 1 && ExpectedGroupSize == 1 && MinimumGroupSize == 1) {
                this.myDHTInDebugMode = true;
            }
            else if (ReplicationFactor < 2 || this.myDHTBinSize < 2) {
                throw new VsyncDHTException("DHTEnable: Replication factor must be >= 2 and (ExpectedGroupSize / ReplicationFactor) must be > 1");
            }

            this.doRegister(Vsync.IM_DHT_PUT, new Action<object>(kvps => this.doDHTPut(kvps, 0, -1, -1)));
            this.doRegister(Vsync.IM_DHT_PUT, new Action<object, int, int, int>(this.doDHTPut));
            this.doRegister(Vsync.IM_DHT_PUT, new Action<int, int, int>((sendingShard, versionId, viewId) => this.doDHTPut(null, sendingShard, versionId, viewId)));
            this.doRegister(Vsync.IM_DHT_GET, new Action<object>(keys => {
                int myAg = this.GetAffinityGroup(Vsync.my_address);
                List<KeyValuePair<object, object>> result = new List<KeyValuePair<object, object>>();
                foreach (object key in (IEnumerable)keys) {
                    int khash = this.DHTKeyHash(key);

                    // Filter if not for my affinity group; shouldn't happen at all
                    if (this.GetAffinityGroup(khash) == myAg && this.theView.GetMyRank() < this.theView.members.Length) {
                        using (var tmpLockObj = new LockAndElevate(this.DHTDictLock)) {
                            object value;
                            if ((value = this.DHTReader(key)) != null) {
                                result.Add(new KeyValuePair<object, object>(key, value));
                            }
                        }
                    }
                    else if ((VsyncSystem.Debug & VsyncSystem.DHTS) != 0) {
                        Vsync.WriteLine("DHT_GET hander: filtering and ignoring a get to a different affinity group");
                    }
                }

                // This is necessary because of a bug in the Message library: it seems to have a problem with zero-length
                // lists of KeyValuePair<kt,vt> objects and encodes them as zero-length lists of type object..
                if ((VsyncSystem.Debug & VsyncSystem.DHTS) != 0) {
                    string ks = " ";
                    foreach (object key in (IEnumerable)keys) {
                        ks += key + "[Ag=" + this.GetAffinityGroup(key.GetHashCode()) + "] ";
                    }

                    Vsync.WriteLine("DHT_GET hander[Ag=" + myAg + "]: I was asked about keys " + ks + " and found " + result.Count + " matches");
                }

                if (result.Count > 0) {
                    this.doReply(result);
                }
                else {
                    this.doNullReply();
                }
            }));

            // Uses a special hook: *= will put the handler at the front of the queue, ensuring that the DHT mapping is
            // recomputed before anyone might try and use it.
            this.ViewHandlers *= v => {
                if (v.members.Length == 0) {
                    return;
                }

                using (var tmpLockObj = new LockAndElevate(this.DHTViewLock)) {
                    this.curDHTView = v;
                }

                int nActive = v.members.Length;
                this.DHTHMaps = new bool[this.myDHTnShards, log2(Math.Max(nActive, this.myDHTnShards * this.myDHTBinSize)) + 1];
                this.DHTAgNonEmpty = new bool[this.myDHTnShards];
                for (int n = 0; n < nActive; n++) {
                    int pseudoGrp = this.GetAffinityGroup(v.members[n]);
                    if (pseudoGrp >= 0) {
                        this.DHTHMaps[pseudoGrp, log2(n + 1)] = true;
                        this.DHTAgNonEmpty[pseudoGrp] = true;
                    }
                }

                this.replaylastSTKVPS(v.viewid);
            };

            // This is special too: we get a chance to shift DHT key-value items around during the PROPOSED step as new views are computed
            this.FlushHandlers += this.DHTShuffle;

            // Goals here are to (1) Spread the work around, and (2) Make sure each joining member is initialized by a sender
            // belonging to the appropriate affinity group. This code is a bit awkward because it only can be used when the
            // DHT is sufficiently large, and because a DHT with a number of members that isn't an exact multiple of 
            // myDHTnBins might have a few "extra" members at the end.  This is why when rankOfCheckptSender wraps we
            // always want to set it back to hisAg, not to rankOfCheckptSender%v.members.Length!
            this.RegisterChkptChoser((v, who) => {
                View prevView;
                using (var tmpLockObj = new LockAndElevate(this.DHTViewLock)) {
                    prevView = this.curDHTView;
                }

                if (v.joiners.Contains(Vsync.my_address)) {
                    return false;
                }

                int hisAg = this.GetAffinityGroup(v, who);
                int rankOfCheckptSender = ((who.GetHashCode() % this.myDHTnShards) * this.myDHTnShards) + hisAg;
                List<Address> candidates = new List<Address>();
                for (int off = 0; off < prevView.members.Length / this.myDHTnShards; off++) {
                    if (rankOfCheckptSender >= prevView.members.Length) {
                        rankOfCheckptSender = hisAg;
                    }

                    if (!v.leavers.Contains(prevView.members[rankOfCheckptSender])) {
                        if (this.GetAffinityGroup(rankOfCheckptSender) != hisAg) {
                            throw new VsyncException("Bug in new DHT checkpoint choser (1)");
                        }
                        if (!v.joiners.Contains(prevView.members[rankOfCheckptSender]))
                            candidates.Add(prevView.members[rankOfCheckptSender]);
                    }

                    rankOfCheckptSender += this.myDHTnShards;
                }

                if (candidates.Count() == 0) {
                    return true;
                }

                return candidates[(who.GetHashCode() % candidates.Count())].isMyAddress();
            });
            this.RegisterMakeChkpt(view => {
                using (var tmpLockObj = new LockAndElevate(this.DHTDictLock)) {
                    if (this.DHTContents.Count > 0) {
                        if (this.usesDHTDefaults) {
                            // In-memory case; just send the whole thing in one big message
                            this.SendChkpt(Msg.toBArray(this.DHTContents.Keys.ToArray()), Msg.toBArray(this.DHTContents.Values.ToArray()));
                        }
                        else {
                            // External user-defined storage.  Here we do the transfer one object at a time because the files
                            // in external storage could be quite large (a common reason for storing them externally)
                            foreach (KeyValuePair<object, DHTItem> kvp in this.DHTContents) {
                                DHTItem chkptDhtItem = new DHTItem(kvp.Value, this.DHTExtReader(kvp.Key, (string)kvp.Value.value));
                                this.SendChkpt(Msg.toBArray(new[] { kvp.Key }), Msg.toBArray(new[] { chkptDhtItem }));
                            }
                        }
                    }
                }

                this.EndOfChkpt();
            });
            this.RegisterLoadChkpt(new Action<byte[], byte[]>((kba, vba) => {
                object[] keys = Msg.BArrayToObjects(kba);
                object[] values = Msg.BArrayToObjects(vba);
                using (var tmpLockObj = new LockAndElevate(this.DHTDictLock)) {
                    for (int i = 0; i < keys.Length; i++) {
                        if (this.usesDHTDefaults) {
                            if (!this.DHTContents.ContainsKey(keys[i])) {
                                this.DHTContents.Add(keys[i], (DHTItem)values[i]);
                            }
                        }
                        else {
                            this.DHTWriter(keys[i], (DHTItem)values[i]);
                        }
                    }
                }
            }));
            this.VsyncCallDone();
        }

        private int[] lastVersionId;

        private int myDHTLastViewId = -1;

        private int myDHTGetHashCodeVID;

        private readonly LockObject myDHTGetHashCodeVIDLock = new LockObject("myDHTGetHashCodeVIDLock");

        private List<object[]>[] retainedKVPS;

        private readonly LockObject lastSTKVPSLock = new LockObject("lastSTKVPSLock");

        private List<object[]> lastSTKVPS = new List<object[]>();

        private readonly Semaphore waitForPutSema = new Semaphore(0, int.MaxValue);

        private void doDHTPut(object kvps, int sendingShard, int versionId, int viewId) {
            int myAg = this.GetAffinityGroup(Vsync.my_address);
            using (var tmpLockObj = new LockAndElevate(this.myDHTGetHashCodeVIDLock)) {
                if (viewId > this.myDHTLastViewId) {
                    using (var tmpLockObj1 = new LockAndElevate(this.lastSTKVPSLock)) {
                        this.lastSTKVPS.Add(new[] { kvps, sendingShard, versionId, viewId });
                    }

                    return;
                }

                if (versionId > 0) {
                    // This branch detects and ignores DHTGetHashCodeChanged-related duplicates.  Those never
                    // come from sendingShard == my own shard Id, so that one entry in lastVersionId is untouched
                    if (sendingShard == myAg) {
                        throw new VsyncException("doDHTPut: sendingShard came through as " + sendingShard + ", which is my own shard!");
                    }

                    if (versionId <= this.lastVersionId[sendingShard]) {
                        if ((VsyncSystem.Debug & VsyncSystem.DHTS) != 0) {
                            Vsync.WriteLine("DHT_PUT hander: filtering and ignoring a duplicated shuffle message");
                        }

                        return;
                    }

                    if (versionId > this.myDHTGetHashCodeVID) {
                        // Arrived early...
                        if ((VsyncSystem.Debug & VsyncSystem.DHTS) != 0) {
                            Vsync.WriteLine("DHT_PUT hander: retaining an early shuffle message");
                        }

                        this.retainedKVPS[sendingShard].Add(new[] { kvps, sendingShard, versionId, viewId });
                        return;
                    }

                    this.lastVersionId[sendingShard] = versionId;
                }
                else if (versionId == 0) {
                    // This branch uses the lastVersionId[myAg] to hold the viewid, and in that way senses dups
                    if (viewId <= this.lastVersionId[myAg]) {
                        if ((VsyncSystem.Debug & VsyncSystem.DHTS) != 0) {
                            Vsync.WriteLine("DHT_PUT hander: filtering and ignoring a duplicated state transfer message");
                        }

                        return;
                    }

                    if (viewId != this.lastVersionId[myAg] + 1 && this.lastVersionId[myAg] != -1) {
                        throw new VsyncException("in doDHTPut: viewId of " + viewId + " was unexpected: lastVersionId[myAg=" + myAg + "] was " + this.lastVersionId[myAg]);
                    }

                    this.lastVersionId[myAg] = viewId;
                }
            }

            if (kvps != null) {
                foreach (object okvp in (IEnumerable)kvps) {
                    object key = okvp.GetType().GetMethod("get_Key").Invoke(okvp, new object[0]);
                    DHTItem value = (DHTItem)okvp.GetType().GetMethod("get_Value").Invoke(okvp, new DHTItem[0]);
                    int khash = this.DHTKeyHash(key);

                    // Filter if not for my affinity group
                    View theView;
                    using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                        theView = this.theView;
                    }

                    if (this.GetAffinityGroup(khash) == this.GetAffinityGroup(Vsync.my_address) && theView.GetMyRank() < theView.members.Length) {
                        using (var tmpLockObj = new LockAndElevate(this.DHTDictLock)) {
                            this.DHTWriter(key, value);
                        }
                    }
                    else if ((VsyncSystem.Debug & VsyncSystem.DHTS) != 0) {
                        Vsync.WriteLine("DHT_PUT hander: filtering and ignoring a put to a different affinity group");
                    }
                }
            }

            if (versionId > 0) {
                this.waitForPutSema.Release();
            }
        }

        private void replaylastSTKVPS(int vid) {
            if (vid <= this.myDHTLastViewId) {
                return;
            }

            this.myDHTLastViewId = vid;
            List<object[]> old;
            using (var tmpLockObj = new LockAndElevate(this.lastSTKVPSLock)) {
                old = this.lastSTKVPS;
                this.lastSTKVPS = new List<object[]>();
            }

            foreach (object[] oo in old) {
                int idx = 0;
                object kvps = oo[idx++];
                int sendingshard = (int)oo[idx++];
                int versionid = (int)oo[idx++];
                int viewid = (int)oo[idx];
                if (viewid > vid) {
                    using (var tmpLockObj = new LockAndElevate(this.lastSTKVPSLock)) {
                        this.lastSTKVPS.Add(oo);
                    }
                }
                else if (viewid == vid) {
                    this.doDHTPut(kvps, sendingshard, versionid, viewid);
                }
            }
        }

        /// <summary>
        /// Called when the application has modified the GetHashCode method used to map keys to shards
        /// </summary>
        /// <param name="versionId">A positive GetHashCode() "version number" that needs to be identical in all the callers.</param>
        /// <remarks>The GetHashCode method needs to change through a series of consistent totally ordered actions, and
        /// for each change, the same version number should be used by all members.  The number must also increase each time
        /// DHTGetHashCodeChanged is called in any given view (for example, you can just use a counter initialized to 1).
        /// </remarks>
        public void DHTGetHashCodeChanged(int versionId) {
            View theView;
            using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                theView = this.theView;
            }

            if (versionId <= 0 || versionId <= this.lastVersionId[this.GetAffinityGroup(theView.GetMyRank())]) {
                throw new VsyncDHTException("DHTGetHashCodeChanged: version number must be > 0, and must increase each time this method is called in a given view");
            }

            using (var tmpLockObj = new LockAndElevate(this.myDHTGetHashCodeVIDLock)) {
                this.myDHTGetHashCodeVID = versionId;
            }

            this.DHTShuffle(theView, versionId, true);
            for (int i = 0; i < this.myDHTnShards; i++) {
                List<object[]> kvpsl;
                using (var tmpLockObj = new LockAndElevate(this.myDHTGetHashCodeVIDLock)) {
                    kvpsl = this.retainedKVPS[i];
                    this.retainedKVPS[i] = new List<object[]>();
                }

                foreach (object[] oo in kvpsl) {
                    int idx = 0;
                    object kvps = oo[idx++];
                    int sendingshard = (int)oo[idx++];
                    int versionid = (int)oo[idx++];
                    int viewid = (int)oo[idx];
                    this.doDHTPut(kvps, sendingshard, versionid, viewid);
                }
            }

            for (int cnt = 1; cnt < this.myDHTnShards; cnt++) {
                ILock.NoteThreadState("waitForPutSema.WaitOne()");
                this.waitForPutSema.WaitOne();
                ILock.NoteThreadState(null);
            }
        }

        private void DHTShuffle(View nextView) {
            this.DHTShuffle(nextView, 0, false);
        }

        /*
         * Shuffles DHT items that are on the wrong node after a view change or a user change to the GetHashCode() method for keys
         */

        private void DHTShuffle(View nextView, int versionId, bool shuffleMode) {
            if (nextView.members.Length == 0) {
                return;
            }

            View theView;
            using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                theView = this.theView;
            }

            if (theView == null) {
                return;
            }

            int myOldRank = theView.GetMyRank();
            int myNewRank = nextView.GetMyRank();
            int myOldAg = this.GetAffinityGroup(myOldRank), myNewAg = this.GetAffinityGroup(myNewRank), myRankInMyAg = myNewRank / this.myDHTnShards;
            if (myOldRank == -1) {
                return;
            }

            if (!shuffleMode && nextView.leavers.Length > 0) {
                // DHT state reconciliation for existing members that got shifted around by the new view and are no longer in the same affinity group
                // Each member looks for the next DHTRedundancyFactor guys who are now new members of his affinity group, but previously weren't, and sends state
                int rankOfMember = myOldRank;
                int fnd = 0;
                int coverFor = 0;
                for (int cnt = 1; cnt < this.myDHTnShards && (cnt - coverFor - 1) < DHTRedundancyFactor; cnt++) {
                    if (nextView.leavers.Contains(theView.members[(myOldRank + (cnt * this.myDHTnShards)) % theView.members.Length])) {
                        ++coverFor;
                    }
                }

                for (int cnt = 0; cnt < theView.members.Length - 1 && fnd < DHTRedundancyFactor + coverFor; cnt++) {
                    rankOfMember = (rankOfMember + 1) % theView.members.Length;
                    Address who = theView.members[rankOfMember];
                    int rankInNextView = nextView.GetRankOf(who);
                    if (rankInNextView != -1 && this.GetAffinityGroup(rankInNextView) == myOldAg && this.GetAffinityGroup(rankInNextView) != this.GetAffinityGroup(rankOfMember)) {
                        // We found someone who will be in "our" affinity group but isn't currently there
                        ++fnd;
                        List<KeyValuePair<object, DHTItem>> kvps = new List<KeyValuePair<object, DHTItem>>();
                        using (var tmpLockObj = new LockAndElevate(this.DHTDictLock)) {
                            foreach (KeyValuePair<object, DHTItem> item in this.DHTContents) {
                                kvps.Add(item);
                            }
                        }

                        if (kvps.Count > 0) {
                            this.P2PSend(who, Vsync.IM_DHT_PUT, kvps, myNewAg, 0, nextView.viewid);
                        }
                    }
                }

                this.Flush();
            }
            else if (shuffleMode && myRankInMyAg < DHTRedundancyFactor) {
                List<KeyValuePair<object, DHTItem>>[] kvpsl = new List<KeyValuePair<object, DHTItem>>[this.myDHTnShards];
                for (int n = 0; n < this.myDHTnShards; n++) {
                    kvpsl[n] = new List<KeyValuePair<object, DHTItem>>();
                }

                using (var tmpLockObj = new LockAndElevate(this.DHTDictLock)) {
                    foreach (KeyValuePair<object, DHTItem> item in this.DHTContents) {
                        kvpsl[this.GetAffinityGroup(this.DHTKeyHash(item.Key))].Add(item);
                    }

                    for (int n = 0; n < nextView.members.Length; n++) {
                        if (this.GetAffinityGroup(n) != myNewAg) {
                            List<KeyValuePair<object, DHTItem>> kvps = kvpsl[this.GetAffinityGroup(n)];
                            if (kvps.Count > 0) {
                                this.P2PSend(nextView.members[n], Vsync.IM_DHT_PUT, kvps, myNewAg, versionId, nextView.viewid);
                            }
                            else {
                                this.P2PSend(nextView.members[n], Vsync.IM_DHT_PUT, myNewAg, versionId, nextView.viewid);
                            }
                        }
                    }
                }
            }

            if (this.GetAffinityGroup(myOldRank) != this.GetAffinityGroup(myNewRank) || shuffleMode) {
                using (var tmpLockObj = new LockAndElevate(this.DHTDictLock)) {
                    Dictionary<object, DHTItem> old = this.DHTContents;
                    this.DHTContents = new Dictionary<object, DHTItem>(1000);
                    foreach (KeyValuePair<object, DHTItem> item in old) {
                        if (this.GetAffinityGroup(this.DHTKeyHash(item.Key)) == this.GetAffinityGroup(myNewRank)) {
                            this.DHTContents.Add(item.Key, item.Value);
                        }
                    }
                }
            }
        }

        private void DHTCleanup() {
            List<object> toDelete = new List<object>();
            using (var tmpLockObj = new LockAndElevate(this.DHTDictLock)) {
                long now = DateTime.UtcNow.Ticks;
                foreach (KeyValuePair<object, DHTItem> kvp in this.DHTContents) {
                    if ((now - kvp.Value.createTimestamp) / 10000L > this.myDHTItemTimeout) {
                        toDelete.Add(kvp.Key);
                    }
                }

                foreach (object key in toDelete) {
                    this.DHTContents.Remove(key);
                }
            }

            if (!this.usesDHTDefaults) {
                foreach (object key in toDelete) {
                    this.DHTExtWriter(key, null);
                }
            }

            Vsync.OnTimer(this.myDHTItemTimeout, this.DHTCleanup);
        }

        private int GetAffinityGroup(Address a) {
            using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                return (this.theView == null) ? -1 : this.GetAffinityGroup(this.theView, a);
            }
        }

        internal int GetAffinityGroup(View v, Address a) {
            return v.GetRankOf(a) % this.myDHTnShards;
        }

        internal int GetAffinityGroup(int hash) {
            return Math.Abs(hash) % this.myDHTnShards;
        }

        internal int DHTKeyHash(object key) {
            return ((key is int) ? (int)key : key.GetHashCode()) % this.myDHTnShards;
        }

        internal List<Address> GetAgMembers(List<object> keys) {
            List<Address> mlist = new List<Address>();
            bool[] IncludeAg = new bool[this.myDHTnShards];
            foreach (object key in keys) {
                IncludeAg[this.GetAffinityGroup(this.DHTKeyHash(key))] = true;
            }

            View theView;
            using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                theView = this.theView;
            }

            for (int n = 0; n < theView.members.Length; n++) {
                if (IncludeAg[this.GetAffinityGroup(n)]) {
                    mlist.Add(theView.members[n]);
                }
            }

            return mlist;
        }

        // Create something that looks like the group address but indicates the AffinityGroup via the port numbers
        internal Address PseudoAddress(int AffinityGroup) {
            Address pa = this.gaddr;
            pa.p2pPort = pa.ackPort = AffinityGroup;
            pa.cachedHashCode = 0;
            return pa;
        }

        internal int GetAffinityGrpIdx(Address addr) {
            if (addr == Vsync.VSYNCMEMBERS.gaddr) {
                return -1;
            }

            Address a = new Address(addr);
            Address mg = new Address(this.gaddr);
            a.p2pPort = a.ackPort = a.cachedHashCode = 0;
            mg.p2pPort = mg.ackPort = mg.cachedHashCode = 0;
            if (mg == a) {
                return addr.p2pPort;
            }

            return -1;
        }

        /// <summary>
        /// Uses the current group as a DHT and stores a new (key,value) pair, which overwrites any previous one.  
        /// </summary>
        /// <param name="key">key for the object being stored</param>
        /// <param name="value">value of that object</param>
        /// <remarks>DHT put operations aren't totally ordered, hence concurrent Add requests for the same key leave the DHT in an inconsistent state.</remarks>
        public void DHTPut(object key, object value) {
            this.DHTPut(new List<KeyValuePair<object, object>> { new KeyValuePair<object, object>(key, value) });
        }

        internal myHandlers theResolvers = new myHandlers();

        /// <summary>
        /// Polymorphic variant of SetDHTPutCollisionResolver.  
        /// </summary>
        /// <typeparam name="KT">Key type</typeparam>
        /// <typeparam name="VT">Value type</typeparam>
        /// <typeparam name="VTIncoming">Value type for the incoming value that triggered the Put collision</typeparam>
        /// <param name="theResolver">Method with signature VT theResolver(KT,VT,VTIncoming)</param>
        /// <remarks>
        /// This variant of SetDHTPutCollisionResolver allows you to specify multiple resolvers, each with
        /// its own type signature.  If you use this option, Vsync will call the first resolver that matches.
        /// If none matches, Vsync will check to see if there is a universal resolver for the group.
        /// </remarks>
        public void SetDHTPutCollisionResolver<KT, VT, VTIncoming>(Func<KT, VT, VTIncoming, VT> theResolver) {
            if (typeof(KT) == typeof(object) && typeof(VT) == typeof(object) && typeof(VTIncoming) == typeof(object)) {
                this.myResolver = (dynamic)theResolver;
                return;
            }

            this.theResolvers += theResolver;
        }

        /// <summary>
        /// DHTPut for a single key,value pair
        /// </summary>
        /// <typeparam name="KT">Key type</typeparam>
        /// <typeparam name="VT">Value type</typeparam>
        /// <param name="key">key</param>
        /// <param name="value">value</param>
        public void DHTPut<KT, VT>(KT key, VT value) {
            this.DHTPut(new List<KeyValuePair<KT, VT>> { new KeyValuePair<KT, VT>(key, value) });
        }

        /// <summary>
        /// Uses the current group as a DHT and stores a set of new (key,value) pairs, which overwrite any previous ones.   Atomicity is not guaranteed 
        /// </summary>
        /// <param name="kvps">A list of key-value pairs to put</param>
        /// <typeparam name="KT"></typeparam>
        /// <typeparam name="VT"></typeparam>
        /// <remarks>DHT put operations aren't totally ordered, hence concurrent Add requests for the same key leave the DHT in an inconsistent state.</remarks>
        public void DHTPut<KT, VT>(List<KeyValuePair<KT, VT>> kvps) {
            View theView;
            using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                theView = this.theView;
            }

            if (!this.VsyncCallStart()) {
                return;
            }

            if (this.myDHTBinSize == 0) {
                throw new VsyncException("DHTPut: must first call DHTEnable");
            }

            if (this.DHTAgNonEmpty == null) {
                throw new VsyncException("DHTPut: group must be created and initial members should join before first call to DHTPut");
            }

            if (!this.HasFirstView || theView.members.Length < this.myDHTMinSize) {
                throw new VsyncDHTException("DHTPut: group is currently smaller (" + this.theView.members.Length + ") than the minimum required size (" + this.myDHTMinSize + ")");
            }

            foreach (KeyValuePair<KT, VT> kvp in kvps) {
                object key = kvp.Key;
                int khash = this.DHTKeyHash(key);
                FlowControl.FCBarrierCheck();
                int targetAg = this.GetAffinityGroup(khash);
                if (targetAg < 0 || targetAg > this.DHTAgNonEmpty.Length) {
                    throw new VsyncException("DHTPut: key " + key + " mapped to affinity group " + targetAg + " which was outside range of DHTAgNonEmpty[0.." + this.DHTAgNonEmpty.Length + "]");
                }

                if (!this.DHTAgNonEmpty[targetAg]) {
                    Vsync.WriteLine("WARNING: DHTPut called on a <key,value> pair that maps to a depopulated affinity group (hint: maybe the underlying group or the replication factor is too small!)");
                    continue;
                }

                if ((VsyncSystem.Debug & VsyncSystem.DHTS) != 0) {
                    object value = kvp.Value;
                    Vsync.WriteLine("Application called DHTPut with key=" + key + ", value=" + value + ", HashCode = " + this.DHTKeyHash(key) + ", targetAg=" + targetAg);
                }

                try {
                    ILock.NoteThreadState("Wedged.WaitOne()");
                    this.Wedged.WaitOne();
                    ILock.NoteThreadState(null);
                    if (this.myDHTBinSize < 20 || this.myDHTBinSize <= 2 * log2(theView.members.Length) || this.myDHTInDebugMode) {
                        // Until the actual size of an affinity group gets fairly large, send p2p.  But as the number of p2p sends pushes beyond log2, tunnelling will eventually
                        // be preferable despite its higher latency
                        for (int off = targetAg; off < theView.members.Length; off += this.myDHTnShards) {
                            this.P2PSend(theView.members[off], Vsync.IM_DHT_PUT, new List<KeyValuePair<object, DHTItem>> { new KeyValuePair<object, DHTItem>(kvp.Key, new DHTItem(kvp.Value)) });
                        }
                    }
                    else {
                        // We're use the PseudoAddress here as a kind of trick to avoid actually creating N/ReplicationFactor real groups
                        List<KeyValuePair<object, DHTItem>> list = new List<KeyValuePair<object, DHTItem>> { new KeyValuePair<object, DHTItem>(kvp.Key, new DHTItem(kvp.Value)) };
                        this.IPMCTunnel(this.PseudoAddress(this.GetAffinityGroup(khash)), Msg.toBArray(new object[] { Vsync.IM_DHT_PUT, list }));
                    }
                }
                finally {
                    this.Wedged.Release();
                }
            }

            this.VsyncCallDone();
        }

        /// <summary>
        /// Treats the the current group as a DHT and retrieves an object by key
        /// </summary>
        /// <param name="key"></param>
        /// <returns>The value from the (key,value) pair</returns>
        public VT DHTGet<KT, VT>(KT key) {
            List<KeyValuePair<KT, VT>> res = this.DHTGet<KT, VT>(new List<KT> { key });
            if (res.Count > 0) {
                return res[0].Value;
            }

            return default(VT);
        }

        internal static Timeout DHTTimeout = new Timeout(15000, Timeout.TO_NULLREPLY);

        /// <summary>
        /// Treats the the current group as a DHT and retrieves a list of objects by key.  No promise of atomicity
        /// with respect to DHTPut (if that's what you need, use DHTOrderedGet)
        /// </summary>
        /// <param name="ikeys"></param>
        /// <typeparam name="KT"></typeparam>
        /// <typeparam name="VT"></typeparam>
        /// <returns>A list of (key,value) pairs for items that were found</returns>
        public List<KeyValuePair<KT, VT>> DHTGet<KT, VT>(IEnumerable<KT> ikeys) {
            if (!this.VsyncCallStart()) {
                return new List<KeyValuePair<KT, VT>>();
            }

            View theView;
            using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                theView = this.theView;
            }

            List<KT> keys = new List<KT>();
            foreach (KT ik in ikeys) {
                keys.Add(ik);
            }

            if ((VsyncSystem.Debug & VsyncSystem.DHTS) != 0) {
                string ks = " ";
                foreach (KT key in keys) {
                    ks += key + " ";
                }

                Vsync.WriteLine("Application called DHTGet with keys { " + ks + "}");
            }

            if (this.myDHTBinSize == 0) {
                throw new VsyncException("DHTGet: must first call DHTEnable");
            }

            if (this.DHTAgNonEmpty == null) {
                throw new VsyncException("DHTGet: group must be created and initial members should join before first call to DHTPut");
            }

            if (!this.HasFirstView || this.GetSize() < this.myDHTMinSize) {
                throw new VsyncDHTException("DHTGet: group is currently smaller than the minimum required size");
            }

            List<List<KeyValuePair<KT, VT>>> partialResults = new List<List<KeyValuePair<KT, VT>>>();
            IEnumerable<IGrouping<int, KT>> keysGroupedByAg = keys.GroupBy(key => this.GetAffinityGroup(this.DHTKeyHash(key)));
            foreach (IGrouping<int, KT> GroupedKey in keysGroupedByAg) {
                if (this.myDHTBinSize == 0) {
                    throw new VsyncException("DHTGet: must first call DHTEnable");
                }

                int N = theView.members.Length;
                int myBase = theView.GetMyRank();
                int startAt = rand.Next(N);
                int log2N = log2(N);
                int kgrp = GroupedKey.Key;
                Address whoToAsk = null;
                Address dontAsk = null;

                // Note: this logic only makes sense for at most 2 tries!
                for (int retry = 0; retry < 2 && dontAsk != Vsync.my_address; retry++) {
                    try {
                        if (this.GetAffinityGroup(myBase) == kgrp) {
                            whoToAsk = Vsync.my_address;
                        }
                        else {
                            // First check and see if there happens to be a 1-hop neighbor we could ask
                            for (int n = 0; whoToAsk == null && n < log2N; n++) {
                                if (this.GetAffinityGroup((myBase + (1 << n)) % N) == kgrp && (dontAsk == null || theView.members[(myBase + (1 << n)) % N] != dontAsk)) {
                                    whoToAsk = theView.members[(myBase + (1 << n)) % N];
                                }
                            }
                        }

                        // If no luck, check starting at some random location and just take anyone in the right affinity group
                        for (int n = 0; whoToAsk == null && n < theView.members.Length; n++) {
                            if (this.GetAffinityGroup((startAt + n) % N) == kgrp && (dontAsk == null || theView.members[(startAt + n) % N] != dontAsk)) {
                                whoToAsk = theView.members[(startAt + n) % N];
                            }
                        }

                        if (whoToAsk == null) {
                            throw new VsyncException("DHT can't find anyone to ask about keys mapping to DHT affinity group " + kgrp);
                        }

                        List<KT> gk = new List<KT>();
                        foreach (KT grouped in GroupedKey) {
                            gk.Add(grouped);
                        }

                        try {
                            ILock.NoteThreadState("Wedged(DHT).WaitOne()");
                            this.Wedged.WaitOne();
                            ILock.NoteThreadState(null);
                            if (!this.P2PQuery(whoToAsk, DHTTimeout, Vsync.IM_DHT_GET, gk, EOL, partialResults)) {
                                // Two cases: He may have done a nullreply, or he may have actually failed.
                                using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                                    theView = this.theView;
                                }

                                if (theView.GetRankOf(whoToAsk) == -1) {
                                    dontAsk = whoToAsk;
                                }
                            }
                        }
                        finally {
                            this.Wedged.Release();
                        }
                    }
                    catch (VsyncAbortReplyException) {
                        Vsync.WriteLine("DHTGet: AbortReplyException!");
                        dontAsk = whoToAsk;
                    }
                }
            }

            Dictionary<KT, VT> deDuped = new Dictionary<KT, VT>(1000);
            List<KeyValuePair<KT, VT>> results = new List<KeyValuePair<KT, VT>>();
            foreach (List<KeyValuePair<KT, VT>> kvpl in partialResults) {
                foreach (KeyValuePair<KT, VT> res in kvpl) {
                    if (!deDuped.ContainsKey(res.Key)) {
                        deDuped.Add(res.Key, res.Value);
                    }
                }
            }

            foreach (KeyValuePair<KT, VT> res in deDuped) {
                results.Add(res);
            }

            this.VsyncCallDone();
            return results;
        }

        /// <summary>
        /// Atomically and with total order, puts a key,value pair into the DHT
        /// </summary>
        /// <param name="key"></param>
        /// <param name="value"></param>
        /// <typeparam name="KT"></typeparam>
        /// <typeparam name="VT"></typeparam>
        public void DHTOrderedPut<KT, VT>(KT key, VT value) {
            if (!this.VsyncCallStart()) {
                return;
            }

            this.OrderedSend(this.GetAgMembers(new List<object> { key }), Vsync.IM_DHT_PUT, new List<KeyValuePair<object, DHTItem>> { new KeyValuePair<object, DHTItem>(key, new DHTItem(value)) });
            this.VsyncCallDone();
        }

        /// <summary>
        /// Atomically and with total order, puts a set of key,value pairs into the DHT
        /// </summary>
        /// <param name="kvps"></param>
        /// <typeparam name="KT"></typeparam>
        /// <typeparam name="VT"></typeparam>
        public void DHTOrderedPut<KT, VT>(List<KeyValuePair<KT, VT>> kvps) {
            if (!this.VsyncCallStart()) {
                return;
            }

            List<KeyValuePair<KT, DHTItem>> newList = new List<KeyValuePair<KT, DHTItem>>();
            foreach (KeyValuePair<KT, VT> kvp in kvps) {
                newList.Add(new KeyValuePair<KT, DHTItem>(kvp.Key, new DHTItem(kvp.Value)));
            }

            if (newList.Count > 0) {
                this.OrderedSend(this.GetAgMembers(kvps.Select(kvp => (object)kvp.Key).ToList()), Vsync.IM_DHT_PUT, newList);
            }

            this.VsyncCallDone();
        }

        /// <summary>
        /// Atomically and with total order, removes a set of keys from the DHT
        /// </summary>
        /// <param name="keys"></param>
        /// <typeparam name="KT"></typeparam>
        public void DHTOrderedRemove<KT>(IEnumerable<KT> keys) {
            if (!this.VsyncCallStart()) {
                return;
            }

            byte[] b0 = new byte[0];
            List<KeyValuePair<KT, byte[]>> toSend = new List<KeyValuePair<KT, byte[]>>();
            foreach (KT key in keys) {
                toSend.Add(new KeyValuePair<KT, byte[]>(key, b0));
            }

            if (toSend.Count > 0) {
                this.OrderedSend(this.GetAgMembers(keys.Select(k => (object)k).ToList()), Vsync.IM_DHT_PUT, toSend);
            }

            this.VsyncCallDone();
        }

        /// <summary>
        /// Removes the value associated with some set of keys.  Atomicity is not guaranteed
        /// </summary>
        /// <param name="keys"></param>
        /// <typeparam name="KT"></typeparam>
        /// <returns>The value from the (key,value) pair</returns>
        /// <remarks>DHT operations are reliable but not totally ordered, hence DHTRemove for a key shouldn't be issued concurrently with DHTPut operations using the identical key.</remarks>
        public void DHTRemove<KT>(IEnumerable<KT> keys) {
            if (!this.VsyncCallStart()) {
                return;
            }

            foreach (KT key in keys) {
                this.DHTPut(key, new byte[0]);
            }

            this.VsyncCallDone();
        }

        /// <summary>
        /// Removes the value associated with the key.
        /// </summary>
        /// <param name="key"></param>
        /// <typeparam name="KT"></typeparam>
        /// <returns>The value from the (key,value) pair</returns>
        /// <remarks>DHT operations are reliable but not totally ordered, hence DHTRemove for a key shouldn't be issued concurrently with DHTPut operations using the identical key.</remarks>
        public void DHTRemove<KT>(KT key) {
            if (!this.VsyncCallStart()) {
                return;
            }

            this.DHTPut(key, new byte[0]);
            this.VsyncCallDone();
        }

        /// <summary>
        /// Performs a virtually synchronous DHTGet operation for a set of keys, returning a list of (key,value) pairs, deduplicated by key
        /// </summary>
        /// <param name="keys"></param>
        /// <typeparam name="KT"></typeparam>
        /// <typeparam name="VT"></typeparam>
        /// <returns></returns>
        public List<KeyValuePair<KT, VT>> DHTOrderedGet<KT, VT>(IEnumerable<KT> keys) {
            if (!this.VsyncCallStart()) {
                return new List<KeyValuePair<KT, VT>>();
            }

            List<List<KeyValuePair<KT, VT>>> results = new List<List<KeyValuePair<KT, VT>>>();
            List<KT> toSend = new List<KT>();
            foreach (KT key in keys) {
                toSend.Add(key);
            }

            this.OrderedQuery(ALL, DHTTimeout, new QueryKey<KT>(Vsync.my_address, keys, false), Vsync.IM_DHT_GET, toSend, EOL, results);
            Dictionary<KT, VT> deDuped = new Dictionary<KT, VT>(1000);
            foreach (List<KeyValuePair<KT, VT>> rl in results) {
                foreach (KeyValuePair<KT, VT> res in rl) {
                    if (!deDuped.ContainsKey(res.Key)) {
                        deDuped.Add(res.Key, res.Value);
                    }
                }
            }

            List<KeyValuePair<KT, VT>> rv = new List<KeyValuePair<KT, VT>>();
            foreach (KeyValuePair<KT, VT> res in deDuped) {
                rv.Add(res);
            }

            this.VsyncCallDone();
            return rv;
        }

        /// <summary>
        /// Performs a DHTGet operation for a single key, returning the value or null
        /// </summary>
        /// <typeparam name="KT"></typeparam>
        /// <typeparam name="VT"></typeparam>
        /// <param name="key"></param>
        /// <returns></returns>
        /// <remarks>In this case DHTOrderedGet and DHTGet are actually identical</remarks>
        public VT DHTOrderedGet<KT, VT>(KT key) {
            return this.DHTGet<KT, VT>(key);
        }

        internal static Dictionary<Address, bool[]> hmInfo = new Dictionary<Address, bool[]>(1000);

        internal static LockObject hmLock = new LockObject("hmLock");

        internal static int log2(int N) {
            int i;
            for (i = 0; (1 << i) < N; i++) {
            }

            // Rounds down
            if ((1 << i) == N) {
                return i;
            }

            return i - 1;
        }

        internal static int log2RU(int N) {
            int i;
            for (i = 0; (1 << i) < N; i++) {
            }

            return i;
        }

        private static string PHMap(bool[] hm, int nb = int.MaxValue) {
            string bs = " ";
            foreach (bool b in hm) {
                if (nb-- > 0) {
                    bs += (b ? "+" : "-") + " ";
                }
            }

            return bs;
        }

        internal class ddh {
            internal Address dest;

            internal byte[] data;

            internal int hopcnt;

            internal ddh(Address d, byte[] da, int h) {
                this.dest = d;
                this.data = da;
                this.hopcnt = h;
            }
        }

        internal class gsdh {
            internal Address gaddr;

            internal Address sender;

            internal byte[] data;

            internal int hopcnt;

            internal gsdh(Address g, Address s, byte[] da, int h) {
                this.gaddr = g;
                this.sender = s;
                this.data = da;
                this.hopcnt = h;
            }
        }

        internal static LockObject TunnelThreadsLock = new LockObject("TunnelThreadsLock");

        internal static Thread IPMCTunnelThread;

        internal static Thread UDPTunnelThread;

        internal static List<ddh> ddhList = new List<ddh>();

        internal static LockObject ddhLock = new LockObject("ddhLock", ThreadPriority.AboveNormal);

        internal Semaphore ddhNotEmpty = new Semaphore(0, int.MaxValue);

        internal static List<gsdh> gsdhList = new List<gsdh>();

        internal static LockObject gsdhLock = new LockObject("gsdhLock");

        internal Semaphore gsdhNotEmpty = new Semaphore(0, int.MaxValue);

        internal static int nInUDPTunnel() {
            using (var tmpLockObj = new LockAndElevate(ddhLock)) {
                return ddhList.Count;
            }
        }

        internal static int nInIPMCTunnel() {
            using (var tmpLockObj = new LockAndElevate(gsdhLock)) {
                return gsdhList.Count;
            }
        }

        internal class IPMCVinfo {
            internal int IMVid;

            internal Address gaddr;

            internal Address sender;

            internal View v;

            internal IPMCVinfo(int vid, Address ga, Address s, View theView) {
                this.IMVid = vid;
                this.gaddr = ga;
                this.sender = s;
                this.v = theView;
            }
        }

        // These need to spawn threads because they can't risk blocking on the looped-back deliveries via the RECVB bounded buffer
        internal void SetupIMTunnels() {
            this.doRegister(Vsync.BECLIENT, new Action<Address>(this.becomeClientOf));
            this.doRegister(Vsync.IM_UDP_TUNNEL, new Action<Address, byte[], int>((dest, data, hopcnt) => {
                if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0) {
                    Vsync.WriteLine("UDP Tunnel event handler: got a new UDP packet tunnelling to dest=" + dest + ", data.Length=" + data.Length + ", hopcount is " + hopcnt);
                }

                using (var tmpLockObj = new LockAndElevate(ddhLock)) {
                    ddhList.Add(new ddh(dest, data, hopcnt));
                    this.ddhNotEmpty.Release();
                }

                using (var tmpLockObj = new LockAndElevate(TunnelThreadsLock)) {
                    if (UDPTunnelThread == null) {
                        UDPTunnelThread = new Thread(() => {
                            try {
                                while (!VsyncSystem.VsyncActive) {
                                    Vsync.Sleep(250);
                                }

                                while (VsyncSystem.VsyncActive) {
                                    VsyncSystem.RTS.ThreadCntrs[6]++;
                                    this.ddhNotEmpty.WaitOne(1000);
                                    ddh dh;
                                    using (var tmpLockObj1 = new LockAndElevate(ddhLock)) {
                                        dh = ddhList.FirstOrDefault();
                                        if (dh != null) {
                                            ddhList.Remove(dh);
                                        }
                                    }

                                    if (dh != null) {
                                        if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0) {
                                            Vsync.WriteLine("UDP Tunnel event handler calling UDPTunnel: dest=" + dh.dest + ", data.Length=" + dh.data.Length);
                                        }

                                        this.UDPTunnel(dh.dest, dh.data, dh.hopcnt + 1);
                                    }
                                }
                            }
                            catch (VsyncShutdownException) {
                                VsyncSystem.CheckLocksHeld();
                            }

                            VsyncSystem.ThreadTerminationMagic();
                        }) { Name = "IM_UDP_TUNNEL thread", Priority = ThreadPriority.AboveNormal, IsBackground = true };
                        UDPTunnelThread.Start();
                    }
                }
            }));
            this.doRegister(Vsync.IM_IPMC_TUNNEL, new Action<Address, Address, byte[], int>((gaddr, sender, data, hopcnt) => {
                if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0) {
                    Vsync.WriteLine("IPMC Tunnel[ql=" + gsdhList.Count + "] got a new incoming request: this.gaddr=" + this.gaddr + ", dest gaddr=" + gaddr + ", sender=" + sender + ", data length=" + data.Length + ", hopcnt=" + hopcnt);
                }

                using (var tmpLockObj = new LockAndElevate(gsdhLock)) {
                    gsdhList.Add(new gsdh(gaddr, sender, data, hopcnt));
                }

                this.gsdhNotEmpty.Release();
                using (var tmpLockObj = new LockAndElevate(TunnelThreadsLock)) {
                    if (IPMCTunnelThread == null) {
                        IPMCTunnelThread = new Thread(() => {
                            try {
                                while (!VsyncSystem.VsyncActive) {
                                    Vsync.Sleep(250);
                                }

                                while (VsyncSystem.VsyncActive) {
                                    VsyncSystem.RTS.ThreadCntrs[7]++;
                                    this.gsdhNotEmpty.WaitOne(1000);
                                    gsdh gdh;
                                    using (var tmpLockObj1 = new LockAndElevate(gsdhLock)) {
                                        gdh = gsdhList.FirstOrDefault();
                                    }

                                    if (gdh != null) {
                                        gsdhList.Remove(gdh);
                                        int ag = this.GetAffinityGrpIdx(gdh.gaddr);
                                        if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0) {
                                            Vsync.WriteLine("IPMC Tunnel[ql=" + gsdhList.Count + "]  event handler: this.gaddr=" + this.gaddr + ", dest gaddr=" + gdh.gaddr + ((ag == -1) ? string.Empty : ("(affinity group " + ag + ")")) + ", sender=" + gdh.sender + ", data.Length=" + gdh.data.Length);
                                        }

                                        IPMCNextHops(gdh.gaddr, gdh.sender, gdh.hopcnt, (nextHop, nToScan) => {
                                            if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0) {
                                                Vsync.WriteLine("IPMC Tunnel event handler: nextHop will be " + nextHop + " for  gaddr=" + ((ag == -1) ? gdh.gaddr.ToString() : ("(affinity group " + ag + ")")) + ", sender=" + gdh.sender + ", data.Length=" + gdh.data.Length);
                                            }

                                            Vsync.VSYNCMEMBERS.doP2PSend(nextHop, true, Vsync.IM_IPMC_TUNNEL, gdh.gaddr, gdh.sender, gdh.data, nToScan);
                                        });
                                        if ((ag == -1 && Group.doLookup(gdh.gaddr) != null) || (ag >= 0 && Vsync.my_address.GetHashCode() % this.myDHTnShards == ag)) {
                                            IPMCTunnelLoopback(gdh.gaddr, gdh.data);
                                        }
                                    }
                                }
                            }
                            catch (VsyncShutdownException) {
                                VsyncSystem.CheckLocksHeld();
                            }

                            VsyncSystem.ThreadTerminationMagic();
                        }) { Name = "IM_IPMC_TUNNEL thread", Priority = ThreadPriority.AboveNormal, IsBackground = true };
                        IPMCTunnelThread.Start();
                    }
                }
            }));

            BoundedBuffer IPMCbb = new BoundedBuffer("IPMC:BB", 256, ILock.LLIPMC, 0, 1);
            new Thread(() => {
                try {
                    while (!VsyncSystem.VsyncActive) {
                        Vsync.Sleep(250);
                    }

                    while (VsyncSystem.VsyncActive) {
                        VsyncSystem.RTS.ThreadCntrs[8]++;
                        IPMCVinfo vi = (IPMCVinfo)IPMCbb.get();
                        if (vi == null) {
                            break;
                        }

                        IPMCViewCast(vi.IMVid, vi.gaddr, vi.sender, vi.v);
                    }
                }
                catch (VsyncShutdownException) {
                    VsyncSystem.CheckLocksHeld();
                }

                VsyncSystem.ThreadTerminationMagic();
            }) { Name = "IM_IPMCViewCast_TUNNEL thread", IsBackground = true }.Start();

            this.doRegister(Vsync.IM_IPMC_TUNNEL, new Action<int, Address, Address, int, View>((IMVid, gaddr, sender, hopcnt, v) => {
                if (Vsync.VSYNCMEMBERS.HasFirstView && Vsync.VSYNCMEMBERS.theView.viewid == IMVid) {
                    IPMCbb.put(new IPMCVinfo(IMVid, gaddr, sender, v));
                }
                else if (!Vsync.VSYNCMEMBERS.HasFirstView || Vsync.VSYNCMEMBERS.theView.viewid < IMVid) {
                    using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.ViewLock)) {
                        Vsync.VSYNCMEMBERS.stashedIPMCviews.Add(new IPMCVinfo(IMVid, gaddr, sender, v));
                    }
                }

                IPMCNextHops(gaddr, sender, hopcnt, (nextHop, nToScan) => Vsync.VSYNCMEMBERS.doP2PSend(nextHop, true, Vsync.IM_IPMC_TUNNEL, gaddr, sender, nToScan, v));
            }));

            this.doRegister(Vsync.IM_IPMC_VIEWS, new Action<View[]>(vs => {
                foreach (View v in vs) {
                    IPMCNewView(v.gaddr, v);
                }
            }));
        }

        internal void replayStashedVinfo() {
            List<IPMCVinfo> newstash = new List<IPMCVinfo>(), toReplay = new List<IPMCVinfo>();
            using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.ViewLock)) {
                View IMv = Vsync.VSYNCMEMBERS.theView;
                foreach (IPMCVinfo vi in this.stashedIPMCviews) {
                    if (vi.IMVid > IMv.viewid) {
                        newstash.Add(vi);
                    }
                    else if (vi.IMVid == IMv.viewid) {
                        toReplay.Add(vi);
                    }
                }

                this.stashedIPMCviews = newstash;
            }

            if (toReplay.Count > 0) {
                new Thread(() => {
                    try {
                        foreach (IPMCVinfo vi in toReplay) {
                            IPMCViewCast(vi.IMVid, vi.gaddr, vi.sender, vi.v);
                        }
                    }
                    catch (VsyncShutdownException) {
                        VsyncSystem.CheckLocksHeld();
                    }

                    VsyncSystem.ThreadTerminationMagic();
                }) { Name = "ReplayStashedVinfo", IsBackground = true }.Start();
            }
        }

        // Just sends directly 
        internal void UDPTunnel(Address dest, byte[] data, int hopcnt) {
            Vsync.VSYNCMEMBERS.UDPTunnel(dest, 0, data, hopcnt);
        }

        internal class ShortCutInfo {
            internal Address who;

            internal Address gaddr;

            internal ShortCutInfo(Address w, Address g) {
                this.who = w;
                this.gaddr = g;
            }
        }

        internal static List<ShortCutInfo> AllShortCuts = new List<ShortCutInfo>();

        internal static LockObject ShortCutsLock = new LockObject("ShortCutsLock", ThreadPriority.Highest);

        internal Dictionary<Address, bool> ShortCuts = new Dictionary<Address, bool>(1000);

        internal void UpdateShortCuts(View v) {
            List<ShortCutInfo> scl = new List<ShortCutInfo>();
            Group g = Group.doLookup(v.gaddr);
            if (g == null) {
                return;
            }

            if (g == Vsync.ORACLE && Vsync.ClientOf == null) {
                foreach (Address a in g.theView.members) {
                    if (!a.isMyAddress()) {
                        scl.Add(new ShortCutInfo(a, g.gaddr));
                    }
                }
            }
            else {
                tokenInfo theToken;
                using (var tmpLockObj = new LockAndElevate(g.TokenLock)) {
                    theToken = g.theToken;
                }

                if ((g.flags & Group.G_ISLARGE) != 0 && theToken != null) {
                    for (int level = 0; level < theToken.nlevels; level++) {
                        if (theToken.next[level] != null && !theToken.next[level].isMyAddress()) {
                            scl.Add(new ShortCutInfo(theToken.next[level], v.gaddr));
                        }

                        if (theToken.last[level] != null && !theToken.last[level].isMyAddress()) {
                            scl.Add(new ShortCutInfo(theToken.last[level], v.gaddr));
                        }
                    }
                }
            }

            using (var tmpLockObj = new LockAndElevate(ShortCutsLock)) {
                this.ShortCuts = new Dictionary<Address, bool>(1000);
                foreach (ShortCutInfo sci in scl) {
                    if (!this.ShortCuts.ContainsKey(sci.who)) {
                        this.ShortCuts.Add(sci.who, true);
                    }
                }

                foreach (ShortCutInfo sci in AllShortCuts) {
                    if (sci.gaddr != v.gaddr) {
                        scl.Add(sci);
                    }
                }

                AllShortCuts = scl;
            }
        }

        // Sends but "jiggers" the route for retransmission attempts
        internal void UDPTunnel(Address dest, int jigger, byte[] data, int hopcnt) {
            if (hopcnt > 10) {
                if ((VsyncSystem.Debug & VsyncSystem.DISCARDS) != 0) {
                    Vsync.WriteLine("WARNING: Discarding a packet in UDPTunnel: hopcnt>10");
                }

                using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                    ++VsyncSystem.RTS.Discarded;
                }

                return;
            }

            View v = null;
            if (!Vsync.VSYNC_LARGE) {
                using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.ViewLock)) {
                    v = Vsync.VSYNCMEMBERS.theView;
                }
            }
            else {
                using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.TokenLock)) {
                    if (Vsync.VSYNCMEMBERS.theToken != null) {
                        v = Vsync.VSYNCMEMBERS.theToken.WorkingView;
                    }
                }
            }

            if (v == null) {
                if ((VsyncSystem.Debug & VsyncSystem.DISCARDS) != 0) {
                    Vsync.WriteLine("WARNING: Discarding a packet in UDPTunnel: the working view is null");
                }

                using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                    ++VsyncSystem.RTS.Discarded;
                }

                return;
            }

            if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0) {
                Vsync.WriteLine("UDP Tunnel sender method: dest=" + dest + ", jigger=" + jigger + " data length=" + data.Length);
            }

            if (dest.isMyAddress()) {
                if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0) {
                    Vsync.WriteLine("UDP Tunnel: I'm the destination! loop back");
                }

                IPMCTunnelLoopback(this.gaddr, data);
                return;
            }

            int mybaseRank = v.GetMyRank();
            int destRank = v.GetRankOf(dest);
            int N = v.members.Length;
            if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0) {
                Vsync.WriteLine("MybaseRank=" + mybaseRank + ", destRank=" + destRank + ", N=" + N);
            }

            // This next line is the core of the UDP emulation layer, and what we do is to forward the packet
            // in hops.  Start by assuming jigger is always 0.
            // For example to reach the member with rank 5 from a sender who happens to have rank 0 in a group of size 9,
            // this code computes log2((9-0+5) mod 9), which is log2(5), hence 2.  Call this k.  The code then 
            // then forwards it to member (1<<k), which is member 4.
            // Member 4 receives it, and it computes log2((9-4+5)%9), which is log2(1), which is k=0.  So member 4
            // forwards it member 5.
            // Now think about the same scenario but sending from 5 back to 0, same group of size 9
            // First we compute (9-5+0)%9, and we end up with 4.
            // Now we compute log2(4)=2, then 1<<2, which is 4 again.
            // Add 5 back in and we have 9, mod 9, giving 0.  So we forward directly from member 5 to member 0.
            // This has the effect of maintaining log(N) links from each node in VSYNCMEMBERS to the nodes at offsets N/2, N/4, N/8, etc to the "right",
            // wrapping as we get to N.  So we need log(N) TCP links and can reach all N members in log(N) hops, worst case
            // The "jigger" parameter is used when retransmitting UDP packets to avoid having a single failure "disconnect" the whole subtree of nodes below
            // the failed node.  When retransmitting, this forces us to use the "wrong" first hop if non-zero.  By virtue of that the second and subsequent messages
            // still follow an optimal route, but it isn't always the same route.  To do this we just change which of the log(N) outgoing links we use for the
            // first hop, unless the first hop would have taken us directly to the target node.
            // So... the "trueTargetOffset" looks at how far the actual destination is to the "right" of me in the view
            int trueTargetOffset = (N - mybaseRank + destRank) % N;

            // The base2 log of the offset rounds down and determines which TCP overlay link we'll use: N/2, N/4, ... 0
            int l2OfTrueOffset = log2(trueTargetOffset);

            // That TCP overlay link takes us to some node, call it the "selected" target.  Compute it's offset to the right of me
            int selectedTargetOffset = 1 << l2OfTrueOffset;

            // If we're retransmitting and the target isn't the next hop...
            if (jigger != 0 && selectedTargetOffset != trueTargetOffset) {
                // Carefully apply the jigger, making sure we don't accidently exceed log2(N)
                selectedTargetOffset = 1 << ((l2OfTrueOffset + jigger) % (log2(N) + 1));
            }

            // Now apply the selected target offset to my own base rank, mod N, and that gives the node to which we'll send the UDP packet
            bool isShortCut;
            using (var tmpLockObj = new LockAndElevate(ShortCutsLock)) {
                this.ShortCuts.TryGetValue(dest, out isShortCut);
            }

            if (mybaseRank == -1 || destRank == -1 || trueTargetOffset == (1 << l2OfTrueOffset) || isShortCut) {
                if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0) {
                    Vsync.WriteLine("UDPTunnel... ReliableSender.P2PSend: dest=" + dest + ", mybaseRank=" + mybaseRank + ", destRank=" + destRank + ", using direct TCPSendTo");
                }

                ReliableSender.P2PSend(dest, dest.p2pPort, data, ReliableSender.RECVBB);
                return;
            }

            if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0) {
                Vsync.WriteLine("UDPTunnel.... ReliableSender.doP2PSend: dest= " + dest + "... computed target " + v.members[(mybaseRank + selectedTargetOffset) % N] + ", using mybaseRank=" + mybaseRank + ", destRank=" + destRank + ", N=" + N + ", trueTargetOffset=" + trueTargetOffset + ", l2ofTrueTargetOffset=" + l2OfTrueOffset + ", selectedTargetOffset=" + selectedTargetOffset);
            }

            Address target = v.members[(mybaseRank + selectedTargetOffset) % N];
            this.doP2PSend(target, true, Vsync.IM_UDP_TUNNEL, dest, data, hopcnt);
        }

        internal void IPMCTunnel(Address gaddr, byte[] data) {
            if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0) {
                Vsync.WriteLine("IPMC Tunnel sender method: this.gaddr=" + this.gaddr + ", argument gaddr=" + gaddr + ", data.Length=" + data.Length);
            }

            if (Group.doLookup(gaddr) != null) {
                IPMCTunnelLoopback(gaddr, data);
            }

            IPMCNextHops(gaddr, Vsync.my_address, int.MaxValue, (nextHop, nToScan) => {
                if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0) {
                    Vsync.WriteLine("IPMC Tunnel next hop will be via " + nextHop + " for message to gaddr=" + gaddr + ", data.Length=" + data.Length);
                }

                Vsync.VSYNCMEMBERS.doP2PSend(nextHop, true, Vsync.IM_IPMC_TUNNEL, gaddr, Vsync.my_address, data, nToScan);
            });
        }

        private static void IPMCTunnelLoopback(Address gaddr, byte[] data) {
            object[] obs = Msg.BArrayToObjects(data);
            Group g = Group.Lookup(gaddr);
            g.doP2PSend(Vsync.my_address, true, (int)obs[0], obs[1]);
        }

        internal static void IPMCViewCast(int IMVid, Address gaddr, Address sender, View v) {
            View IMv = null;
            if (!Vsync.VSYNC_LARGE) {
                using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.ViewLock)) {
                    IMv = Vsync.VSYNCMEMBERS.theView;
                }
            }
            else {
                using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.TokenLock)) {
                    if (Vsync.VSYNCMEMBERS.theToken != null) {
                        IMv = Vsync.VSYNCMEMBERS.theToken.WorkingView;
                    }
                }
            }

            if (IMv == null || IMv.viewid != IMVid) {
                return;
            }

            if (gaddr == Vsync.VSYNCMEMBERS.gaddr) {
                // When membership changes, we need to reset all the forwarding tables because the algorithm is dependent on the view of VSYNCMEMBERS
                if (Vsync.ClientOf == null && Vsync.ORACLE.HasFirstView && Vsync.ORACLE.theView.GetMyRank() == 0) {
                    List<View> theViews = new List<View>();
                    using (var tmpLockObj = new LockAndElevate(Group.TPGroupsLock)) {
                        foreach (KeyValuePair<Address, Group> kvp in Group.TPGroups) {
                            Group tpg = kvp.Value;
                            if (tpg.theView != null && tpg.gaddr != Vsync.VSYNCMEMBERS.gaddr) {
                                theViews.Add(tpg.theView);
                            }
                        }
                    }

                    Vsync.VSYNCMEMBERS.doSend(false, false, Vsync.IM_IPMC_VIEWS, theViews.ToArray());
                }

                Vsync.VSYNCMEMBERS.replayStashedVinfo();
                return;
            }

            // This case is used when some single group has a membership change.  Logic requires that these P2P messages be delivered after the IM_IPMC_VIEWS multicast
            // associated with the most recent VSYNCMEMBERS membership update.
            if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0) {
                Vsync.WriteLine("IPMCViewCast[" + Vsync.my_address + "]: gaddr=" + gaddr + ", sender=" + sender + ", View=" + v);
            }

            IPMCNewView(gaddr, v);
            IPMCNextHops(gaddr, sender, int.MaxValue, (nextHop, nToScan) => {
                if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0) {
                    Vsync.WriteLine("IPMCViewCast[" + Vsync.my_address + "] next hop will be via " + nextHop + " for gaddr=" + gaddr + ", sender=" + sender + ", View=" + v);
                }

                if (nextHop == sender) {
                    throw new VsyncException("IPMCNextHops: trying to forward back to the originator of a multicast!");
                }

                Vsync.VSYNCMEMBERS.doP2PSend(nextHop, true, Vsync.IM_IPMC_TUNNEL, IMv.viewid, gaddr, sender, nToScan, v);
            });
        }

        // This guy does a callback to the designated action routine for each next hop the data should take
        internal static void IPMCNextHops(Address gaddr, Address sender, int nToScan, Action<Address, int> action) {
            if (!Vsync.VSYNCMEMBERS.HasFirstView) {
                if ((VsyncSystem.Debug & VsyncSystem.DISCARDS) != 0) {
                    Vsync.WriteLine("DISCARD (no first view): IPMCNextHops: gaddr=" + gaddr + ", sender=" + sender + ", nToScan=" + nToScan);
                }

                return;
            }

            View v = null;
            using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.TokenLock)) {
                if (Vsync.VSYNCMEMBERS.theToken != null) {
                    v = Vsync.VSYNCMEMBERS.theToken.WorkingView;
                }
            }

            if (v == null) {
                using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.ViewLock)) {
                    v = Vsync.VSYNCMEMBERS.theView;
                }
            }

            int myBase = v.GetMyRank();
            int sbase = v.GetRankOf(sender);
            int N = v.members.Length;
            int ag = Vsync.VSYNCMEMBERS.GetAffinityGrpIdx(gaddr);
            if (sbase <= myBase) {
                sbase += N;
            }

            bool[] hm = null;
            if (gaddr == Vsync.VSYNCMEMBERS.gaddr) {
                hm = new bool[log2(v.members.Length) + 1];

                // With each hop deeper into the tree, halve the link span that we'll look at
                if (nToScan > hm.Length) {
                    nToScan = hm.Length;
                }

                for (int b = 0; b < nToScan; b++) {
                    hm[b] = true;
                }

                if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0) {
                    Vsync.WriteLine("IPMC Tunnel: dest is VSYNCMEMBERS, setting hm = {" + PHMap(hm) + "}");
                }
            }
            else if (ag >= 0) {
                hm = new bool[Vsync.VSYNCMEMBERS.myDHTnShards];
                if (nToScan > hm.Length) {
                    nToScan = hm.Length;
                }

                for (int b = 0; b < nToScan; b++) {
                    hm[b] = Vsync.VSYNCMEMBERS.DHTHMaps[ag, b];
                }

                if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0) {
                    Vsync.WriteLine("IPMC Tunnel: is an artificial DHT affinity subgroup with hm = {" + PHMap(hm) + "}");
                }
            }
            else {
                bool[] hmm;
                using (var tmpLockObj = new LockAndElevate(hmLock)) {
                    hmInfo.TryGetValue(gaddr, out hmm);
                }

                if (hmm != null) {
                    hm = new bool[hmm.Length];
                    if (nToScan > hm.Length) {
                        nToScan = hm.Length;
                    }

                    for (int b = 0; b < nToScan; b++) {
                        hm[b] = hmm[b];
                    }
                }

                if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0) {
                    Vsync.WriteLine("IPMC Tunnel: is an artificial DHT affinity subgroup of an application group, hencing using hm = {" + PHMap(hm) + "}");
                }
            }

            if (hm == null || myBase == -1) {
                if ((VsyncSystem.Debug & (VsyncSystem.TUNNELING | VsyncSystem.DISCARDS)) != 0) {
                    Vsync.WriteLine("WARNING: IPMC tunnel ignoring a packet with gaddr=" + gaddr + ", sender=" + sender + ", pseudoDepth=" + nToScan + " (couldn't find the group, or my own rank)");
                }

                using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                    VsyncSystem.RTS.Discarded++;
                }

                return;
            }

            // The idea below is pretty simple, but sometimes simple things are hard to write down.  Suppose that my rank is 0 and I want to broadcast.
            // I would send a packet on every link I'm allowed to use, namely to the member at 1, 2, ... N/2
            // Notice that this would be log2(N) packets sent.  But to whom should each receiver forward?
            // At the next "depth" in the forwarding tree, the guy I sent to via my first link out shouldn't forward: he doesn't look at "any" links
            // The guy I reached via my second link out should forward only on his own first link: he looks at link 0
            // The guy I reached via my third link out should forward on on his first two links, etc.
            // Next level down repeats this idea
            // So we get a kind of tree: shallow on its left, log2(N) deep if we follow its extreme right side to the bottom
            // Any given multicast always tracks down the binary tree that we saw "looking down" from its sender (the root)
            // Surprisingly, the actual rule used is pretty simple, once you visualize it this way
            if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0) {
                string slist = " ";
                for (int i = 1; i < v.members.Length; i <<= 1) {
                    slist += v.members[(myBase + i) % N];
                }

                Vsync.WriteLine("IPMC Tunnel: gaddr=" + gaddr + ", sender=" + sender + ", myBase=" + myBase + ", sbase=" + sbase + ", nToScan=" + nToScan + ", v.members=" + Address.VectorToString(v.members) + ", hm = {" + PHMap(hm) + "} in skiplist= {" + slist + "}");
            }

            for (int k = 0; k < hm.Length; k++) {
                if (hm[k]) {
                    if ((myBase + (1 << k)) < sbase) {
                        if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0) {
                            Vsync.WriteLine("IPMC Tunnel: Sending a copy to v.members[" + (1 << k) + "]=" + v.members[(myBase + (1 << k)) % N]);
                        }

                        action(v.members[(myBase + (1 << k)) % N], k);
                    }
                }
            }
        }

        internal static LockObject IPMCNewViewLock = new LockObject("IPMCNewViewLock");

        internal static View TunnelView;

        internal static void IPMCNewView(Address gaddr, View v) {
            using (var tmpLockObj = new LockAndElevate(IPMCNewViewLock)) {
                if (gaddr == Vsync.VSYNCMEMBERS.gaddr) {
                    if (TunnelView != null && v.viewid <= TunnelView.viewid) {
                        return;
                    }

                    TunnelView = v;

                    // VSYNCMEMBERS view changed: recompute everything
                    Dictionary<Address, bool[]> oldhmInfo;
                    using (var tmpLockObj1 = new LockAndElevate(hmLock)) {
                        hmInfo = new Dictionary<Address, bool[]>(1000);
                        oldhmInfo = hmInfo;
                    }

                    doIPMCNewView(gaddr, v);
                    foreach (KeyValuePair<Address, bool[]> kvp in oldhmInfo) {
                        if (kvp.Key == gaddr) {
                            continue;
                        }

                        Group g = Group.Lookup(kvp.Key) ?? TrackingProxyLookup(kvp.Key);
                        if (g != null && g.HasFirstView) {
                            doIPMCNewView(kvp.Key, g.theView);
                        }
                    }
                }
                else {
                    doIPMCNewView(gaddr, v);
                }
            }
        }

        // This housekeeping method updates the skiplist: true if I have any members down the link
        // from me to the guy at offset 2^k to my right, for k=0...log2(N), false if not
        internal static void doIPMCNewView(Address gaddr, View v) {
            int myBase = v.GetMyRank();
            int N = v.members.Length;
            if (myBase == -1) {
                using (var tmpLockObj = new LockAndElevate(hmLock)) {
                    if (hmInfo.ContainsKey(gaddr)) {
                        hmInfo.Remove(gaddr);
                    }
                }

                return;
            }

            bool[] hasMembers = new bool[log2(N) + 1];
            foreach (Address m in v.members) {
                if (!m.isMyAddress()) {
                    for (int rankOf = 0; rankOf < N; rankOf++) {
                        if (m == v.members[(rankOf + myBase) % N]) {
                            hasMembers[log2(rankOf)] = true;
                            break;
                        }
                    }
                }
            }

            using (var tmpLockObj = new LockAndElevate(hmLock)) {
                // Safely delete the old map if it had one, then remember this new mapping
                if (hmInfo.ContainsKey(gaddr)) {
                    hmInfo.Remove(gaddr);
                }

                hmInfo.Add(gaddr, hasMembers);
            }
        }

        internal void becomeClientOf(Address who) {
            if (Vsync.ClientOf == null && Vsync.ORACLE.theView.GetMyRank() != -1) {
                // The multicast reaches all system members, but (obviously) ORACLE members ignore it
                return;
            }

            if (Vsync.ClientOf != null && Vsync.ClientOf != who) {
                using (var tmpLockObj = new LockAndElevate(Vsync.RIPLock)) {
                    if (!Vsync.RIPList.Contains(Vsync.ClientOf)) {
                        Vsync.RIPList.Add(Vsync.ClientOf);
                    }
                }
            }

            Vsync.ClientOf = who;
            Vsync.OracleFailedAt = 0;
            Vsync.ORACLE.theView.members[0] = who;
            Group g;
            if ((g = Group.Lookup(Vsync.ORACLE.gname)) != null) {
                g.GroupClose();
            }

            ILock.Barrier(ILock.LLWAIT, ILock.LCLIENTOF).BarrierRelease(1);
        }

        private void sortThenDeliverInOrder() {
            Address[] Senders;
            int[] vids, msgids;
            this.GenerateOrdering(out Senders, out vids, out msgids, true);
        }

        private void GenerateOrdering(out Address[] senders, out int[] vids, out int[] msgids, bool flushing) {
            using (var tmpLockObj = new LockAndElevate(this.OutOfOrderQueueLock)) {
                if ((VsyncSystem.Debug & VsyncSystem.ORDEREDSEND) != 0) {
                    Vsync.WriteLine("Vsync.ORDEREDSEND: GenerateOrdering, flushing=" + flushing);
                }

                if (flushing) {
                    if ((VsyncSystem.Debug & VsyncSystem.ORDEREDSEND) != 0) {
                        int cnt = 0;
                        foreach (Msg m in this.OutOfOrderQueue) {
                            if (m.ordered) {
                                ++cnt;
                            }
                        }

                        if (this.desiredOrderQueue.Count != 0 || cnt > 0) {
                            string doq = " ", moq = " ";
                            foreach (svi sv in this.desiredOrderQueue) {
                                doq += sv.sender + "::" + sv.vid + ":" + sv.msgid + " ";
                            }

                            foreach (Msg m in this.OutOfOrderQueue) {
                                moq += m.sender + "::" + m.vid + ":" + m.msgid + (m.ordered ? "*ordered" : string.Empty) + " ";
                            }

                            Vsync.WriteLine("GenerateOrdering: During flush found DesiredOrderQueue = {" + doq + "}, OutOfOrderQueue = { " + moq + "}");
                        }
                    }

                    this.desiredOrderQueue = new List<svi>();
                    this.OutOfOrderQueue.Sort();
                }

                int idx = 0;
                foreach (Msg m in this.OutOfOrderQueue) {
                    if (!flushing && m.ordered) {
                        continue;
                    }

                    ++idx;
                }

                senders = new Address[idx];
                vids = new int[idx];
                msgids = new int[idx];
                idx = 0;
                foreach (Msg m in this.OutOfOrderQueue) {
                    if (!flushing && m.ordered) {
                        continue;
                    }

                    m.ordered = true;
                    senders[idx] = m.sender;
                    vids[idx] = m.vid;
                    msgids[idx] = m.msgid;
                    ++idx;
                }
            }

            if (flushing) {
                if ((VsyncSystem.Debug & VsyncSystem.ORDEREDSEND) != 0) {
                    Vsync.WriteLine("SortThenDeliverInOrder<" + this.gname + ">: " + this.OrderToString(senders, vids, msgids));
                }

                this.DeliverInOrder("Vsync.SortThenDeliverInOrder", senders, vids, msgids);
                this.desiredOrderQueue = new List<svi>();
                using (var tmpLockObj = new LockAndElevate(this.OutOfOrderQueueLock)) {
                    this.OutOfOrderQueue = new List<Msg>();
                    this.OutOfOrderQueueCount = 0;
                }
            }
            else if ((VsyncSystem.Debug & VsyncSystem.ORDEREDSEND) != 0) {
                Vsync.WriteLine("GenerateOrdering<" + this.gname + ">: " + this.OrderToString(senders, vids, msgids));
            }
        }

        internal bool onDOQ(Msg m) {
            using (var tmpLockObj = new LockAndElevate(this.OutOfOrderQueueLock)) {
                foreach (svi sviQE in this.desiredOrderQueue) {
                    if (sviQE.vid == m.vid && sviQE.msgid == m.msgid && sviQE.sender == m.sender) {
                        return true;
                    }
                }

                return false;
            }
        }

        internal void DeliverInOrder(string cfrom, Address[] senders, int[] vids, int[] msgids) {
            int vid = -1;
            using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                if (this.theView != null) {
                    vid = this.theView.viewid;
                }
            }

            using (var tmpLockObj = new LockAndElevate(this.OutOfOrderQueueLock)) {
                for (int n = 0; n < senders.Length; n++) {
                    if (vids[n] < vid) {
                        continue;
                    }

                    foreach (svi sviQE in this.desiredOrderQueue) {
                        if (sviQE.vid == vids[n] && sviQE.msgid == msgids[n] && sviQE.sender == senders[n]) {
                            throw new VsyncException("OrderedSend: multiple orderings for " + senders[n] + "::" + vids[n] + ":" + msgids[n]);
                        }
                    }

                    this.desiredOrderQueue.Add(new svi(senders[n], vids[n], msgids[n]));
                }

                List<Msg> toDeliver = new List<Msg>();
                svi sv;
                while ((sv = this.desiredOrderQueue.FirstOrDefault()) != null) {
                    if (sv.vid < vid) {
                        this.desiredOrderQueue.RemoveAt(0);
                        continue;
                    }

                    bool fnd = false;
                    List<Msg> newOOQ = new List<Msg>();
                    foreach (Msg m in this.OutOfOrderQueue) {
                        if (m.vid == sv.vid && m.msgid == sv.msgid && m.sender == sv.sender) {
                            this.desiredOrderQueue.RemoveAt(0);
                            if (fnd) {
                                throw new VsyncException("DeliverInOrder<" + cfrom + ">: Duplicate redelivery of " + m.sender + "::" + m.vid + ":" + m.msgid);
                            }

                            fnd = true;
                            m.type = Msg.REDELIVERY;
                            toDeliver.Add(m);
                        }
                        else {
                            newOOQ.Add(m);
                        }
                    }

                    this.OutOfOrderQueue = newOOQ;
                    this.OutOfOrderQueueCount = this.OutOfOrderQueue.Count;
                    if (!fnd) {
                        break;
                    }
                }

                if (toDeliver.Count > 0) {
                    this.incomingSends.putFront(toDeliver);
                }
            }
        }

        internal void GotLastSeqns(int vid, int[] LastSeqns) {
            if (this == Vsync.ORACLE || this.PendingQueue == null || (this.flags & G_ISLARGE) != 0) {
                // Before first view is known, or in ORACLE (which has a special structure), or in large groups, which implement view synchrony in a different way
                return;
            }

            using (var tmpLockObj = new LockAndElevate(this.PendingQueueLock)) {
                if (this.theView.viewid != vid) {
                    throw new VsyncException("GotLastSeqns: theView.vid=" + this.theView.viewid + ", but GotLastSeqns has vid=" + vid);
                }

                int myRank = this.theView.GetMyRank();
                if (myRank == -1) {
                    return;
                }

                this.theView.LastMsg = LastSeqns;
                for (int i = 0; i < LastSeqns.Length; i++) {
                    if (i == myRank || LastSeqns[i] == this.theView.NextIncomingMsgID[1 + i]) {
                        this.PendingQueue[1 + i] = null;
                    }
                }

                if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                    using (var tmpLockObj1 = new LockAndElevate(ReliableSender.ackInfoLock)) {
                        ReliableSender.ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: GotLastSeqns: nullify PendingQueue for <" + this.gname + ">" + Environment.NewLine);
                    }
                }
            }
        }

        internal bool IAmLeader() {
            View theView;
            using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                theView = this.theView;
            }

            if (!this.HasFirstView || theView.hasFailed == null) {
                return false;
            }

            return theView.IAmLeader();
        }

        internal bool IAmRank0() {
            View theView;
            using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                theView = this.theView;
            }

            return theView.IAmRank0();
        }

        internal int nLive() {
            int n = 0;
            foreach (bool b in this.theView.hasFailed) {
                if (!b) {
                    ++n;
                }
            }

            return n;
        }

        /// <exclude>
        /// <summary>
        /// Internal, used to ensure that lists of Groups can be sorted
        /// </summary>
        /// <returns>A hashcode for this group</returns>
        /// </exclude>
        public override int GetHashCode() {
            return this.gaddr.GetHashCode();
        }

        /// <summary>
        /// Looks up a group by Address
        /// </summary>
        /// <param name="gaddr">An Address for the desired group</param>
        /// <returns>a Group object, or null if not found</returns>
        public static Group Lookup(Address gaddr) {
            if (gaddr == null || Vsync.ORACLE == null || Vsync.VSYNCMEMBERS == null || gaddr == Vsync.ORACLE.gaddr || gaddr == Vsync.VSYNCMEMBERS.gaddr) {
                return null;
            }

            using (var tmpLockObj = new LockAndElevate(VsyncGroupsLock)) {
                Group g;
                if (VsyncGroups.TryGetValue(gaddr, out g)) {
                    return g;
                }
            }

            return null;
        }

        internal static Group Lookup(int vaddr) {
            using (var tmpLockObj = new LockAndElevate(VsyncGroupsLock)) {
                foreach (KeyValuePair<Address, Group> kvp in VsyncGroups) {
                    if (kvp.Value.myVirtIPAddr == vaddr) {
                        return kvp.Value;
                    }
                }
            }

            return null;
        }

        internal static Group doLookup(Address gaddr) {
            if (gaddr == null) {
                return null;
            }

            using (var tmpLockObj = new LockAndElevate(VsyncGroupsLock)) {
                Group g;
                if (VsyncGroups.TryGetValue(gaddr, out g)) {
                    return g;
                }
            }

            if (Vsync.ORACLE != null && gaddr == Vsync.ORACLE.gaddr) {
                return Vsync.ORACLE;
            }

            if (Vsync.VSYNCMEMBERS != null && gaddr == Vsync.VSYNCMEMBERS.gaddr) {
                return Vsync.VSYNCMEMBERS;
            }

            return null;
        }

        /// <summary>
        /// Looks up a group by name
        /// </summary>
        /// <param name="gname">the group name</param>
        /// <returns>a Group object, or null if not found</returns>
        public static Group Lookup(string gname) {
            if (gname.Equals("ORACLE", StringComparison.Ordinal) || gname.Equals("VSYNCMEMBERS", StringComparison.Ordinal)) {
                return null;
            }

            using (var tmpLockObj = new LockAndElevate(VsyncGroupsLock)) {
                foreach (KeyValuePair<Address, Group> kvp in VsyncGroups) {
                    if (kvp.Value.gname.Equals(gname, StringComparison.Ordinal)) {
                        return kvp.Value;
                    }
                }
            }

            return null;
        }

        internal static Group doLookup(string gname) {
            using (var tmpLockObj = new LockAndElevate(VsyncGroupsLock)) {
                foreach (KeyValuePair<Address, Group> kvp in VsyncGroups) {
                    if (kvp.Value.gname.Equals(gname, StringComparison.Ordinal)) {
                        return kvp.Value;
                    }
                }
            }

            if (gname.Equals("ORACLE", StringComparison.Ordinal)) {
                return Vsync.ORACLE;
            }

            return null;
        }

        /// <summary>
        /// Gets the current View of a group.  
        /// </summary>
        /// <returns>the current view of the group</returns>
        /// <remarks>
        /// The View is a central property of the Vsync model.  Learn more about it by reading about
        /// <it>virtual synchrony</it>.  With the View you can build very sophisticated workload sharing and fault-tolerance mechanisms
        /// easily and with confidence in their correctness.
        /// </remarks>
        public View GetView() {
            return this.theView;
        }

        /// <summary>
        /// Gets the name of a group
        /// </summary>
        /// <returns>the group name</returns>
        public string GetName() {
            return this.gname;
        }

        private string PFlags(int flags) {
            if (flags == 0) {
                return string.Empty;
            }

            string s = string.Empty;
            for (int n = 0; (1 << n) <= flags; n++) {
                if ((flags & (1 << n)) != 0) {
                    s += flagNames[n] + " ";
                }
            }

            return "{ " + s + "}";
        }

        /// <exclude>
        /// <summary>
        /// Internal, pretty-prints the state of a group for debugging purposes
        /// </summary>
        /// <returns>string representing the group state</returns>
        /// </exclude>
        public override string ToString() {
            try {
                if (this == Vsync.ORACLE && Vsync.ClientOf != null) {
                    return "ORACLE requests: I access the ORACLE remotely as a client of " + Vsync.ClientOf;
                }

                tokenInfo theToken;
                View theView;
                int msgid;
                using (var tmpLockObj = new LockAndElevate(this.TokenLock))
                using (var tmpLockObj1 = new LockAndElevate(this.ViewLock)) {
                    theToken = this.theToken;
                    theView = this.theView;
                    msgid = this.nextMsgid;
                }

                int f;
                string ssNeeded = string.Empty;
                using (var tmpLockObj = new LockAndElevate(this.GroupFlagsLock)) {
                    f = this.flags;
                    if (this.HasFirstView) {
                        string psr = string.Empty;
                        if (theView.PendingSends.Count > 0) {
                            psr = ", " + theView.PendingSends.Count + " PendingSend records (minMsgId=" + theView.PendingSends.First().msgid + ")";
                        }

                        ssNeeded = ", " + (theView.minStable > theView.lastStabilitySent ? "Need" : "Don't need") + " to send stability info (last sent at " + Vsync.MsToSecs(this.SentStableAt) + "; MaxBacklogSent=" + this.CurrentBacklog + psr + ")";
                    }
                }

                string repAddr = "[VirtIP: " + MCMDSocket.PMCAddr(this.myVirtIPAddr) + ", PhysIP: " + MCMDSocket.PMCAddr(this.myPhysIPAddr) + "]";
                string s = !this.HasFirstView ? string.Empty : (Environment.NewLine + "    " + theView);
                s = "group <" + this.gname + (this.where == null ? string.Empty : "(created by " + this.where + ")") + ">... gaddr " + this.gaddr + this.PFlags(f) + ", IP address " + repAddr + s + Environment.NewLine + "    My recieved multicast count " + this.rcvdMcastsCnt + ", rate " + this.rcvdMcastsRate + ", next outgoing msgid " + msgid + ssNeeded;
                if ((this.flags & G_ISLARGE) != 0 && !this.isTrackingProxy) {
                    if (theToken != null) {
                        s += Environment.NewLine + "      " + theToken;
                    }
                    else {
                        s += Environment.NewLine + "      .... Token still uninitialized";
                    }

                    s += Environment.NewLine + "      Large-group garbage collection has collected messages with (vid:id) in range (*:[0-" + this.gcollectedTo + "])";
                }

                using (var tmpLockObj = new LockAndElevate(this.groupLock))
                using (var tmpLockObj1 = new LockAndElevate(this.curMsgListLock)) {
                    foreach (KeyValuePair<Thread, Msg> kvp in this.curMsgList) {
                        s += Environment.NewLine + "  Thread " + (kvp.Key.Name ?? "(unnamed)") + " is currently busy delivering " + kvp.Value;
                    }
                }

                if (this.incomingSends != null) {
                    using (var tmpLockObj = new LockAndElevate(this.incomingSends.Lock)) {
                        if (this.incomingSends.fullSlots > 0) {
                            s += Environment.NewLine + "      A user-level delay during multicast delivery has allowed multicasts to enqueue (count=" + this.incomingSends.fullSlots + "):";
                            for (int i = 0; i < this.incomingSends.fullSlots; i++) {
                                object o = this.incomingSends.theBuffer[(this.incomingSends.gNext + i) % this.incomingSends.size];
                                if (o == null) {
                                    s += Environment.NewLine + "        (null entry: EOF)";
                                }
                                else if (o.GetType() == typeof(Msg)) {
                                    s += Environment.NewLine + "        Incoming multicast ready for delivery: " + o;
                                }
                                else if (o.GetType() == typeof(View)) {
                                    s += Environment.NewLine + "        " + o;
                                }
                            }
                        }
                    }
                }

                if (this.incomingP2P != null) {
                    using (var tmpLockObj = new LockAndElevate(this.incomingP2P.Lock)) {
                        if (this.incomingP2P.fullSlots > 0) {
                            s += Environment.NewLine + "      A user-level delay during p2p delivery has allowed p2p messages to enqueue (count=" + this.incomingP2P.fullSlots + "):";
                            for (int i = 0; i < this.incomingP2P.fullSlots; i++) {
                                object o = this.incomingP2P.theBuffer[(this.incomingSends.gNext + i) % this.incomingSends.size];
                                if (o == null) {
                                    s += Environment.NewLine + "        (null entry: EOF)";
                                }
                                else if (o.GetType() == typeof(Msg)) {
                                    s += Environment.NewLine + "        Incoming P2P ready for delivery: " + o;
                                }
                                else if (o.GetType() == typeof(View)) {
                                    s += Environment.NewLine + "        " + o;
                                }
                            }
                        }
                    }
                }

                using (var tmpLockObj = new LockAndElevate(this.ToDoLock)) {
                    foreach (Msg m in this.ToDo) {
                        s += Environment.NewLine + "      ToDo: " + m;
                    }
                }

                using (var tmpLockObj = new LockAndElevate(this.P2PStashLock)) {
                    foreach (Msg m in this.P2PStash) {
                        s += Environment.NewLine + "      Stashed: " + m;
                    }
                }

                if (this.PendingQueue != null) {
                    using (var tmpLockObj = new LockAndElevate(this.PendingQueueLock)) {
                        for (int i = 0; i < this.PendingQueue.Length; i++) {
                            if (this.PendingQueue[i] == null || this.PendingQueue[i].Count == 0) {
                                continue;
                            }

                            s += Environment.NewLine + "      PendingQueue";
                            if ((this.flags & G_ISLARGE) == 0) {
                                if (i > 0) {
                                    s += " for sender " + theView.members[i - 1];
                                }
                                else {
                                    s += " from ORACLE";
                                }
                            }

                            s += ":";
                            foreach (KeyValuePair<long, Msg> kvp in this.PendingQueue[i]) {
                                s += Environment.NewLine + "            " + kvp.Value;
                            }
                        }
                    }
                }

                using (var tmpLockObj = new LockAndElevate(this.CausalOrderListLock)) {
                    if (this.CausalOrderList.Count > 0) {
                        s += Environment.NewLine + "      CausalSend multicasts awaiting delivery (myVT = " + VTtoString(theView.myVT) + "):";
                        foreach (ctuple ct in this.CausalOrderList) {
                            s += Environment.NewLine + "        " + VTtoString(ct.theVT) + " " + ct.theMsg;
                        }
                    }
                }

                using (var tmpLockObj = new LockAndElevate(this.OutOfOrderQueueLock)) {
                    if (this.OutOfOrderQueue.Count > 0) {
                        s += Environment.NewLine + "      Known ordering information: { ";
                        foreach (svi sv in this.desiredOrderQueue) {
                            s += "[" + sv.sender + "::" + sv.vid + ":" + sv.msgid + "] ";
                        }

                        s += "}" + Environment.NewLine + "      Totally Ordered Sends Awaiting Order Info (ql=" + this.OutOfOrderQueueCount + "):";
                        foreach (Msg m in this.OutOfOrderQueue) {
                            s += Environment.NewLine + "        " + m;
                        }
                    }
                }

                using (var tmpLockObj = new LockAndElevate(this.OrderedSubsetListLock)) {
                    if (this.OrderedSubsetPQ.Count > 0) {
                        s += Environment.NewLine + "      Subset multicasts awaiting order information (myTS=" + this.myTS + "):";
                        foreach (KeyValuePair<osspq, Msg> kvp in this.OrderedSubsetPQ) {
                            s += Environment.NewLine + "             " + kvp;
                        }
                    }
                }

                using (var tmpLockObj = new LockAndElevate(this.UnstableLock)) {
                    if (this.Unstable != null && this.Unstable.Count > 0) {
                        s += Environment.NewLine + "      Unstable multicast messages: {";
                        foreach (Msg m in this.Unstable) {
                            s += " " + m.sender + "[" + m.vid + ":" + m.msgid + "]";
                        }

                        s += " }";
                    }
                }

                return s;
            }
            catch (Exception e) {
                return "Unable to print state of group " + (this.gname ?? "(name unknown)") + " because " + e;
            }
        }

        /// <exclude>
        /// <summary>
        /// Internal, pretty-prints the state of a group for debugging purposes
        /// </summary>
        /// <returns>string representing the group state</returns>
        /// </exclude>
        public static string GetState() {
            string state = string.Empty;
            List<Group> isClone = new List<Group>();
            using (var tmpLockObj = new LockAndElevate(VsyncGroupsLock)) {
                foreach (KeyValuePair<Address, Group> kvp in VsyncGroups) {
                    isClone.Add(kvp.Value);
                }
            }

            if (isClone.Count != 0) {
                state += "GROUPS:" + Environment.NewLine;
                foreach (Group g in isClone) {
                    if (g != Vsync.ORACLE) {
                        try {
                            state += GetGroupState(g) + "   ----------------------------------------------------------------------------------------------------" + Environment.NewLine;
                        }
                        catch (Exception) {
                            if (g.gname != null) {
                                state += "Vsync threw an exception while trying to print the state of group <" + g.gname + ">";
                            }
                        }
                    }
                }
            }

            state += "MEMBERSHIP ORACLE:" + Environment.NewLine + (Vsync.ORACLE == null ? "NO ORACLE" : GetGroupState(Vsync.ORACLE));
            using (var tmpLockObj = new LockAndElevate(TPGroupsLock)) {
                if (TPGroups.Count != 0) {
                    state += "    TRACKING PROXIES:" + Environment.NewLine;
                    foreach (KeyValuePair<Address, Group> kvp in TPGroups) {
                        Group tpg = kvp.Value;
                        try {
                            state += "       " + Group.TPtoString(tpg) + Environment.NewLine;
                        }
                        catch (Exception) {
                            if (tpg.gname != null) {
                                state += "Vsync threw an exception while trying to print the state of group <" + tpg.gname + ">";
                            }
                        }
                    }
                }
            }

            if (Vsync.Proposed != null && Vsync.Proposed.Length > 0) {
                state += "    PROPOSED VIEW DELTAS:" + Environment.NewLine;
                foreach (Vsync.ViewDelta vd in Vsync.Proposed) {
                    state += "        " + vd + Environment.NewLine;
                }
            }

            state += vgGetState() + Environment.NewLine;
            state += dumpStash();
            return state;
        }

        private static string GetGroupState(Group g) {
            string s = "   " + (g.GroupOpen ? string.Empty : "** CLOSED **") + g + Environment.NewLine;
            if ((g.flags & G_ISLARGE) != 0) {
                s += g.LGRelayGetState();
            }
            else {
                s += g.AggState();
            }

            s += g.GetLockState();
            if ((g.flags & G_USESOOB) != 0) {
                s += OOBState(g, false);
            }

            return s;
        }

        /// <summary>
        /// Associate a name with a group.
        /// </summary>
        /// <param name="gname">the group name</param>
        /// <remarks>
        /// Rarely used, this method associates a group name with a group.  For a durable group the name is typically a file name 
        /// in the global file system and will be the file in which group keys and checkpoint data is saved by Vsync.  Access to the
        /// file plays a central role in the Vsync protection scheme: users who can't access that file can't access the group key
        /// and hence can't see the data if the group is a secured one.  In fact Vsync has no admission control policies of its own:
        /// it just rides along on the file system security architecture in this sense.
        /// </remarks>
        public void Bind(string gname) {
            if (this.GroupOpen) {
                return;
            }

            this.gname = gname;
        }

        internal void SetMap(string where, int[] mm) {
            this.myVirtIPAddr = mm[MCMDSocket.VIRTUAL];
            this.myPhysIPAddr = mm[MCMDSocket.PHYSICAL];
            MCMDSocket.SetMap(where, this.gname, false, mm);
        }

        internal void NewView(View v, string calledFrom, int[] curMap) {
            View nv = null;
            this.NewView(v, calledFrom, curMap, ref nv);
        }

        internal void NewView(View v, string calledFrom, int[] curMap, ref View nv) {
            bool hadFirstView = this.HasFirstView;
            if ((VsyncSystem.Debug & (VsyncSystem.MSGIDS | VsyncSystem.VIEWCHANGE | VsyncSystem.STARTSEQ)) != 0) {
                Vsync.WriteLine("ENTERING NEWVIEW[caller:" + calledFrom + "]: Group " + this.gname + ",  with new view=" + v);
            }

            if (v.viewid > 0 && v.members.Length > 0 && v.joiners.Contains(v.members[0])) {
                // This can happen if a group loses its (only) current member just as someone is joining...
                this.InitializeGroup(v);
            }

            if (this.isTrackingProxy) {
                // These are used only by the ORACLE to track groups on behalf of their members
                // and by clients to track the ORACLE itself
                using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                    this.theView = v;
                    this.nextMsgid = 0;
                }

                if (!hadFirstView && v.joiners.Length == 0) {
                    v.joiners = new[] { Vsync.my_address };
                }

                this.HasFirstView = true;
                replayStash(this);
                List<byte[]> ae = this.IPMCArrivedEarly;
                List<ReliableSender.MReplayMe> mae = this.MsgArrivedEarly;
                this.IPMCArrivedEarly = null;
                this.MsgArrivedEarly = null;
                MCMDSocket.drainIPMCArrivedEarly(ae);
                this.drainEarlyArrivalMsgQ(mae);
                if (v.members.Length == 0) {
                    using (var tmpLockObj = new LockAndElevate(TPGroupsLock)) {
                        TPGroups.Remove(this.gaddr);
                    }
                }

                return;
            }

            if (!this.HasFirstView) {
                if (!this.gname.Equals("ORACLE", StringComparison.Ordinal) && v.GetMyRank() == -1) {
                    Vsync.WriteLine("NewView: I'm not actually IN the first view for " + this.gname + Environment.NewLine + "The view is " + v);
                    return;
                }

                using (var tmpLockObj = new LockAndElevate(this.ToDoLock)) {
                    if (this.ToDo.Count > 0) {
                        List<Msg> newToDo = new List<Msg>();
                        foreach (Msg m in this.ToDo) {
                            if (m.vid >= v.viewid) {
                                newToDo.Add(m);
                            }
                        }

                        this.ToDo = newToDo;
                        this.ToDoCount = this.ToDo.Count;
                    }
                }
            }

            if ((this.flags & G_ISLARGE) == 0 || !this.HasFirstView) {
                using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                    this.nextMsgid = 0;
                }
            }

            if (curMap != null) {
                if (this != Vsync.ORACLE || Vsync.ClientOf == null) {
                    this.SetMap("Newview<" + this.gname + ">", curMap);
                }

                ReliableSender.StartGroupReader(this);
            }

            this.opqDrain();
            if (v.joiners.Length > 0) {
                foreach (Address who in v.joiners) {
                    this.WatchEvent(who, W_JOIN);
                }
            }

            if (v.leavers.Length > 0) {
                foreach (Address who in v.leavers) {
                    this.WatchEvent(who, W_LEAVE);
                }
            }

            if (this.theView != null && this.theView.viewid >= v.viewid) {
                if ((VsyncSystem.Debug & VsyncSystem.GROUPEVENTS) != 0) {
                    Vsync.WriteLine("NEWVIEW: IGNORE view update for Group " + this.gname + ", " + v);
                }

                return;
            }

            if ((VsyncSystem.Debug & VsyncSystem.GROUPEVENTS) != 0) {
                Vsync.WriteLine("NEWVIEW(" + calledFrom + "): Group " + this.gname + ", " + v);
            }

            SortedList<long, Msg>[] oldPendingQueue = this.PendingQueue;
            int PQlen;
            if ((this.flags & G_ISLARGE) == 0) {
                PQlen = v.members.Length + 1;

                // In small groups, we flush when changing views, hence Unstable can be discarded.  In large groups, the rule is different
                using (var tmpLockObj = new LockAndElevate(this.UnstableLock)) {
                    this.Unstable = new List<Msg>();
                    this.UnstableCount = 0;
                }
            }
            else {
                PQlen = 2;
            }

            if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                using (var tmpLockObj = new LockAndElevate(ReliableSender.ackInfoLock)) {
                    ReliableSender.ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: newview: reinitialize PendingQueue for <" + this.gname + ">" + Environment.NewLine);
                }
            }

            using (var tmpLockObj = new LockAndElevate(this.PendingQueueLock)) // Synchronized with GotAMsg, which is a real-time procedure that needs to be rather nimble...
            using (var tmpLockObj1 = new LockAndElevate(this.ViewLock)) {
                this.sortThenDeliverInOrder();
                this.finalizePendingSafeSends(v);
                if (v.joiners.Length > 0) {
                    if (this.theChkptChoser == null && v.IAmLeader()) {
                        using (var tmpLockObj2 = new LockAndElevate(this.theChkptMakersLock)) {
                            v.theChkptMakers = this.theChkptMakers;
                        }
                    }
                    else if (this.theChkptChoser != null) {
                        foreach (Address who in v.joiners) {
                            if (this.theChkptChoser(v, who)) {
                                using (var tmpLockObj2 = new LockAndElevate(this.theChkptMakersLock)) {
                                    v.theChkptMakers = this.theChkptMakers;
                                }

                                break;
                            }
                        }
                    }
                }

                this.theView = v;
                this.nRaw = 0;
                this.receivedOrderedSends = false;
                for (int i = 0; i < this.myDHTnShards; i++) {
                    this.lastVersionId[i] = -1;
                }

                nv = v;
                this.incomingSends.put(v);
                SortedList<long, Msg>[] oldPQ = this.PendingQueue;
                this.PendingQueue = new SortedList<long, Msg>[PQlen];
                this.PendingQueueCount = 0;
                for (int i = 0; i < PQlen; i++) {
                    this.PendingQueue[i] = new SortedList<long, Msg>();
                }

                if (oldPQ != null && (VsyncSystem.Debug & VsyncSystem.DISCARDS) != 0) {
                    foreach (SortedList<long, Msg> sl in oldPQ) {
                        if (sl != null && sl.Count > 0) {
                            string ms = " ";
                            foreach (KeyValuePair<long, Msg> kvp in sl) {
                                ms += kvp.Value.sender + "::" + kvp.Value.vid + ":" + kvp.Value.msgid + " ";
                            }

                            Vsync.WriteLine("WARNING: Newview<" + this.gname + ">: When installing view " + v.viewid + " found and discarded undelivered retained messages {" + ms + "}");
                        }
                    }
                }
            }

            using (var tmpLockObj = new LockAndElevate(this.CausalOrderListLock)) {
                this.CausalOrderList = new List<ctuple>();
                this.CausalOrderListCount = 0;
            }

            this.HasFirstView = true;
            if ((this.flags & G_ISLARGE) == 0) {
                this.resetSGAggregations();
            }

            if (oldPendingQueue != null) {
                new Thread(() => {
                    try {
                        for (int oldi = 0; oldi < oldPendingQueue.Length && (this.GroupOpen || !this.WasOpen); oldi++) {
                            if (oldPendingQueue[oldi] != null) {
                                foreach (KeyValuePair<long, Msg> kvp in oldPendingQueue[oldi]) {
                                    if (kvp.Value.vid >= v.viewid) {
                                        this.GotAMsg(kvp.Value, Msg.MULTICAST, "Newview");
                                    }
                                    else {
                                        if ((VsyncSystem.Debug & VsyncSystem.DISCARDS) != 0) {
                                            Vsync.WriteLine("Discarding a duplicate in NewView: message had a stale viewid");
                                        }

                                        using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                            ++VsyncSystem.RTS.Discarded;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    catch (VsyncShutdownException) {
                        VsyncSystem.CheckLocksHeld();
                    }

                    VsyncSystem.ThreadTerminationMagic();
                }) { Name = "replay OldPendingQueue contents in g.NewView()", IsBackground = true }.Start();
            }

            if (this.durabilityMethod != null) {
                this.durabilityMethod.NewView(v);
                if (v.GetMyRank() == 0 && !this.IAmSafeSendLeader) {
                    this.durabilityMethod.PlayBack();
                }
            }

            replayStash(this);
            this.theView.isFinal = false;
            this.GroupOpen = true;
            ReliableSender.resetTheToken(this);
            this.UpdateShortCuts(v);

            if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.VIEWWAIT)) != 0) {
                Vsync.WriteLine("Releasing LLINITV barrier lock for gaddr " + this.gaddr + "(Lock [" + ILock.LLINITV + "][" + ILock.GetLockId(ILock.LLINITV, this.gaddr.GetHashCode()) + "])");
            }

            ILock.Barrier(ILock.LLINITV, this.gaddr).BarrierReleaseAll();
            if (v.members.Length == 0) {
                this.GroupClose();
            }
        }

        /* Reset aggregation info in a small group */

        private void resetSGAggregations() {
            if (!this.HasFirstView) {
                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                    Vsync.WriteLine("Reinitialize the AggList<" + this.gname + "> called but HasFirstView=false");
                }

                return;
            }

            View theView;
            using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                theView = this.theView;
            }

            int N = theView.members.Length;
            if (N == 0) {
                return;
            }

            LinkedList<object>[] oldAggList;
            using (var tmpLockObj = new LockAndElevate(this.AggListLock)) {
                oldAggList = this.AggList;
                int nlevels = log2RU(N) + 1;
                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                    Vsync.WriteLine("Reinitialize the AggList<" + this.gname + "> for VID=" + theView.viewid + "[nlevels=" + nlevels + "] from the AggTypes List in <" + this.gname + ">... (it lists " + this.AggTypes.Count + " types)");
                }

                this.AggList = new LinkedList<object>[nlevels];
                binfo.resetBarrierList();
                for (int n = 0; n < nlevels; n++) {
                    this.AggList[n] = new LinkedList<object>();
                    foreach (AggInfo ag in this.AggTypes) {
                        if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                            Vsync.WriteLine("Calling constructor in <" + this.gname + "> to allocate a new aggregator of type " + ag.KVT);
                        }

                        // These are actually "aggregator" objects of some derived type
                        this.AggList[n].AddLast(ag.myFactory.Invoke(new[] { this, theView.viewid, n, ag.theDel, ag.theTimeout }));
                    }
                }
            }

            if (oldAggList != null) {
                foreach (LinkedList<object> item in oldAggList) {
                    foreach (IAggregateEventHandler ae in item) {
                        ae.AggEvent(Group.BreakWaits, theView.viewid, null, null, 0);
                    }
                }
            }
        }

        // Takes advantage of the fact that commit has the effect of also making anything in the SS list atomic
        // The list is sorted in a standard order and now all members of View v will also have the same list contents
        // So, we can safely deliver these messages prior to installing the new view.
        private void finalizePendingSafeSends(View v) {
            SortedList<SUTW, Msg> newSSList = new SortedList<SUTW, Msg>();
            using (var tmpLockObj = new LockAndElevate(this.SSLock)) {
                foreach (KeyValuePair<SUTW, Msg> ss in this.SSList) {
                    if (!ss.Key.commitFlag) {
                        ss.Key.commitFlag = true;

                        // The value picked must be larger than anything on the queue but also deterministic: all group members must use the same value for the same message.
                        // We also prefer to respect the ordering on message id's.  This particular TS should do the trick: these messages will move to the end of the queue
                        // and then be delivered in msgid order, ties broken by sender id
                        ss.Key.Who = ss.Key.Sender;
                        ss.Key.TS = int.MaxValue - 10000 + ss.Value.msgid;
                        if ((VsyncSystem.Debug & VsyncSystem.SAFESEND) != 0) {
                            Vsync.WriteLine("SAFEDELIVER[FINALIZE]: " + ss.Value.sender + "::" + ss.Value.vid + ":" + ss.Value.msgid + "... SET ORDER: " + ss.Key.Sender + "::*+" + (ss.Key.TS - (int.MaxValue - 10000)));
                        }

                        newSSList.Add(ss.Key, ss.Value);
                    }
                    else {
                        newSSList.Add(ss.Key, ss.Value);
                    }
                }

                this.SSList = newSSList;
                if ((VsyncSystem.Debug & VsyncSystem.SAFESEND) != 0) {
                    Vsync.WriteLine("SAFESEND[FINALIZE]: Queue after completion and resorting: ");
                    foreach (KeyValuePair<SUTW, Msg> ss in this.SSList) {
                        Vsync.WriteLine("      (UID=" + ss.Key.Sender + "::" + ss.Key.Uid + "): " + ss.Value.sender + "::" + ss.Value.vid + ":" + ss.Value.msgid + "... ORDER: " + ss.Key.Who + "::" + (ss.Key.TS > 10000 ? ss.Key.TS - (int.MaxValue - 10000) : ss.Key.TS) + ")");
                    }
                }

                this.deliverSSItems();
            }
        }

        private void drainEarlyArrivalMsgQ(List<ReliableSender.MReplayMe> mae) {
            if (mae == null || mae.Count == 0) {
                return;
            }

            new Thread(() => {
                try {
                    foreach (ReliableSender.MReplayMe m in mae) {
                        ReliableSender.GotIncoming(m.type, m.gaddr, m.sender, m.minStable, m.msg, false);
                    }
                }
                catch (VsyncShutdownException) {
                    VsyncSystem.CheckLocksHeld();
                }

                VsyncSystem.ThreadTerminationMagic();
            }) { Name = "MsgDrain for <" + this.gname + ">", Priority = ThreadPriority.AboveNormal, IsBackground = true }.Start();
        }

        /// <summary>
        /// Event code designating that the watched process has joined the group
        /// </summary>
        public const int W_JOIN = 0;

        /// <summary>
        /// Event code designating that the watched process has left the group
        /// </summary>
        public const int W_LEAVE = 1;

        internal void WatchEvent(Address who, int ev) {
            myWatches mwl = this.Watch[who];
            if (mwl == null) {
                return;
            }

            foreach (Watcher w in mwl.hList) {
                w(ev);
            }
        }

        /// <summary>
        /// Register a handler for incoming multicasts or queries in the group.
        /// </summary>
        /// <param name="request">The id for the requests corresponding to this handler</param>
        /// <param name="del">A request handler; it will be called for messages with matching id and type signatures</param>
        /// <remarks>
        /// A process setting up a group uses Register to register a handler for a specific request identifier, which will be a small integer
        /// counting up from 0.  The delegate is of any type you wish, and there can be multiple handlers for the same request type.  When Vsync
        /// receives a message in a group it will invoke all handlers for which types exactly match.  Unfortunately, Vsync can't do sophisticated
        /// type inference at this time, so it expects exact matches: if a class Dog extends Animal, and a handler defines some argument of type
        /// Animal, that handler won't be invoked for an incoming message containing a Dog, even though a Dog is an Animal.  Sorry!
        /// </remarks>
        public void RegisterHandler(int request, Delegate del) {
            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            this._RegisterHandler(request, del);
        }

        internal class ChkptMkr {
            private readonly Group myGroup;

            public ChkptMkr(Group g) {
                this.myGroup = g;
            }

            public static ChkptMkr operator +(ChkptMkr a, ChkptMaker maker) {
                a.myGroup.RegisterMakeChkpt(maker);
                return a;
            }

            public static ChkptMkr operator -(ChkptMkr a, ChkptMaker maker) {
                a.myGroup.UnRegisterMakeChkpt(maker);
                return a;
            }
        }

        internal ChkptMkr MakeChkpt;

        /// <summary>
        /// A process setting up a group uses RegisterMakeChkpt to register a method that will create a checkpoint
        /// for storage into a file (when terminating the group) or for state-transfer to a new joining member.
        /// </summary>
        /// <param name="maker">checkpoint making procedure, of type ChkptMaker</param>
        public void RegisterMakeChkpt(ChkptMaker maker) {
            using (var tmpLockObj = new LockAndElevate(this.theChkptMakersLock)) {
                this.theChkptMakers.Add(maker);
            }
        }

        /// <summary>
        /// A process setting up a group uses RegisterMakeChkpt to register a method that will create a checkpoint
        /// for storage into a file (when terminating the group) or for state-transfer to a new joining member.
        /// </summary>
        /// <param name="maker">checkpoint making procedure, of type ChkptMaker</param>
        public void UnRegisterMakeChkpt(ChkptMaker maker) {
            using (var tmpLockObj = new LockAndElevate(this.theChkptMakersLock)) {
                this.theChkptMakers.Remove(maker);
            }
        }

        /// <summary>
        /// This API is used in situations where the checkpoint for a joining member must be from a source
        /// that depends on who the joiner is.  It cannot be used by the application if the group is using the
        /// the Vsync DHT, which has its own special choser, because only one choser function can be specified per group
        /// </summary>
        /// <param name="choser">Called once per joining member in all group members who were in the prior view, returns true in the single member who will 
        /// make the checkpoint on behalf of that joining member.  Notice that if many members all join at once, different sources can send the checkpoint
        /// for different receivers.  We highly recommend aiming for that kind of parallelism if you will have large numbers of joiners.  The DHT
        /// uses this scheme because for any given joiner, only certain group members are suitable checkpoint senders</param>
        /// <remarks>Using this API, a group designer can control which group member is selected to send state transfers, on a joiner by joiner basis.
        /// The method will be invoked in parallel at all group members as a new view is about to be installed, and each returns true or false.  The intent is
        /// that just one returns true for any particular joiner; it will create a checkpoint, which will be sent to that joiner.
        /// 
        /// For example, in a group that internally replicates data in multiple patterns (perhaps, it shards a relational database, with each shard
        /// on a different subset of the group members), when a new member joins a shard, the state transfer should be for that shard.  In such cases
        /// you can use a CheckpointChoser function to select the lowest ranked member in the same shard as the joiner.  If you selected some random
        /// member, or always transferred state from the rank-0 member (the leader) of the group, as in the default behavior for Vsync, the sender
        /// wouldn't have that shard and hence couldn't send the needed state.
        /// 
        /// Clearly, this entire approach makes sense only if you can define a selector function that operates purely on the member's Address and the
        /// membership of the group.  For example, you might take the hashcode of an address and compute that value modulo some integer K to map the 
        /// members into the range 0..K-1.  These K "subgroups" could then play the role of shard groups.  Vsync can support fancier mappings that might
        /// depend on other information, but you would need to be sure that all members have the identical state when the choser is invoked.
        /// 
        /// WARNING: If every member returns false, the joiner hangs waiting for state transfer, then a timeout for the join occurs, and the new member will be
        /// dropped from the system (it will throw a "poison" exception).  Conversely, if the member that offers to do the state transfer crashes, the join
        /// will fail, throwing a "join failed" exception.
        /// </remarks>
        public void RegisterChkptChoser(ChkptChoser choser) {
            if (this.theChkptChoser != null && this.theChkptChoser != choser) {
                throw new VsyncException("RegisterChkptChoser: Attempt to register two checkpoint chosers for group <" + this.gname + ">");
            }

            this.theChkptChoser = choser;
        }

        internal class ChkptLdr {
            private readonly Group myGroup;

            public ChkptLdr(Group g) {
                this.myGroup = g;
            }

            public static ChkptLdr operator +(ChkptLdr a, Delegate loader) {
                a.myGroup.RegisterLoadChkpt(loader);
                return a;
            }
        }

        internal ChkptLdr LoadChkpt;

        /// <summary>
        /// Register a checkpoint loading method
        /// </summary>
        /// <param name="loader">Checkpoint loading method</param>
        /// <remarks>        
        /// A process setting up a group uses RegisterLoadChkpt to define a method that will load a checkpoint as part of
        /// a state-transfer to initialize joining members if the group already is active when they join
        /// </remarks>
        public void RegisterLoadChkpt(Delegate loader) {
            this.RegisterHandler(Vsync.STATEXFER, loader);
            this.flags |= G_NEEDSTATEXFER;
        }

        private static int tsl;

        internal bool CheckPointFileExists() {
            return File.Exists(this.myCheckpointFile + ".chkpt");
        }

        internal void LoadCheckpointFromFile() {
            for (int retry = 0; retry < 3; retry++) {
                try {
                    byte[] lb = new byte[4];
                    this.myChkptStream = new FileStream(this.myCheckpointFile + ".chkpt", FileMode.Open);
                    while (this.myChkptStream.Read(lb, 0, 4) == 4) {
                        int len = (lb[3] << 24) | (lb[2] << 16) | (lb[1] << 8) | lb[0];
                        if (len < 0 || len > Vsync.VSYNC_MAXMSGLEN + 1024) {
                            throw new VsyncException("Group <" + this.gname + ">: corrupted checkpoint file[len=" + len + " must be within 0.." + (Vsync.VSYNC_MAXMSGLEN + 1024) + "]");
                        }

                        byte[] buffer = new byte[len];
                        if (this.myChkptStream.Read(buffer, 0, len) != len) {
                            throw new IOException("unexpected EOF");
                        }

                        if (!Msg.VerifySignature(buffer, 0, len)) {
                            throw new VsyncException("Group <" + this.gname + ">: corrupted checkpoint file[signature verification failed]");
                        }

                        if (this.userSpecifiedKey) {
                            this.decipherBuf(buffer);
                        }

                        object[] obs = Msg.BArrayToObjects(buffer);
                        object[] args = new object[obs.Length + 1];
                        args[0] = Vsync.STATEXFER;
                        for (int i = 0; i < obs.Length; i++) {
                            args[i + 1] = obs[i];
                        }

                        this.cbAction(null, -1, -1, Vsync.my_address, args);
                    }

                    this.myChkptStream.Close();
                    this.myChkptStream = null;
                    return;
                }
                catch (Exception) {
                }
            }

            throw new VsyncException("LoadCheckPointFromFile: I/O exception");
        }

        // Old style
        internal void doRegister(int request, Delegate del) {
            this._RegisterHandler(request, del);
        }

        private void _RegisterHandler(int request, Delegate del) {
            this.Handlers[request] += new CallBack(false, del);
        }

        private RNGCryptoServiceProvider AesSeed;

        /// <summary>
        /// Places a group into secure mode, selecting a new randomly generated AES key for the initial create, and later reading the
        /// key from the checkpoint .hdr file when a new member joins.
        /// </summary>
        /// <remarks>In this mode, Vsync stores the key in plain text form in the .hdr file, and checkpoints are also
        /// unencrypted.  Thus anyone with file system permissions could gain access to the group data.  Use the overload
        /// of SetSecure lat lets you specify a key that you manage the key outside of Vsync if you want to avoid this particular threat. </remarks>
        public void SetSecure() {
            if (this.GroupOpen) {
                throw new VsyncException("Illegal to call SetSecure after Group.Join");
            }

            if (this.myCheckpointFile == null) {
                throw new VsyncException("Setsecure: To have Vsync pick a group key, must first call g.Persistent()");
            }

            this.flags |= G_SECURE;
            this.InitializeMyAes();
            this.myAESkey = new byte[this.myAes.KeySize >> 3];
            this.AesSeed.GetBytes(this.myAESkey);
            SetAesKey(this.myAes, this.myAESkey);
        }

        /// <summary>
        /// Places a group into secure mode using a specified key that the end-user must manage externally to Vsync.  
        /// </summary>
        /// <param name="theKey">myAesKeySize-byte AES key</param>
        /// <remarks>The given key must be the same one used by other group members or some form of horrible problem will occur, probably a crash.
        /// Also, keep in mind that an attacker with root privilages could still use a debugger to attach to the program and read myAESKey from memory.
        /// Still, this form of security is stronger than if you let Vsync pick its own keys.</remarks>
        public void SetSecure(byte[] theKey) {
            this.flags |= G_SECURE;
            this.InitializeMyAes();
            if ((theKey.Length << 3) != this.myAes.KeySize) {
                throw new ArgumentException("Key must be a byte[" + (this.myAes.KeySize >> 3) + "] vector");
            }

            this.userSpecifiedKey = true;
            this.myAESkey = theKey;
            if (this.myAESkey == null || (this.flags & G_SECURE) == 0) {
                Vsync.WriteLine("Group <" + this.gname + ">, set myAes=null in SetAEsKey");
                this.myAes = null;
                return;
            }

            SetAesKey(this.myAes, this.myAESkey);
        }

        internal void InitializeMyAes() {
            if (this.AesSeed != null || (this.flags & G_SECURE) == 0) {
                return;
            }

            this.AesSeed = new RNGCryptoServiceProvider();
            doInitializeAes(out this.myAes);
        }

        internal static void doInitializeAes(out Aes theAes) {
            theAes = Aes.Create();
            if (theAes == null) {
                throw new VsyncException("myAes null after Aes.Create()");
            }

            theAes.Padding = PaddingMode.None;
            KeySizes[] ks = theAes.LegalKeySizes;
            int ksbits = 0;
            int bsbits = 0;
            foreach (KeySizes k in ks) {
                ksbits = Math.Max(ksbits, k.MaxSize);
            }

            ks = theAes.LegalBlockSizes;
            foreach (KeySizes k in ks) {
                bsbits = Math.Max(bsbits, k.MaxSize);
            }

            theAes.KeySize = ksbits;
            theAes.BlockSize = bsbits;
        }

        internal static void SetAesKey(Aes theAes, byte[] theAesKey) {
            bool allZero = true;
            int nb = theAes.KeySize >> 3;
            for (int b = 0; b < nb; b++) {
                if (theAesKey[b] != 0) {
                    allZero = false;
                }
            }

            if (allZero) {
                return;
            }

            theAes.Key = theAesKey;
        }

        /// <summary>
        /// Declares that this group is persistent, gives a file in which state should be stored.  Vsync will append the needed
        /// file name extensions, using .ckpt for the checkpoint and .hdr for a header containing various system data.  A file
        /// named filename.bak contains the previous checkpoint and is available to the user in case a checkpoint becomes corrupted
        /// </summary>
        /// <param name="filename">A file name, normally for sharing between all the group members.</param>
        public void Persistent(string filename) {
            this.myCheckpointFile = filename;
        }

        internal bool isPersistent() {
            return this.myCheckpointFile != null;
        }

        internal void setupPersistentFile() {
            int retryCnt = 0;
            bool tryagain = true;
            while (tryagain) {
                tryagain = false;
                byte[] theKey;
                if (tsl == 0) {
                    tsl = Msg.toBArray((long)0).Length;
                }

                try {
                    if ((this.flags & G_SECURE) != 0) {
                        this.InitializeMyAes();
                        theKey = new byte[this.myAes.KeySize >> 3];
                    }
                    else {
                        theKey = new byte[16];
                    }

                    for (int retry = 0; retry < 15; retry++) {
                        try {
                            this.myChkptStream = new FileStream(this.myCheckpointFile + ".hdr", FileMode.Open);
                            if (this.myChkptStream.Read(theKey, 0, theKey.Length) == theKey.Length) {
                                break;
                            }

                            this.myChkptStream.Close();
                            this.myChkptStream = null;
                            Vsync.Sleep(500 * ((Vsync.my_address.GetHashCode() % 10) + retry));
                        }
                        catch (FileNotFoundException) {
                            // Lucky me: I get to create the persistent file
                            throw;
                        }
                        catch (IOException) {
                            // Can happen if a race arises with many trying to join concurrently
                            Vsync.Sleep(500 * ((Vsync.my_address.GetHashCode() % 10) + retry));
                        }
                    }

                    if (this.myChkptStream == null) {
                        throw new VsyncException("Unable to open checkpoint file <" + this.myCheckpointFile + ".hdr> (tried 15 times)");
                    }

                    if ((this.flags & G_SECURE) != 0 && !this.userSpecifiedKey) {
                        this.myAESkey = theKey;
                        SetAesKey(this.myAes, this.myAESkey);
                    }

                    long ts = TypeSignature(this);
                    byte[] tsb = new byte[Msg.toBArray(ts).Length];
                    if (this.myChkptStream.Read(tsb, 0, tsl) != tsl) {
                        throw new IOException("Unexpected EOF");
                    }

                    long chkts = (long)Msg.BArrayToObjects(tsb)[0];
                    if (ts != chkts) {
                        Vsync.WriteLine("WARNING: Checkpoint for <" + this.gname + "> records different type signatures than this member (using it anyhow, but this can cause instability in your application)");
                    }

                    this.myChkptStream.Close();
                    this.myChkptStream = null;
                }
                catch (FileNotFoundException) {
                    // Ignore; this arises normally during the initial group create
                    try {
                        this.myChkptStream = new FileStream(this.myCheckpointFile + ".hdr", FileMode.Create);
                    }
                    catch {
                        if (++retryCnt == 5) {
                            throw new VsyncException("Unable to create or access " + this.myCheckpointFile + ".hdr");
                        }

                        Vsync.Sleep(500 * ((Vsync.my_address.GetHashCode() % 10) + retryCnt));
                        tryagain = true;
                        continue;
                    }

                    if ((this.flags & G_SECURE) != 0) {
                        theKey = this.myAESkey ?? new byte[this.myAes.KeySize >> 3];
                    }
                    else {
                        theKey = new byte[16];
                    }

                    byte[] kOut = new byte[theKey.Length];
                    if ((this.flags & G_SECURE) != 0 && !this.userSpecifiedKey) {
                        Buffer.BlockCopy(theKey, 0, kOut, 0, Buffer.ByteLength(theKey));
                    }

                    this.myChkptStream.Write(kOut, 0, theKey.Length);
                    long ts = TypeSignature(this);
                    byte[] tsb = Msg.toBArray(ts);
                    this.myChkptStream.Write(tsb, 0, tsb.Length);
                    this.myChkptStream.Close();
                    this.myChkptStream = null;
                }
                catch (Exception e) {
                    throw new VsyncException("Unexpected file I/O exception " + e.Message + " on checkpoint file", e);
                }
            }
        }

        internal bool makingCheckpoint = false;

        /// <summary>
        /// Causes the current group state to be written to the checkpoint file
        /// </summary>
        public void MakeCheckpoint(View v) {
            if (!this.VsyncCallStart()) {
                return;
            }

            this.makingCheckpoint = true;
            this.myChkptStream = new FileStream(this.myCheckpointFile + ".tmp", FileMode.Create);
            this.inhibitEOC = true;
            using (var tmpLockObj = new LockAndElevate(this.theChkptMakersLock)) {
                if (this.theChkptMakers.Count > 0) {
                    foreach (ChkptMaker cpm in this.theChkptMakers) {
                        cpm(v);
                    }
                }
            }

            this.inhibitEOC = false;
            if (this.makingCheckpoint) {
                this.SendChkpt();
            }

            this.VsyncCallDone();
        }

        internal void MakeCheckpointIfLeader() {
            if (this.theView.IAmLeader()) {
                this.MakeCheckpoint(this.theView);
            }

            if (this.CheckpointFrequency > 0) {
                Vsync.OnTimerThread(this.CheckpointFrequency, this.MakeCheckpointIfLeader);
            }
        }

        /// <summary>
        /// Completion identifier used in DiskLogger
        /// </summary>
        public class CompletionTag : IComparable, IComparable<CompletionTag>, IEqualityComparer, IEqualityComparer<CompletionTag>, IEquatable<CompletionTag> {
            /// <summary>
            /// Sender of the SafeSend
            /// </summary>
            public readonly Address sender;

            /// <summary>
            /// ViewID in which it was sent
            /// </summary>
            public readonly int vid;

            /// <summary>
            /// Msgid of the message
            /// </summary>
            public readonly int msgid;

            internal readonly Msg theMsg;

            internal bool ordered; // True if final ordering is known

            internal bool done; // True if application has done its update

            /// <exclude></exclude>
            public CompletionTag(Msg m) {
                if (m.sender == null || m.sender.isNull() || m.vid == Msg.UNINITIALIZED || m.msgid == Msg.UNINITIALIZED) {
                    throw new VsyncException("CompletionTag: illegal msg sender/vid/msgid");
                }

                this.sender = m.sender;
                this.vid = m.vid;
                this.msgid = m.msgid;
                this.theMsg = m;
            }

            /// <exclude></exclude>
            public static bool operator <(CompletionTag first, CompletionTag second) {
                return Compare(first, second) < 0;
            }

            /// <exclude></exclude>
            public static bool operator >(CompletionTag first, CompletionTag second) {
                return Compare(first, second) > 0;
            }

            /// <exclude></exclude>
            public static bool operator <=(CompletionTag first, CompletionTag second) {
                return Compare(first, second) <= 0;
            }

            /// <exclude></exclude>
            public static bool operator >=(CompletionTag first, CompletionTag second) {
                return Compare(first, second) >= 0;
            }

            /// <exclude></exclude>
            public static bool operator ==(CompletionTag first, CompletionTag second) {
                return Compare(first, second) == 0;
            }

            /// <exclude></exclude>
            public static bool operator !=(CompletionTag first, CompletionTag second) {
                return Compare(first, second) != 0;
            }

            /// <exclude></exclude>
            public static int Compare(CompletionTag first, CompletionTag second) {
                if (object.ReferenceEquals(first, second)) {
                    return 0;
                }

                if (object.ReferenceEquals(first, null)) {
                    return -1;
                }

                if (object.ReferenceEquals(second, null)) {
                    return 1;
                }

                int comparison = first.sender.CompareTo(second);
                if (comparison != 0) {
                    return comparison;
                }

                comparison = first.vid.CompareTo(second.vid);
                if (comparison != 0) {
                    return comparison;
                }

                comparison = first.msgid.CompareTo(second.msgid);
                return comparison;
            }

            /// <exclude></exclude>
            public int CompareTo(object other) {
                return this.CompareTo(other as CompletionTag);
            }

            /// <exclude></exclude>
            public int CompareTo(CompletionTag other) {
                return Compare(this, other);
            }

            /// <exclude></exclude>
            public override bool Equals(object other) {
                return Compare(this, other as CompletionTag) == 0;
            }

            /// <exclude></exclude>
            public bool Equals(CompletionTag other) {
                return Compare(this, other) == 0;
            }

            /// <exclude></exclude>
            public new bool Equals(object first, object second) {
                return Compare(first as CompletionTag, second as CompletionTag) == 0;
            }

            /// <exclude></exclude>
            public bool Equals(CompletionTag first, CompletionTag second) {
                return Compare(first, second) == 0;
            }

            /// <exclude></exclude>
            public override int GetHashCode() {
                return this.sender.GetHashCode() + (this.vid * 100010057) + (this.msgid * 71043311);
            }

            /// <exclude></exclude>
            public int GetHashCode(object other) {
                return other.GetHashCode();
            }

            /// <exclude></exclude>
            public int GetHashCode(CompletionTag other) {
                return other.GetHashCode();
            }

            /// <exclude></exclude>
            public override string ToString() {
                return "[" + this.sender + "::" + this.vid + ":" + this.msgid + "]";
            }
        }

        /// <summary>
        /// Durability Methods must implement this API
        /// </summary>
        public interface IDurability {
            /// <summary>
            /// Logs a message, returns a new CompletionTag object for it
            /// </summary>
            /// <param name="m">The message to log</param>
            /// <returns>The associated sender:vid:msgid</returns>
            CompletionTag LogMsg(Msg m);

            /// <summary>
            /// Returns the CompletionTag of the most recently logged message
            /// </summary>
            /// <returns>The associated sender:vid:msgid</returns>
            CompletionTag GetCompletionTag();

            /// <summary>
            /// Called when the SafeSend sets the deliver order for a pending message
            /// </summary>
            /// <param name="m">The associated message</param>
            void SetOrder(Msg m);

            /// <summary>
            /// Starts an asynchronous update, later user should call Done(ct)
            /// </summary>
            /// <param name="ct">The associated completion tag</param>
            void BeginAsyncUpdate(CompletionTag ct);

            /// <summary>
            /// Called by the application when done processing an update
            /// </summary>
            /// <param name="ct">The associated completion tag</param>
            void Done(CompletionTag ct);

            /// <summary>
            /// Invoked by Vsync when a new view becomes defined.  Will be called first, they PlayBack(), in the leader.
            /// </summary>
            /// <param name="v"></param>
            void NewView(View v);

            /// <summary>
            /// On reinitialization of a group after all members fail, or when the view changes
            /// and a new process assumes the role of group leader, invoked by Vsync (in the leader only) to "play back"
            /// any messages that might not be stable in the group.  Ideally, the new leader would
            /// only need to take actions after a recovery from a full group failure, at which point
            /// it should replay all messages that didn't reach the state of being "Done" at all the
            /// members where they were delivered during the previous run.  It isn't possible to avoid
            /// duplicates so that becomes the problem of the application, which will need to filter them
            /// out.  
            /// </summary>
            void PlayBack();

            /// <summary>
            /// Tells the logger to shut itself down, called on group Terminate()
            /// </summary>
            void Shutdown();
        }

        internal IDurability durabilityMethod;

        internal volatile bool IAmSafeSendLeader;

        /// <summary>
        /// Overrides the default (in-memory) durability rule for SafeSend
        /// </summary>
        /// <param name="theMethod">An object implementing the IDurability API</param>
        public void SetDurabilityMethod(IDurability theMethod) {
            if (this.durabilityMethod != null) {
                throw new VsyncException("SetDurabilityMethod: method was already registered");
            }

            this.durabilityMethod = theMethod;
        }

        internal delegate void DLQuery(Address[] senders, int[] vids, int[] msgids);

        internal delegate void DLDone(int nCleanup, Address[] senders, int[] vids, int[] msgids);

        internal delegate void DLCleanup();

        /// <summary>
        /// This build-in class provides log-file based durability for SafeSend.  Requires a prior call to g.SetSafeSendThreshold with a small integer constant
        /// specifying how many of the group members must maintain logs.  Throws SafeSendException if an attempt is made to issue a SafeSend in a view with fewer than
        /// this number of members.
        /// </summary>
        public sealed class DiskLogger : IDurability, IDisposable {
            private bool disposed;

            internal bool dirty;

            internal LockObject theLock;

            internal Group theGroup;

            internal Thread theThread;

            internal string theFileName = "no name";

            internal FileStream theFileStream;

            internal int myRank = -1;

            internal Semaphore SleepOn = new Semaphore(0, int.MaxValue);

            private List<CompletionTag> PendingList = new List<CompletionTag>();

            private readonly List<CompletionTag> AsyncList = new List<CompletionTag>();

            private readonly List<CompletionTag> DoneList = new List<CompletionTag>();

            /// <exclude></exclude>
            public DiskLogger(Group g, string filename) {
                if (g.safeSendThreshold <= 1) {
                    throw new SafeSendException("DiskLogger requires SafeSendThreshold >= 2");
                }

                this.theGroup = g;
                this.theFileName = filename;
                this.theLock = new LockObject("DiskLogger<" + this.theGroup.gname + ">");
                this.doSetup();
            }

            /// <summary>
            /// Disposes of SleepOn semaphore
            /// </summary>
            public void Dispose() {
                this.Dispose(true);
            }

            private void Dispose(bool disposing) {
                if (disposing) {
                    using (var tmpLockObj = new LockAndElevate(this.theLock)) {
                        if (this.disposed) {
                            return;
                        }

                        this.disposed = true;
                    }

                    this.SleepOn.Release();
                    this.SleepOn.Dispose();
                    if (this.theFileStream != null) {
                        this.theFileStream.Dispose();
                    }

                    this.SleepOn = null;
                }
            }

            /// <exclude></exclude>
            public CompletionTag LogMsg(Msg m) {
                using (var tmpLockObj = new LockAndElevate(this.theLock)) {
                    this.dirty = true;
                    return this.LogMsg(this.theFileStream, m);
                }
            }

            // Must call with appropriate lock
            private CompletionTag LogMsg(FileStream whichFileStream, Msg m) {
                if (this.myRank == -1 || this.myRank >= this.theGroup.GetSafeSendThreshold()) {
                    return null;
                }

                CompletionTag ct = new CompletionTag(m);
                using (var tmpLockObj = new LockAndElevate(this.theLock)) {
                    if (whichFileStream == null) {
                        throw new SafeSendException("Error: attempted to do a SafeSend in a group that has fewer than SafeSendThreshold members");
                    }

                    if (whichFileStream == this.theFileStream) {
                        foreach (CompletionTag oct in this.PendingList) {
                            if (oct.sender == ct.sender && oct.vid == ct.vid && oct.msgid == ct.msgid) {
                                return ct;
                            }
                        }

                        this.PendingList.Add(ct);
                    }

                    this.WriteObjects(m);
                }

                return ct;
            }

            internal void WriteObjects(params object[] obs) {
                byte[] ba = Msg.toBArray(obs);
                byte[] baLen = new byte[4];
                int bl = ba.Length;
                baLen[0] = (byte)((bl >> 24) & 0xFF);
                baLen[1] = (byte)((bl >> 16) & 0xFF);
                baLen[2] = (byte)((bl >> 8) & 0xFF);
                baLen[3] = (byte)(bl & 0xFF);
                this.theFileStream.Seek(0, SeekOrigin.End);
                this.theFileStream.Write(baLen, 0, 4);
                this.theFileStream.Write(ba, 0, ba.Length);
                this.theFileStream.Flush(true);
            }

            /// <exclude></exclude>
            public CompletionTag GetCompletionTag() {
                Msg m = this.theGroup.curMsg();
                if (m == null) {
                    throw new VsyncException("DiskLogger: curmsg null");
                }

                return new CompletionTag(m);
            }

            /// <exclude></exclude>
            /// Called when the order is determined for message m, and these calls match the sequential delivery order
            public void SetOrder(Msg m) {
                if (this.myRank == -1 || this.myRank >= this.theGroup.GetSafeSendThreshold()) {
                    return;
                }

                bool fnd = false;
                CompletionTag mct = m.ct;
                if (mct == null) {
                    throw new VsyncException("ct null in SetOrder");
                }

                using (var tmpLockObj = new LockAndElevate(this.theLock)) {
                    List<CompletionTag> newPendingList = new List<CompletionTag>();
                    foreach (CompletionTag ct in this.PendingList) {
                        if (ct.sender == mct.sender && ct.vid == mct.vid && ct.msgid == mct.msgid) {
                            fnd = true;
                            if (ct.ordered) {
                                return;
                            }
                        }
                        else if (ct.ordered) {
                            newPendingList.Add(ct);
                        }
                        else if (m != null) {
                            m.ct.ordered = true;
                            newPendingList.Add(m.ct);
                            m = null;
                        }
                        else {
                            newPendingList.Add(ct);
                        }
                    }

                    if (m != null) {
                        m.ct.ordered = true;
                        newPendingList.Add(m.ct);
                    }

                    if (!fnd) {
                        throw new VsyncException("DiskLogger.SetOrder: couldn't find " + mct.sender + "::" + mct.vid + ":" + mct.msgid);
                    }

                    this.PendingList = newPendingList;
                }
            }

            /// <exclude></exclude>
            public void BeginAsyncUpdate(CompletionTag ct) {
                using (var tmpLockObj = new LockAndElevate(this.theLock)) {
                    this.AsyncList.Add(ct);
                }
            }

            /// <exclude></exclude>
            public void Done(CompletionTag ct) {
                using (var tmpLockObj = new LockAndElevate(this.theLock)) {
                    if (this.AsyncList.Contains(ct)) {
                        // In this case, expects to be called twice: once being the automated event from the callback handler, once by the asynchronous completion logic
                        this.AsyncList.Remove(ct);
                    }
                    else if (!this.DoneList.Contains(ct)) {
                        this.DoneList.Add(ct);
                        this.dirty = true;
                        if (this.theGroup.IAmSafeSendLeader && this.DoneList.Count == 1000) {
                            this.SleepOn.Release();
                        }
                    }
                }
            }

            /// <exclude></exclude>
            public void Shutdown() {
                this.SleepOn.Release();
            }

            /// <exclude></exclude>
            public void NewView(View v) {
                using (var tmpLockObj = new LockAndElevate(this.theLock)) {
                    int rank = v.GetMyRank();
                    if (rank == -1 || rank >= this.theGroup.GetSafeSendThreshold()) {
                        return;
                    }

                    if (this.myRank != rank && this.theFileStream != null) {
                        this.myRank = rank;
                        this.theFileStream.Flush(true);
                        this.theFileStream.Dispose();
                        Vsync.Sleep(50);
                        this.theFileStream = null;
                        if (rank == -1) {
                            return;
                        }
                    }
                    else if (this.theFileStream != null) {
                        return;
                    }
                    else {
                        this.myRank = rank;
                    }

                    if (this.theFileStream == null) {
                        for (int retry = 0; retry < 60; retry++) {
                            try {
                                // Open it in exclusive mode to be sure that the previous owner, if any, has finished writing to it.  Could require a few tries
                                this.theFileStream = new FileStream(this.theFileName + "-" + this.myRank + ".dat", FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.None);
                                break;
                            }
                            catch (IOException e) {
                                if ((VsyncSystem.Debug & VsyncSystem.DISKLOGGER) != 0) {
                                    Vsync.WriteLine("Attempt failed, IOException=" + e);
                                }

                                Vsync.Sleep(500);
                            }
                        }

                        if (this.theFileStream == null) {
                            throw new VsyncException("DiskLogger: can't access " + this.theFileName + "-" + this.myRank + ".dat (tried for 30 secs)");
                        }

                        this.ReadLog();
                    }

                    if (rank == 0 && this.theThread == null) {
                        this.theThread = new Thread(() => {
                            try {
                                Timeout myTO = new Timeout(Vsync.VSYNC_DEFAULTTIMEOUT, Timeout.TO_NULLREPLY);
                                int myThreshold = this.theGroup.GetSafeSendThreshold() - 1;
                                this.SleepOn.WaitOne(30 * 1000);
                                while (VsyncSystem.VsyncActive && (this.theGroup.GroupOpen || !this.theGroup.WasOpen)) {
                                    Address[] senders;
                                    int[] vids;
                                    int[] msgids;
                                    List<bool[]> status = new List<bool[]>();

                                    // First, construct a list of completion tags that should be checked, in delivery order
                                    using (var tmpLockObj1 = new LockAndElevate(this.theLock)) {
                                        if (!this.dirty) {
                                            continue;
                                        }

                                        senders = new Address[this.DoneList.Count];
                                        vids = new int[this.DoneList.Count];
                                        msgids = new int[this.DoneList.Count];
                                        int idx = 0;
                                        foreach (CompletionTag ct in this.DoneList) {
                                            senders[idx] = ct.sender;
                                            vids[idx] = ct.vid;
                                            msgids[idx] = ct.msgid;
                                            ++idx;
                                        }
                                    }

                                    // Now find out which are done everywhere; question is where is the "cutoff point", again in delivery order
                                    if (this.theGroup.Query(myThreshold, myTO, Vsync.DISKLOGGER, senders, vids, msgids, Group.EOL, status) == myThreshold) {
                                        int idx = 0;
                                        int ndx = 0;
                                        while (idx < senders.Length) {
                                            bool allTrue = true;
                                            foreach (bool[] ba in status) {
                                                if (!ba[idx]) {
                                                    allTrue = false;
                                                    break;
                                                }
                                            }

                                            if (allTrue) {
                                                senders[ndx] = senders[idx];
                                                vids[ndx] = vids[idx];
                                                msgids[ndx] = msgids[idx];
                                                ++ndx;
                                            }

                                            ++idx;
                                        }

                                        if (ndx > 0) {
                                            Vsync.ArrayResize(ref senders, ndx);
                                            Vsync.ArrayResize(ref vids, ndx);
                                            Vsync.ArrayResize(ref msgids, ndx);
                                            using (var tmpLockObj1 = new LockAndElevate(this.theLock)) {
                                                this.SetDoneBit(senders, vids, msgids);
                                            }

                                            this.WriteObjects(ndx, senders, vids, msgids);
                                            List<string> oks = new List<string>();

                                            // Finally, if everyone successfully logs that those are collectable, safe to collect. 
                                            if (this.theGroup.Query(myThreshold, myTO, Vsync.DISKLOGGER, ndx, senders, vids, msgids, Group.EOL, oks) == myThreshold) {
                                                this.theGroup.Query(myThreshold, myTO, Vsync.DISKLOGGER, Group.EOL, new List<string>());
                                            }
                                        }
                                    }

                                    this.SleepOn.WaitOne(30 * 1000);
                                }
                            }
                            catch (VsyncShutdownException) {
                                return;
                            }
                            catch (ThreadInterruptedException) {
                                return;
                            }

                            VsyncSystem.ThreadTerminationMagic();
                        }) { Name = "DiskLogger<" + this.theGroup.gname + ">: garbage collector", IsBackground = true };
                        this.theThread.Start();
                    }
                }
            }

            private void doSetup() {
                // Called as the first phase of garbage collection to gather statistics on the specified completion tags
                this.theGroup.doRegister(Vsync.DISKLOGGER, new DLQuery((senders, vids, msgids) => {
                    if (this.myRank <= 0 || this.myRank >= this.theGroup.GetSafeSendThreshold()) {
                        this.theGroup.NullReply();
                        return;
                    }

                    string inq = " ";
                    for (int i = 0; i < senders.Length; i++) {
                        inq += senders[i] + "::" + vids[i] + ":" + msgids[i] + " ";
                    }

                    bool[] myStatus = new bool[senders.Length];
                    using (var tmpLockObj = new LockAndElevate(this.theLock)) {
                        foreach (CompletionTag ct in this.PendingList) {
                            for (int idx = 0; idx < senders.Length; idx++) {
                                if (ct.done && senders[idx] == ct.sender && vids[idx] == ct.vid && msgids[idx] == ct.msgid) {
                                    myStatus[idx] = true;
                                    break;
                                }
                            }
                        }

                        foreach (CompletionTag ct in this.DoneList) {
                            for (int idx = 0; idx < senders.Length; idx++) {
                                if (senders[idx] == ct.sender && vids[idx] == ct.vid && msgids[idx] == ct.msgid) {
                                    myStatus[idx] = true;
                                    break;
                                }
                            }
                        }
                    }

                    string ms = string.Empty;
                    foreach (bool b in myStatus) {
                        ms += b ? "1 " : "0 ";
                    }

                    if ((VsyncSystem.Debug & VsyncSystem.DISKLOGGER) != 0) {
                        Vsync.WriteLine("Disklogger: Responding to an inquiry {" + inq + "}, myStatus={" + ms + "}");
                    }

                    this.theGroup.doReply(myStatus);
                }));

                // Second phase notes that these message are now collectable but doesn't collect them yet
                this.theGroup.doRegister(Vsync.DISKLOGGER, new DLDone((howMany, senders, vids, msgids) => {
                    if (this.myRank <= 0 || this.myRank >= this.theGroup.GetSafeSendThreshold()) {
                        this.theGroup.NullReply();
                        return;
                    }

                    string inq = " ";
                    for (int i = 0; i < senders.Length; i++) {
                        inq += senders[i] + "::" + vids[i] + ":" + msgids[i] + " ";
                    }

                    using (var tmpLockObj = new LockAndElevate(this.theLock)) {
                        this.SetDoneBit(senders, vids, msgids);
                        this.WriteObjects(howMany, senders, vids, msgids);
                    }

                    if ((VsyncSystem.Debug & VsyncSystem.DISKLOGGER) != 0) {
                        Vsync.WriteLine("Disklogger: Responding to an prepare message {" + inq + "}");
                    }

                    this.theGroup.doReply("OK");
                }));

                // Now can cleanup the log, if you wish
                this.theGroup.doRegister(Vsync.DISKLOGGER, new DLCleanup(() => {
                    if (this.myRank == -1 || this.myRank >= this.theGroup.GetSafeSendThreshold()) {
                        return;
                    }

                    if ((VsyncSystem.Debug & VsyncSystem.DISKLOGGER) != 0) {
                        Vsync.WriteLine("Disklogger: Recieved a commit message");
                    }

                    this.RewriteLog(false);
                    this.theGroup.doReply("OK");
                }));
            }

            internal void RewriteLog(bool verbose) {
                using (var tmpLockObj = new LockAndElevate(this.theLock)) {
                    try {
                        int nc = 0;
                        if (verbose) {
                            Vsync.WriteLine("... creating temp file <" + this.theFileName + "-" + this.myRank + ".tmp>");
                        }

                        using (FileStream newFileStream = new FileStream(this.theFileName + "-" + this.myRank + ".tmp", FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.None)) {
                            List<CompletionTag> newPendingList = new List<CompletionTag>();
                            foreach (CompletionTag ct in this.PendingList) {
                                if (!ct.done) {
                                    newPendingList.Add(ct);
                                    this.LogMsg(newFileStream, ct.theMsg);
                                }
                                else {
                                    ++nc;
                                }
                            }

                            if (verbose) {
                                Vsync.WriteLine("... Wrote " + (this.PendingList.Count - nc) + " SafeSend messages to new log file");
                            }

                            this.PendingList = newPendingList;
                            this.theFileStream.Flush();
                            this.theFileStream.Dispose();
                            newFileStream.Flush();
                        }

                        Vsync.Sleep(250);
                        if (verbose) {
                            Vsync.WriteLine("... Renaming file");
                        }

                        File.Replace(this.theFileName + "-" + this.myRank + ".tmp", this.theFileName + "-" + this.myRank + ".dat", this.theFileName + "-" + this.myRank + ".bak");
                        Vsync.Sleep(250);
                        this.theFileStream = new FileStream(this.theFileName + "-" + this.myRank + ".dat", FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.None);
                        if ((VsyncSystem.Debug & VsyncSystem.DISKLOGGER) != 0) {
                            Vsync.WriteLine("Disklogger: Successful garbage collection of " + nc + " SafeSend messages");
                        }

                        if (verbose) {
                            Vsync.WriteLine("... DiskLogger logfile repair successful");
                        }
                    }
                    catch (IOException e) {
                        throw new VsyncException("DiskLogger: Unable to handle I/O exception " + e.Message, e);
                    }
                }
            }

            private int SetDoneBit(Address[] senders, int[] vids, int[] msgids) {
                int fnd = 0;
                foreach (CompletionTag ct in this.PendingList) {
                    for (int idx = 0; idx < senders.Length; idx++) {
                        if (senders[idx] == ct.sender && vids[idx] == ct.vid && msgids[idx] == ct.msgid) {
                            ct.done = true;
                            ++fnd;
                            break;
                        }
                    }
                }

                return fnd;
            }

            /// <exclude></exclude>
            public void PlayBack() {
                List<Msg> toResend = new List<Msg>();
                if ((VsyncSystem.Debug & VsyncSystem.DISKLOGGER) != 0) {
                    Vsync.WriteLine("** Disklogger: entering PlayBack");
                }

                using (var tmpLockObj = new LockAndElevate(this.theLock)) {
                    if (this.theFileStream == null) {
                        return;
                    }

                    View theView;
                    using (var tmpLockObj1 = new LockAndElevate(this.theGroup.ViewLock)) {
                        theView = this.theGroup.theView;
                    }

                    if (theView.members.Length < this.theGroup.GetSafeSendThreshold()) {
                        return;
                    }

                    this.theGroup.IAmSafeSendLeader = true;
                    List<CompletionTag> newPendingList = new List<CompletionTag>();
                    foreach (CompletionTag ct in this.PendingList) {
                        if (!ct.done) {
                            toResend.Add(ct.theMsg);
                        }
                        else {
                            newPendingList.Add(ct);
                        }
                    }

                    this.PendingList = newPendingList;
                }

                if (toResend.Count > 0) {
                    new Thread(() => {
                        try {
                            foreach (Msg m in toResend) {
                                if (VsyncSystem.VsyncActive) {
                                    this.theGroup.SafeSend(Msg.BArrayToObjects(m.payload));
                                }
                            }
                        }
                        catch (VsyncShutdownException) {
                        }

                        VsyncSystem.ThreadTerminationMagic();
                    }) { Name = "SafeSend:Playback<" + this.theGroup.gname + ">", IsBackground = true }.Start();
                }
            }

            // Call holds theLock
            internal void ReadLog() {
                byte[] ba = new byte[4];
                bool corrupt = false;
                this.theFileStream.Seek(0, SeekOrigin.Begin);
                while (this.theFileStream.Read(ba, 0, 4) == 4) {
                    int len = (ba[0] << 24) | (ba[1] << 16) | (ba[2] << 8) | ba[3];
                    ba = new byte[Math.Abs(len)];
                    int nb;
                    if ((nb = this.theFileStream.Read(ba, 0, len)) == len) {
                        object[] obs = Msg.BArrayToObjects(ba);
                        if (Msg.CheckTypes(obs, typeof(Msg))) {
                            CompletionTag ct = new CompletionTag((Msg)Msg.BArrayToObjects(ba)[0]);
                            bool fnd = false;
                            foreach (CompletionTag oct in this.PendingList) {
                                if (oct.sender == ct.sender && oct.vid == ct.vid && oct.msgid == ct.msgid) {
                                    fnd = true;
                                    break;
                                }
                            }

                            if (!fnd) {
                                this.PendingList.Add(ct);
                            }
                        }
                        else if (Msg.CheckTypes(obs, typeof(int), typeof(Address[]), typeof(int[]), typeof(int[]))) {
                            int x = 1; // x = 0; int howMany = (int)obs[x++];
                            Address[] senders = (Address[])obs[x++];
                            int[] vids = (int[])obs[x++];
                            int[] msgids = (int[])obs[x];
                            foreach (CompletionTag ct in this.PendingList) {
                                for (int idx = 0; idx < senders.Length; idx++) {
                                    if (senders[idx] == ct.sender && vids[idx] == ct.vid && msgids[idx] == ct.msgid) {
                                        ct.done = true;
                                        break;
                                    }
                                }
                            }
                        }
                        else {
                            corrupt = true;
                            Vsync.WriteLine("Warning: DiskLogger unable to interpret data read from a log file... truncating and initiating autorepair");
                            break;
                        }
                    }
                    else {
                        corrupt = true;
                        Vsync.WriteLine("Warning: DiskLogger expected " + len + " bytes but EOF after " + nb + " bytes.... truncating and initiating autorepair");
                        break;
                    }
                }

                if (corrupt) {
                    Vsync.WriteLine("WARNING: Vsync detected a damaged or partially written DiskLogger log file... auto-repairing");
                    this.RewriteLog(true);
                }

                int nd = 0;
                foreach (CompletionTag ct in this.PendingList) {
                    if (ct.done) {
                        ++nd;
                    }
                }

                if ((VsyncSystem.Debug & VsyncSystem.DISKLOGGER) != 0) {
                    Vsync.WriteLine("Disklogger ReadLog finished.  Read " + this.PendingList.Count + " messages, of which " + nd + " were flagged as completed");
                }
            }
        }

        /// <summary>
        /// Requests that the state of the group be checkpointed automatically at the specified interval
        /// </summary>
        /// <param name="interval">inter-checkpoint interval in seconds</param>
        public void SetCheckpointFrequency(int interval) {
            this.CheckpointFrequency = Math.Max(-1, Math.Min(interval, int.MaxValue / 1000) * 1000);
            if (this.CheckpointFrequency > 0) {
                Vsync.OnTimerThread(this.CheckpointFrequency, this.MakeCheckpointIfLeader);
            }
        }

        /// <summary>Register view callback handler. </summary>
        /// <param name="cbproc">Handler for view callbacks</param>
        /// <remarks>
        /// A process setting up a group calls RegisterViewCB to register a callback handler that will be invoked when a new View is received.
        /// Read about the <it>virtual synchrony model</it> to learn more about the View property of groups, which is a key feature of the Vsync system
        /// and will be very useful to you in designing applications that make full use of Vsync.
        /// </remarks>
        public void RegisterViewHandler(ViewHandler cbproc) {
            VHCallBack vcb = new VHCallBack(false, cbproc);
            using (var tmpLockObj = new LockAndElevate(this.ViewHandlers.vhListLock)) {
                this.ViewHandlers.vhList.Add(vcb);
            }
        }

        internal class Initer {
            private readonly Group myGroup;

            public Initer(Group g) {
                this.myGroup = g;
            }

            public static Initer operator +(Initer a, Initializer maker) {
                a.myGroup.RegisterInitializer(maker);
                return a;
            }
        }

        internal Initer Initializer;

        /// <summary>
        /// A process setting up a group calls RegisterInitializer to declare the method that will initialize the group if this member turns out to create it
        /// </summary>
        /// <param name="initproc"></param>
        public void RegisterInitializer(Initializer initproc) {
            this.theInitializer = initproc;
        }

        internal void doRegisterViewCB(VHCallBack vcb) {
            using (var tmpLockObj = new LockAndElevate(this.ViewHandlers.vhListLock)) {
                this.ViewHandlers.vhList.Add(vcb);
            }
        }

        private void TypeCheck(object[] obs) {
            if (obs == null || obs.Length < 1) {
                throw new VsyncException("Wrong number of arguments");
            }

            if (obs[0].GetType() == typeof(Msg)) {
                return;
            }

            if (obs[0].GetType() != typeof(int)) {
                throw new VsyncException("First argument should be a request type");
            }

            int request = (int)obs[0];
            if (this.Handlers[request] == null) {
                return;
            }

            foreach (CallBack cb in this.Handlers[request].hList) {
                if (TypeMatch(obs, cb)) {
                    return;
                }
            }

            string ts = string.Empty;
            foreach (object o in obs) {
                ts += o.GetType() + "...";
            }

            throw new VsyncException("No callback for request " + Vsync.rToString((int)obs[0]) + " matches the provided type signature: " + ts);
        }

        internal int rcode(object[] obs) {
            object rc = obs[0];
            Type t = rc.GetType();
            if (t == typeof(int)) {
                return (int)rc;
            }

            if (t == typeof(byte)) {
                return (byte)rc;
            }

            throw new VsyncException("Request code was of type " + rc.GetType() + " but expected byte or int!");
        }

        private static bool TypeMatch(object[] obs, CallBack cb) {
            if (cb.cbProc.ptypes.Length != obs.Length - 1) {
                return false;
            }

            for (int i = 0; i < cb.cbProc.ptypes.Length; i++) {
                if (obs[i + 1] == null || (obs[i + 1].GetType() != cb.cbProc.ptypes[i] && cb.cbProc.ptypes[i] != typeof(object))) {
                    return false;
                }
            }

            return true;
        }

        private static bool DHTTypeMatch(object[] obs, CallBack cb) {
            if (cb.cbProc.ptypes.Length != obs.Length) {
                return false;
            }

            for (int i = 0; i < obs.Length; i++) {
                if (obs[i] == null || (obs[i].GetType() != cb.cbProc.ptypes[i] && cb.cbProc.ptypes[i] != typeof(object))) {
                    return false;
                }
            }

            return true;
        }

        // Returns a 64-bit value computed from an SHA2/256 hash of the type signature of the group
        // SHA2/256 is actually a 256-bit result, so we just loop over it and XOR the parts
        internal static long TypeSignature(Group g) {
            if (g.TypeSig != 0) {
                return g.TypeSig;
            }

            List<string> sigs = new List<string>();
            int ridx = 0;
            foreach (myHandlers mh in g.Handlers.ListofhLists) {
                if (mh != null) {
                    foreach (CallBack cb in mh.hList) {
                        string s = "[" + ridx++ + "]";
                        foreach (Type pt in cb.cbProc.ptypes) {
                            s += pt + ":";
                        }

                        sigs.Add(s);
                    }
                }
            }

            tokenInfo theToken;
            using (var tmpLockObj = new LockAndElevate(g.TokenLock)) {
                theToken = g.theToken;
            }

            if (theToken != null) {
                foreach (AggInfo ag in g.AggTypes) {
                    sigs.Add(ag.KVT);
                }
            }

            sigs.Sort();
            string sig = string.Empty;
            foreach (string s in sigs) {
                sig = sig + s + ";";
            }

            if ((g.flags & G_SECURE) != 0) {
                sig += "(secure)";
            }

            g.TypeSigStr = sig;
            if ((VsyncSystem.Debug & VsyncSystem.TYPESIGS) != 0) {
                Vsync.WriteLine("Computing type signature for " + g.gname + ", long form is " + sig);
            }

            using (MemoryStream ms = new MemoryStream(Msg.StringToBytes(sig)))
            using (HMAC hm = new HMACSHA256(new byte[] { 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11 }))
            using (var tmpLockObj = new LockAndElevate(Msg.VerifyLock)) {
                byte[] ba = hm.ComputeHash(ms);
                long rval = 0;
                for (int i = 0; i < ba.Length; i++) {
                    rval ^= (((long)ba[i]) & 0xFF) << ((i & 3) << 3);
                }

                if ((VsyncSystem.Debug & VsyncSystem.TYPESIGS) != 0) {
                    Vsync.WriteLine("... returning compressed version " + rval);
                }

                if (rval == 0) {
                    rval = 0x1010101001010101;
                }

                return rval;
            }
        }

        internal const int CREATE = 0x0001;

        internal const int JOIN = 0x0002;

        internal const int CANBEORACLE = 0x0004;

        /// <summary>
        /// A process calls Join to join or create a group; Vsync will figure out what to do.  Set up the group in advance by registering data types, handlers, aggregators.
        /// </summary>
        public void Join() {
            this.Join(0L);
        }

        /// <summary>
        /// Join a group, specifying an offset into the group state
        /// </summary>
        /// <param name="off">offset into the group's state</param>
        public void Join(long off) {
            if (this.GroupOpen) {
                throw new VsyncException("Group Join/Create but the group was already active");
            }

            this.ThrashingCheck();
            using (var tmpLockObj = new LockAndElevate(this.UniversalP2PHandlers.uhListLock))
            using (var tmpLockObj1 = new LockAndElevate(this.UniversalMHandlers.uhListLock)) {
                if (this.UniversalP2PHandlers.uhList.Count > 0 || this.UniversalMHandlers.uhList.Count > 0) {
                    this.hasUniversalHandlers = true;
                }
            }

            if (this.myCheckpointFile != null) {
                this.setupPersistentFile();
            }

            Group[] groups = { this };
            if (this != Vsync.ORACLE && this != Vsync.VSYNCMEMBERS) {
                this.Handlers.locked = this.UniversalMHandlers.locked = this.UniversalP2PHandlers.locked = true;
            }

            doJoin(CREATE | JOIN, 0, groups, off);
            JoinWait(groups);
        }

        /// <summary>
        /// A process calls JoinExisting to join a group that must be preexisting.  Set up the group in advance by registering data types, handlers, aggregators.
        /// </summary>
        public void JoinExisting() {
            this.JoinExisting(0L);
        }

        /// <summary>
        /// Join an existing group, specifying an offset into the group state
        /// </summary>
        /// <param name="off">offset into the group's state</param>
        public void JoinExisting(long off) {
            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            this.ThrashingCheck();
            Group[] groups = { this };
            doJoin(JOIN, 0, groups, off);
            JoinWait(groups);
        }

        /// <summary>
        /// A process calls Create to create a new group.  Set up the group in advance by registering data types, handlers, aggregators.
        /// </summary>
        public void Create() {
            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            Group[] groups = { this };
            doJoin(CREATE | JOIN, 0, groups, 0L);
            JoinWait(groups);
        }

        private void ThrashingCheck() {
            using (var tmpLockObj = new LockAndElevate(this.RecentlyLeftLock)) {
                if (RecentlyLeft.Contains(this.gaddr)) {
                    // This is to prevent developers from building applications that thrash, putting Vsync under heavy stress
                    throw new VsyncException("Vsync join error: Illegal to rejoin an existing group within 5 minutes after leaving it.");
                }
            }
        }

        /// <summary>
        /// A process calls multiCreate to create a set of groups as a single atomic action. 
        /// </summary>
        /// <param name="groups">List of groups to create</param>
        /// <remarks>Set up the groups in advance by registering data types, handlers, aggregators.</remarks>
        public static void multiCreate(Group[] groups) {
            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            doJoin(CREATE | JOIN, 0, groups, 0L);
            JoinWait(groups);
        }

        /// <summary>
        /// A master process calls this overload of multiCreate to create a set of groups containing a set of members as a single atomic action. 
        /// </summary>
        /// <param name="workers">List of processes to initially include in the groups</param>
        /// <param name="groups">List of groups</param>
        /// <remarks>Set up the groups in advance by registering data types, handlers, aggregators.</remarks>
        public static void multiCreate(Address[] workers, Group[] groups) {
            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            doJoin(CREATE | JOIN, 0, workers, groups, 0L);
        }

        /// <summary>
        /// A master process calls this overload of multiJoin to add a set of workers to a list of groups as a single atomic action.  
        /// </summary>
        /// <param name="workers">List of processes to add to the groups</param>
        /// <param name="groups">List of groups</param>
        /// <remarks>Set up the groups in advance by registering data types, handlers, aggregators.</remarks>
        public static void multiJoin(Address[] workers, Group[] groups) {
            multiJoin(workers, groups, 0L);
        }

        /// <summary>
        /// Joint a list of groups, specifying an offset into the group state
        /// </summary>
        /// <param name="workers">List of processes to add to the groups</param>
        /// <param name="groups">List of groups</param>
        /// <param name="offset">Offset into the group state</param>
        public static void multiJoin(Address[] workers, Group[] groups, long offset) {
            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            foreach (Group g in groups) {
                if (!g.HasFirstView) {
                    throw new VsyncException("multiJoin: Can only be called by a current member of <" + g.gname + ">");
                }
            }

            doJoin(CREATE | JOIN, 0, workers, groups, offset);
        }

        /// <summary>
        /// A process calls multiJoin to join a set of group as a single atomic action.  
        /// </summary>
        /// <param name="groups">List of groups to join</param>
        /// <remarks>Set up the groups in advance by registering data types, handlers, aggregators.</remarks>
        public static void multiJoin(Group[] groups) {
            multiJoin(groups, 0L);
        }

        /// <summary>
        /// Join a set of groups as a single atomic action
        /// </summary>
        /// <param name="groups">List of groups to join</param>
        /// <param name="offset">Offset into the group state</param>
        public static void multiJoin(Group[] groups, long offset) {
            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            doJoin(CREATE | JOIN, 0, groups, offset);
            JoinWait(groups);
        }

        /// <summary>
        /// Manager for a group calls Terminate to garbage collect the group, leaving members operational.
        /// </summary>
        /// <remarks>Once this call is issued, if any member tries to issue Vsync system calls on the group, those calls will
        /// fail and a warning will print to the console.  So don't call Terminate while your group is still active. </remarks>
        public void Terminate() {
            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            if (!this.GroupOpen || (this.flags & G_TERMINATING) != 0) {
                return;
            }

            doTerminate(new[] { this });
        }

        /// <summary>
        /// Manager for a set of groups calls <c>multiTerminate</c> to garbage collect the groups as a single action, leaving members operational.
        /// </summary>
        /// <param name="groups">List of the groups to terminate</param>
        public static void multiTerminate(Group[] groups) {
            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            foreach (Group g in groups) {
                if (!g.HasFirstView) {
                    throw new VsyncException("multiTerminate: Caller must Join <" + g.gname + "> before calling multiTerminate");
                }
            }

            doTerminate(groups);
        }

        /// <summary>
        /// A process calls HasFailed to report a failure
        /// </summary>
        /// <param name="who">Address of the failed process</param>
        /// <remarks>
        /// The caller and failed process must both belong to the current view.  The target will be forced out of the
        /// Vsync system (a poison pill will be sent to it just in case it is still running) and it will drop out of
        /// all groups to which it belongs.
        /// </remarks>
        public void HasFailed(Address who) {
            if (this.theView.GetRankOf(who) == -1) {
                return;
            }

            Vsync.NodeHasFailed(who, "(From app-level HasFailed)", false);
        }

        internal Semaphore xferWait = new Semaphore(0, int.MaxValue);

        private static void JoinWait(Group[] groups) {
            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            foreach (Group g in groups) {
                if (!g.HasFirstView) {
                    if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.VIEWWAIT)) != 0) {
                        Vsync.WriteLine("Waiting on LLINITV barrier lock for gaddr " + g.gaddr + "(Lock [" + ILock.LLINITV + "][" + ILock.GetLockId(ILock.LLINITV, g.gaddr.GetHashCode()) + "])");
                    }

                    if (!g.HasFirstView) {
                        ILock.Barrier(ILock.LLINITV, g.gaddr).BarrierWait();
                    }

                    if ((VsyncSystem.Debug & (VsyncSystem.VIEWCHANGE | VsyncSystem.VIEWWAIT)) != 0) {
                        Vsync.WriteLine("After LLINITV barrier lock for gaddr " + g.gaddr + "(Lock [" + ILock.LLINITV + "][" + ILock.GetLockId(ILock.LLINITV, g.gaddr.GetHashCode()) + "])");
                    }

                    if (g.joinFailed) {
                        // Join but it didn't exist, or Create but it did exist
                        throw new VsyncException(g.reason);
                    }

                    if (!g.HasFirstView) {
                        throw new VsyncException("JoinWait barrier returned but group has no view!!! " + g.gaddr);
                    }

                    if (g.theView.GetMyRank() == -1) {
                        throw new VsyncException("JoinWait barrier returned but I'm not in " + Address.VectorToString(g.theView.members) + " (gaddr " + g.gaddr + ")");
                    }
                }

                if ((g.flags & G_NEEDSTATEXFER) != 0) {
                    ILock.NoteThreadState("xferWait.WaitOne()");
                    g.xferWait.WaitOne();
                    ILock.NoteThreadState(null);
                    g.xferWait.Release();
                }

                int lcnt = 0;
                while (!g.CallbacksDone) {
                    if (lcnt++ > 250) {
                        throw new VsyncException("Stuck waiting for NEWVIEW callbacks to occur in <" + g.gname + ">.Join()");
                    }

                    Vsync.Sleep(100);
                }
            }
        }

        internal class vGroup {
            internal Address creator;

            internal Address vGroupAddr;

            internal Address[] vGMembers;

            internal vGroup(Address who, Address[] members) {
                this.creator = Vsync.my_address;
                this.vGroupAddr = who;
                this.vGMembers = members;
            }

            internal vGroup(Address createdBy, Address who, Address[] members) {
                this.creator = createdBy;
                this.vGroupAddr = who;
                this.vGMembers = members;
            }
        }

        internal static List<vGroup> vGList = new List<vGroup>();

        internal static LockObject vGLock = new LockObject("vGLock");

        internal static Random rand = new Random();

        internal static Address virtualGroup(Address[] members) {
            using (var tmpLockObj = new LockAndElevate(vGLock)) {
                foreach (vGroup vg in vGList) {
                    if (vGMatch(vg.vGMembers, members)) {
                        return vg.vGroupAddr;
                    }
                }
            }

            vGroup nvg = new vGroup(newVGAddress(members), members);
            using (var tmpLockObj = new LockAndElevate(vGLock)) {
                vGList.Add(nvg);
            }

            return nvg.vGroupAddr;
        }

        internal static bool vGMatch(Address[] l0, Address[] l1) {
            if (l0.Length != l1.Length) {
                return false;
            }

            for (int i = 0; i < l0.Length; i++) {
                if (l0[i] != l1[i]) {
                    return false;
                }
            }

            return true;
        }

        internal static Address newVGAddress(Address[] members) {
            // Creates a placeholder Address() with a negative pid (used to notice that this is a placeholder), picked
            // to reduce risk of collisions if we test Vsync with multiple "masters" on one machine.  Otherwise the home
            // IP address should suffice to avoid problems.
            Address nVGA = new Address(Vsync.my_address.home, -rand.Next(1, int.MaxValue));
            if (Vsync.ClientOf != null) {
                Vsync.ORACLE.P2PSend(Vsync.ClientOf, Vsync.RELAYREGISTERVG, Vsync.my_address, nVGA, members);
            }
            else {
                Vsync.ORACLE.doSend(false, false, Vsync.REGISTERVG, Vsync.my_address, nVGA, members);
            }

            return nVGA;
        }

        internal static void noteVGMap(Address master, Address nVGA, Address[] members) {
            if (master.isMyAddress() || Vsync.VSYNCMEMBERS.theView.GetRankOf(master) == -1) {
                return;
            }

            vGroup nvg = new vGroup(newVGAddress(members), members);
            using (var tmpLockObj = new LockAndElevate(vGLock)) {
                foreach (vGroup vg in vGList) {
                    if (vg.vGroupAddr == nVGA) {
                        throw new VsyncException("Reuse of nVGA " + nVGA);
                    }
                }

                vGList.Add(nvg);
            }

            Vsync.VSYNCMEMBERS.Watch[master] += ev => {
                using (var tmpLockObj = new LockAndElevate(vGLock)) {
                    vGList.Remove(nvg);
                }
            };
        }

        internal static vGroup vGLookup(Address vga) {
            using (var tmpLockObj = new LockAndElevate(vGLock)) {
                foreach (vGroup vg in vGList) {
                    if (vg.vGroupAddr == vga) {
                        return vg;
                    }
                }
            }

            return null;
        }

        internal static string vgGetState() {
            string s = "MEMBER-SET SHORTCUTS: ";
            using (var tmpLockObj = new LockAndElevate(vGLock)) {
                if (vGList.Count == 0) {
                    return string.Empty;
                }

                foreach (vGroup vg in vGList) {
                    s += Environment.NewLine + "  Creator: " + vg.creator + ", members={" + Address.VectorToString(vg.vGMembers) + "}";
                }
            }

            return s;
        }

        internal static void doJoin(int mode, int level, Address[] newMembers, Group[] groups, long offset) {
            doJoin(mode, level, virtualGroup(newMembers), groups, offset);
        }

        internal static void doJoin(int mode, int level, Group[] groups, long offset) {
            doJoin(mode, level, Vsync.my_address, groups, offset);
        }

        internal static void doJoin(int mode, int level, Address who, Group[] groups, long offset) {
            int groupsToJoin = 0;
            groups = groups.AsEnumerable().Where(g => ((!g.GroupOpen) || (!who.isMyAddress()))).ToArray();
            foreach (Group g in groups) {
                g.TypeSig = TypeSignature(g);
                groupsToJoin++;
                g.GroupOpen = true;
            }

            if (groupsToJoin == 0) {
                return;
            }

            Address[] gaddrs = new Address[groups.Length];
            string[] gnames = new string[groups.Length];
            int[] flags = new int[groups.Length];
            long[] tsigs = new long[groups.Length];
            for (int idx = 0; idx < groups.Length; idx++) {
                gnames[idx] = groups[idx].gname;
                gaddrs[idx] = groups[idx].gaddr;
                flags[idx] = groups[idx].flags;
                tsigs[idx] = groups[idx].TypeSig;
                if (gnames[idx] == null || gaddrs[idx] == null) {
                    throw new VsyncException("Something is wrong in doJoin");
                }
            }

            if (Vsync.ClientOf != null) {
                if ((VsyncSystem.Debug & VsyncSystem.RELAYLOGIC) != 0) {
                    Vsync.WriteLine("Invoking Vsync.RELAYJOIN: sender " + Vsync.my_address + ", client of " + Vsync.ClientOf + ", vectors of length " + gnames.Length);
                    for (int n = 0; n < gnames.Length; n++) {
                        Vsync.WriteLine("   gname " + gnames[n] + ", gaddrs " + gaddrs[n] + ", gsigs " + tsigs[n]);
                    }
                }

                bool ISend = false;
                while (Vsync.ClientOf != null && Vsync.ORACLE.doP2PQuery(Vsync.ClientOf, new Timeout(Vsync.VSYNC_DEFAULTTIMEOUT, Timeout.TO_FAILURE, "RELAYJOIN"), Vsync.RELAYJOIN, who, Vsync.ORACLE.uids++, mode, gnames, gaddrs, offset, tsigs, flags).Length == 0) {
                    if (Vsync.newClientOfCnt++ == 0) {
                        ISend = true;
                    }

                    Vsync.ClientOf = null;
                    if (ISend) {
                        Vsync.ORACLE.doSend(false, false, Vsync.JOIN, Vsync.my_address, mode, new[] { "ORACLE" }, new[] { Vsync.ORACLE.gaddr }, offset, new[] { 0L }, new[] { 0 }, ++VsyncSystem.VsyncJoinCounter);
                    }

                    ILock.Barrier(ILock.LLWAIT, ILock.LCLIENTOF).BarrierWait(Vsync.ORACLE);
                }
            }
            else {
                if ((VsyncSystem.Debug & VsyncSystem.GVELOGIC) != 0) {
                    string gns = string.Empty, isls = " ";
                    foreach (string gs in gnames) {
                        gns += " " + gs;
                    }

                    foreach (int f in flags) {
                        isls += f + " ";
                    }

                    Vsync.WriteLine("Sending Vsync.JOIN requests to the ORACLE for gnames [" + gns + " ], gaddrs [" + Address.VectorToString(gaddrs) + "], isLarge{" + isls + "}");
                }

                Vsync.ORACLE.doSend(false, false, Vsync.JOIN, who, mode, gnames, gaddrs, offset, tsigs, flags, ++VsyncSystem.VsyncJoinCounter);
            }

            VsyncSystem.VsyncRestarting = false;
        }

        internal static void doTerminate(Group[] groups) {
            Address[] gaddrs = new Address[groups.Length];
            int idx = 0;
            foreach (Group g in groups) {
                if (g.GroupOpen) {
                    g.Query(ALL, new Timeout(15000, Timeout.TO_FAILURE), Vsync.TERMINATE, g.gaddr, EOL);
                    g.Flush();
                    gaddrs[idx++] = g.gaddr;
                }
            }

            while (Vsync.ClientOf != null) {
                if (Vsync.ORACLE.doP2PQuery(Vsync.ClientOf, new Timeout(Vsync.VSYNC_DEFAULTTIMEOUT, Timeout.TO_FAILURE, "RELAYTERM"), Vsync.RELAYTERM, Vsync.my_address, Vsync.ORACLE.uids++, gaddrs).Length != 0) {
                    break;
                }
            }

            if (Vsync.ClientOf == null) {
                Vsync.ORACLE.doSend(false, false, Vsync.TERMINATE, Vsync.my_address, Vsync.ORACLE.uids++, gaddrs);
            }

            TerminationWait(groups);
        }

        internal const int NPING = 3;

        // Every Vsync member pings randomly selected members of groups to which it belongs at a rate of
        // NPINGs per second.  For example, if NPING=3, each member picks three other processes (if it can find that many)
        // and just nudges them, once per second.  This triggers various failure detection logic so that if a process
        // fails, or even an entire group fails, we'll figure it out quickly and clean up the mess
        internal static void GroupMemberHeartBeat() {
            while (!VsyncSystem.VsyncActive) {
                Vsync.Sleep(250);
            }

            try {
                while (VsyncSystem.VsyncActive) {
                    VsyncSystem.RTS.ThreadCntrs[9]++;
                    Random rand = new Random();
                    List<Address> alist = new List<Address>();
                    using (var tmpLockObj = new LockAndElevate(VsyncGroupsLock)) {
                        int N = 0;
                        foreach (KeyValuePair<Address, Group> kvp in VsyncGroups) {
                            if (kvp.Value.HasFirstView) {
                                N += kvp.Value.theView.members.Length;
                            }
                        }

                        if (N > 1) {
                            for (int k = 0; alist.Count < NPING && k < N; k++) {
                                int which = rand.Next(N);
                                int cnt = 0;
                                foreach (KeyValuePair<Address, Group> kvp in VsyncGroups) {
                                    Group g = kvp.Value;
                                    if (g.HasFirstView) {
                                        int off = which - cnt;
                                        if (off >= 0 && off < g.theView.members.Length) {
                                            if (!g.theView.members[off].isMyAddress() && !alist.Contains(g.theView.members[off])) {
                                                alist.Add(g.theView.members[off]);
                                            }
                                        }

                                        cnt += g.theView.members.Length;
                                    }
                                }
                            }
                        }
                    }

                    foreach (Address a in alist) {
                        SendPing(a);
                    }

                    Vsync.Sleep(30000);
                }
            }
            catch (VsyncShutdownException) {
                VsyncSystem.CheckLocksHeld();
            }

            VsyncSystem.ThreadTerminationMagic();
        }

        internal static MCMDSocket.GRPair[] GroupRates() {
            List<MCMDSocket.GRPair> GRPList = new List<MCMDSocket.GRPair>();
            using (var tmpLockObj = new LockAndElevate(VsyncGroupsLock)) {
                foreach (KeyValuePair<Address, Group> kvp in VsyncGroups) {
                    Group g = kvp.Value;
                    if ((VsyncSystem.Debug & VsyncSystem.MCMD) != 0) {
                        Vsync.WriteLine("MCMD: Updating rate info for gaddr=" + g.gaddr + ", g.rcvdMcastsRate = (rate:" + g.rcvdMcastsRate + " cnt:" + g.rcvdMcastsCnt + ")/2 giving " + ((g.rcvdMcastsRate + g.rcvdMcastsCnt) / 2));
                    }

                    g.rcvdMcastsRate = (g.rcvdMcastsRate + g.rcvdMcastsCnt) / 2;
                    g.rcvdMcastsCnt = 0;
                    GRPList.Add(new MCMDSocket.GRPair(g.gaddr, g.rcvdMcastsRate));
                }
            }

            return GRPList.ToArray();
        }

        internal void OracleHeartBeat() {
            try {
                int n = 1;
                int looped = 0;
                int counter = 0;
                List<Address> CleanUp = new List<Address>();
                while (VsyncSystem.VsyncActive && (this.GroupOpen || !this.WasOpen)) {
                    VsyncSystem.RTS.ThreadCntrs[10]++;
                    Vsync.Sleep(1000);
                    View theView;
                    Address sendTo = null;
                    using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                        theView = this.theView;
                    }

                    if (!this.HasFirstView) {
                        if (looped++ == 5) {
                            if ((VsyncSystem.Debug & VsyncSystem.STARTSEQ) != 0) {
                                Vsync.WriteLine("VSYNC ORACLE SERVICE: Restarted");
                            }

                            VsyncSystem.VsyncRestarting = false;
                            View v = new View("ORACLE", Vsync.ORACLE.gaddr, new[] { Vsync.my_address }, 0, false);
                            Vsync.ORACLE.NewView(v, "ORACLE", null);

                            ReliableSender.StartGroupReader(Vsync.ORACLE);

                            // Runs only in the current leader
                            Vsync.ORACLE.LeaderMode = true;
                            Vsync.ORACLE.GroupOpen = true;
                            Vsync.OracleViewThread = new Thread(Vsync.OracleViewTask) { Name = "Vsync <ORACLE> View Thread", IsBackground = true };
                            Vsync.IAmOracle = true;
                            Vsync.OracleViewThread.Start();
                            MCMDSocket.RunMappingTask();
                        }
                    }
                    else if (theView != null) {
                        if (theView.IAmLeader()) {
                            n = (n + 1) % theView.members.Length;
                            if (!theView.members[n].isMyAddress() && !theView.hasFailed[n]) {
                                SendPing(theView.members[n]);
                            }
                        }
                        else if ((n = theView.GetMyRank()) > 0) {
                            while (theView.hasFailed[--n]) {
                                if (n == 0) {
                                    throw new VsyncException("Total failure of the ORACLE group (of which I'm a client): Vsync must shut down.");
                                }
                            }

                            SendPing(theView.members[n]);
                        }

                        if ((counter % 1) == 0) {
                            // Every second, the Oracle members....
                            using (var tmpLockObj = new LockAndElevate(TPGroupsLock)) {
                                foreach (KeyValuePair<Address, Group> kvp in TPGroups) {
                                    Group g = kvp.Value;
                                    int r = theView.GetMyRank();
                                    if (this.HasFirstView && r != -1 && (((g.gaddr.GetHashCode() + counter) % theView.members.Length) == r)) {
                                        if (g.theView != null && g.theView.members.Length > 0) {
                                            for (int i = 0; i < g.theView.members.Length; i++) {
                                                if (!g.theView.hasFailed[i]) {
                                                    // ... take turns pinging the leaders of each group (the first non-failed member in the view)
                                                    // The idea is to spread load but also to be sure that every group definitely does get pinged once per second
                                                    sendTo = g.theView.members[i];
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        if (sendTo != null) {
                            SendPing(sendTo);
                        }
                    }

                    if (++counter % 600 == 0) {
                        /* Every five minutes */
                        using (var tmpLockObj = new LockAndElevate(Vsync.RIPLock)) {
                            foreach (Address a in CleanUp) {
                                Vsync.RIPList.Remove(a);
                            }

                            CleanUp = new List<Address>();
                            foreach (Address a in Vsync.RIPList) {
                                CleanUp.Add(a);
                            }
                        }
                    }
                }
            }
            catch (VsyncShutdownException) {
                VsyncSystem.CheckLocksHeld();
            }

            VsyncSystem.ThreadTerminationMagic();
        }

        // Ping him, unless something is already in the send queue or the send queue length is excessive
        private static void SendPing(Address sendTo) {
            if (sendTo.isMyAddress()) {
                return;
            }

            bool fnd = false;
            if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                using (var tmpLockObj = new LockAndElevate(ReliableSender.ackInfoLock)) {
                    ReliableSender.ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: SendPing to " + sendTo + Environment.NewLine);
                }
            }

            using (var tmpLockObj = new LockAndElevate(ReliableSender.PendingSendBufferLock)) {
                if (ReliableSender.PendingSendBuffer.Count + ReliableSender.P2PPendingSendBuffer.Count > Vsync.VSYNC_ASYNCMTOTALLIMIT * 2) {
                    fnd = true;
                }
                else {
                    foreach (ReliableSender.MsgDesc md in ReliableSender.PendingSendBuffer) {
                        if (md.dest == sendTo) {
                            fnd = true;
                            break;
                        }
                    }

                    if (!fnd) {
                        foreach (ReliableSender.MsgDesc md in ReliableSender.P2PPendingSendBuffer) {
                            if (md.dest == sendTo) {
                                fnd = true;
                                break;
                            }
                        }
                    }
                }
            }

            if (!fnd) {
                ReliableSender.SendP2P(Msg.ISPING, sendTo, null, new byte[0], true);
            }
        }

        internal LockObject RateLock = new LockObject("RateLock");

        internal int accumulatedMsgTokens = 0;

        internal int accumulatedByteTokens = 0;

        internal int msgTokenRate = int.MaxValue;

        internal int byteTokenRate = int.MaxValue;

        internal int sleepDelay = 0;

        internal Thread RateThread;

        /// <summary>
        /// Sets a rate limit for multicasts expressed as messages per second
        /// </summary>
        /// <param name="msgspersec">Limit on messages per time unit</param>
        public void SetRateLimit(int msgspersec) {
            this.SetRateLimit(msgspersec, int.MaxValue, 1000);
        }

        /// <summary>
        /// Sets a rate limit for multicasts in this group.  
        /// </summary>
        /// <param name="msgspertimeunit">Limit on messages per time unit</param>
        /// <param name="bytespertimeunit">Limit on bytes per time unit</param>
        /// <param name="timeunit">Time unit for the limits in milliseconds</param>
        public void SetRateLimit(int msgspertimeunit, int bytespertimeunit, int timeunit) {
            using (var tmpLockObj = new LockAndElevate(this.RateLock)) {
                this.msgTokenRate = msgspertimeunit;
                this.byteTokenRate = bytespertimeunit;
                this.sleepDelay = Math.Max(timeunit, 50);
                if (this.RateThread == null) {
                    this.RateThread = new Thread(() => {
                        while (!VsyncSystem.VsyncActive) {
                            Vsync.Sleep(250);
                        }

                        try {
                            while (VsyncSystem.VsyncActive) {
                                VsyncSystem.RTS.ThreadCntrs[11]++;
                                Monitor.Enter(this.RateLock);
                                if (this.msgTokenRate >= int.MaxValue / 2) {
                                    this.accumulatedMsgTokens = this.msgTokenRate;
                                }
                                else {
                                    this.accumulatedMsgTokens = (this.accumulatedMsgTokens / 2) + this.msgTokenRate;
                                }

                                if (this.byteTokenRate >= int.MaxValue / 2) {
                                    this.accumulatedByteTokens = this.byteTokenRate;
                                }
                                else {
                                    this.accumulatedByteTokens = (this.accumulatedByteTokens / 2) + this.byteTokenRate;
                                }

                                Monitor.PulseAll(this.RateLock);
                                Monitor.Exit(this.RateLock);
                                Vsync.Sleep(this.sleepDelay);
                            }
                        }
                        catch (VsyncShutdownException) {
                            VsyncSystem.CheckLocksHeld();
                        }

                        VsyncSystem.ThreadTerminationMagic();
                    }) { Name = "Group [" + this.gname + "]: Leaky bucket rate controller thread", IsBackground = true };
                    this.RateThread.Start();
                }
            }
        }

        // Implements the internal logic for the leaky bucket rate controller, supported optionally on a per-group basis
        internal void RateLimit(int nb) {
            if (this.RateThread == null) {
                return;
            }

            Monitor.Enter(this.RateLock);
            while (this.accumulatedMsgTokens == 0 || this.accumulatedByteTokens < nb) {
                Monitor.Wait(this.RateLock);
            }

            this.accumulatedMsgTokens--;
            this.accumulatedByteTokens -= nb;
            Monitor.Exit(this.RateLock);
        }

        private readonly List<KeyValuePair<int, long>> IdsByThreadId = new List<KeyValuePair<int, long>>();

        private readonly LockObject IdsByThreadIdLock = new LockObject("IdsByThreadIdLock");

        internal long newLoggingId() {
            long myId;
            using (var tmpLockObj = new LockAndElevate(this.IdsByThreadIdLock)) {
                myId = this.myLoggingId++;
                foreach (KeyValuePair<int, long> kvp in this.IdsByThreadId) {
                    if (kvp.Key == Thread.CurrentThread.ManagedThreadId) {
                        this.IdsByThreadId.Remove(kvp);
                        break;
                    }
                }

                this.IdsByThreadId.Add(new KeyValuePair<int, long>(Thread.CurrentThread.ManagedThreadId, myId));
            }

            return myId;
        }

        internal long lookupLoggingId() {
            using (var tmpLockObj = new LockAndElevate(this.IdsByThreadIdLock)) {
                foreach (KeyValuePair<int, long> kvp in this.IdsByThreadId) {
                    if (kvp.Key == Thread.CurrentThread.ManagedThreadId) {
                        return kvp.Value;
                    }
                }
            }

            return -1;
        }

        internal volatile bool usesSubsetSend;

        internal volatile bool receivedOrderedSends;

        /// <summary>
        /// A totally ordered Vsync multicast primitive.  All members receive these messages in the same view and in the identical order.
        /// </summary>
        /// <param name="obs">A variable-length argument list specifying a request ID and a set of arguments that should match some handler.</param>
        /// <remarks>
        /// A totally ordered Vsync multicast primitive that can be extremely fast, particularly if sent by the group leader.  OrderedSend is a <it>non-durable multicast</it>.
        ///
        /// This non-durable ordered form of Send is often the right choice, as it offers total ordering but can be very fast, especially if sent from the group leader. 
        /// 
        /// Basically, maps to an IP multicast, but delivery is then delayed until ordering information is specified by the leader (the leader gets a special
        /// break: in that member, OrderedSend is performed using the cheapest Send because FIFO is all we need in that case).
        /// Synchronized with respect to membership changes in accordance with the virtual synchrony model, which is a strong and
        /// useful property.  The first parameter is an identifier for the message handler to invoke (a small integer) and the remaining
        /// are the arguments, which are objects of types known to Vsync.  An exception will be thrown if the group doesn't have a message handler for
        /// the specified request id, and matching the number and types of objects you specified.
        ///
        /// Read more about the <it>virtual synchrony model</it> to learn about the options
        /// and how to pick the fastest mechanism for the setting in which your application will run.
        /// </remarks>
        public void OrderedSend(params object[] obs) {
            if (this.receivedOrderedSends && this.UnstableCount == 0 && ReliableSender.PendingSendBuffer.Count == 0 && ReliableSender.P2PPendingSendBuffer.Count == 0 && this.ToDoCount == 0 && this.incomingSends.FullSlots() == 0) {
                // A conservative test: no unstable incoming messages, so everyone knows of any prior OrderedSends by other senders.  And my 
                // PendingSendBuffer and lgPendingSendBuffer are empty, so everyone knows of anything I already sent.
                // And... last but not least... I'm "caught up" for incoming messages...
                this.receivedOrderedSends = false;
            }

            if (this.IAmRank0() && !this.receivedOrderedSends) {
                this._Send(true, obs);
                return;
            }

            if (!this.VsyncCallStart()) {
                return;
            }

            if (obs.Length > 1 && obs[0] is int && IsSubsetSend(obs[1])) {
                object[] newobs = new object[obs.Length + 1];
                newobs[0] = obs[1];
                for (int i = 0; i < obs.Length; i++) {
                    newobs[i + 1] = obs[i];
                }

                obs = newobs;
            }

            this.ThreadCheck();
            if (IsSubsetSend(obs[0])) {
                this.usesSubsetSend = true;
                this.doOrderedSubsetSend(obs);
            }
            else {
                if (this.usesSubsetSend && (VsyncSystem.Debug & VsyncSystem.WARNABOUTSUBSETS) != 0) {
                    Vsync.WriteLine("WARNING: In group <" + this.gname + "> application is mixing OrderedSubsetSends with OrderedSend.  The relative order is not guaranteed");
                }

                this.OrderedSendWith((vid, mid, flag, m) => this.doSend(vid, mid, m.nRaw, flag, Vsync.ORDEREDSEND, m), obs);
            }

            this.VsyncCallDone();
        }

        private static bool IsSubsetSend(object obj) {
            Type t = obj.GetType();
            return t == typeof(List<Address>) || t == typeof(Address[]) || (t.IsGenericType && t.GetGenericTypeDefinition() == typeof(QueryKey<>)) || (t == typeof(Msg) && ((Msg)obj).destList != null);
        }

        private void doOrderedSubsetSend(object[] obs) {
            bool copyDown = false;
            List<Address> dests;
            Type t = obs[0].GetType();
            if (t == typeof(List<Address>)) {
                dests = (List<Address>)obs[0];
                copyDown = true;
            }
            else if (t == typeof(Msg) && ((Msg)obs[0]).destList != null) {
                dests = ((Msg)obs[0]).destList;
            }
            else if (t.IsGenericType && t.GetGenericTypeDefinition() == typeof(QueryKey<>)) {
                dests = ((QKD)obs[0]).GetDests(this);
                copyDown = true;
            }
            else {
                throw new VsyncException("doOrderedSubsetSend: can't identify the subset destination list");
            }

            if (copyDown) {
                object[] newObs = new object[obs.Length - 1];
                for (int n = 0; n < obs.Length - 1; n++) {
                    newObs[n] = obs[n + 1];
                }

                obs = newObs;
            }

            Msg m = new Msg(obs);
            this.SetMsgIds(m, false, true);
            List<long> ts = new List<long>();
            List<Address> who = new List<Address>();
            if ((VsyncSystem.Debug & VsyncSystem.ORDEREDSEND) != 0) {
                Vsync.WriteLine("doOrderedSubsetSend[" + Address.VectorToString(dests.ToArray()) + "]... sending " + m.sender + "::" + m.vid + ":" + m.msgid + "... will wait for " + dests.Count + " responses");
            }

            FlowControl.FCBarrierCheck(dests);
            int nr = this.doQuery(dests.Count, new Timeout(Vsync.VSYNC_DEFAULTTIMEOUT * 3 / 2, Timeout.TO_FAILURE), dests, Vsync.ORDEREDSEND, dests, this.myTS, m, EOL, ts, who);
            if ((VsyncSystem.Debug & VsyncSystem.ORDEREDSEND) != 0) {
                Vsync.WriteLine("doOrderedSubsetSend... " + m.sender + "::" + m.vid + ":" + m.msgid + "... got " + nr + " responses");
            }

            if (nr > 0) {
                long cts = ts[0];
                Address cwho = who[0];
                for (int n = 1; n < nr; n++) {
                    if (ts[n] == cts) {
                        cts = ts[n];
                        if (who[n].CompareTo(cwho) > 0) {
                            cwho = who[n];
                        }
                    }
                    else if (ts[n] > cts) {
                        cts = ts[n];
                        cwho = who[n];
                    }
                }

                if ((VsyncSystem.Debug & VsyncSystem.ORDEREDSEND) != 0) {
                    Vsync.WriteLine("doOrderedSubsetSend... got " + nr + " responses for " + m.sender + "::" + m.vid + ":" + m.msgid);
                    Vsync.WriteLine("... send [" + Address.VectorToString(dests.ToArray()) + "] commit time @ " + cts + "::" + cwho);
                }

                if (cts > this.myTS) {
                    this.myTS = cts;
                }

                this.doSend(false, false, dests, Vsync.ORDEREDSEND, m.sender, m.vid, m.msgid, cts, cwho);
            }
        }

        private void OrderedSendWith(Action<int, int, bool, Msg> theSend, object[] obs) {
            if ((this.flags & G_ISLARGE) != 0) {
                this.Send(obs);
                return;
            }

            if (this.myLoggingFcn != null) {
                this.myLoggingFcn(IL_ORDEREDSEND, IL_START, Vsync.my_address, this.newLoggingId(), obs);
            }

            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            if (obs.Length != 1 || obs[0].GetType() != typeof(Msg)) {
                this.cbCheck(obs);
            }

            this.RateLimit(obs.Length);
            FlowControl.FCBarrierCheck();
            Msg m;
            if (obs.Length == 1 && obs[0].GetType() == typeof(Msg)) {
                m = (Msg)obs[0];
            }
            else {
                m = new Msg(obs);
                try {
                    ILock.NoteThreadState("Wedged(OrderedSendWidth).WaitOne()");
                    this.Wedged.WaitOne();
                    ILock.NoteThreadState(null);
                    using (var tmpLockObj = new LockAndElevate(this.CommitLock))
                    using (var tmpLockObj1 = new LockAndElevate(this.ViewLock)) {
                        m.vid = this.theView == null ? -1 : this.theView.viewid;
                        m.msgid = this.nextMsgid++;
                        m.nRaw = this.nRaw;
                        this.nRaw = 0;
                    }
                }
                finally {
                    this.Wedged.Release();
                }
            }

            m.dest = this.gaddr;
            theSend(m.vid, m.msgid, false, m);
        }

        private delegate void MergeSafeSendReplies(int[] timestamp, Address[] who);

        /// <summary>
        /// The slowest but strongest of the Vsync multicast primitives, offering a totally ordered, durable multicast matching the Paxos semantics.
        /// </summary>
        /// <param name="obs">A variable-length argument list specifying a request ID and a set of arguments that should match some handler.</param>
        /// <throws>VsyncSafeSendException if the group size drops below the SafeSendThreshold</throws>
        /// <remarks>
        /// The slowest but strongest of the Vsync multicast primitives, offering a totally ordered, durable multicast matching the Paxos semantics
        /// and suitable for use in State Machine Replication or Transactional Database settings where the very strongest possible properties
        /// are needed, even at substantial performance cost.
        /// 
        /// This form of Send is costly, and might not be the right choice: the properties are very powerful, but they aren't cheap. 
        /// The cost is even higher if SafeSend is used in a large group from any member except the rank-0 process (this cost could
        /// be reduced but the needed code isn't trivial and this version of Vsync is just not optimized for SafeSend by non-rank0 members of large groups)
        /// 
        /// Before using SafeSend we recommend that you consider using the mostly-safe Send primitives, but then call Flush before replying
        /// to the end-user.  This will usually be just as safe and yet much faster for many purposes.  We've written a paper on this topic.
        /// 
        /// Basically, maps to a two-phase commit: the first phase is via IP multicast, but safesendThreshold group members must ack before delivery occurs.
        /// The default for safesendThreshold is ALL, but you can set a lower value using SetSafeSendThreshold to some other value, like 2 or 3.
        /// The sender will count as one of the the acking members, so in fact Vsync actually waits for safesendThreshold-1 replies.
        /// If a view change occurs, any pending SafeSend messages that have not yet been delivered are flushed (hence reach
        /// all members) and then delivered as part of the new view COMMIT protocol.
        /// 
        /// The SafeSend primitive is synchronized with respect to membership changes in accordance with the virtual synchrony model, which is a strong and
        /// useful property.  The first parameter is an identifier for the message handler to invoke (a small integer) and the remai ning
        /// are the arguments, which are objects of types known to Vsync.  An exception will be thrown if the group doesn't have a message handler for
        /// the specified request id, and matching the number and types of objects you specified.
        /// 
        /// Read more about the <it>virtual synchrony model</it> to learn about the options
        /// and how to pick the fastest mechanism for the setting in which your application will run.
        /// </remarks>
        public void SafeSend(params object[] obs) {
            if (!this.VsyncCallStart()) {
                return;
            }

            if ((this.flags & G_ISLARGE) != 0) {
                throw new VsyncException("Safesend: Not supported in large groups");
            }

            this.ThreadCheck();
            if (this.myLoggingFcn != null) {
                this.myLoggingFcn(IL_SAFESEND, IL_START, Vsync.my_address, this.newLoggingId(), obs);
            }

            this.TypeCheck(obs);
            this.RateLimit(obs.Length);
            FlowControl.FCBarrierCheck();
            this.doSafeSend(obs);
            this.VsyncCallDone();
        }

        /// <summary>
        /// This method is used to specify how many members of a group need to acknowledge a SafeSend multicast before it can be delivered.
        /// For example, if the value specified is 3, then once a copy of the message is at 3 members, delivery occurs (even if the group has 1000 members).
        /// </summary>
        /// <param name="value">The number of members SafeSend will wait for</param>
        /// <remarks>SafeSend waits for replies from the members ranked 0..SafeSendThreshold-1.  This parameter functions exactly as does the Paxos
        /// "number of acceptors" parameter (continuing the analogy, the full set of members are "listeners")</remarks>
        public void SetSafeSendThreshold(int value) {
            this.safeSendThreshold = value;
        }

        internal int GetSafeSendThreshold() {
            View theView;
            using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                theView = this.theView;
            }

            if (this.HasFirstView) {
                if (this.safeSendThreshold == ALL) {
                    return theView.members.Length;
                }

                if (theView.members.Length < this.safeSendThreshold) {
                    return -1;
                }

                return this.safeSendThreshold;
            }

            return -1;
        }

        /// <summary>
        /// Specifies a method that will be used to ensure the durability of a SafeSend.  If not specified, in-memory caching at the acceptors is used
        /// </summary>
        /// <param name="theMethod">A method implementing the durabilityMethod API</param>
        public void SetDurabilityMethod(durabilityMethod theMethod) {
            this.safeSendDurabilityMethod = theMethod;
        }

        private void doSafeSend(object[] obs) {
            if (this.theView.nLive() < this.safeSendThreshold) {
                throw new VsyncSafeSendException("Group<" + this.gname + ">: size dropped below SafeSend threshold=" + this.safeSendThreshold);
            }

            int maxTime = int.MinValue;
            Address maxAddr = Vsync.my_address;
            this.cbCheck(obs);
            Msg m;
            if (obs.Length == 1 && obs[0].GetType() == typeof(Msg)) {
                m = (Msg)obs[0];
            }
            else {
                m = new Msg(obs);
                try {
                    ILock.NoteThreadState("Wedged(doSafeSend).WaitOne()");
                    this.Wedged.WaitOne();
                    ILock.NoteThreadState(null);
                    using (var tmpLockObj = new LockAndElevate(this.groupLock))
                    using (var tmpLockObj1 = new LockAndElevate(this.CommitLock)) {
                        m.vid = this.theView.viewid;
                        m.msgid = this.nextMsgid++;
                        m.nRaw = this.nRaw;
                        this.nRaw = 0;
                    }
                }
                finally {
                    this.Wedged.Release();
                }
            }

            // Timeout needs to be long because we might encounter the disklogger in the middle of garbage collection, which involves copying files and can take a while
            Msg.InvokeFromBArrays(this.QueryToBAFromSystem(m.vid, m.msgid, m.nRaw, this.safeSendThreshold, new Timeout(Vsync.VSYNC_DEFAULTTIMEOUT * 4, Timeout.TO_FAILURE, "SAFESEND"), Vsync.SAFESEND, Vsync.my_address, m.msgid, m), new MergeSafeSendReplies((timestamp, who) => {
                if (timestamp.Length < this.safeSendThreshold) {
                    throw new VsyncSafeSendException("Group<" + this.gname + ">: size dropped below SafeSend threshold=" + this.safeSendThreshold);
                }

                for (int n = 0; n < timestamp.Length; n++) {
                    if (timestamp[n] > maxTime || (timestamp[n] == maxTime && who[n].GetHashCode() > maxAddr.GetHashCode())) {
                        maxTime = timestamp[n];
                        maxAddr = who[n];
                    }
                }
            }));

            // By using Send instead of doSend, this code deliberately allows the Send to be blocked if the group
            // is wedged for a membership change (doSend ignores that kind of wedging).  In such cases upon receipt,
            // the corresponding message will already have been delivered. But we don't want flow control to kick in.
            this.NonFlowControlledSend(Vsync.SAFEDELIVER, Vsync.my_address, m.msgid, maxTime, maxAddr);
        }

        /// <summary>
        /// The cheapest and fastest of the Vsync multicast primitives, offering a FIFO (by sender) but otherwise unordered, non-durable multicast.
        /// </summary>
        /// <param name="obs">A variable-length argument list specifying a request ID and a set of arguments that should match some handler.</param>
        /// <remarks> 
        /// The cheapest and fastest of the Vsync multicast primitives, offering a FIFO (by sender) but otherwise unordered, non-durable multicast.
        /// 
        /// This cheap form of Send is usually, but not always, the right choice.  Read more about the <it>virtual synchrony model</it> to learn about the options
        /// and how to pick the fastest mechanism for the setting in which your application will run.
        /// 
        /// Basically, maps to an IP multicast, but with reliability and ordering on a per-sender basis, and delivered as soon as it arrives.
        /// Nonetheless, synchronized with respect to membership changes in accordance with the virtual synchrony model, which is a strong and
        /// useful property.  The first parameter is an identifier for the message handler to invoke (a small integer) and the remaining
        /// are the arguments, which are objects of types known to Vsync.  An exception will be thrown if the group doesn't have a message handler for
        /// the specified request id, and matching the number and types of objects you specified.
        /// </remarks>
        public void Send(params object[] obs) {
            this._Send(true, obs);
        }

        private void NonFlowControlledSend(params object[] obs) {
            this._Send(false, obs);
        }

        private void _Send(bool okToBlock, object[] obs) {
            if (!this.VsyncCallStart()) {
                return;
            }

            obs = subsetShortcut(obs);
            if (okToBlock) {
                this.ThreadCheck();
            }

            if (this.myLoggingFcn != null) {
                this.myLoggingFcn(IL_SEND, IL_START, Vsync.my_address, this.newLoggingId(), obs);
            }

            if (okToBlock) {
                this.RateLimit(obs.Length);
            }

            List<Address> dests = null;
            if (IsSubsetSend(obs[0])) {
                dests = GetDests(obs);
            }

            if (okToBlock) {
                FlowControl.FCBarrierCheck(dests);
            }

            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            this.doSend(false, false, obs);
            this.VsyncCallDone();
        }

        private List<Address> GetDests(object[] obs) {
            List<Address> dests;
            Type t = obs[0].GetType();
            if (t == typeof(List<Address>)) {
                dests = (List<Address>)obs[0];
            }
            else if (t == typeof(Address[])) {
                dests = ((Address[])obs[0]).ToList();
            }
            else if (t == typeof(QKD) || (t.IsGenericType && t.GetGenericTypeDefinition() == typeof(QueryKey<>))) {
                dests = ((QKD)obs[0]).GetDests(this);
            }
            else {
                dests = ((Msg)obs[0]).destList;
            }
            return dests;
        }

        private static object[] subsetShortcut(object[] obs) {
            if (obs.Length > 1 && obs[0] is int && IsSubsetSend(obs[1])) {
                object[] newobs = new object[obs.Length + 1];
                newobs[0] = obs[1];
                for (int i = 0; i < obs.Length; i++) {
                    newobs[i + 1] = obs[i];
                }

                obs = newobs;
            }

            return obs;
        }

        internal void ThreadCheck() {
            if (this != Vsync.ORACLE && this != Vsync.VSYNCMEMBERS && (!VsyncSystem.VsyncActive || VsyncSystem.VsyncRestarting || !this.GroupOpen)) {
                throw new VsyncException("Group multicast operation was initiated before the system was fully operational or before the group Join completed");
            }

            if (Thread.CurrentThread == this.groupIPMCReaderThread) {
                Vsync.WriteLine("WARNING: <" + this.gname + ">.Send()/g.Query() or some multicast primitive was called from the incoming multicasts delivery thread (high risk of deadlocks)");
            }
        }

        /// <summary>
        /// An unreliable version of Send.
        /// </summary>
        /// <param name="obs">A variable-length argument list specifying a request ID and a set of arguments that should match some handler.</param>
        /// <remarks> 
        /// The RawSend API is provided for advanced users only.  The multicast is sent without retransmission in the event of failure and
        /// is not acknowledged by the receiver.  RawSend is currently disabled for Large Group cases (it maps to reliable Send).
        /// 
        /// Please note that when using RawSend at high rates, loss rates can spike unless the sender employs a non-zero value for the VSYNC_RATELIM parameter,
        /// which limits the number of packets transmitted per second.  See the user manual for details
        /// </remarks>
        public void RawSend(params object[] obs) {
            if (!this.VsyncCallStart()) {
                return;
            }

            this.ThreadCheck();
            if (this.myLoggingFcn != null) {
                this.myLoggingFcn(IL_SEND, IL_START, Vsync.my_address, this.newLoggingId(), obs);
            }

            this.RateLimit(obs.Length);
            FlowControl.FCBarrierCheck();
            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            this.doSend(false, (this.flags & G_ISLARGE) == 0, obs);
            this.VsyncCallDone();
        }

        /// <summary>
        /// An Vsync multicast that runs nearly as fast as Send, but with a stronger "casuality-preserving" ordering property.
        /// </summary>
        /// <param name="obs">A variable-length argument list specifying a request ID and a set of arguments that should match some handler.</param>
        /// <remarks> 
        /// Imagine that Send(X) is performed by member A, and then member B, receiving X, issues Send(Y).  With the FIFO property of Send, nothing prevents
        /// member C from receiving Y before X!  CausalSend guarantees that if X "happens before" Y, then CausalSend(X) will be delivered before CausalSend(Y)
        /// 
        /// For most purposes, Send or Causal send is the best choice, followed by a call to Flush() prior to responding to external clients.  
        /// Read more about the <it>virtual synchrony model</it> to learn about the options
        /// and how to pick the fastest mechanism for the setting in which your application will run.
        /// 
        /// Send and CausalSend both map to an IP multicast or a tunneled application-implemented multicast, and CausalSend will usually be delivered as soon as it arrives.
        /// CausalSend is synchronized with respect to membership changes in accordance with the virtual synchrony model, which is a strong and
        /// useful property.  The first parameter is an identifier for the message handler to invoke (a small integer) and the remaining
        /// are the arguments, which are objects of types known to Vsync.  An exception will be thrown if the group doesn't have a message handler for
        /// the specified request id, and matching the number and types of objects you specified.
        /// </remarks>
        public void CausalSend(params object[] obs) {
            if (!this.VsyncCallStart()) {
                return;
            }

            this.ThreadCheck();
            if ((this.flags & G_ISLARGE) != 0) {
                this.Send(obs);
            }
            else if (this.theView.members.Length > 5) {
                // In larger groups the VT scheme doesn't work well; use OrderedSend instead
                this.OrderedSend(obs);
            }
            else {
                int[] myVT;
                int theVid;
                using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                    theVid = this.theView.viewid;
                    myVT = new int[this.theView.myVT.Length];
                    Buffer.BlockCopy(this.theView.myVT, 0, myVT, 0, Buffer.ByteLength(this.theView.myVT));
                    myVT[this.theView.GetMyRank()] = this.theView.myClock++;
                }

                if ((VsyncSystem.Debug & VsyncSystem.CAUSALDELIVERY) != 0) {
                    Vsync.WriteLine("Sending a causal multicast in vid=" + theVid + ", with VT=" + VTtoString(myVT));
                }

                this.Send(Vsync.CAUSALSEND, theVid, myVT, new Msg(obs));
            }

            this.VsyncCallDone();
        }

        internal static void doMultiSend(List<Group> glist, bool fromOracle, params object[] obs) {
            foreach (Group g in glist) {
                g.RateLimit(obs.Length);
                g.TypeCheck(obs);
                g.doSend(fromOracle, false, obs);
            }
        }

        private readonly LockObject RelayedLGSendsLock = new LockObject("RelayedLGSendsLock");

        private List<Msg> RelayedLGSends = new List<Msg>();

        private Address prevLGOwner;

        private bool LGSetupDone;

        internal string LGRelayGetState() {
            string s = string.Empty;
            using (var tmpLockObj = new LockAndElevate(this.RelayedLGSendsLock)) {
                if (this.RelayedLGSends.Count == 0) {
                    return s;
                }

                s = "LG Relayed Sends queue:" + Environment.NewLine;
                foreach (Msg m in this.RelayedLGSends) {
                    s += "  --  " + m + Environment.NewLine;
                }
            }

            return s;
        }

        internal void LGSetup() {
            if (this.LGSetupDone) {
                return;
            }

            this.LGSetupDone = true;
            tokenInfo outerToken;
            using (var tmpLockObj = new LockAndElevate(this.TokenLock)) {
                outerToken = this.theToken;
            }

            if (outerToken != null) {
                this.prevLGOwner = outerToken.groupOwner;
            }

            // Note that the peek-ahead logic for messages watches for RELAYSEND and expects the ViewDelta vector to be the first (and only) argument... If this is changed, that also needs to change
            this.doRegister(Vsync.RELAYSEND, new Action<Vsync.ViewDelta[]>(vds => {
                tokenInfo theToken;
                View theView = null;
                if (!this.HasFirstView) {
                    using (var tmpLockObj = new LockAndElevate(this.CommitLock)) {
                        Vsync.CommitGVUpdates(this, vds, ref theView);
                    }
                }

                using (var tmpLockObj = new LockAndElevate(this.TokenLock))
                using (var tmpLockObj1 = new LockAndElevate(this.ViewLock)) {
                    theToken = this.theToken;
                    theView = this.theView;
                }

                vds = vds.Select(vd => vd).Where(vd => vd.gaddr == this.gaddr && vd.prevVid >= (theView == null ? -1 : theView.viewid)).ToArray();
                if (vds.Length == 0) {
                    return;
                }

                if ((VsyncSystem.Debug & (VsyncSystem.RELAYLOGIC | VsyncSystem.TOKENLOGIC)) != 0) {
                    Vsync.WriteLine("Large Group owner relaying COMMIT for a vector of view deltas in <" + this.gname + ">");
                    foreach (Vsync.ViewDelta vd in vds) {
                        Vsync.WriteLine("   " + vd);
                    }
                }

                if (theView == null || theToken == null) {
                    throw new VsyncException("Large group had a total failure just as I was joining.");
                }

                theToken.applyViewDeltas(this, vds);
                if (this.myFirstLeadershipView == 0) {
                    return;
                }

                this.becomeGroupOwner();
                foreach (Vsync.ViewDelta vd in vds) {
                    if (vd.prevVid >= theView.viewid) {
                        if ((VsyncSystem.Debug & (VsyncSystem.GROUPEVENTS | VsyncSystem.RELAYLOGIC | VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENFLUSH)) != 0) {
                            Vsync.WriteLine("In RELAYSEND relaying COMMIT in <" + this.gname + "> for ViewDelta " + vd);
                        }

                        using (var tmpLockObj = new LockAndElevate(theToken.slock)) {
                            if (theToken.unstableVIDMID == 0) {
                                theToken.unstableVIDMID = this.nextMsgid;
                                theToken.unstableVID = theToken.viewid;
                            }
                        }

                        this.doSend(false, false, Vsync.COMMIT, vds);
                        break;
                    }
                }

                List<Msg> toRelay;
                using (var tmpLockObj = new LockAndElevate(this.RelayedLGSendsLock)) {
                    toRelay = this.RelayedLGSends;
                    this.RelayedLGSends = new List<Msg>();
                }

                foreach (Msg m in toRelay) {
                    this.doSend(false, false, m);
                }

                // Asynchronously send off a message to the ORACLE: I'm stable up to whatever the current viewid shows
                int stableVID;
                using (var tmpLockObj = new LockAndElevate(theToken.slock)) {
                    stableVID = theToken.stableVID;
                }

                Vsync.ORACLE.doSend(false, false, Vsync.ISSTABLE, this.gaddr, stableVID);
            }));

            // Register the flush aggregator for this group
            this.doRegisterAggregator((FlushAggKey key, bool lV, bool dV) => lV && dV);
        }

        internal void doUnorderedSend(params object[] obs) {
            if (obs == null || obs.Length < 1) {
                throw new ArgumentNullException("obs", "Vsync.Group.Cast");
            }

            if (obs.Length == 1 && obs[0].GetType() == typeof(object[])) {
                obs = (object[])obs[0];
            }

            this.doTheSend(false, false, false, Msg.UNORDERED, obs);
        }

        internal void doSendNotFromOracle(params object[] obs) {
            this.doSend(false, false, obs);
        }

        internal void doRawSendNotFromOracle(params object[] obs) {
            this.doSend(false, true, obs);
        }

        internal void doSendFromOracle(params object[] obs) {
            this.doSend(true, false, obs);
        }

        internal void doSend(bool isFromOracle, bool isRaw, params object[] obs) {
            if (obs == null || obs.Length < 1) {
                throw new ArgumentNullException("obs", "Vsync.Group.Cast");
            }

            if (obs.Length == 1 && obs[0].GetType() == typeof(object[])) {
                obs = (object[])obs[0];
            }

            this.doTheSend(isFromOracle, isRaw, false, isRaw ? Msg.RAWMULTICAST : Msg.MULTICAST, obs);
        }

        internal void doSend(int vid, int msgid, int nRaw, bool isFromOracle, params object[] obs) {
            if (obs == null || obs.Length < 1) {
                throw new ArgumentNullException("obs", "Vsync.Group.Cast");
            }

            if (obs.Length == 1 && obs[0].GetType() == typeof(object[])) {
                obs = (object[])obs[0];
            }

            this.doTheSend(vid, msgid, nRaw, isFromOracle, true, false, Msg.MULTICAST, obs);
        }

        internal void doSendRaw(params object[] obs) {
            if (obs == null || obs.Length < 1) {
                throw new ArgumentNullException("obs", "Vsync.Group.Cast");
            }

            if (obs.Length == 1 && obs[0].GetType() == typeof(object[])) {
                obs = (object[])obs[0];
            }

            this.doTheSend(false, true, true, Msg.MULTICAST, obs);
        }

        private void doTheSend(bool sentByOracle, bool isRaw, bool isBeacon, byte type, object[] obs) {
            this.doTheSend(Msg.UNINITIALIZED, Msg.UNINITIALIZED, 0, sentByOracle, isRaw, isBeacon, type, obs);
        }

        private void doTheSend(int vid, int msgid, int nRaw, bool sentByOracle, bool isRaw, bool isBeacon, byte type, object[] obs) {
            // Loops while it finds the group wedged (e.g. membership is changing), then does the requested send
            int waitingTime = 0;
            for (int retry = 0; waitingTime < Vsync.VSYNC_DEFAULTTIMEOUT * 8 && (VsyncSystem.VsyncActive || !VsyncSystem.VsyncWasActive); retry++) {
                if (retry > 0) {
                    int howLong = retry < 10 ? 25 : 250;
                    Vsync.Sleep(howLong);
                    waitingTime += howLong;
                }

                // Perhaps non-ideal but the idea here is that from when we first assign message id's to a multicast until we send the
                // last fragment, we hold the SIFLock, preventing anyone else from touching the multicast send id# counter
                // The down side is that for Vsync, this is a fairly long-held lock and may be implicated in a multi-thread deadlock
                // involving the CommitLock
                using (var tmpLockObj = new LockAndElevate(this.SIFLock)) {
                    Msg m;
                    int xvid = -1;
                    using (var tmpLockObj1 = new LockAndElevate(this.ViewLock)) {
                        if (this.theView != null) {
                            xvid = this.theView.viewid;
                        }
                    }

                    if (!isRaw && (this.flags & G_WEDGED) != 0) {
                        if ((VsyncSystem.Debug & VsyncSystem.GROUPEVENTS) != 0) {
                            Vsync.WriteLine("doTheSend: forced to loop because <" + this.gname + "> vid " + xvid + " is wedged");
                        }

                        continue;
                    }

                    if (obs[0].GetType() == typeof(Msg) && ((Msg)obs[0]).destList != null) {
                        m = (Msg)obs[0];
                        foreach (Address dest in m.destList) {
                            this.doP2PSend(dest, true, m);
                        }

                        return;
                    }

                    if (IsSubsetSend(obs[0])) {
                        List<Address> dests = GetDests(obs);
                        obs = fixObs(obs);
                        this.cbCheck(obs);
                        m = new Msg(obs);
                        this.SetMsgIds(m, false, true);
                        foreach (Address dest in dests) {
                            this.doP2PSend(dest, true, m);
                        }

                        return;
                    }

                    if ((VsyncSystem.Debug & VsyncSystem.MESSAGELAYER) != 0) {
                        Vsync.WriteLine("doSend: GroupOpen " + this.GroupOpen + ", sendByOracle=" + sentByOracle + ", isRaw=" + isBeacon + ", type=" + type);
                    }

                    if (!this.GroupOpen && !isBeacon) {
                        return;
                    }

                    if (obs.Length == 1 && obs[0].GetType() == typeof(Msg)) {
                        m = (Msg)obs[0];
                    }
                    else {
                        this.cbCheck(obs);
                        m = new Msg(obs);
                    }

                    if (sentByOracle) {
                        m.flags |= Msg.SENTBYORACLE;
                    }

                    if ((this.flags & G_ISLARGE) != 0) {
                        tokenInfo theToken;
                        using (var tmpLockObj1 = new LockAndElevate(this.TokenLock)) {
                            theToken = this.theToken;
                        }

                        if (theToken != null && !theToken.IAmLgOwner) {
                            if (m.vid != -1 && m.msgid != -1) {
                                using (var tmpLockObj2 = new LockAndElevate(this.RelayedLGSendsLock)) {
                                    this.RelayedLGSends.Add(m);
                                }
                            }

                            this.doP2PSend(theToken.groupOwner, true, Vsync.RELAYSEND, m);
                            return;
                        }
                    }

                    if (isBeacon) {
                        // Special, used currently only by ORACLE BeaconTask
                        m.vid = 0;
                        m.msgid = -1;
                    }
                    else if (vid != Msg.UNINITIALIZED) {
                        m.vid = vid;
                        m.msgid = msgid;
                        m.nRaw = nRaw;
                    }
                    else if (m.vid == Msg.UNINITIALIZED) {
                        this.SetMsgIds(m, sentByOracle, isRaw);
                    }

                    if ((this.flags & G_SECURE) != 0 && (type == Msg.ISGRPP2P || type == Msg.ISRAWGRPP2P || type == Msg.MULTICAST || type == Msg.RAWMULTICAST || type == Msg.UNORDERED || type == Msg.ISREPLY)) {
                        this.cipherMsg(m);
                    }

                    if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.VIEWWAIT)) != 0) {
                        Vsync.WriteLine("ReliableSender.SendGroup to <" + this.gname + ">... type=" + Msg.mtypes[type] + ", Msg=" + m);
                    }

                    ReliableSender.SendGroup(type, this, m.vid, m.msgid, (byte)(m.flags & ~Msg.CIPHER), Msg.toBArray(m), m.nRaw);
                }

                return;
            }

            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("doTheSend");
            }

            // NOTE: The timeout has to be long because (1) flush can be slow, and worse than that, someone may have just
            // crashed without a graceful shutdown; if so, detecting the failure will take something like 2*VSYNC_DEFAULTTIMEOUT time
            throw new VsyncException("doTheSend: Group stuck in a wedged state for " + (waitingTime / 1000) + " seconds");
        }

        internal void SetMsgIds(Msg m, bool sentByOracle, bool isRaw) {
            tokenInfo theToken;
            using (var tmpLockObj = new LockAndElevate(this.TokenLock)) {
                theToken = this.theToken;
            }

            if (this.myLoggingFcn != null) {
                m.Lid = this.lookupLoggingId();
            }

            if ((this.flags & G_ISLARGE) != 0) {
                if (theToken != null) {
                    ILock lgb;
                    using (var tmpLockObj = new LockAndElevate(theToken.FlushingBarrierLock)) {
                        lgb = theToken.FlushingBarrier;
                    }

                    if (lgb != null) {
                        if ((VsyncSystem.Debug & VsyncSystem.FLUSHING) != 0) {
                            Vsync.WriteLine("Before BarrierWait in SetMsgIds");
                        }

                        lgb.BarrierWait();
                        if ((VsyncSystem.Debug & VsyncSystem.FLUSHING) != 0) {
                            Vsync.WriteLine("After BarrierWait in SetMsgIds");
                        }
                    }
                }
            }

            string which = "?";
            if (!sentByOracle || this == Vsync.ORACLE) {
                if (this.HasFirstView) {
                    // Blocks if group view is currently changing
                    try {
                        // Once we've assigned a message id, this member is committed to delivering this message in the current view
                        ILock.NoteThreadState("Wedged(SetMsgIds).WaitOne()");
                        this.Wedged.WaitOne();
                        ILock.NoteThreadState(null);
                        using (var tmpLockObj = new LockAndElevate(this.CommitLock))
                        using (var tmpLockObj1 = new LockAndElevate(this.ViewLock)) {
                            m.vid = this.theView.viewid;
                            m.msgid = this.nextMsgid++;

                            // Each message tells how many raw messages, sent in a row, it immediately follows
                            if (isRaw) {
                                m.nRaw = this.nRaw++;
                            }
                            else {
                                m.nRaw = this.nRaw;
                                this.nRaw = 0;
                            }
                        }

                        which = "HasFirstView";
                    }
                    finally {
                        this.Wedged.Release();
                    }
                }
                else {
                    m.vid = 0;
                    m.msgid = -1;
                    which = "NoFirstView";
                }
            }
            else if ((this.flags & G_ISLARGE) == 0) {
                Group tp = TrackingProxyLookup(this.gaddr);
                if (tp != null && tp.HasFirstView) {
                    using (var tmpLockObj = new LockAndElevate(this.CommitLock))
                    using (var tmpLockObj1 = new LockAndElevate(tp.ViewLock)) {
                        m.vid = tp.theView.viewid;
                        m.msgid = tp.nextMsgid++;
                        m.nRaw = this.nRaw;
                        this.nRaw = 0;
                    }

                    which = "TP/HasFirstView";
                }
                else {
                    m.vid = 0;
                    m.msgid = -1;
                    which = "TP/NoFirstView";
                }
            }
            else {
                throw new VsyncException("Oracle is trying to send in a large group: <" + this.gname + ">");
            }

            m.dest = this.gaddr;
            if ((VsyncSystem.Debug & VsyncSystem.MSGIDS) != 0) {
                Vsync.WriteLine("Set msgids(SentByOracle=" + sentByOracle + ") " + which + ": " + m);
            }
        }

        /// <summary>
        /// Flushes any unstable messages, pauses until the operation completes, then returns.
        /// </summary>
        /// <remarks>
        /// When using the non-Paxos multicast and query options, conditions can arise in which the user needs to know that past operations
        /// on the group have stabilized before some next action (such as checkpointing the group) can occur.  For this, call Flush.
        /// To learn more, read about the <it>virtual synchrony model</it> as implemented by Vsync.
        /// </remarks>
        public void Flush() {
            this.Flush(int.MaxValue);
        }

        /// <summary>
        /// Flushes unstable messages until k copies have definitely reached their destinations
        /// </summary>
        /// <param name="k">A "stability threshold" similar to the Paxos stability threshold parameter.</param>
        public void Flush(int k) {
            if (!VsyncSystem.VsyncActive) {
                return;
            }

            checkGroupIsOpen(this);
            if ((this.flags & G_ISLARGE) == 0 && k > 0) {
                ReliableSender.waitForStability(k);
            }
            else {
                this.doFlush(k, new Vsync.UnstableList[0], new Address[0]);
            }
        }

        private static void checkGroupIsOpen(object g) {
            if (g == null) {
                docheckGroup(null);
            }
            else if (g.GetType() == typeof(Group)) {
                docheckGroup((Group)g);
            }
            else if (g.GetType() == typeof(List<Group>)) {
                foreach (Group grp in (List<Group>)g) {
                    docheckGroup(grp);
                }
            }
        }

        private static void docheckGroup(Group g) {
            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            if (g != null && !g.GroupOpen && g.WasOpen) {
                throw new VsyncException("An operation was attempted on group <" + g.gname + ">, but this group is closed");
            }
        }

        internal void doFlush(int k, Vsync.UnstableList[] usl, Address[] leaving) {
            using (Semaphore CPSSema = new Semaphore(0, int.MaxValue)) {
                List<Msg> mustSend;
                int cpscnt;
                this.startFlush(k, usl, out mustSend, out cpscnt, CPSSema);
                this.endFlush(leaving, mustSend, cpscnt, CPSSema);
            }
        }

        internal void startFlush(int k, Vsync.UnstableList[] usl, out List<Msg> mustSend, out int cpscnt, Semaphore CPSSema) {
            mustSend = new List<Msg>();
            using (var tmpLockObj = new LockAndElevate(this.UnstableLock)) {
                foreach (Vsync.UnstableList us in usl) {
                    if (us.flusher == Vsync.my_address) {
                        foreach (Msg m in this.Unstable) {
                            if (m.gaddr == us.gaddr && m.sender == us.sender && m.vid == us.vid && m.msgid >= us.mid_low && m.msgid <= us.mid_hi) {
                                this.Unstable.Remove(m);
                                this.UnstableCount--;
                                mustSend.Add(m);
                                break;
                            }
                        }
                    }
                }
            }

            cpscnt = 0;
            using (var tmpLockObj = new LockAndElevate(ReliableSender.PendingSendBufferLock)) {
                foreach (ReliableSender.MsgDesc md in ReliableSender.PendingSendBuffer) {
                    if (md.group == this) {
                        lock (md) {
                            if (md.CPSList != null) {
                                md.CPSList.Add(CPSSema);
                                ++cpscnt;
                            }
                        }
                    }
                }

                foreach (ReliableSender.MsgDesc md in ReliableSender.P2PPendingSendBuffer) {
                    if (md.group == this) {
                        lock (md) {
                            if (md.CPSList != null) {
                                md.CPSList.Add(CPSSema);
                                ++cpscnt;
                            }
                        }
                    }
                }

                foreach (ReliableSender.MsgDesc lgmd in ReliableSender.LgPendingSendBuffer) {
                    if (lgmd.group == this) {
                        lock (lgmd) {
                            if (lgmd.CPSList != null) {
                                lgmd.CPSList.Add(CPSSema);
                                ++cpscnt;
                            }
                        }
                    }
                }
            }
        }

        internal void endFlush(Address[] leaving, List<Msg> mustSend, int cpscnt, Semaphore CPSSema) {
            foreach (Msg m in mustSend) {
                if ((this.flags & G_SECURE) != 0) {
                    this.cipherMsg(m);
                }

                ReliableSender.SendGroup(m.type, this, m, m.sender.isMyAddress());
            }

            ReliableSender.PendingSendCleanup(leaving);
            ReliableSender.CompletePendingSends(this, cpscnt, CPSSema);
        }

        internal class FragInfo {
            internal Address sender;

            internal int fragId;

            internal long fragTime;

            internal bool[] gotFrag;

            internal bool iscomp;

            internal bool isRaw;

            internal int nFragsRemaining;

            internal byte[] body;

            internal Msg TrueMsg;

            internal LockObject Lock = new LockObject("FragInfo.Lock");

            internal FragInfo(Address s, int fid, long tl, int nf, bool ic, bool ir) {
                this.fragTime = Vsync.NOW;
                this.sender = s;
                this.fragId = fid;
                this.body = new byte[tl];
                this.nFragsRemaining = nf;
                this.gotFrag = new bool[nf];
                this.iscomp = ic;
                this.isRaw = ir;
                if (!Vsync.BigTimeouts && tl > 500000) {
                    // Switch to big-timeout mode if incoming object is larger than 500KB
                    Vsync.BigTimeouts = true;
                    Vsync.VSYNC_DEFAULTTIMEOUT = Vsync.VSYNC_DEFAULTTIMEOUT * 2;
                }
            }
        }

        internal static string deFragState() {
            string s = "Defragmentation in progress:" + Environment.NewLine;
            using (var tmpLockObj = new LockAndElevate(dfLock)) {
                if (dfList.Count == 0) {
                    return string.Empty;
                }

                foreach (FragInfo fi in dfList) {
                    using (var tmpLockObj1 = new LockAndElevate(fi.Lock)) {
                        string got = " ";
                        foreach (bool b in fi.gotFrag) {
                            got += b ? "+ " : "- ";
                        }

                        s += "  [sender=" + fi.sender + ", gaddr=" + (fi.TrueMsg != null && fi.TrueMsg.gaddr != null ? fi.TrueMsg.gaddr.ToString() : "null") + ", fragId=" + fi.fragId + ", nFragsRemaining=" + fi.nFragsRemaining + ", got={" + got + "}, final length will be " + fi.body.Length + "] reconstruction underway for " + (Vsync.NOW - fi.fragTime) + "ms" + Environment.NewLine;
                    }
                }

                return s;
            }
        }

        internal static LockObject dfLock = new LockObject("dfLock");

        internal static LockObject sendInFragsLock = new LockObject("sendInFragsLock");

        internal static List<FragInfo> dfList = new List<FragInfo>();

        internal static int nextFid;

        internal static void fiCleanup(Address gaddr) {
            using (var tmpLockObj = new LockAndElevate(dfLock)) {
                if (dfList.Count == 0) {
                    return;
                }

                List<FragInfo> ndflist = new List<FragInfo>();
                foreach (FragInfo fi in dfList) {
                    if (fi.TrueMsg == null || (fi.TrueMsg.gaddr != null && fi.TrueMsg.gaddr != gaddr)) {
                        ndflist.Add(fi);
                    }
                }

                dfList = ndflist;
            }
        }

        internal static void fiCleanup() {
            using (var tmpLockObj = new LockAndElevate(dfLock)) {
                if (dfList.Count == 0) {
                    return;
                }

                List<FragInfo> ndflist = new List<FragInfo>();
                foreach (FragInfo fi in dfList) {
                    // Raw packets time out rapidly since the fragments might never be retransmitted.  Reliable packets, in contrast, linger a long time since
                    // in principle, any missing fragments will be resent "soon"
                    if (fi.isRaw ? (Vsync.NOW - fi.fragTime < Math.Max(500, fi.gotFrag.Length * 25)) : (Vsync.NOW - fi.fragTime < Math.Max(15000, fi.gotFrag.Length * 250))) {
                        ndflist.Add(fi);
                    }
                }

                dfList = ndflist;
            }
        }

        internal static FragInfo deFragLookup(Group g, Address sender, int fid, long tl, int nf, bool iscomp, bool isRaw) {
            using (var tmpLockObj = new LockAndElevate(dfLock)) {
                foreach (FragInfo dfi in dfList) {
                    if (dfi.sender == sender && dfi.fragId == fid) {
                        return dfi;
                    }
                }
            }

            using (var tmpLockObj = new LockAndElevate(Vsync.RIPLock)) {
                if (Vsync.RIPList.Contains(sender)) {
                    return null;
                }
            }

            FragInfo fi = new FragInfo(sender, fid, tl, nf, iscomp, isRaw);
            using (var tmpLockObj = new LockAndElevate(dfLock)) {
                dfList.Add(fi);
            }

            return fi;
        }

        internal const byte FFIC = 0x01;

        internal const byte FFIR = 0x01;

        internal static byte fflags(bool ic, bool isRaw) {
            byte rv = 0;
            if (ic) {
                rv |= FFIC;
            }

            if (isRaw) {
                rv |= FFIR;
            }

            return rv;
        }

        internal static bool ffic(byte ff) {
            return (ff & FFIC) != 0;
        }

        internal static bool ffir(byte ff) {
            return (ff & FFIR) != 0;
        }

        internal static void deFragGotFrag(Group g, Address sender, int fragId, long trueLen, int nFrags, int fragN, byte fflags, byte[] frag) {
            FragInfo fi = deFragLookup(g, sender, fragId, trueLen, nFrags, ffic(fflags), ffir(fflags));
            if ((VsyncSystem.Debug & VsyncSystem.FRAGER) != 0) {
                Vsync.WriteLine("deFragmenter got a fragment for a " + trueLen + " byte object; senderId=" + Vsync.my_address + ", fid=" + fragId + ", this was fragment " + fragN + (fi == null ? " (** SENDER ON RIP LIST: IGNORING **)" : string.Empty));
            }

            if (fi == null) {
                return;
            }

            bool doDelivery = false;
            List<FragInfo> toRemove = new List<FragInfo>();
            using (var tmpLockObj = new LockAndElevate(fi.Lock)) {
                if (fi.gotFrag[fragN]) {
                    return;
                }

                fi.gotFrag[fragN] = true;
                Buffer.BlockCopy(frag, 0, fi.body, (int)(fragN * Vsync.VSYNC_FRAGLEN), Buffer.ByteLength(frag));
                if (--fi.nFragsRemaining == 0) {
                    if (fi.TrueMsg != null) {
                        doDelivery = true;
                    }
                    else {
                        toRemove.Add(fi);
                    }
                }
            }

            using (var tmpLockObj = new LockAndElevate(dfLock)) {
                foreach (FragInfo rfi in toRemove) {
                    dfList.Remove(rfi);
                }
            }

            if (doDelivery) {
                fragDoDelivery(g, fi);
            }
        }

        internal static void deFragRdv(Group g, Msg m) {
            Msg outer = (Msg)Msg.BArrayToObjects(m.payload, typeof(Msg))[0];
            object[] objs = Msg.BArrayToObjects(outer.payload, typeof(Address), typeof(int), typeof(long), typeof(int), typeof(byte));
            int idx = 0;
            Address sender = (Address)objs[idx++];
            int fid = (int)objs[idx++];
            long tl = (long)objs[idx++];
            int nf = (int)objs[idx++];
            bool ic = ffic((byte)objs[idx]);
            bool ir = ffir((byte)objs[idx]);
            FragInfo fi = deFragLookup(g, sender, fid, tl, nf, ic, ir);
            if (fi == null) {
                return;
            }

            bool doDelivery = false;
            using (var tmpLockObj = new LockAndElevate(fi.Lock)) {
                if ((VsyncSystem.Debug & VsyncSystem.FRAGER) != 0) {
                    Vsync.WriteLine("deFragmenter rdv: senderId=" + Vsync.my_address + ", fid=" + fid + (fi == null ? " (** SENDER ON RIP LIST: IGNORING **)" : string.Empty));
                }

                fi.TrueMsg = m;
                if (fi.nFragsRemaining == 0) {
                    doDelivery = true;
                }
            }

            if (doDelivery) {
                fragDoDelivery(g, fi);
            }
        }

        private static void fragDoDelivery(Group g, FragInfo fi) {
            Msg m;
            using (var tmpLockObj = new LockAndElevate(dfLock)) {
                dfList.Remove(fi);
            }

            if (fi.TrueMsg == null) {
                throw new VsyncException("Fragger: Rdv failure");
            }

            using (var tmpLockObj = new LockAndElevate(fi.Lock)) {
                if (fi.iscomp) {
                    fi.body = ReliableSender.DeCompress(fi.body);
                }

                m = new Msg(fi.body) { dest = fi.TrueMsg.dest, flags = (byte)((fi.TrueMsg.flags & ~Msg.FRAGGED) | Msg.DEFRAGGED), gaddr = fi.TrueMsg.gaddr, msgid = fi.TrueMsg.msgid, sender = fi.TrueMsg.sender, Lid = fi.TrueMsg.Lid, UID = -1, type = fi.TrueMsg.type, vid = fi.TrueMsg.vid, asReceived = fi.TrueMsg };

                // Don't use the reassembled message to satisfy retransmission requests
                // The "true message" will be used if responding to a NACK using a message on m.unstable
                deFragDone(fi);
            }

            m.myObs = null;
            if ((m.flags & Msg.TOKEN) != 0) {
                ReliableSender.gotToken(m);
            }
            else if ((m.flags & Msg.HASREPLY) != 0) {
                AwaitReplies.gotReply(m);
            }
            else {
                if (m.type == Msg.ISGRPP2P || m.type == Msg.ISRAWGRPP2P) {
                    g.doAction(m);
                }
                else {
                    g.doDeliveryCallbacks(m, "deFragGotFrag", Msg.MULTICAST);
                }
            }
        }

        internal static void deFragDone(FragInfo fi) {
            fi.body = null;
            fi.TrueMsg = null;
        }

        internal static void deFragNoteFailure(Address who) {
            using (var tmpLockObj = new LockAndElevate(dfLock)) {
                List<FragInfo> newList = new List<FragInfo>();
                foreach (FragInfo fi in dfList) {
                    if (fi.sender != who) {
                        newList.Add(fi);
                    }
                }

                dfList = newList;
            }
        }

        private static bool reEnteredSIF;

        internal static byte[] SendInFrags(bool p2p, bool isRaw, Address dest, Group g, byte[] buffer, byte[] bufferAsGiven) {
            bool ic = bufferAsGiven != null;
            using (var tmpLockObj = new LockAndElevate(sendInFragsLock)) {
                if (reEnteredSIF) {
                    throw new VsyncException("Recursive entry to SendInFrags");
                }

                reEnteredSIF = true;
                int fid = ++nextFid;
                long bl = buffer.Length;
                int off = 0;
                int nf = (int)((bl + Vsync.VSYNC_FRAGLEN - 1) / Vsync.VSYNC_FRAGLEN);
                long wbl = bl;
                for (int n = 0; n < nf; n++) {
                    byte[] frag = new byte[Math.Min(wbl, Vsync.VSYNC_FRAGLEN)];
                    Buffer.BlockCopy(buffer, off, frag, 0, Buffer.ByteLength(frag));
                    wbl -= frag.Length;
                    off += frag.Length;
                    if (g != null) {
                        // These next lines can't run through the flow-controlled version of P2PSend and Send because of the risk of a deadlock
                        // The core issue is that SendInFrags is currently a static method, since I use it both within groups and also for pure
                        // Vsync-Vsync communication outside of groups (for example, retransmission of a message on the unstable list).  Thus if we allow
                        // flow control to lock send A, it may be that for the FC state to drain, message B needs to be retransmitted, and for this, fragmented
                        if (p2p) {
                            if (isRaw) {
                                g.RawP2PSend(dest, Vsync.FRAGMENT, Vsync.my_address, fid, (long)buffer.Length, nf, n, fflags(ic, isRaw), frag);
                            }
                            else {
                                g.doP2PSend(dest, true, Vsync.FRAGMENT, Vsync.my_address, fid, (long)buffer.Length, nf, n, fflags(ic, isRaw), frag);
                            }
                        }
                        else {
                            g.doSend(g == Vsync.ORACLE && dest != Vsync.ORACLE.gaddr, isRaw, Vsync.FRAGMENT, Vsync.my_address, fid, (long)buffer.Length, nf, n, fflags(ic, isRaw), frag);
                        }
                    }
                    else {
                        throw new VsyncException("SendInFragments: can't fragment a p2p non-group message");
                    }
                }

                if ((VsyncSystem.Debug & VsyncSystem.FRAGER) != 0) {
                    Vsync.WriteLine("Fragmented a " + bl + " byte object and sent it as " + nf + " fragments using senderId=" + Vsync.my_address + ", fid=" + fid);
                }

                // Surgery: replace the old message with a reference that will let us match it with the fragmented message
                Msg outer = new Msg(bufferAsGiven ?? buffer);
                Msg inner = Msg.InnerMsg(outer.payload);
                if (inner == null) {
                    // Special for fragmented tokens
                    inner = new Msg(Vsync.my_address, fid, bl, nf, fflags(ic, isRaw)) { dest = g.gaddr };
                }
                else {
                    // Normal case: everything except tokens
                    inner.payload = Msg.toBArray(Vsync.my_address, fid, bl, nf, fflags(ic, isRaw));
                    inner.cipherPayload = null;
                    inner.flags &= ~Msg.CIPHER & 0xFF;
                }

                outer.payload = Msg.toBArray(inner);
                outer.cipherPayload = null;
                outer.flags &= ~Msg.CIPHER & 0xFF;
                outer.myObs = inner.myObs = null;
                reEnteredSIF = false;
                return outer.toBArray();
            }
        }

        internal byte[] cipherBuf(byte[] buffer) {
            if (this.myAes == null) {
                throw new VsyncException("<" + this.gname + ">: ciperBuf but myAES=null");
            }

            if (buffer.Length == 0) {
                throw new VsyncException("Buffer null in cipherBuf");
            }

            if (buffer.Length == 0) {
                return buffer;
            }

            return this.encipher(buffer);
        }

        internal byte[] CryptoWrap(byte[] buffer) {
            return Msg.toBArray(Vsync.CRYPTOWRAPPED, this.cipherBuf(buffer));
        }

        internal void cipherMsg(Msg m) {
            using (var tmpLockObj = new LockAndElevate(m.Lock)) {
                if (m.vid < 0 || m.msgid < 0 || this.myAes == null || m.cipherPayload != null) {
                    return;
                }

                m.myObs = null;
                using (var tmpLockObj1 = new LockAndElevate(this.myAesLock)) {
                    m.cipherPayload = this.encipher(m.payload);
                }

                m.flags |= Msg.CIPHER;
            }
        }

        internal byte[] decipherBuf(byte[] buffer) {
            if (this.myAes == null) {
                throw new VsyncException("<" + this.gname + ">: deciperBuf but myAES=null");
            }

            if (buffer.Length == 0) {
                return buffer;
            }

            return this.decipher(buffer);
        }

        internal void decipherMsg(Msg m) {
            if ((m.payload != null && m.cipherPayload != null) || (m.flags & Msg.CIPHER) == 0) {
                return;
            }

            using (var tmpLockObj = new LockAndElevate(m.Lock)) {
                m.myObs = null;
                if (m.cipherPayload == null && m.payload != null) {
                    m.cipherPayload = m.payload;
                }

                using (var tmpLockObj1 = new LockAndElevate(this.myAesLock)) {
                    m.payload = this.decipher(m.cipherPayload);
                }
            }
        }

        private byte[] encipher(byte[] buffer) {
            int nb = this.myAes.BlockSize >> 3;
            byte[] IV = new byte[nb];
            this.AesSeed.GetBytes(IV);
            return encipher(this, this.myAes, this.myAesLock, IV, buffer);
        }

        internal static byte[] encipher(Group g, Aes myAes, LockObject myAesLock, byte[] iv, byte[] buffer) {
            using (var tmpLockObj = new LockAndElevate(myAesLock)) {
                int nb = myAes.BlockSize >> 3;
                myAes.IV = iv;
                if ((VsyncSystem.Debug & VsyncSystem.CIPHER) != 0) {
                    tokenInfo.dumpBv((g != null ? ("<" + g.gname + "> ") : "<null> ") + "[encipher]myAes.Key=", myAes.Key);
                    tokenInfo.dumpBv((g != null ? ("<" + g.gname + "> ") : "<null> ") + "[encipher]myAes.IV=", myAes.IV);
                    Vsync.WriteLine((g != null ? ("<" + g.gname + "> ") : "<null> ") + "[encipher]Buffer length is " + buffer.Length);
                }

                int len = (((buffer.Length + 4) + (nb - 1)) / nb) * nb;
                byte[] padded = new byte[len];
                int idx = 0;
                padded[idx++] = (byte)((buffer.Length >> 24) & 0xFF);
                padded[idx++] = (byte)((buffer.Length >> 16) & 0xFF);
                padded[idx++] = (byte)((buffer.Length >> 8) & 0xFF);
                padded[idx++] = (byte)(buffer.Length & 0xFF);
                while (idx - 4 < buffer.Length) {
                    padded[idx] = buffer[idx - 4];
                    idx++;
                }

                while (idx < len - 4) {
                    padded[idx++] = 0;
                }

                ICryptoTransform myEncryptor;
                using (myEncryptor = myAes.CreateEncryptor(myAes.Key, myAes.IV)) {
                    MemoryStream msEncrypt = null;
                    try {
                        msEncrypt = new MemoryStream();
                        CryptoStream csEncrypt = null;
                        try {
                            csEncrypt = new CryptoStream(msEncrypt, myEncryptor, CryptoStreamMode.Write);
                            csEncrypt.Write(padded, 0, padded.Length);
                            byte[] ev = msEncrypt.ToArray();
                            byte[] result = new byte[iv.Length + ev.Length];
                            Buffer.BlockCopy(iv, 0, result, 0, Buffer.ByteLength(iv));
                            Buffer.BlockCopy(ev, 0, result, iv.Length, Buffer.ByteLength(ev));
                            return result;
                        }
                        finally {
                            if (csEncrypt != null) {
                                csEncrypt.Dispose();
                                msEncrypt = null;
                            }
                        }
                    }
                    finally {
                        if (msEncrypt != null) {
                            msEncrypt.Dispose();
                        }
                    }
                }
            }
        }

        // Caller has a lock on myAes
        private byte[] decipher(byte[] buffer) {
            using (var tmpLockObj = new LockAndElevate(this.myAesLock)) {
                int nb = this.myAes.BlockSize >> 3;
                byte[] iv = new byte[nb];
                Buffer.BlockCopy(buffer, 0, iv, 0, nb);
                this.myAes.IV = iv;
                if ((VsyncSystem.Debug & VsyncSystem.CIPHER) != 0) {
                    tokenInfo.dumpBv("<" + this.gname + "> [decipher]myAes.Key=", this.myAes.Key);
                    tokenInfo.dumpBv("<" + this.gname + "> [decipher]myAes.IV=", this.myAes.IV);
                }

                using (this.myDecryptor = this.myAes.CreateDecryptor(this.myAes.Key, this.myAes.IV)) {
                    MemoryStream msDecrypt = null;
                    try {
                        msDecrypt = new MemoryStream(buffer, nb, buffer.Length - nb);
                        CryptoStream csDecrypt = null;
                        try {
                            csDecrypt = new CryptoStream(msDecrypt, this.myDecryptor, CryptoStreamMode.Read);
                            byte[] padded = new byte[this.myAes.BlockSize >> 3];
                            csDecrypt.Read(padded, 0, padded.Length);
                            int len = (padded[0] << 24) + (padded[1] << 16) + (padded[2] << 8) + padded[3];
                            if (len < 0 || len > Vsync.VSYNC_MAXMSGLENTOTAL) {
                                Vsync.WriteLine("WARNING: Decryption failure (object may be corrupted, or may have been enciphered with a different key)");
                                return new byte[0];
                            }

                            if ((VsyncSystem.Debug & VsyncSystem.CIPHER) != 0) {
                                Vsync.WriteLine("[decipher]Length will be " + len);
                            }

                            byte[] result = new byte[len];
                            int idx = 4;
                            int off = 0;
                            while (len-- > 0) {
                                if (idx == padded.Length) {
                                    csDecrypt.Read(padded, idx = 0, padded.Length);
                                }

                                result[off++] = padded[idx++];
                            }

                            return result;
                        }
                        finally {
                            if (csDecrypt != null) {
                                csDecrypt.Dispose();
                                msDecrypt = null;
                            }
                        }
                    }
                    finally {
                        if (msDecrypt != null) {
                            msDecrypt.Dispose();
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Sends one message in a stream of messages that constitute a state transfer or checkpoint.
        /// </summary>
        /// <param name="obs">A variable-length list of arguments that must match one of the checkpoint loading methods</param>
        /// <remarks>
        /// Sends one message in a stream of messages that constitute a state transfer or checkpoint.
        /// Each of these messages can contain any objects that the Vsync Msg layer is able to Marshall,
        /// namely predefined types known to Vsync, or other object types that the user has registered via <see cref="Msg.RegisterType"/>.
        /// The system matches each incoming checkpoint message with the list of registered handlers, invoking the handler(s) that have
        /// exact matches with the types of the incoming message. 
        /// </remarks>
        public void SendChkpt(params object[] obs) {
            object[] args = new object[obs.Length + 1];
            args[0] = Vsync.STATEXFER;
            for (int i = 0; i < obs.Length; i++) {
                args[i + 1] = obs[i];
            }

            if (this.myChkptStream == null) {
                foreach (Address a in this.nextView.joiners) {
                    bool sendToHim = this.theChkptChoser == null || this.theChkptChoser(this.nextView, a);
                    if (sendToHim) {
                        this.doP2PSend(a, true, args);
                    }
                }
            }
            else {
                try {
                    if (obs.Length > 0) {
                        byte[] buffer = Msg.toBArray(obs);
                        if (this.userSpecifiedKey) {
                            this.cipherBuf(buffer);
                        }

                        int len = buffer.Length;
                        byte[] lb = new byte[4];
                        lb[0] = (byte)(len & 0xFF);
                        len >>= 8;
                        lb[1] = (byte)(len & 0xFF);
                        len >>= 8;
                        lb[2] = (byte)(len & 0xFF);
                        len >>= 8;
                        lb[3] = (byte)(len & 0xFF);
                        this.myChkptStream.Write(lb, 0, 4);
                        this.myChkptStream.Write(buffer, 0, buffer.Length);
                    }
                    else {
                        this.makingCheckpoint = false;
                        this.myChkptStream.Close();
                        this.myChkptStream = null;
                        if (!File.Exists(this.myCheckpointFile + ".chkpt")) {
                            File.Create(this.myCheckpointFile + ".chkpt").Close();
                        }

                        if (!File.Exists(this.myCheckpointFile + ".bak")) {
                            File.Create(this.myCheckpointFile + ".bak").Close();
                        }

                        bool replaced = false;
                        int tried = 0;
                        while (!replaced && tried++ < 3) {
                            try {
                                File.Replace(this.myCheckpointFile + ".tmp", this.myCheckpointFile + ".chkpt", this.myCheckpointFile + ".bak", false);
                                replaced = true;
                            }
                            catch (IOException) {
                                if (tried == 3) {
                                    throw;
                                }

                                Vsync.Sleep(250);
                            }
                        }
                    }
                }
                catch (Exception e) {
                    throw new VsyncException("I/O error: " + e.Message + " while writing checkpoint", e);
                }
            }

            this.VsyncCallDone();
        }

        /// <summary>
        /// Called as an end-of-state-transfer or end-of-checkpoint marker.
        /// </summary>
        public void EndOfChkpt() {
            if (!this.inhibitEOC) {
                this.SendChkpt();
            }

            this.VsyncCallDone();
        }

        /*private static string bprnt(byte[] buf)
        {
            string s = string.Empty;
            for (int b = 0; b < buf.Length; b++)
            {
                s = s + " " + buf[b];
            }

            return s;
        }*/

        /// <summary>
        /// Issues an unordered, non-durable point-to-point request to a designated member of some group and then waits for it to 
        /// reply.
        /// </summary>
        /// <param name="dest">the target for the query</param>
        /// <param name="obs">A variable list of arguments that specify the request id and the arguments to some handler</param>
        /// <returns>Return returned as a byte[] array</returns>
        /// <remarks>
        /// Issues an unordered, non-durable point-to-point request to a designated member of some group and then waits for it to 
        /// reply (<see cref="Reply"/>, <see cref="NullReply"/> and <see cref="AbortReply"/>).
        /// The first parameter is an object of type <see cref="Timeout"/> and specifies a timeout after which the Query ceases to wait for a non-responsive
        /// member, and the default action to take in that case.  The next parameter is the request handle: a small integer identifying this request.
        /// Remaining parameters become typed arguments to the handler for the request.  Returns a byte[] array in which the reply is encoded.
        /// Normally, the user would employ Msg.BArraysToObjects() or Msg.InvokeFromBArrays() to decode these replies.
        /// </remarks>
        public byte[] P2PQueryToBarray(Address dest, params object[] obs) {
            if (!this.VsyncCallStart()) {
                return null;
            }

            Timeout timeout;
            splitObs(this, out timeout, ref obs);
            this.cbCheck(obs);
            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            byte[] buffer = Msg.toBArray(obs);
            if ((this.flags & G_SECURE) != 0) {
                buffer = this.CryptoWrap(buffer);
            }

            byte[] rv = ReliableSender.QueryP2P(Msg.ISGRPP2P, dest, timeout, this, buffer);
            this.VsyncCallDone();
            return rv;
        }

        /// <summary>
        /// Issues an unordered, non-durable point-to-point request to a designated member of some group and then waits for it to 
        /// reply.
        /// </summary>
        /// <param name="dest">the target for the query</param>
        /// <param name="obs">A variable list of arguments that specify the request id and the arguments to some handler</param>
        /// <returns>Returns result via user-supplied list objects</returns>
        /// <remarks>
        /// Issues an unordered, non-durable point-to-point request to a designated member of some group and then waits for it to 
        /// reply (<see cref="Reply"/>, <see cref="NullReply"/> and <see cref="AbortReply"/>).
        /// The first parameter is an object of type <see cref="Timeout"/> and specifies a timeout after which the Query ceases to wait for a non-responsive
        /// member, and the default action to take in that case.  The next parameter is the request handle: a small integer identifying this request.
        /// Remaining parameters become typed arguments to the handler for the request.  Returns a byte[] array in which the reply is encoded.
        /// Normally, the user would employ Msg.BArraysToObjects() or Msg.InvokeFromBArrays() to decode these replies.
        /// </remarks>
        public bool P2PQuery(Address dest, params object[] obs) {
            if (!this.VsyncCallStart()) {
                return false;
            }

            FlowControl.FCBarrierCheck();
            Timeout timeout;
            object[] resRefs;
            splitObs(this, out timeout, ref obs, out resRefs);
            this.cbCheck(obs);
            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            byte[] buffer = Msg.toBArray(obs);
            if ((this.flags & G_SECURE) != 0) {
                buffer = this.CryptoWrap(buffer);
            }

            buffer = ReliableSender.QueryP2P(Msg.ISGRPP2P, dest, timeout, this, buffer);
            List<byte[]> barrays = new List<byte[]>();
            if (buffer == null || buffer.Length == 0) {
                this.VsyncCallDone();
                return false;
            }

            barrays.Add(buffer);
            Msg.BArraysToLists(resRefs, barrays);
            this.VsyncCallDone();
            return true;
        }

        internal byte[] doP2PQuery(Address dest, params object[] obs) {
            Timeout timeout;
            splitObs(this, out timeout, ref obs);
            this.cbCheck(obs);
            byte[] buffer = Msg.toBArray(obs);
            if ((this.flags & G_SECURE) != 0) {
                buffer = this.CryptoWrap(buffer);
            }

            return ReliableSender.QueryP2P(Msg.ISGRPP2P, dest, timeout, this, buffer);
        }

        internal byte[] doPureP2PQuery(Address dest, params object[] obs) {
            Timeout timeout;
            splitObs(this, out timeout, ref obs);
            this.cbCheck(obs);
            byte[] buffer = Msg.toBArray(obs);
            if ((this.flags & G_SECURE) != 0) {
                buffer = this.CryptoWrap(buffer);
            }

            return ReliableSender.QueryP2P(Msg.ISPUREP2P, dest, timeout, this, buffer);
        }

        /// <summary>
        /// Sends a point-to-point message to a specific member of the current group, specified via the dest field.  
        /// </summary>
        /// <param name="dest">Which member of the group to send to</param>
        /// <param name="obs">A variable list of arguments that specify the request id and the arguments to some handler</param>
        /// <remarks>
        /// Sends a point-to-point message to a specific member of the current group, specified via the dest field.  
        /// The
        /// first parameter specified the request handle: a small integer identifying this request.
        /// Remaining parameters become typed arguments to the handler for the request.
        /// </remarks>
        public void P2PSend(Address dest, params object[] obs) {
            if (!this.VsyncCallStart()) {
                return;
            }

            FlowControl.FCBarrierCheck();
            this.cbCheck(obs);
            byte[] buffer = Msg.toBArray(obs);
            if ((this.flags & G_SECURE) != 0) {
                buffer = this.CryptoWrap(buffer);
            }

            ReliableSender.SendP2P(Msg.ISGRPP2P, dest, this, buffer, true);
            this.VsyncCallDone();
        }

        internal void doP2PSend(Address dest, bool localSender, params object[] obs) {
            byte[] buffer = Msg.toBArray(obs);
            if ((this.flags & G_SECURE) != 0) {
                buffer = this.CryptoWrap(buffer);
            }

            ReliableSender.SendP2P(Msg.ISGRPP2P, dest, this, buffer, localSender);
        }

        internal void doPureP2PSend(Address dest, bool localSender, params object[] obs) {
            byte[] buffer = Msg.toBArray(obs);
            ReliableSender.SendP2P(Msg.ISPUREP2P, dest, null, buffer, localSender);
        }

        /// <summary>
        /// Used to send an unreliable datagram.  Best if the object size is well below the VSYNC_MAXMSGLEN
        /// </summary>
        /// <param name="dest">Target node within this group</param>
        /// <param name="obs">Request code and parameters</param>
        /// <remarks>
        /// RawP2PSend is used to send an unreliable datagram, for example in support of a gossip-push protocol.  
        /// No attempt will be made to retransmit if the message is dropped.
        /// Caution: if a very large object is sent this way, and some fragments are lost, resources will be tied up
        /// for many seconds on the receiver until the garbage collection logic notices the unrepaired gap and discards
        /// the partial packet.  We recommend that SendRawP2P not be used for objects that exceed the VSYNC_MAXMSGLEN 
        /// limit (in fact, because your data will be encoded and might be enciphered, you need to limit your packets
        /// to a considerably smaller size.  In the worst case many hundreds of bytes of overhead may be added by
        /// these mechanisms, and by the Msg serialization code)
        /// 
        /// Please note that when using RawP2PSend at high rates, loss rates can spike unless the sender employs a non-zero value for the VSYNC_RATELIM parameter,
        /// which limits the number of packets transmitted per second.  See the user manual for details
        /// </remarks>
        public void RawP2PSend(Address dest, params object[] obs) {
            if (!this.VsyncCallStart()) {
                return;
            }

            FlowControl.FCBarrierCheck();
            this.cbCheck(obs);
            byte[] buffer = Msg.toBArray(obs);
            if ((this.flags & G_SECURE) != 0) {
                buffer = this.CryptoWrap(buffer);
            }

            ReliableSender.SendP2P(Msg.ISRAWGRPP2P, dest, this, buffer, true);
            this.VsyncCallDone();
        }

        /// <summary>
        /// Used to send an unreliable query, to which the receiver will reply.  Best if the object size is well below the VSYNC_MAXMSGLEN
        /// </summary>
        /// <param name="dest">Target node, within this group</param>
        /// <param name="obs">Request code and parameters</param>
        /// <remarks>
        /// RawP2PQuery is used to send an unreliable query, for example in support of a gossip-pull or push-pull protocol.  
        /// No attempt will be made to retransmit if the message is dropped.
        /// Caution: if a very large object is sent this way, and some fragments are lost, resources will be tied up
        /// for many seconds on the receiver until the garbage collection logic notices the unrepaired gap and discards
        /// the partial packet.  We recommend that SendRawP2P not be used for objects that exceed the VSYNC_MAXMSGLEN 
        /// limit (in fact, because your data will be encoded and might be enciphered, you need to limit your packets
        /// to a considerably smaller size.  In the worst case many hundreds of bytes of overhead may be added by
        /// these mechanisms, and by the Msg serialization code)
        /// 
        /// RawP2PQuery is useful in time-sensitive applications where a message that might be delayed and need to be
        /// resent would be of low value because of the elapsed time.  Often, one uses RawReply to respond to such a 
        /// Query, for the same reason.
        /// 
        /// If a timeout occurs, the specified timeout action will be taken
        /// </remarks>
        public bool RawP2PQuery(Address dest, params object[] obs) {
            if (!this.VsyncCallStart()) {
                return false;
            }

            FlowControl.FCBarrierCheck();
            Timeout timeout;
            object[] resRefs;
            splitObs(this, out timeout, ref obs, out resRefs);
            this.cbCheck(obs);
            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            byte[] buffer = Msg.toBArray(obs);
            if ((this.flags & G_SECURE) != 0) {
                buffer = this.CryptoWrap(buffer);
            }

            buffer = ReliableSender.QueryP2P(Msg.ISRAWGRPP2P, dest, timeout, this, buffer);
            List<byte[]> barrays = new List<byte[]>();
            if (buffer == null || buffer.Length == 0) {
                this.VsyncCallDone();
                return false;
            }

            barrays.Add(buffer);
            Msg.BArraysToLists(resRefs, barrays);
            this.VsyncCallDone();
            return true;
        }

        /// <summary>
        /// Used to send an unreliable datagram in reply to a RawP2PQuery.  Best if the reply object size is well below the VSYNC_MAXMSGLEN
        /// </summary>
        /// <param name="obs">The reply data</param>
        /// <remarks>
        /// RawReply is used in conjunction with RawP2PQuery, and sends a reply unreliably: no attempt will be made to retransmit if the message is dropped.
        /// Caution: if a very large object is sent this way, and some fragments are lost, resources will be tied up
        /// for many seconds on the receiver until the garbage collection logic notices the unrepaired gap and discards
        /// the partial packet.  We recommend that SendRawP2P not be used for objects that exceed the VSYNC_MAXMSGLEN 
        /// limit (in fact, because your data will be encoded and might be enciphered, you need to limit your packets
        /// to a considerably smaller size.  In the worst case many hundreds of bytes of overhead may be added by
        /// these mechanisms, and by the Msg serialization code)
        /// 
        /// Note that Reply() also works for RawP2PQuery: the query is sent unreliably but the reply will be acked.  However, this mixture is uncommon.
        /// The converse is also true: nothing prevents an application from using RawReply to respond to a Query sent reliably.
        /// 
        /// If the reply is dropped, the Query or RawQuery will eventually time out and take the indicated timeout action.
        /// </remarks>
        public void RawReply(params object[] obs) {
            if (!this.GroupOpen && this.WasOpen) {
                return;
            }

            if (!this.VsyncCallStart()) {
                return;
            }

            Msg replyTo;
            using (var tmpLockObj = new LockAndElevate(Rlock)) {
                replyTo = this.getReplyToAndClear();
            }

            if (replyTo == null) {
                throw new VsyncException("Attempted to reply twice to same message, or to a message that wasn't a query");
            }

            if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                Vsync.WriteLine("Sending reply to " + replyTo.sender + ", " + replyTo.vid + ":" + replyTo.msgid);
            }

            byte[] result = Msg.toBArray(obs);
            bool enciphered = false;
            if ((this.flags & G_SECURE) != 0 && (replyTo.flags & Msg.ENCIPHEREDREPLY) != 0) {
                enciphered = true;
                result = this.cipherBuf(result);
            }

            bool deliverToOracle = (replyTo.flags & Msg.SENTBYORACLE) != 0;
            byte[] buffer = Msg.toBArray(RT_REPLY, replyTo.vid, replyTo.msgid, deliverToOracle, enciphered, result);
            Vsync.PendingLeaderOps plos;
            using (var tmpLockObj = new LockAndElevate(this.groupLock)) {
                plos = this.NotifyDALOnReply;
            }

            if (plos != null && plos.reqMsg == replyTo) {
                Vsync.DALReplyNotify(this, new Msg(this.gaddr, Msg.ISREPLY, replyTo.sender, Msg.NewMsgAsBArray(Vsync.my_address, this.gaddr, this.theView.viewid, -1, 0L, 0, 0, 0, buffer), this.theView.viewid, -1), plos, replyTo);
            }

            ReliableSender.SendP2P(Msg.ISRAWREPLY, replyTo.sender, this.rgroup(replyTo.gaddr), this.theView == null ? 0 : this.theView.viewid, ReliableSender.P2PSequencer.NextP2PSeqn("reply/1", replyTo.sender), buffer, true, null, replyTo);
            this.VsyncCallDone();
        }

        /// <exclude>
        /// <summary>
        /// Internal, declared public to satisfy C# scoping requirement.
        /// </summary>
        /// <param name="obs"></param>
        /// </exclude>
        public delegate void querySender(params object[] obs);

        /// <summary>
        /// Issues an unordered, non-durable multicast to the group and waits for replies, returning them as a byte[][] array, with one byte[] vector per reply.
        /// </summary>
        /// <param name="nreplies">number of replies desired</param>
        /// <param name="timeout">Vsync.Timeout object specifying the timeout and action to take if it occurs before reply is received</param>
        /// <param name="obs">variable-length list specifying method to invoke, arameters to method being invoked</param>
        /// <returns>a byte[][] array with one byte[] vector per received reply</returns>
        /// <remarks>
        /// Issues an unordered, non-durable multicast to the group and waits for replies (<see cref="Reply"/>, <see cref="NullReply"/> and <see cref="AbortReply"/>).
        /// 
        /// This is the very fastest form of virtually synchronous query, but can be lost in the event of a failure.  Typically performed as a single IP multicast with
        /// instant invocation of the handler routine in the receiving processes.  Read about the <it>virtual synchrony model</it> to learn more about when Query is a safe choice.
        /// 
        /// The number of replies desired can be specified as an integer (normally 1 or 2), or as the special constant ALL.  The first
        /// of the parameter after nreplies is an object of type <see cref="Timeout"/> and specifies a timeout after which the Query ceases to wait for a non-responsive
        /// member, and the default action to take in that case.  The next parameter is the request handle: a small integer identifying this request.
        /// Remaining parameters become typed arguments to the handler for the request.  Returns a byte[][] array in which each entry is a reply from one process.
        /// Normally, the user would employ Msg.BArraysToObjects() or Msg.InvokeFromBArrays() to decode these replies.
        /// </remarks>
        public List<byte[]> QueryToBA(int nreplies, Timeout timeout, params object[] obs) {
            return this._Query(false, false, this.doSendNotFromOracle, nreplies, timeout, obs);
        }

        /// <summary>
        /// Unreliable version of QueryToBA
        /// </summary>
        /// <param name="nreplies">number of replies desired</param>
        /// <param name="timeout">timeout action</param>
        /// <param name="obs">arguments to the call</param>
        /// <returns>byte[][] array containing the replies</returns>
        public List<byte[]> RawQueryToBA(int nreplies, Timeout timeout, params object[] obs) {
            return this._Query(false, true, this.doRawSendNotFromOracle, nreplies, timeout, obs);
        }

        private List<byte[]> QueryToBAFromSystem(int vid, int mid, int nRaw, int nreplies, Timeout timeout, params object[] obs) {
            return this._Query(vid, mid, nRaw, false, false, this.doSendNotFromOracle, nreplies, timeout, obs);
        }

        /// <summary>
        ///  Issues an unordered and reliable but potentially non-durable multicast to the group, then waits for replies
        /// </summary>
        /// <param name="nreplies">number of replies desired</param>
        /// <param name="given">variable-length list specifying method to invoke, timeout, parameters to method being invoked, EOLMarker, vectors for received results</param>
        /// <returns>how many replies were actually received</returns>
        /// <remarks>
        /// Issues an unordered and reliable but potentially non-durable multicast to the group and waits for replies (<see cref="Reply"/>, <see cref="NullReply"/> and <see cref="AbortReply"/>).
        /// 
        /// This is the very fastest way to query an Vsync group; it typically requires a single IP multicast per invocation.  However, there are obscure failure patterns that
        /// could cause it to be nondurable (the query is "lost" in the event of certain sequences of failures).  
        /// Read about the <it>virtual synchrony model</it> to learn more about when stronger Query variations would be needed.
        /// 
        /// The number of replies desired can be specified as an integer (normally 1 or 2), or as the special constant ALL.  The first
        /// of the parameter after nreplies is an object of type <see cref="Timeout"/> and specifies a timeout after which the Query ceases to wait for a non-responsive
        /// member, and the default action to take in that case.  The next parameter is the request handle: a small integer identifying this request.
        /// Remaining parameters become typed arguments to the handler for the request.  Counts the replies received and returns this number but the actual replies
        /// are passed to the user in a series of vectors, which should be passed in as by-ref parameters after a marker, the Vsync EOLmarker, which separates
        /// the list of arguments to the invoked method from the places to put recieved replies.
        /// 
        /// For example:  int[] hisAge = new int[0], nreps;  nreps = Query(GET_AGE, 1, new Timeout(1000, TO_ABORTREPLY), "John Smith", Vsync.EOLmarker, hisAge);
        /// </remarks>
        public int Query(int nreplies, params object[] given) {
            Timeout timeout;
            object[] resRefs;
            splitObs(this, out timeout, ref given, out resRefs);
            List<byte[]> barrays = this.QueryToBA(nreplies, timeout, given);
            Msg.BArraysToLists(resRefs, barrays);
            return barrays.Count;
        }

        /// <summary>
        /// Like Query, but uses RawSend
        /// </summary>
        /// <param name="nreplies">number of replies desired</param>
        /// <param name="given">variable-length list specifying method to invoke, timeout, parameters to method being invoked, EOLMarker, vectors for received resultsvariable-length list specifying method to invoke, timeout, parameters to method being invoked, EOLMarker, vectors for received results</param>
        /// <returns></returns>
        public int RawQuery(int nreplies, params object[] given) {
            Timeout timeout;
            object[] resRefs;
            splitObs(this, out timeout, ref given, out resRefs);
            List<byte[]> barrays = this.RawQueryToBA(nreplies, timeout, given);
            Msg.BArraysToLists(resRefs, barrays);
            return barrays.Count;
        }

        internal int doQuery(int nreplies, params object[] given) {
            Timeout timeout;
            object[] resRefs;
            splitObs(this, out timeout, ref given, out resRefs);
            List<byte[]> barrays = this.doQueryToBA(false, nreplies, timeout, given);
            Msg.BArraysToLists(resRefs, barrays);
            return barrays.Count;
        }

        internal static void splitObs(object g, out Timeout timeout, ref object[] obs, out object[] refs) {
            splitObs(g, out timeout, ref obs);
            int nRefs = 0;
            while (nRefs < obs.Length && obs[(obs.Length - 1) - nRefs].GetType() != typeof(EOLMarker)) {
                ++nRefs;
            }

            if (nRefs == obs.Length) {
                refs = new object[0];
                return;
            }

            refs = new object[nRefs];
            for (int i = 0; i < nRefs; i++) {
                try {
                    refs[i] = obs[obs.Length - nRefs + i];
                    if (refs[i] == null) {
                        throw new ArgumentException();
                    }

                    // At this point we used to complain if the length wasn't initially 0, but these days we allow
                    // "Accumulators" hence the exception is no longer thrown.  But the logic above still is useful:
                    // an exception will be thrown if something is wrong (better to throw it when the call is first made rather than later..).
                }
                catch (Exception e) {
                    throw new ArgumentException("In an Vsync Query, all reply variables must be lists", e);
                }
            }

            Vsync.ArrayResize(ref obs, obs.Length - nRefs - 1);
        }

        internal static void splitObs(object g, out Timeout timeout, ref object[] obs) {
            checkGroupIsOpen(g);
            if (obs[0].GetType() == typeof(Timeout)) {
                timeout = (Timeout)obs[0];
                for (int i = 0; i < obs.Length - 1; i++) {
                    obs[i] = obs[i + 1];
                }

                Vsync.ArrayResize(ref obs, obs.Length - 1);
            }
            else {
                timeout = new Timeout(Vsync.VSYNC_DEFAULTTIMEOUT, Timeout.TO_ABORTREPLY);
            }

            obs = subsetShortcut(obs);
        }

        internal void QueryInvoke(int nreplies, params object[] obs) {
            Timeout timeout;
            splitObs(this, out timeout, ref obs);
            Delegate del = (Delegate)obs[obs.Length - 1];
            Vsync.ArrayResize(ref obs, obs.Length - 1);
            Msg.InvokeFromBArrays(this.QueryToBA(nreplies, timeout, obs), del);
        }

        internal List<byte[]> doQueryToBA(bool sentByOracle, int nreplies, params object[] obs) {
            Timeout timeout;
            splitObs(this, out timeout, ref obs);
            querySender asyncSendQuery;
            if (sentByOracle) {
                asyncSendQuery = this.doSendFromOracle;
            }
            else {
                asyncSendQuery = this.doSendNotFromOracle;
            }

            return this._Query(sentByOracle, false, asyncSendQuery, nreplies, timeout, obs);
        }

        internal void doQueryInvoke(int nreplies, params object[] obs) {
            Timeout timeout;
            splitObs(this, out timeout, ref obs);
            Delegate del = (Delegate)obs[obs.Length - 1];
            Vsync.ArrayResize(ref obs, obs.Length - 1);
            Msg.InvokeFromBArrays(this.doQueryToBA(false, nreplies, timeout, obs), del);
        }

        /// <summary>
        ///  Issues an ordered but potentially non-durable multicast to the group and waits for replies
        /// </summary>
        /// <param name="nreplies">number of replies desired</param>
        /// <param name="given">variable-length list specifying method to invoke, timeout, parameters to method being invoked, EOLMarker, vectors for received results</param>
        /// <returns>how many replies were actually received</returns>
        /// <remarks>
        /// Issues an ordered but potentially non-durable multicast to the group and waits for replies (<see cref="Reply"/>, <see cref="NullReply"/> and <see cref="AbortReply"/>).
        /// 
        /// This is a slightly slower form of virtually synchronous query, and may not be durable be lost in the event of a failure.  Can be done in a single IP multicast if
        /// the sender was the group leader but if not, delivery will be delayed until the group leader decides and notifies members of the ordering to use.
        /// Read about the <it>virtual synchrony model</it> to learn more about when OrderedQuery is needed.
        /// 
        /// The number of replies desired can be specified as an integer (normally 1 or 2), or as the special constant ALL.  The first
        /// of the parameter after nreplies is an object of type <see cref="Timeout"/> and specifies a timeout after which the Query ceases to wait for a non-responsive
        /// member, and the default action to take in that case.  The next parameter is the request handle: a small integer identifying this request.
        /// Remaining parameters become typed arguments to the handler for the request.  Counts the replies received and returns this number but the actual replies
        /// are passed to the user in a series of vectors, which should be passed in as by-ref parameters after a marker, the Vsync EOLmarker, which separates
        /// the list of arguments to the invoked method from the places to put recieved replies.
        /// 
        /// For example:  int[] hisAge = new int[0], nreps;  nreps = OrderedQuery(GET_AGE, 1, new Timeout(1000, TO_ABORTREPLY), "John Smith", Vsync.EOLmarker, hisAge);
        /// </remarks>
        public int OrderedQuery(int nreplies, params object[] given) {
            Timeout timeout;
            object[] resRefs;
            splitObs(this, out timeout, ref given, out resRefs);
            List<byte[]> barrays = this.OrderedQueryToBA(nreplies, timeout, given);
            Msg.BArraysToLists(resRefs, barrays);
            return barrays.Count;
        }

        internal int doOrderedQuery(int nreplies, params object[] given) {
            Timeout timeout;
            object[] resRefs;
            splitObs(this, out timeout, ref given, out resRefs);
            List<byte[]> barrays = this.doOrderedQueryToBA(nreplies, timeout, given);
            Msg.BArraysToLists(resRefs, barrays);
            return barrays.Count;
        }

        /// <summary>
        /// Issues a totally ordered (but not necessarily durable) multicast to the group and waits for replies.
        /// </summary>
        /// <param name="nreplies">number of replies desired</param>
        /// <param name="obs">variable-length list specifying method to invoke, timeout, parameters to method being invoked</param>
        /// <returns>a List contaiining one byte[] vector per received reply</returns>
        /// <remarks>
        /// Issues a totally ordered (but not necessarily durable) multicast to the group and waits for replies (<see cref="Reply"/>, <see cref="NullReply"/> and <see cref="AbortReply"/>).
        /// The number of replies desired can be specified as an integer (normally 1 or 2), or as the special constant ALL.  The first
        /// of the parameter after nreplies is an object of type <see cref="Timeout"/> and specifies a timeout after which the Query ceases to wait for a non-responsive
        /// member, and the default action to take in that case.  The next parameter is the request handle: a small integer identifying this request.
        /// Remaining parameters become typed arguments to the handler for the request.  Returns a byte[][] array in which each entry is a reply from one process.
        /// Normally, the user would employ Msg.BArraysToObjects() or Msg.InvokeFromBArrays() to decode these replies.
        /// 
        /// This is a slightly slower form of virtually synchronous query, and may not be durable be lost in the event of a failure.  Can be done in a single IP multicast if
        /// the sender was the group leader but if not, delivery will be delayed until the group leader decides and notifies members of the ordering to use.
        /// Read about the <it>virtual synchrony model</it> to learn more about when OrderedQuery is needed.
        /// </remarks>
        public List<byte[]> OrderedQueryToBA(int nreplies, params object[] obs) {
            Timeout timeout;
            splitObs(this, out timeout, ref obs);
            return this._Query(false, false, this.OrderedSend, nreplies, timeout, obs);
        }

        /// <summary>
        ///  Issues a causally ordered but potentially non-durable multicast to the group and waits for replies
        /// </summary>
        /// <param name="nreplies">number of replies desired</param>
        /// <param name="given">variable-length list specifying method to invoke, timeout, parameters to method being invoked, EOLMarker, vectors for received results</param>
        /// <returns>how many replies were actually received</returns>
        /// <remarks>
        /// Issues  a causally ordered but potentially non-durable multicast to the group and waits for replies (<see cref="Reply"/>, <see cref="NullReply"/> and <see cref="AbortReply"/>).
        /// 
        /// This is a slightly slower form of virtually synchronous query, and may not be durable be lost in the event of a failure.  Can be done in a single IP multicast 
        /// but delivery might be slightly delayed if the causal ordering would otherwise be violated.
        /// Read about the <it>virtual synchrony model</it> to learn more about when CausalQuery is needed.
        /// 
        /// The number of replies desired can be specified as an integer (normally 1 or 2), or as the special constant ALL.  The first
        /// of the parameter after nreplies is an object of type <see cref="Timeout"/> and specifies a timeout after which the Query ceases to wait for a non-responsive
        /// member, and the default action to take in that case.  The next parameter is the request handle: a small integer identifying this request.
        /// Remaining parameters become typed arguments to the handler for the request.  Counts the replies received and returns this number but the actual replies
        /// are passed to the user in a series of vectors, which should be passed in as by-ref parameters after a marker, the Vsync EOLmarker, which separates
        /// the list of arguments to the invoked method from the places to put recieved replies.
        /// 
        /// For example:  int[] hisAge = new int[0], nreps;  nreps = CausalQuery(GET_AGE, 1, new Timeout(1000, TO_ABORTREPLY), "John Smith", Vsync.EOLmarker, hisAge);
        /// </remarks>
        public int CausalQuery(int nreplies, params object[] given) {
            Timeout timeout;
            object[] resRefs;
            splitObs(this, out timeout, ref given, out resRefs);
            List<byte[]> barrays = this.CausalQueryToBA(nreplies, timeout, given);
            Msg.BArraysToLists(resRefs, barrays);
            return barrays.Count;
        }

        /// <summary>
        /// Issues a causally ordered (but not necessarily durable) multicast to the group and waits for replies.
        /// </summary>
        /// <param name="nreplies">number of replies desired</param>
        /// <param name="obs">variable-length list specifying method to invoke, timeout, parameters to method being invoked</param>
        /// <returns>a List contaiining one byte[] vector per received reply</returns>
        /// <remarks>
        /// Issues a causally ordered (but not necessarily durable) multicast to the group and waits for replies (<see cref="Reply"/>, <see cref="NullReply"/> and <see cref="AbortReply"/>).
        /// The number of replies desired can be specified as an integer (normally 1 or 2), or as the special constant ALL.  The first
        /// of the parameter after nreplies is an object of type <see cref="Timeout"/> and specifies a timeout after which the Query ceases to wait for a non-responsive
        /// member, and the default action to take in that case.  The next parameter is the request handle: a small integer identifying this request.
        /// Remaining parameters become typed arguments to the handler for the request.  Returns a byte[][] array in which each entry is a reply from one process.
        /// Normally, the user would employ Msg.BArraysToObjects() or Msg.InvokeFromBArrays() to decode these replies.
        /// 
        /// This is a slightly slower form of virtually synchronous query, and may not be durable be lost in the event of a failure.  Can be done in a single IP multicast 
        /// but delivery might be slightly delayed if the causal ordering would otherwise be violated.
        /// Read about the <it>virtual synchrony model</it> to learn more about when CausalQuery is needed.
        /// </remarks>
        public List<byte[]> CausalQueryToBA(int nreplies, params object[] obs) {
            Timeout timeout;
            splitObs(this, out timeout, ref obs);
            return this._Query(false, false, this.CausalSend, nreplies, timeout, obs);
        }

        internal List<byte[]> doOrderedQueryToBA(int nreplies, params object[] obs) {
            Timeout timeout;
            splitObs(this, out timeout, ref obs);
            return this._Query(false, false, this.OrderedSend, nreplies, timeout, obs);
        }

        internal void doOrderedQueryInvoke(int nreplies, params object[] obs) {
            Timeout timeout;
            splitObs(this, out timeout, ref obs);
            Delegate del = (Delegate)obs[obs.Length - 1];
            Vsync.ArrayResize(ref obs, obs.Length - 1);
            Msg.InvokeFromBArrays(this.doOrderedQueryToBA(nreplies, timeout, obs), del);
        }

        /// <summary>
        /// Issues a Paxos-style (ordered, durable) multicast to the group and returns a byte[] vector encoding replies.
        /// </summary>
        /// <param name="nreplies">number of replies desired</param>
        /// <param name="obs">variable-length list specifying method to invoke, timeout, parameters to method being invoked</param>
        /// <returns>a List containing one byte[] vector per received reply</returns>
        /// <remarks>
        /// Issues a Paxos-style (ordered, durable) multicast to the group and returns a byte[] vector encoding replies.
        /// waits for replies (<see cref="Reply"/>, <see cref="NullReply"/> and <see cref="AbortReply"/>).
        /// 
        /// This is the slowest but most robust form of virtually synchronous query, and matches the State Machine Replication model.  Requires a form of internal 2-phase commit, which
        /// will involve round-trip acks from a majority of group members.  Read about the <it>virtual synchrony model</it> to learn more about when SafeQuery is needed.
        /// 
        /// The number of replies desired can be specified as an integer (normally 1 or 2), or as the special constant ALL.  The first
        /// of the parameter after nreplies is an object of type <see cref="Timeout"/> and specifies a timeout after which the Query ceases to wait for a non-responsive
        /// member, and the default action to take in that case.  The next parameter is the request handle: a small integer identifying this request.
        /// Remaining parameters become typed arguments to the handler for the request.  Returns a List in which each entry is a reply from one process.
        /// Normally, the user would employ Msg.BArraysToObjects() or Msg.InvokeFromBArrays() to decode these replies.
        /// </remarks>
        public List<byte[]> SafeQueryToBA(int nreplies, params object[] obs) {
            Timeout timeout;
            splitObs(this, out timeout, ref obs);
            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            return this._Query(false, false, this.SafeSend, nreplies, timeout, obs);
        }

        /// <summary>
        /// Issues a Paxos-style (ordered, durable) multicast to the group and waits for replies
        /// </summary>
        /// <param name="nreplies">number of replies desired, or MAJORITY, or ALL</param>
        /// <param name="given">variable-length list specifying method to invoke, timeout, parameters, EOLMarker, and result vectors</param>
        /// <returns>number of replies actually received</returns>
        /// <remarks>
        /// Issues a Paxos-style (ordered, durable) multicast to the group and waits for replies (<see cref="Reply"/>, <see cref="NullReply"/> and <see cref="AbortReply"/>).
        /// 
        /// This is the slowest but most robust form of virtually synchronous query, and matches the State Machine Replication model.  Requires a form of internal 2-phase commit, which
        /// will involve round-trip acks from a majority of group members.  Read about the <it>virtual synchrony model</it> to learn more about when SafeQuery is needed.
        /// 
        /// The number of replies desired can be specified as an integer (normally 1 or 2), or as the special constant ALL.  The first
        /// of the parameter after nreplies is an object of type <see cref="Timeout"/> and specifies a timeout after which the Query ceases to wait for a non-responsive
        /// member, and the default action to take in that case.  The next parameter is the request handle: a small integer identifying this request.
        /// Remaining parameters become typed arguments to the handler for the request.  Returns the number of replies received but discards their contents.
        /// 
        /// For example:  int[] hisAge = new int[0], nreps;  nreps = SafeQuery(GET_AGE, 1, new Timeout(1000, TO_ABORTREPLY), "John Smith", Vsync.EOLmarker, hisAge);
        /// </remarks>
        public int SafeQuery(int nreplies, params object[] given) {
            Timeout timeout;
            object[] resRefs;
            splitObs(this, out timeout, ref given, out resRefs);
            List<byte[]> barrays = this.SafeQueryToBA(nreplies, timeout, given);
            Msg.BArraysToLists(resRefs, barrays);
            return barrays.Count;
        }

        internal int doSafeQuery(int nreplies, params object[] given) {
            Timeout timeout;
            object[] resRefs;
            splitObs(this, out timeout, ref given, out resRefs);
            List<byte[]> barrays = this.doSafeQueryToBA(nreplies, timeout, given);
            Msg.BArraysToLists(resRefs, barrays);
            return barrays.Count;
        }

        internal void SafeQueryInvoke(int nreplies, params object[] obs) {
            Timeout timeout;
            splitObs(this, out timeout, ref obs);
            Delegate del = (Delegate)obs[obs.Length - 1];
            Vsync.ArrayResize(ref obs, obs.Length - 1);
            Msg.InvokeFromBArrays(this.SafeQueryToBA(nreplies, timeout, obs), del);
        }

        internal List<byte[]> doSafeQueryToBA(int nreplies, params object[] obs) {
            Timeout timeout;
            splitObs(this, out timeout, ref obs);
            return this._Query(false, false, this.SafeSend, nreplies, timeout, obs);
        }

        internal void doSafeQueryInvoke(int nreplies, params object[] obs) {
            Timeout timeout;
            splitObs(this, out timeout, ref obs);
            Delegate del = (Delegate)obs[obs.Length - 1];
            Vsync.ArrayResize(ref obs, obs.Length - 1);
            Msg.InvokeFromBArrays(this.doSafeQueryToBA(nreplies, timeout, obs), del);
        }

        internal List<byte[]> doUnorderedQueryToBA(int nreplies, params object[] obs) {
            Timeout timeout;
            splitObs(this, out timeout, ref obs);
            return this._Query(false, false, this.doUnorderedSend, nreplies, timeout, obs);
        }

        internal List<byte[]> UnorderedQueryToBA(int nreplies, params object[] obs) {
            Timeout timeout;
            splitObs(this, out timeout, ref obs);
            return this._Query(false, false, this.doUnorderedSend, nreplies, timeout, obs);
        }

        /// <summary>
        /// Issues an unordered multicast to the group and waits for replies
        /// </summary>
        /// <param name="nreplies">number of replies desired, or MAJORITY, or ALL</param>
        /// <param name="given">variable-length list specifying method to invoke, timeout, parameters, EOLMarker, and result vectors</param>
        /// <returns>number of replies actually received</returns>
        /// <remarks>
        /// Issues an unordered multicast to the group and waits for replies (<see cref="Reply"/>, <see cref="NullReply"/> and <see cref="AbortReply"/>).
        /// The number of replies desired can be specified as an integer (normally 1 or 2), or as the special constant ALL.  The first
        /// of the parameter after nreplies is an object of type <see cref="Timeout"/> and specifies a timeout after which the Query ceases to wait for a non-responsive
        /// member, and the default action to take in that case.  The next parameter is the request handle: a small integer identifying this request.
        /// Remaining parameters become typed arguments to the handler for the request.  Returns the number of replies received but discards their contents.
        /// </remarks>
        public int UnorderedQuery(int nreplies, params object[] given) {
            Timeout timeout;
            object[] resRefs;
            splitObs(this, out timeout, ref given, out resRefs);
            List<byte[]> barrays = this.UnorderedQueryToBA(nreplies, timeout, given);
            Msg.BArraysToLists(resRefs, barrays);
            return barrays.Count;
        }

        internal int doUnorderedQuery(int nreplies, params object[] given) {
            Timeout timeout;
            object[] resRefs;
            splitObs(this, out timeout, ref given, out resRefs);
            List<byte[]> barrays = this.doUnorderedQueryToBA(nreplies, timeout, given);
            Msg.BArraysToLists(resRefs, barrays);
            return barrays.Count;
        }

        internal void doUnorderedQueryInvoke(int nreplies, params object[] obs) {
            Timeout timeout;
            splitObs(this, out timeout, ref obs);
            Delegate del = (Delegate)obs[obs.Length - 1];
            Vsync.ArrayResize(ref obs, obs.Length - 1);
            Msg.InvokeFromBArrays(this.doUnorderedQueryToBA(nreplies, timeout, obs), del);
        }

        private List<byte[]> _Query(bool sentByOracle, bool isRaw, querySender AsyncSendQuery, int nreplies, Timeout timeout, object[] obs) {
            return this._Query(Msg.UNINITIALIZED, Msg.UNINITIALIZED, 0, sentByOracle, isRaw, AsyncSendQuery, nreplies, timeout, obs);
        }

        private List<byte[]> _Query(int vid, int mid, int nRaw, bool sentByOracle, bool isRaw, querySender AsyncSendQuery, int nreplies, Timeout timeout, object[] obs) {
            if (!this.VsyncCallStart()) {
                return new List<byte[]>();
            }

            long mylid = 0;
            if (this.myLoggingFcn != null) {
                this.myLoggingFcn(IL_QUERY, IL_START, Vsync.my_address, mylid = this.newLoggingId(), obs);
            }

            if (!this.GroupOpen) {
                if ((VsyncSystem.Debug & (VsyncSystem.VIEWWAIT | VsyncSystem.REPLYWAIT)) != 0) {
                    Vsync.WriteLine("Query to a group with GroupOpen==false: return new byte[0][]");
                }

                this.VsyncCallDone();
                return new List<byte[]>();
            }

            if (obs == null || obs.Length < 1) {
                throw new ArgumentNullException("obs", "Vsync.Group.query");
            }

            Msg m;
            if (obs.Length == 1 && obs[0].GetType() == typeof(Msg)) {
                m = (Msg)obs[0];
            }
            else {
                object dests = null;
                if (obs.Length == 1 && obs[0].GetType() == typeof(object[]) && ((object[])obs[0]).Length > 0 && IsSubsetSend(((object[])obs[0])[0])) {
                    dests = GetDests((object[])obs[0]);
                    isRaw = true;
                }
                else if (obs.Length > 0 && IsSubsetSend(obs[0])) {
                    dests = GetDests(obs);
                    obs = fixObs(obs);
                    isRaw = true;
                }

                this.cbCheck(obs);
                m = new Msg(obs);

                // Used to pass additional destination information to the doTheSend code that needs it
                if (dests != null) {
                    if (dests.GetType() == typeof(List<Address>)) {
                        m.destList = (List<Address>)dests;
                    }
                    else if (dests.GetType() == typeof(Address[])) {
                        m.destList = ((Address[])dests).ToList();
                    }
                    else {
                        m.destList = ((QKD)dests).GetDests(this);
                    }
                }
            }

            if (vid != Msg.UNINITIALIZED) {
                m.vid = vid;
                m.msgid = mid;
                m.nRaw = nRaw;
            }
            else {
                this.SetMsgIds(m, sentByOracle, isRaw);
            }

            m.flags |= Msg.NEEDSREPLY;
            if ((this.flags & G_SECURE) != 0) {
                m.flags |= Msg.ENCIPHEREDREPLY;
            }

            if (sentByOracle) {
                m.flags |= Msg.SENTBYORACLE;
            }

            if (nreplies == 0 || !this.HasFirstView) {
                if ((VsyncSystem.Debug & (VsyncSystem.VIEWWAIT | VsyncSystem.REPLYWAIT)) != 0) {
                    Vsync.WriteLine("Query to group<" + this.gname + "> with nreplies=" + nreplies + ", and HasFirstView=" + this.HasFirstView + ": return new byte[0][]");
                }

                this.VsyncCallDone();
                return new List<byte[]>();
            }

            if (nreplies == ALL) {
                nreplies = this.theView.members.Length;
            }
            else if (nreplies == MAJORITY) {
                nreplies = (this.theView.members.Length + 1) / 2;
            }

            nreplies = Math.Min(nreplies, this.theView.members.Length);

            if ((VsyncSystem.Debug & (VsyncSystem.REPLYWAIT | VsyncSystem.VIEWCHANGE)) != 0) {
                Vsync.WriteLine("Registering a wait structure... group " + this.gname + ", wait-id " + m.vid + ":" + m.msgid + ", nreplies " + nreplies);
            }

            AwaitReplies.ReplyInfo ri = AwaitReplies.registerGroupWait(this, m.vid, m.msgid, m.destList, sentByOracle, (this.flags & G_SECURE) != 0, nreplies, timeout.when);
            if ((VsyncSystem.Debug & (VsyncSystem.REPLYWAIT | VsyncSystem.VIEWCHANGE | VsyncSystem.VIEWWAIT)) != 0) {
                Vsync.WriteLine("Sending my query: group " + this.gname + " msgid " + m.vid + ":" + m.msgid + ", ri.wanted=" + ri.replies_wanted);
            }

            AsyncSendQuery(m);
            if ((VsyncSystem.Debug & (VsyncSystem.REPLYWAIT | VsyncSystem.VIEWCHANGE | VsyncSystem.VIEWWAIT)) != 0) {
                Vsync.WriteLine("After sending my query: group " + this.gname + " msgid " + m.vid + ":" + m.msgid + ".... Collecting the replies...");
            }

            AwaitReplies.awaitReplies(ri, this, timeout, m.destList);
            if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                Vsync.WriteLine("Collected replies, list contains " + ri.rdvReplies.Count);
            }

            if ((this.flags & G_SECURE) != 0) {
                this.DecipherReplies(ri);
            }

            if (this.myLoggingFcn != null) {
                this.myLoggingFcn(IL_QUERY, IL_DONE, Vsync.my_address, mylid);
            }

            this.VsyncCallDone();
            return ri.rdvReplies;
        }

        internal void DecipherReplies(AwaitReplies.ReplyInfo ri) {
            List<byte[]> tmp = new List<byte[]>();
            foreach (byte[] r in ri.rdvReplies) {
                tmp.Add(this.decipherBuf(r));
            }

            ri.rdvReplies = tmp;
        }

        internal class querierArgs {
            internal List<byte[]>[] ba;

            internal List<byte[]> bap2p;

            internal Group g;

            internal int nr;

            internal bool sentByOracle;

            internal int whoAmI;

            internal Timeout timeout;

            internal object[] obs;

            internal querierArgs(List<byte[]>[] b, Group group, int n, bool bo, int w, Timeout to, object[] o) {
                this.ba = b;
                this.g = group;
                this.nr = n;
                this.sentByOracle = bo;
                this.whoAmI = w;
                this.timeout = to;
                this.obs = o;
            }

            internal querierArgs(List<byte[]> bp2p, Group group, int w, Timeout to, object[] o) {
                this.ba = null;
                this.bap2p = bp2p;
                this.g = group;
                this.whoAmI = w;
                this.timeout = to;
                this.obs = o;
                this.sentByOracle = false;
            }
        }

        internal static List<byte[]>[] doMultiQuery(List<Group> glist, int nreplies, bool sentByOracle, params object[] obs) {
            Timeout timeout;
            splitObs(glist, out timeout, ref obs);
            int ng = glist.Count;
            int gn = 0;
            List<byte[]>[] ba = new List<byte[]>[ng];
            Thread[] myThreads = new Thread[ng];

            // This is kind of gross but easier than the alternative.  Probably should consider recoding it
            if ((VsyncSystem.Debug & (VsyncSystem.REPLYWAIT | VsyncSystem.VIEWWAIT)) != 0) {
                string s = "Doing a MultiQuery in groups ";
                foreach (Group g in glist) {
                    s += g.gname + " ";
                }

                Vsync.WriteLine(s);
            }

            foreach (Group g in glist) {
                myThreads[gn] = new Thread(myQuerier) { Name = "VSYNC MultiQuery thread for <" + g.gname + ">", IsBackground = true };
                querierArgs qa = new querierArgs(ba, g, nreplies, sentByOracle, gn, timeout, obs);
                myThreads[gn].Start(qa);
                ++gn;
            }

            foreach (Thread t in myThreads) {
                t.Join();
            }

            return ba;
        }

        internal static List<byte[]> doMultiP2PQuery(List<Group> glist, params object[] obs) {
            Timeout timeout;
            splitObs(glist, out timeout, ref obs);
            int ng = glist.Count;
            int gn = 0;
            List<byte[]> ba = new List<byte[]>();
            Thread[] myThreads = new Thread[ng];

            // This is kind of gross but easier than the alternative.  Probably should consider recoding it
            if ((VsyncSystem.Debug & (VsyncSystem.REPLYWAIT | VsyncSystem.VIEWWAIT)) != 0) {
                string s = "Doing a MultiP2PQuery in groups ";
                foreach (Group g in glist) {
                    s += g.gname + " ";
                }

                Vsync.WriteLine(s);
            }

            foreach (Group g in glist) {
                myThreads[gn] = new Thread(myQuerier) { Name = "VSYNC MultiP2PQuery thread for <" + g.gname + ">", IsBackground = true };
                querierArgs qa = new querierArgs(ba, g, gn, timeout, obs);
                myThreads[gn].Start(qa);
                ++gn;
            }

            foreach (Thread t in myThreads) {
                t.Join();
            }

            return ba;
        }

        private static void myQuerier(object o) {
            querierArgs qa = (querierArgs)o;
            try {
                if ((VsyncSystem.Debug & (VsyncSystem.REPLYWAIT | VsyncSystem.VIEWWAIT)) != 0) {
                    Vsync.WriteLine("before multiQuery(" + qa.g.gname + "): index[" + qa.whoAmI + "] ... nreplies " + qa.nr);
                }

                if (qa.ba != null) {
                    qa.ba[qa.whoAmI] = qa.g.doQueryToBA(qa.sentByOracle, qa.nr, qa.timeout, qa.obs);
                }
                else {
                    qa.bap2p[qa.whoAmI] = qa.g.doP2PQuery(qa.g.theView.members[0], qa.timeout, qa.obs);
                }

                if ((VsyncSystem.Debug & (VsyncSystem.REPLYWAIT | VsyncSystem.VIEWWAIT)) != 0) {
                    Vsync.WriteLine("after multiQuery(" + qa.g.gname + "): index[" + qa.whoAmI + "] reply len " + ((qa.ba == null) ? qa.bap2p[qa.whoAmI].Length : qa.ba[qa.whoAmI].Count));
                }
            }
            catch (VsyncShutdownException) {
                qa.ba[qa.whoAmI] = new List<byte[]>();
            }

            VsyncSystem.ThreadTerminationMagic();
        }

        internal static void FixUp(Address Old, Address New) {
            if (Old == null || New == null) {
                return;
            }

            var gClone = VsyncGroupsClone();
            foreach (var g in gClone) {
                using (var tmpLockObj = new LockAndElevate(g.ToDoLock)) {
                    foreach (var m in g.ToDo) {
                        if (Old.Equals(m.sender)) {
                            m.sender = New;
                        }
                    }
                }
            }
        }

        internal void ReplayToDo() {
            if (this.ToDoCount == 0) {
                return;
            }

            using (Semaphore ReplayWait = new Semaphore(0, int.MaxValue)) {
                using (var tmpLockObj = new LockAndElevate(this.ToDoLock)) {
                    new Thread(() => {
                        try {
                            List<Msg> oldToDo;
                            int vid = 0;
                            using (var tmpLockObj1 = new LockAndElevate(this.ToDoLock)) {
                                oldToDo = this.ToDo;
                                this.ToDo = new List<Msg>();
                                this.ToDoCount = 0;
                            }

                            if (oldToDo.Count > 0) {
                                foreach (Msg m in oldToDo) {
                                    if (Vsync.MY_OLD_MASTER != null && Vsync.MY_OLD_MASTER.Equals(m.sender)) {
                                        m.sender = Vsync.MY_MASTER;
                                    }

                                    using (var tmpLockObj1 = new LockAndElevate(this.ViewLock)) {
                                        if (this.theView != null) {
                                            vid = this.theView.viewid;
                                        }
                                    }

                                    if (m.vid > vid || !this.GotAMsg(m, Msg.MULTICAST, "replayToDo")) {
                                        using (var tmpLockObj1 = new LockAndElevate(this.ToDoLock)) {
                                            if (m.toDoTime == 0) {
                                                m.toDoTime = Vsync.NOW;
                                            }
                                            else if ((Vsync.NOW - m.toDoTime) > Vsync.VSYNC_DEFAULTTIMEOUT * 6 && Vsync.VSYNC_SHUTDOWNIFOVERLOADED) {
                                                throw new VsyncException("Vsync is shutting down due to extremely long scheduling delays.  Is your computer unusually overloaded?");
                                            }

                                            this.ToDo.Add(m);
                                            this.ToDoCount++;
                                        }
                                    }
                                }
                            }
                        }
                        catch (VsyncShutdownException) {
                            VsyncSystem.CheckLocksHeld();
                        }

                        VsyncSystem.ThreadTerminationMagic();
                        ReplayWait.Release();
                    }) { Name = "ToDo Replay Thread", IsBackground = true }.Start();
                }

                ILock.NoteThreadState("ReplayWait.WaitOne()");
                ReplayWait.WaitOne();
                ILock.NoteThreadState(null);
            }
        }

        internal void CheckCausalWaitQueue() {
            using (var tmpLockObj = new LockAndElevate(this.CausalOrderListLock)) {
                ctuple ct = this.CausalOrderList.FirstOrDefault();
                if (ct != null && (Vsync.NOW - ct.whenEnqueued) > Vsync.VSYNC_DEFAULTTIMEOUT * 6) {
                    throw new VsyncException("Vsync causal send: message(s) trapped on the causal delivery queue for too long");
                }
            }
        }

        internal int StabilityCbPending = -1;

        internal void isStable(Address who, int n) {
            if (who == null || n < 0) {
                return;
            }

            using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                if (this.theView != null) {
                    int rank = this.theView.isLarge ? -1 : this.theView.GetRankOf(who);
                    if (rank != -1) {
                        this.theView.StableTo[rank + 1] = Math.Max(this.theView.StableTo[rank + 1], n);
                    }
                }
            }

            using (var tmpLockObj = new LockAndElevate(this.UnstableLock)) {
                List<Msg> tmpUnstable = new List<Msg>();
                foreach (Msg m in this.Unstable) {
                    if (m.msgid > n || m.sender != who) {
                        tmpUnstable.Add(m);
                    }
                }

                this.Unstable = tmpUnstable;
                this.UnstableCount = this.Unstable.Count;
            }
        }

        internal static LockObject slock = new LockObject("SendStabilityLock");
        internal static bool sending = false;

        internal static void SendStability() {
            List<Group> wantsStabilitySent = new List<Group>();
            List<Group> igc = Group.VsyncGroupsClone();
            // Make sure we don't launch too many of these threads at a time
            using (var tmpLockObj = new LockAndElevate(slock)) {
                if (sending) {
                    return;
                }
                sending = true;
            }
            new Thread(() => {
                // Do the action as a thread because we're called from the resender thread
                try {
                    foreach (Group g in igc) {
                        View theView;
                        using (var tmpLockObj = new LockAndElevate(g.ViewLock)) {
                            theView = g.theView;
                        }

                        if (theView == null) {
                            continue;
                        }

                        using (var tmpLockObj = new LockAndElevate(g.GroupFlagsLock)) {
                            if (((g.flags & Group.G_SENDINGSTABILITY) == 0 && ((theView.minStable < theView.lastStabilitySent || g.CurrentBacklog != g.PreviousBacklog) && (Vsync.NOW - g.SentStableAt) > 100)) || ((FlowControl.Waiting > 0 || ReliableSender.rWaiting > 0) && (Vsync.NOW - g.SentStableAt) > 1000)) {
                                wantsStabilitySent.Add(g);
                            }
                        }
                    }

                    foreach (Group g in wantsStabilitySent) {
                        if (ReliableSender.doSendStability(g)) {
                            using (var tmpLockObj = new LockAndElevate(g.GroupFlagsLock)) {
                                g.CurrentBacklog = 0;
                            }
                        }
                    }
                }
                catch (VsyncShutdownException) {
                    VsyncSystem.CheckLocksHeld();
                }
                using (var tmpLockObj = new LockAndElevate(slock)) {
                    sending = false;
                }
                VsyncSystem.ThreadTerminationMagic();
            }) { Name = "Sending stability", Priority = ThreadPriority.Highest, IsBackground = true }.Start();
        }

        /// <exclude>
        /// <summary>
        /// Internal for use by Vsync; public only to satisfy C# scope rules.
        /// </summary>
        /// </exclude>
#if PROTOCOL_BUFFERS
        [ProtoContract(SkipConstructor = true)]
#else
        [AutoMarshalled]
#endif
        public class FlushAggKey : IEquatable<FlushAggKey> {
            /// <exclude>
            /// <summary>
            /// Internal for use by Vsync
            /// </summary>
            /// </exclude>
            [ProtoMember(1)]
            public readonly Address who;

            /// <exclude>
            /// <summary>
            /// Internal for use by Vsync
            /// </summary>
            /// </exclude>
            [ProtoMember(2)]
            public readonly int state;

#if !PROTOCOL_BUFFERS
            /// <exclude></exclude>
            public FlushAggKey() {
            }
#endif

            internal FlushAggKey(Address a, int s) {
                this.who = a;
                this.state = s;
            }

            /// <exclude>
            /// <summary>
            /// Internal for use by Vsync
            /// </summary>
            /// <returns>string encoding the state of the flush aggregator</returns>
            /// </exclude>
            public override string ToString() {
                return this.who + ((this.state == tokenInfo.SETSTABLETO) ? "|1" : "|0");
            }

            /// <exclude></exclude>
            public static bool operator ==(FlushAggKey first, FlushAggKey second) {
                return Equals(first, second);
            }

            /// <exclude></exclude>
            public static bool operator !=(FlushAggKey first, FlushAggKey second) {
                return !Equals(first, second);
            }

            /// <exclude>
            /// <summary>
            /// Equality comparison
            /// </summary>
            /// <param name="first">First comparison target</param>
            /// <param name="second">Second comparison target</param>
            /// </exclude>
            public static bool Equals(FlushAggKey first, FlushAggKey second) {
                if (object.ReferenceEquals(first, second)) {
                    return true;
                }

                if (object.ReferenceEquals(first, null) || object.ReferenceEquals(second, null)) {
                    return false;
                }

                return first.who == second.who && first.state == second.state;
            }

            /// <exclude>
            /// <summary>
            /// Equality comparison
            /// </summary>
            /// <param name="other">comparison target</param>
            /// </exclude>
            public override bool Equals(object other) {
                return Equals(this, other as FlushAggKey);
            }

            /// <exclude>
            /// <summary>
            /// Equality comparison
            /// </summary>
            /// <param name="other">comparison target</param>
            /// </exclude>
            public bool Equals(FlushAggKey other) {
                return Equals(this, other);
            }

            /// <exclude>
            /// <summary>
            /// Required hashcode method
            /// </summary>
            /// <returns>the hash code</returns>
            /// </exclude>
            public override int GetHashCode() {
                return this.who.GetHashCode() + (this.state * 1717);
            }
        }

        /// <exclude>
        /// <summary>
        /// Internal, represents the tokens employed in the Vsync token-tree algorithm.  Declared public to comply with C# scoping rules.
        /// </summary>
        /// </exclude>
        public class tokenInfo : ISelfMarshalled {
            // Wire portion only includes these fields
            internal Address gaddr; // The group in which this token is circulating

            internal Address groupOwner; // The sender for that group, used because the members don't track

            internal Address sender; // Most recent sender, useful for debugging

            internal Vsync.ViewDelta[] viewDeltas;

            // Recent View Deltas, sent as an vector when some kind of membership event occurs
            internal volatile int logicalClock;

            internal int state; // State currently has just 3 values

            internal int stableAtSender; // Stable up to this msgid. 

            internal int viewid; // Viewid for this token

            internal int alsoSeenBase; // alsoSeen is computed wrt to this base

            internal long alsoSeen; // Up to 64 bits for ids > stable that have been seen membership in large groups

            internal int tokenLevel; // Level of the token tree at which this token was sent

            internal int aggStable; // Aggregated stable value for nodes within the specified level, for transmission

            internal int stableTo; // Propagates out from the group leader and triggers garbage collection

            internal byte[][] incomingValuesArray; // Extracted on incoming token, undefined for outgoing token

            // State values
            internal const int NORMAL = 0; // Large group in the normal operational mode

            internal const int INQUIRY = 1; // New leader inquiring about member states

            internal const int SETSTABLETO = 2;

            // New leader is promulgating the initial "stableto" value for its first view

            // Not transmitted (inferred on token arrival)
            internal const int RINGSIZE = 8;

            // 25 worked well in Quicksilver Scalable Multicast.  Must be >= 2!  Guess: optimal is log(N)

            // Per-group values used within the token algorithms    
            internal long whenReceived; // Time when this token was received

            internal volatile bool inhibitResenderLoop;

            // While stabilizing after a large-group membership change, inhibits resender loop temporarily
            internal long gotAllAt; // ... associated delay timer

            internal int unstableVIDMID; // Multicast ID number that was used to cast a view id that isn't stable yet

            internal int unstableVID; // Associated viewID

            internal int stableVID; // Max view id to have become stable so far

            internal LockObject slock = new LockObject("token.slock"); // Protects the VID fields

            internal Group theGroup;

            internal View WorkingView;

            internal long WorkingViewInstalledAt;

            internal bool IAmLgOwner = false;

            internal bool[] IAmRank0;

            internal ILock FlushingBarrier; // Used to wait while flushing is running

            internal LockObject FlushingBarrierLock = new LockObject("token.FlushingBarrierLock");

            // Better safe than sorry!
            internal int nlevels;

            internal int[] mySubgroupIdx;

            internal int[] myOffset;

            internal int[] StableByLevel;

            // Used in the rank-0 members of each ring, StableByLevel[i] is the value of aggStable received from the last guy in ring [i]
            internal int[] includeViewDeltas; // Tells me if the view delta vector for this level needs to be included

            internal tokenInfo[] lastToken; // Last token I received 

            internal Address[] next;

            internal Address[] last;

            internal bool[] lastValidated; // I've received at least one token from last since prior reset

            internal bool[] sentAToken; // True if I sent a token to try and "push" last[i] into sync with me

            internal bool[] pinged; // True if I didn't get a token from you so I pinged you

            internal int[] tokenInMotion; // Counts the number of tokens to next[level] that are "in motion"

            internal LockObject tokenInMotionLock = new LockObject("tokenInMotionLock");

            internal long resetTime;

            internal tokenInfo(Group g) {
                if (g.theToken == null || g.theToken.viewDeltas == null) {
                    this.viewDeltas = new Vsync.ViewDelta[0];
                    this.WorkingView = g.theView;
                }
                else {
                    this.viewDeltas = g.theToken.viewDeltas;
                    this.WorkingView = g.theToken.WorkingView;
                }

                this.WorkingViewInstalledAt = Vsync.NOW;
                this.theGroup = g;
                this.reinitializeToken(g);
                this.IAmLgOwner = g.theView.GetMyRank() == 0;
            }

            // Caller must hold g.Lock and g.tokenLock
            internal static void newToken(Group g) {
                tokenInfo oldToken = g.theToken;
                g.theToken = new tokenInfo(g);
                if (oldToken != null) {
                    g.theToken.stableTo = oldToken.stableTo;
                    g.theToken.logicalClock = oldToken.logicalClock + 1;
                }

                if (oldToken == null || oldToken.theGroup.AggList == null) {
                    return;
                }

                g.theToken.logicalClock = oldToken.logicalClock;
                if (oldToken.IAmLgOwner) {
                    foreach (LinkedList<object> item in oldToken.theGroup.AggList) {
                        foreach (IAggregateEventHandler ae in item) {
                            ae.AggEvent(Group.BreakWaits);
                        }
                    }
                }
                else if ((VsyncSystem.Debug & VsyncSystem.TOKENFLUSH) != 0) {
                    Vsync.WriteLine("<" + g.gname + ">: Unhibit breakwaits (I wasn't the previous LgOwner");
                }
            }

            internal void resetStableByLevel(Group g) {
                if ((VsyncSystem.Debug & VsyncSystem.TOKENSTABILITY) != 0) {
                    Vsync.WriteLine("<" + g.gname + ">: LogicalClock=" + this.logicalClock + ", reset StableByLevel[*]=-1");
                }

                for (int level = 0; level < this.StableByLevel.Length; level++) {
                    this.StableByLevel[level] = -1;
                }
            }

            // Caller holds g.tokenLock
            internal void reinitializeToken(Group g) {
                Address[] Mlist = this.WorkingView.members;
                int NMemb = Mlist.Length;
                int myrank = this.WorkingView.GetMyRank();
                if (NMemb == 0 || myrank == -1) {
                    return;
                }

                this.nlevels = 0;
                for (int n = NMemb; n > 0; n /= RINGSIZE) {
                    this.nlevels++;
                }

                if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                    Vsync.WriteLine(" REINITIALIZE TOKEN FOR GROUP <" + this.theGroup.gname + ">, view " + this.WorkingView.viewid + " NMemb=" + NMemb + " nlevels=" + this.nlevels);
                }

                this.resetTime = Vsync.NOW;
                this.mySubgroupIdx = new int[this.nlevels];
                this.myOffset = new int[this.nlevels];
                this.next = new Address[this.nlevels];
                this.last = new Address[this.nlevels];
                this.lastValidated = new bool[this.nlevels];
                this.sentAToken = new bool[this.nlevels];
                this.pinged = new bool[this.nlevels];
                ReliableSender.CleanLgCallbacks(g);
                using (var tmpLockObj = new LockAndElevate(this.tokenInMotionLock)) {
                    this.tokenInMotion = new int[this.nlevels];
                }

                this.StableByLevel = new int[this.nlevels];
                this.lastToken = new tokenInfo[this.nlevels];
                this.includeViewDeltas = new int[this.nlevels];
                this.IAmRank0 = new bool[this.nlevels];
                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                    Vsync.WriteLine("Reinitialize the AggList[nlevels=" + this.nlevels + "] from the AggTypes List in <" + g.gname + ">... (it lists " + g.AggTypes.Count + " types)");
                }

                this.theGroup.AggList = new LinkedList<object>[this.nlevels];
                this.viewid = this.WorkingView.viewid;
                using (var tmpLockObj = new LockAndElevate(this.theGroup.AggListLock)) {
                    binfo.resetBarrierList();
                    for (int n = 0; n < this.nlevels; n++) {
                        this.theGroup.AggList[n] = new LinkedList<object>();
                        foreach (AggInfo ag in g.AggTypes) {
                            if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                                Vsync.WriteLine("Calling constructor in <" + g.gname + "> to allocate a new aggregator of type " + ag.KVT);
                            }

                            // These are actually "aggregator" objects of some derived type
                            this.theGroup.AggList[n].AddLast(ag.myFactory.Invoke(new[] { ag.theGroup, this.viewid, n, ag.theDel, ag.theTimeout }));
                        }
                    }
                }

                if (this.viewDeltas.Length != 0) {
                    for (int n = 0; n < this.nlevels; n++) {
                        this.includeViewDeltas[n] = 4;
                    }
                }

                this.groupOwner = Mlist[0];
                this.stableAtSender = this.aggStable = this.stableTo = -1;
                this.gaddr = this.theGroup.gaddr;
                this.sender = Vsync.my_address;

                bool inNextLevel = true;
                int stride = 1;
                int ringsize = RINGSIZE;
                for (int i = 0; i < this.nlevels; i++) {
                    if (inNextLevel) {
                        int residue = -1;
                        for (int delta = 0; delta < 15; delta++) {
                            int theResidue = NMemb % (ringsize - delta);
                            if (theResidue == 0) {
                                break;
                            }

                            if (theResidue > residue) {
                                residue = NMemb % (ringsize - delta);
                            }
                        }

                        this.mySubgroupIdx[i] = myrank / ringsize;
                        this.myOffset[i] = myrank % ringsize;
                        this.IAmRank0[i] = this.myOffset[i] == 0;
                        int sgBase = myrank - this.myOffset[i];
                        int idx = sgBase + ((this.myOffset[i] + stride) % ringsize);
                        if (idx >= NMemb) {
                            idx = sgBase;
                        }

                        this.next[i] = Mlist[idx];
                        int lidx = myrank - stride;
                        if (lidx < sgBase) {
                            lidx += ringsize;
                            while (lidx >= NMemb) {
                                lidx -= stride;
                            }
                        }

                        this.last[i] = Mlist[lidx];
                        this.lastValidated[i] = false;
                        this.sentAToken[i] = false;
                        if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                            Vsync.WriteLine("Token layer[" + i + "] initializing next/last: MemberList = " + Address.VectorToString(Mlist) + ", myRank=" + myrank + ", ringsize=" + ringsize + ", sgBase=" + sgBase + ", last[" + i + "]=" + this.last[i] + ", next[" + i + "]=" + this.next[i]);
                        }

                        inNextLevel = myrank % ringsize == 0;
                        stride = ringsize;
                        ringsize *= RINGSIZE;
                    }
                    else {
                        if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                            Vsync.WriteLine("Token layer[" + i + "] not in at this level, setting nlevels=" + i);
                        }

                        this.nlevels = i;
                    }

                    this.alsoSeen = 0;
                    this.StableByLevel[i] = -1;
                }

                if (this.groupOwner.isMyAddress() && (this.next[this.nlevels - 1] == null || this.next[this.nlevels - 1].isMyAddress())) {
                    this.nlevels = Math.Max(1, this.nlevels - 1);
                }

                if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                    Vsync.WriteLine("... reinitalized token = " + this);
                }

                if ((VsyncSystem.Debug & VsyncSystem.TOKENSTABILITY) != 0) {
                    Vsync.WriteLine("<" + g.gname + ">: New view = " + Address.VectorToString(Mlist) + Environment.NewLine);
                    for (int level = 0; level < this.next.Length; level++) {
                        Vsync.WriteLine("<" + g.gname + ">:   -- last[" + level + "]=" + (this.last[level] == null ? "(null)" : (this.last[level].isMyAddress() ? "(self)" : this.last[level].ToString())));
                        Vsync.WriteLine("<" + g.gname + ">:   -- next[" + level + "]=" + (this.next[level] == null ? "(null)" : (this.next[level].isMyAddress() ? "(self)" : this.next[level].ToString())));
                    }
                }
            }

            // Used to generate a working view by applying view deltas to the group view
            // Parent group is the group within which the action is occuring, but this call can
            // occur far into the future (it mostly updates the WorkingView structure) and we
            // don't do callbacks at this time.  So we just create a temporary, fake, Group object
            // Returns the first group view in which I am the leader (or -1, if none); used in flush
            internal void applyViewDeltas(Group parentGroup, Vsync.ViewDelta[] newvds) {
                using (var tmpLockObj = new LockAndElevate(parentGroup.TokenLock))
                using (var tmpLockObj1 = new LockAndElevate(parentGroup.ViewLock)) {
                    int priorView = -1;
                    if (this.WorkingView != null) {
                        priorView = this.WorkingView.viewid;
                    }

                    this.updateViewDeltas(newvds);
                    using (Group g = new Group()) {
                        g.AggTypes = parentGroup.AggTypes;
                        g.gaddr = parentGroup.gaddr;
                        g.gname = parentGroup.gname;
                        using (var tmpLockObj2 = new LockAndElevate(g.ViewLock)) {
                            g.theView = this.WorkingView;
                        }

                        foreach (Vsync.ViewDelta vd in this.viewDeltas) {
                            if (vd.prevVid == g.theView.viewid) {
                                if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                                    Vsync.WriteLine("  applying view delta = " + vd);
                                }

                                Vsync.UpdateGroupView(false, vd, g, "update theToken.WorkingView");
                                if (parentGroup.myFirstLeadershipView == 0 && g.IAmRank0()) {
                                    parentGroup.myFirstLeadershipView = g.theView.viewid;
                                }
                            }
                        }

                        this.WorkingView = g.theView;
                        this.WorkingViewInstalledAt = Vsync.NOW;
                        if (parentGroup.gaddr != null && parentGroup.gaddr == Vsync.VSYNCMEMBERS.gaddr) {
                            IPMCNewView(parentGroup.gaddr, this.WorkingView);
                        }
                    }

                    if (priorView == this.WorkingView.viewid) {
                        return;
                    }

                    // Finally, recompute the token using the new WorkingView 
                    if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                        Vsync.WriteLine("reinitializing the token from the working view = " + this.WorkingView);
                    }

                    newToken(parentGroup);
                }
            }

            internal void updateViewDeltas(Vsync.ViewDelta[] newvds) {
                if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                    Vsync.WriteLine("TOKEN: updateViewDeltas called on a VD vector of length " + newvds.Length + ", with prior VDS = ");
                    foreach (Vsync.ViewDelta vd in this.viewDeltas) {
                        Vsync.WriteLine("   " + vd);
                    }

                    Vsync.WriteLine("NEW VIEW DELTAS TO MERGE IN:");
                    foreach (Vsync.ViewDelta vd in newvds) {
                        Vsync.WriteLine("   " + vd);
                    }
                }

                // First create one merged list of view deltas
                List<Vsync.ViewDelta> newvdlist = new List<Vsync.ViewDelta>();
                foreach (Vsync.ViewDelta vd in newvds) {
                    bool fnd = false;
                    if (vd.prevVid < this.stableVID) {
                        fnd = true;
                    }
                    else {
                        foreach (Vsync.ViewDelta knownvd in this.viewDeltas) {
                            if (vd.prevVid <= knownvd.prevVid || (knownvd.leaderId == vd.leaderId && knownvd.gaddr == vd.gaddr && knownvd.prevVid == vd.prevVid)) {
                                fnd = true;
                                break;
                            }
                        }
                    }

                    if (!fnd) {
                        foreach (Vsync.ViewDelta knownvd in newvdlist) {
                            if (knownvd.leaderId == vd.leaderId && knownvd.gaddr == vd.gaddr && knownvd.prevVid == vd.prevVid) {
                                fnd = true;
                                break;
                            }
                        }
                    }

                    if (!fnd) {
                        newvdlist.Add(vd);
                    }
                }

                if (newvdlist.Count == 0) {
                    return;
                }

                using (var tmpLockObj = new LockAndElevate(this.slock)) {
                    Vsync.ViewDelta[] mergedVds = new Vsync.ViewDelta[this.viewDeltas.Length + newvdlist.Count];
                    int idx = 0;
                    int maxvid = -1;
                    foreach (Vsync.ViewDelta vd in this.viewDeltas) {
                        mergedVds[idx++] = vd;
                        maxvid = vd.prevVid;
                    }

                    foreach (Vsync.ViewDelta vd in newvdlist) {
                        if (vd.prevVid >= this.stableVID && vd.prevVid > maxvid) {
                            mergedVds[idx++] = vd;
                        }
                    }

                    this.viewDeltas = mergedVds;
                    for (int level = 0; level < this.nlevels; level++) {
                        // Deltas will be included on the next few tokens sent
                        this.includeViewDeltas[level] = 4;
                    }

                    this.fixVDS();

                    // Now apply the vds to create the working view using a fake group 
                    if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                        Vsync.WriteLine("TOKEN: updateViewDeltas recomputed VD vector..." + this);
                    }
                }
            }

            internal void fixVDS() {
                int idx = 0;
                for (int i = 0; i < this.viewDeltas.Length; i++) {
                    if (this.viewDeltas[i] != null && this.viewDeltas[i].prevVid >= this.stableVID) {
                        this.viewDeltas[idx++] = this.viewDeltas[i];
                    }
                }

                if (idx != this.viewDeltas.Length) {
                    Vsync.ArrayResize(ref this.viewDeltas, idx);
                }
            }

            // Checks for holes in the ViewDelta list of the current token; used as a unit-check
            internal void checkVDS(string fromWhere) {
                Group g = doLookup(this.gaddr);
                if (g == null) {
                    Vsync.WriteLine("Warning: CheckVDS(" + fromWhere + ") -- group lookup returned null");
                    return;
                }

                if ((g.flags & G_ISLARGE) == 0) {
                    return;
                }

                tokenInfo theToken;
                using (var tmpLockObj = new LockAndElevate(g.TokenLock)) {
                    theToken = g.theToken;
                }

                View theView;
                using (var tmpLockObj = new LockAndElevate(g.ViewLock)) {
                    theView = g.theView;
                }

                if (theToken == null || theView == null) {
                    Vsync.WriteLine("Warning: CheckVDS(" + fromWhere + ") -- theToken null or theView null");
                    return;
                }

                if (theToken != this) {
                    Vsync.WriteLine("Warning: CheckVDS(" + fromWhere + ") -- theToken != g.theToken");
                    return;
                }

                if (theToken.viewDeltas == null || theToken.viewDeltas.Length == 0) {
                    return;
                }

                Vsync.ViewDelta vd = theToken.viewDeltas[0];
                if (vd.prevVid > theView.viewid) {
                    throw new VsyncException("in checkVDS(" + fromWhere + ") vd[0].previd=" + vd.prevVid + " but theView=" + theView);
                }

                View wv = theToken.WorkingView;
                if (vd.prevVid > wv.viewid) {
                    throw new VsyncException("in checkVDS(" + fromWhere + ") vd[0].previd=" + vd.prevVid + " but WorkingView=" + wv);
                }
            }

            /// <summary>
            /// Constructor for tokens received via Vsync Msg layer
            /// </summary>
            /// <param name="ba">byte vector encoding a token</param>
            public tokenInfo(byte[] ba) {
                int idx = 0;
                object[] obs = Msg.BArrayToObjects(ba, typeof(Address), typeof(Address), typeof(Address), typeof(int), typeof(int), typeof(int), typeof(int), typeof(int), typeof(long), typeof(int), typeof(int), typeof(int), typeof(int), typeof(Vsync.ViewDelta[]), typeof(byte[][]));
                this.gaddr = (Address)obs[idx++];
                this.theGroup = Group.doLookup(this.gaddr);
                this.groupOwner = (Address)obs[idx++];
                this.sender = (Address)obs[idx++];
                this.logicalClock = (int)obs[idx++];
                this.state = (int)obs[idx++];
                this.viewid = (int)obs[idx++];
                this.stableAtSender = (int)obs[idx++];
                this.alsoSeenBase = (int)obs[idx++];
                this.alsoSeen = (long)obs[idx++];
                this.aggStable = (int)obs[idx++];
                this.tokenLevel = (int)obs[idx++];
                this.stableTo = (int)obs[idx++];
                this.stableVID = (int)obs[idx++];
                this.viewDeltas = (Vsync.ViewDelta[])obs[idx++];
                this.incomingValuesArray = (byte[][])obs[idx];
                if (this.theGroup != null && this.theGroup.myAes != null) {
                    using (var tmpLockObj = new LockAndElevate(this.theGroup.myAesLock)) {
                        if ((VsyncSystem.Debug & VsyncSystem.CIPHER) != 0) {
                            foreach (byte[] bbv in this.incomingValuesArray) {
                                dumpBv(Environment.NewLine + "*************" + Environment.NewLine + "Recived, decipher from " + this.sender, bbv);
                            }
                        }

                        for (int i = 0; i < this.incomingValuesArray.Length; i++) {
                            this.incomingValuesArray[i] = this.theGroup.decipherBuf(this.incomingValuesArray[i]);
                        }

                        if ((VsyncSystem.Debug & VsyncSystem.CIPHER) != 0) {
                            foreach (byte[] bbv in this.incomingValuesArray) {
                                dumpBv("After decipher from " + this.sender, bbv);
                            }
                        }
                    }
                }
            }

            internal static void dumpBv(string where, byte[] bv) {
                string s = " { ";
                foreach (byte b in bv) {
                    s += b.ToString("X2") + " ";
                }

                s += "} ";
                Vsync.WriteLine(where + s);
            }

            /// <summary>
            /// Marshall token to out form
            /// </summary>
            /// <returns>byte array encoding the token</returns>
            public byte[] toBArray() {
                byte[][] aggBv = this.aggsToBArray(this.tokenLevel, this.IAmRank0[this.tokenLevel]);

                if (this.theGroup != null && this.theGroup.myAes != null) {
                    using (var tmpLockObj = new LockAndElevate(this.theGroup.myAesLock)) {
                        if ((VsyncSystem.Debug & VsyncSystem.CIPHER) != 0) {
                            foreach (byte[] bbv in aggBv) {
                                dumpBv(Environment.NewLine + "============" + Environment.NewLine + "Before encipher toBArray in " + Vsync.my_address, bbv);
                            }
                        }

                        for (int i = 0; i < aggBv.Length; i++) {
                            aggBv[i] = this.theGroup.cipherBuf(aggBv[i]);
                        }

                        if ((VsyncSystem.Debug & VsyncSystem.CIPHER) != 0) {
                            foreach (byte[] bbv in aggBv) {
                                dumpBv("After encipher   in " + Vsync.my_address, bbv);
                            }
                        }
                    }
                }

                Vsync.ViewDelta[] vds = this.includeViewDeltas[this.tokenLevel]-- > 0 ? this.viewDeltas : new Vsync.ViewDelta[0];
                byte[] bv = Msg.toBArray(this.gaddr, this.groupOwner, this.sender, this.logicalClock, this.state, this.viewid, this.stableAtSender, this.alsoSeenBase, this.alsoSeen, this.aggStable, this.tokenLevel, this.stableTo, this.stableVID, vds, aggBv);
                return bv;
            }

            internal byte[][] aggsToBArray(int level, bool fromRank0Member) {
                List<byte[]> bas = new List<byte[]>();
                using (var tmpLockObj = new LockAndElevate(this.theGroup.AggListLock)) {
                    if (this.theGroup.AggList[level] != null) {
                        foreach (IAggregateEventHandler ae in this.theGroup.AggList[level]) {
                            bas.Add(ae.AggEvent(fromRank0Member ? GetRank0State : GetAggState));
                        }
                    }
                }

                return bas.ToArray();
            }

            /// <exclude>
            /// <summary>
            /// Internal: Pretty-print an Vsync token.  Must be public to satisfy C# scoping rules.
            /// </summary>
            /// <returns>string for the token</returns>
            /// </exclude>
            public override string ToString() {
                Group g = Group.doLookup(this.gaddr);
                string flushing = (this.state == INQUIRY) ? "FLUSH:INQUIRY " : ((this.state == SETSTABLETO) ? "FLUSH:SETSTABLETO " : string.Empty);
                string s = flushing + "TOKEN[level=" + this.tokenLevel + ":" + this.logicalClock + " from " + this.sender + "]: ViewID " + this.viewid + " of group <" + ((g == null) ? this.gaddr.ToString() : g.gname) + ">, groupOwner " + this.groupOwner;
                if (this.viewDeltas.Length == 0) {
                    s += "(No View Delta vector)";
                }

                if (this.WorkingView != null) {
                    s += Environment.NewLine + "         WorkingView = " + this.WorkingView.ViewSummary();
                }

                string sbl = " ";
                for (int level = 0; level < this.nlevels; level++) {
                    sbl += "[" + level + "]=" + this.StableByLevel[level] + " ";
                }

                s += Environment.NewLine + "         StableTo=" + this.stableTo + ", aggStable=" + this.aggStable + ", StableVID=" + this.stableVID + ", stableAtSender=" + this.stableAtSender + ", alsoSeenBase = " + this.alsoSeenBase + ", alsoSeen=" + this.alsoSeen.ToString("X") + ", StableByLevel = {" + sbl + "}";
                s += AggState(this);
                if (this.viewDeltas.Length > 0) {
                    if (this.includeViewDeltas != null) {
                        s += Environment.NewLine + "         ...  includeViewDeltas[";
                        for (int b = this.nlevels; b > 0; b--) {
                            s += " " + (this.includeViewDeltas[b - 1] > 0);
                        }

                        s += " ]";
                    }

                    s += Environment.NewLine + "         ...  vector of view deltas:";
                    foreach (Vsync.ViewDelta vd in this.viewDeltas) {
                        s += Environment.NewLine + "         " + vd;
                    }
                }

                for (int i = 0; i < this.nlevels; i++) {
                    s += Environment.NewLine + "         level[" + i + "] info: mySubgroupIdx=" + this.mySubgroupIdx[i] + ", myOffset=" + this.myOffset[i] + ", StableByLevel=" + this.StableByLevel[i] + (Environment.NewLine + "              gossips to " + (this.next[i] == null ? "(null)" : (this.next[i].isMyAddress() ? "self" : this.next[i].ToString()))) + (", receives gossip from " + (this.last[i] == null ? "(null)" : (this.last[i].isMyAddress() ? "self" : this.last[i].ToString()))) + (", last received token was from " + (this.lastToken[i] == null ? "(none)" : (this.lastToken[i].sender + " and arrived at time " + Vsync.MsToSecs(this.lastToken[i].whenReceived)))) + (this.tokenInMotion[i] > 0 ? (" (" + this.tokenInMotion[i] + " outgoing tokens are in motion)") : string.Empty);
                }

                return s;
            }
        }

        internal static string AggState(tokenInfo ti) {
            string s = string.Empty;
            for (int l = 0; l < ti.nlevels; l++) {
                foreach (IAggregateEventHandler ae in ti.theGroup.AggList[l]) {
                    string astate = ae.AggState();
                    if (astate.Length > 0) {
                        s += "            Aggregation state for " + ae.AggName() + " level " + l + Environment.NewLine + astate;
                    }
                }
            }

            if (s.Length > 0) {
                return Environment.NewLine + "         AGGREGATION DATA FOR THIS TOKEN:" + Environment.NewLine + s;
            }

            return s;
        }

        internal void becomeGroupOwner() {
            using (var tmpLockObj = new LockAndElevate(this.TokenLock)) {
                if (this.theToken.IAmLgOwner) {
                    return;
                }
            }

            if (this.myFirstLeadershipView == 0) {
                throw new VsyncException("becomeGroupOwner yet myFirstLeadershipView was unknown!");
            }

            if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENFLUSH)) != 0) {
                Vsync.WriteLine("Becoming the LargeGroupOwner... for <" + this.gname + "> as of viewid " + this.myFirstLeadershipView);
            }

            this.LgFlush(true);

            if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENFLUSH)) != 0) {
                Vsync.WriteLine("I am now the LargGroupOwner for <" + this.gname + ">!");
            }
        }

        internal void CheckForFutureViews(Msg m) {
            // This peek-ahead code existed way back in Vsync too.  Is it actually a necessary feature of
            // an outboard virtual synchrony implementation?  Check to see if this is a large-group relayed NEWVIEW
            // message.  In that specific case, note the viewid on the message.  It may not be delivered promptly.
            // because other prior view messages may be in the queue, but if so those will do LgFlush calls that can't
            // complete (can't stabilize) because they are trying to flush a view that is already stale....
            object[] obs = Msg.MsgToObjects(m);
            if (obs.Length == 2 && obs[0] is int && ((int)obs[0]) == Vsync.RELAYSEND) {
                if ((VsyncSystem.Debug & VsyncSystem.FLUSHING) != 0) {
                    if (obs[1].GetType() == typeof(Vsync.ViewDelta[])) {
                        Vsync.WriteLine("CheckForFutureViews: " + Vsync.rToString((int)obs[0]) + ", msg " + m.vid + ":" + m.msgid + " from " + m.sender + "... Found a vd vector, len " + ((Vsync.ViewDelta[])obs[1]).Length + "... Starts with previd=" + ((Vsync.ViewDelta[])obs[1])[0].prevVid);
                    }
                }

                if (obs[1].GetType() == typeof(Vsync.ViewDelta[])) {
                    this.gotNewViewDeltas((Vsync.ViewDelta[])obs[1]);
                }
            }
        }

        // Core of virtual synchrony algorithm for large groups is embodied into this flush protocol
        // The logic is (WAY) more tricky than it probably looks, because different processes in the group
        // can be at different stages in learning about the most current view.  We can only stabilize the
        // the group if they all have the same view for long enough to circulate a token.
        // This algorithm is actually a variant
        // on the <>W result of Chandra and Toueg, believe it or not... one of those theory results you never
        // thought you would encounter in practice, yet here it is.  The complexity here arises because if a
        // newer view becomes known to the system, the PeekAhead logic (above, in CheckForFutureViews)
        // aborts the current flush and rushes us to try and flush in the most current view possible
        // Thus we can easily end up with multiple pending views and multicasts before we finally manage to
        // hold still long enough to flush on the view with the largest viewid in the sequence.
        // In practice this could be done only for views that report departures or failures and perhaps doing
        // so would be wise, but right now it kicks in on any view, no matter what it reports
        // Needless to say, thrashing can delay the flush and effectively leave a large group hung until
        // it crashes in some dreadful way.  So thrashing would be a DDOS attack on Vsync.
        internal void LgFlush(bool becomeOwner) {
            tokenInfo theToken;
            using (var tmpLockObj = new LockAndElevate(this.TokenLock)) {
                theToken = this.theToken;
            }

            using (new ILock(ILock.LLLARGE, this.gaddr)) {
                if (theToken.WorkingView.nLive() > 1) {
                    if (this.theView.GetMyRank() == -1 || (!becomeOwner && !theToken.IAmLgOwner)) {
                        throw new VsyncException("LgFlush but I'm either not in the large group, or I lack ownership rights!");
                    }

                    if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENFLUSH)) != 0) {
                        Vsync.WriteLine("BEFORE LgFlush **************************************************" + VsyncSystem.GetState());
                    }

                    using (var tmpLockObj = new LockAndElevate(theToken.FlushingBarrierLock)) {
                        theToken.FlushingBarrier = ILock.IlockRef(ILock.LLLARGEBW, this.gaddr);
                    }

                    using (var tmpLockObj = new LockAndElevate(this.TokenLock)) {
                        // Set up for initial flush
                        theToken.logicalClock++;
                        theToken.IAmLgOwner = true;
                        theToken.groupOwner = Vsync.my_address;
                        theToken.stableTo = -1;
                    }

                    if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENFLUSH)) != 0) {
                        Vsync.WriteLine("In LgFlush before barrier wait... setting theToken.stableTo = -1");
                    }

                    // Wait for it to finish
                    if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENFLUSH)) != 0) {
                        Vsync.WriteLine("LgFlush: Before Flush[INQUIRY]!");
                    }

                    bool doAgain;
                    int limit = theToken.WorkingView.members.Length;
                    do {
                        try {
                            doAgain = false;
                            theToken.state = tokenInfo.INQUIRY;
                            if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENFLUSH)) != 0) {
                                Vsync.WriteLine("Setting Aggregator Value(INQUIRY in vid=" + this.myFirstLeadershipView + "): " + theToken.groupOwner + ":" + tokenInfo.INQUIRY + " to true ");
                            }

                            this.SetAggregatorValueAndVID(this.myFirstLeadershipView, new FlushAggKey(theToken.groupOwner, tokenInfo.INQUIRY), true);
                            if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENFLUSH)) != 0) {
                                Vsync.WriteLine("Calling GetAggResult for FLUSHAgg(INQUIRY in vid=" + this.myFirstLeadershipView + ") myAddress " + Vsync.my_address);
                            }

                            this.GetAggregatorResult<FlushAggKey, bool>(new FlushAggKey(Vsync.my_address, tokenInfo.INQUIRY));
                        }
                        catch (AggregationFailedException) {
                            if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENFLUSH)) != 0) {
                                Vsync.WriteLine("LgFlush: Restarting Flush[INQUIRY]!");
                            }

                            if (--limit <= 0) {
                                throw new VsyncException("Infinite loop in LgFlush");
                            }

                            doAgain = true;
                        }
                    }
                    while (doAgain);
                    if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENFLUSH)) != 0) {
                        Vsync.WriteLine("LgFlush: After Flush[INQUIRY]!");
                    }

                    using (var tmpLockObj = new LockAndElevate(this.TokenLock)) {
                        theToken.stableTo = theToken.StableByLevel[theToken.nlevels - 1];
                    }

                    ReliableSender.gotLgAck(this, theToken.stableTo);
                    theToken.resetStableByLevel(this);

                    if (this.nextMsgid > this.theView.NextIncomingMsgID[1]) {
                        throw new VsyncException("In LgFlush[1] had nextMsgid=" + this.nextMsgid + ", but after protocol setting it DOWN to " + this.theView.NextIncomingMsgID[1] + " in state " + VsyncSystem.GetState());
                    }

                    using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                        this.nextMsgid = this.theView.NextIncomingMsgID[1];
                    }

                    if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENFLUSH)) != 0) {
                        Vsync.WriteLine("In LgFlush after barrier wait... setting theToken.stableTo = " + theToken.stableTo);
                    }

                    // Wait for them to all learn the value of stableTo
                    using (var tmpLockObj = new LockAndElevate(this.TokenLock)) {
                        theToken.logicalClock++;
                    }

                    if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENFLUSH)) != 0) {
                        Vsync.WriteLine("LgFlush: Before Flush[SETSTABLETO]!");
                    }

                    do {
                        try {
                            doAgain = false;
                            using (var tmpLockObj = new LockAndElevate(this.TokenLock)) {
                                theToken.state = tokenInfo.SETSTABLETO;
                            }

                            if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENFLUSH)) != 0) {
                                Vsync.WriteLine("Setting Aggregator Value(STABLETO in vid=" + this.myFirstLeadershipView + "): " + theToken.groupOwner + ":" + tokenInfo.SETSTABLETO + " to true ");
                            }

                            this.SetAggregatorValueAndVID(this.myFirstLeadershipView, new FlushAggKey(theToken.groupOwner, tokenInfo.SETSTABLETO), true);
                            if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENFLUSH)) != 0) {
                                Vsync.WriteLine("Calling GetAggResult for FLUSHAgg(SETSTABLETO in vid=" + this.myFirstLeadershipView + ") myAddress " + Vsync.my_address);
                            }

                            this.GetAggregatorResult<FlushAggKey, bool>(new FlushAggKey(Vsync.my_address, tokenInfo.SETSTABLETO));
                        }
                        catch (AggregationFailedException) {
                            if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENFLUSH)) != 0) {
                                Vsync.WriteLine("LgFlush: Restarting Flush[SETSTABLETO]!");
                            }

                            doAgain = true;
                        }
                    }
                    while (doAgain);
                    if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENFLUSH)) != 0) {
                        Vsync.WriteLine("LgFlush: After Flush[SETSTABLETO]!");
                    }

                    using (var tmpLockObj = new LockAndElevate(theToken.FlushingBarrierLock)) {
                        theToken.FlushingBarrier.BarrierReleaseAll();
                        theToken.FlushingBarrier = null;
                    }

                    if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENFLUSH)) != 0) {
                        Vsync.WriteLine("AFTER LgFlush **************************************************" + VsyncSystem.GetState());
                    }

                    using (var tmpLockObj = new LockAndElevate(this.TokenLock)) {
                        theToken.logicalClock++;
                        theToken.state = tokenInfo.NORMAL;
                    }
                }
                else {
                    if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENFLUSH)) != 0) {
                        Vsync.WriteLine("SKIPPING LgFlush protocol (group only has one member)");
                    }

                    theToken.IAmLgOwner = true;
                    theToken.groupOwner = Vsync.my_address;
                    if (this.nextMsgid > this.theView.NextIncomingMsgID[1]) {
                        throw new VsyncException("In LgFlush[2] had nextMsgid=" + this.nextMsgid + ", but skipping protocol and setting it DOWN to " + this.theView.NextIncomingMsgID[1] + " in state " + VsyncSystem.GetState());
                    }

                    using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                        this.nextMsgid = this.theView.NextIncomingMsgID[1];
                        theToken.stableTo = this.nextMsgid - 1;
                    }

                    ReliableSender.gotLgAck(this, theToken.stableTo);
                }
            }

            if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENFLUSH)) != 0) {
                Vsync.WriteLine("After LgFlush nextMsgId=" + theToken.viewid + ":" + this.nextMsgid);
            }
        }

        // Called each time the large group has a view change.  This causes the group to reapply any future view deltas it knows about
        internal void resetAggregates() {
            tokenInfo theToken;
            using (var tmpLockObj = new LockAndElevate(this.TokenLock)) {
                theToken = this.theToken;
            }

            if (theToken.WorkingView != null && theToken.WorkingView.viewid > this.theView.viewid) {
                throw new VsyncException("resetAggregates");
            }

            theToken.WorkingView = this.theView;
            theToken.WorkingViewInstalledAt = Vsync.NOW;
            theToken.applyViewDeltas(this, new Vsync.ViewDelta[0]);
            this.updateSeenInfo();
        }

        internal void updateSeenInfo() {
            tokenInfo theToken;
            View theView;
            using (var tmpLockObj = new LockAndElevate(this.TokenLock))
            using (var tmpLockObj1 = new LockAndElevate(this.ViewLock)) {
                theToken = this.theToken;
                theView = this.theView;
            }

            long alsoSeen = 0;
            int myStable;
            int alsoSeenBase;
            if (theToken.IAmLgOwner) {
                alsoSeenBase = myStable = theView.NextIncomingMsgID[1] - 1;
            }
            else {
                using (var tmpLockObj = new LockAndElevate(ReliableSender.PendingSendBufferLock)) {
                    myStable = theView.NextIncomingMsgID[1] - 1;
                    alsoSeenBase = theToken.stableTo;
                    foreach (ReliableSender.MsgDesc lgmd in ReliableSender.LgPendingSendBuffer) {
                        if (lgmd.group == this && lgmd.MsgId > alsoSeenBase && (lgmd.MsgId - alsoSeenBase - 1) < 64) {
                            alsoSeen |= 1L << (lgmd.MsgId - alsoSeenBase - 1);
                        }
                    }
                }
            }

            if (theToken.stableAtSender != myStable || theToken.alsoSeenBase != alsoSeenBase || theToken.alsoSeen != alsoSeen) {
                theToken.stableAtSender = myStable;
                theToken.alsoSeenBase = alsoSeenBase;
                theToken.alsoSeen = alsoSeen;
                if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                    string s = string.Empty;
                    foreach (Msg m in this.Unstable) {
                        s += " " + m.vid + ":" + m.msgid;
                    }

                    Vsync.WriteLine("updateSeenInfo: maxStable: " + myStable + ", unstable msgs: {" + s + " }, setting alsoSeenBase = " + alsoSeenBase + ", alsoSeen=" + alsoSeen.ToString("X"));
                }
            }
        }

        internal bool watchingForStableTo = false;

        // In this method, be careful not to touch fields of the incoming token, "toke", that aren't in the
        // transmitted field group.  Those won't be initialized and hence have default values.
        internal void processIncoming(Address who, tokenInfo toke) {
            List<ReliableSender.MsgDesc> toForwardFromPSB = new List<ReliableSender.MsgDesc>();
            using (var tmpLockObj = new LockAndElevate(ReliableSender.PendingSendBufferLock)) {
                foreach (ReliableSender.MsgDesc lgmd in ReliableSender.LgPendingSendBuffer) {
                    if (lgmd.group == this) {
                        toForwardFromPSB.Add(lgmd);
                    }
                }
            }

            ForwardMsg(toke, toForwardFromPSB);
            this.interesting = true;
            try {
                if (toke.viewDeltas != null && toke.viewDeltas.Length != 0) {
                    this.gotNewViewDeltas(toke.viewDeltas);
                }

                using (var tmpLockObj = new LockAndElevate(this.TokenLock)) {
                    bool valid = true;
                    string because = string.Empty;
                    View theView;
                    using (var tmpLockObj1 = new LockAndElevate(this.ViewLock)) {
                        theView = this.theView;
                    }

                    if (theView.viewid > toke.viewid) {
                        if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                            because = "processIncoming: INVALID Token was for view " + toke.viewid + " of group " + this.gname + " but I'm on view " + theView.viewid;
                            Vsync.WriteLine(because);
                        }

                        valid = false;
                    }

                    bool switchOwner = false;
                    if (toke.groupOwner != this.theToken.groupOwner) {
                        if (theView.GetRawRankOf(this.theToken.groupOwner) >= theView.GetRawRankOf(toke.groupOwner)) {
                            if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                                because = "processIncoming: INVALID Token for " + toke.gaddr + " shows owner " + toke.groupOwner + ", but I think " + this.theToken.groupOwner + " should be the owner!";
                                Vsync.WriteLine(because);
                            }

                            valid = false;
                        }
                        else {
                            switchOwner = true;
                        }
                    }

                    if (toke.logicalClock < this.theToken.logicalClock && theView.GetRawRankOf(this.theToken.groupOwner) >= theView.GetRawRankOf(toke.groupOwner)) {
                        if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                            because = "processIncoming: INVALID Token for " + toke.gaddr + " had logical clock " + toke.logicalClock + ", but I think the logical clock should read " + this.theToken.logicalClock + "!";
                            Vsync.WriteLine(because);
                        }

                        valid = false;
                    }

                    if (toke.tokenLevel > this.theToken.last.Length || this.theToken.last[toke.tokenLevel] == null || toke.sender != this.theToken.last[toke.tokenLevel]) {
                        if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                            because = "processIncoming: INVALID Token for " + toke.gaddr + " had level " + toke.tokenLevel + ", but I didn't expect to receive a token from this source at that level!  For me last[level]=" + (this.theToken.last[toke.tokenLevel] == null ? "null" : this.theToken.last[toke.tokenLevel].ToString());
                            Vsync.WriteLine(because);
                        }

                        valid = false;
                    }
                    else {
                        this.theToken.lastValidated[toke.tokenLevel] = true;
                    }

                    if (valid) {
                        if (this.gcollectedTo > theView.NextIncomingMsgID[1]) {
                            throw new VsyncException("<" + this.gname + "> has already garbage collected to " + this.gcollectedTo + ", but I'm waiting for " + theView.NextIncomingMsgID[1] + ", with stableAtSender=" + this.theToken.stableAtSender + VsyncSystem.GetState());
                        }

                        if (toke.gaddr == Vsync.VSYNCMEMBERS.gaddr && Vsync.ClientOf != null && Vsync.ClientOf != toke.groupOwner) {
                            this.becomeClientOf(toke.groupOwner);
                            if (Vsync.ClientOf == toke.groupOwner) {
                                this.theToken.groupOwner = toke.groupOwner;
                            }

                            this.watchingForStableTo = true;
                        }

                        if (switchOwner) {
                            this.switchToNewOwner(toke);
                        }

                        if (toke.logicalClock > this.theToken.logicalClock) {
                            this.theToken.logicalClock = toke.logicalClock;
                            this.theToken.resetStableByLevel(this);
                            this.theToken.state = toke.state;
                            int vid = this.theToken.IAmLgOwner ? this.theToken.theGroup.myFirstLeadershipView : this.theToken.WorkingView.viewid;
                            switch (this.theToken.state) {
                                case tokenInfo.NORMAL:
                                    break;
                                case tokenInfo.INQUIRY:
                                    if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                                        Vsync.WriteLine("Setting Aggregator Value(INQUIRY in vid=" + vid + "): " + this.theToken.groupOwner + ":" + tokenInfo.INQUIRY + " to true ");
                                    }

                                    this.SetAggregatorValueAndVID(vid, new FlushAggKey(this.theToken.groupOwner, tokenInfo.INQUIRY), true);
                                    break;
                                case tokenInfo.SETSTABLETO:
                                    if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                                        Vsync.WriteLine("Setting Aggregator Value(STABLETO in vid=" + vid + "): " + this.theToken.groupOwner + ":" + tokenInfo.SETSTABLETO + " to true ");
                                    }

                                    this.SetAggregatorValueAndVID(vid, new FlushAggKey(this.theToken.groupOwner, tokenInfo.SETSTABLETO), true);
                                    break;
                            }
                        }

                        byte[][] bvs = toke.incomingValuesArray;
                        if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                            Vsync.WriteLine("Aggregation logic: received bvs[" + bvs.Length + "][], list of IAggregateEventHandlers: ");
                            for (int i = 0; i < bvs.Length; i++) {
                                Vsync.WriteLine("    bvs[" + i + "]: byte vector of length " + bvs[i].Length);
                            }

                            foreach (IAggregateEventHandler ae in this.theToken.theGroup.AggList[toke.tokenLevel]) {
                                Vsync.WriteLine("    ae=" + ae.GetType().ToString());
                            }
                        }

                        if (this.theToken.myOffset[toke.tokenLevel] == 0) {
                            // 0'th ranked guy gets incoming token: treat this as a message up from toke.tokenLevel to next higher level
                            if (toke.tokenLevel < this.theToken.nlevels - 1) {
                                // Inner level of the tree
                                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                                    Vsync.WriteLine("Aggregation logic: Inner level of the tree and I am at rank0 for next level (calling GotDValue)");
                                }

                                int idx = 0;
                                foreach (IAggregateEventHandler ae in this.theToken.theGroup.AggList[toke.tokenLevel + 1]) {
                                    object[] KeysNValues = Msg.BArrayToObjects(bvs[idx++]);
                                    int len = (int)KeysNValues[Group.LEN];
                                    int[] vids = (int[])KeysNValues[Group.VIDS];
                                    for (int n = 0; n < len; n++) {
                                        ae.AggEvent(Group.GotDValue, vids[n], KeysNValues[Group.KEYS], KeysNValues[Group.VALS], n);
                                    }
                                }
                            }
                            else {
                                // Root level: Computed the aggregated answer
                                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                                    Vsync.WriteLine("Aggregation logic: Root level of the tree and I am at rank0 (calling GotAggRes)");
                                }

                                int idx = 0;
                                foreach (IAggregateEventHandler ae in this.theToken.theGroup.AggList[toke.tokenLevel]) {
                                    object[] KeysNValues = Msg.BArrayToObjects(bvs[idx++]);
                                    int len = (int)KeysNValues[Group.LEN];
                                    int[] vids = (int[])KeysNValues[Group.VIDS];
                                    for (int n = 0; n < len; n++) {
                                        ae.AggEvent(Group.GotAggRes, vids[n], KeysNValues[Group.KEYS], KeysNValues[Group.VALS], n);
                                    }
                                }
                            }
                        }
                        else {
                            // i'th ranked guy gets incoming token from i-1'th ranked guy
                            if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                                Vsync.WriteLine("Aggregation logic: Received from left, will pass to my right (calling GotRValue)");
                            }

                            int idx = 0;
                            foreach (IAggregateEventHandler ae in this.theToken.theGroup.AggList[toke.tokenLevel]) {
                                object[] KeysNValues = Msg.BArrayToObjects(bvs[idx++]);
                                int len = (int)KeysNValues[Group.LEN];
                                int[] vids = (int[])KeysNValues[Group.VIDS];
                                for (int n = 0; n < len; n++) {
                                    ae.AggEvent(Group.GotRValue, vids[n], KeysNValues[Group.KEYS], KeysNValues[Group.VALS], n);
                                }
                            }
                        }

                        this.theToken.lastToken[toke.tokenLevel] = toke;
                        if (this.theToken.inhibitResenderLoop) {
                            bool GotAll = true;
                            for (int i = 0; i < this.theToken.nlevels; i++) {
                                if (this.theToken.last[i] != null && !this.theToken.last[i].isMyAddress() && (this.theToken.lastToken[i] == null || this.theToken.lastToken[i].logicalClock != this.theToken.logicalClock)) {
                                    GotAll = false;
                                }
                            }

                            if (GotAll && this.theToken.gotAllAt == 0) {
                                this.theToken.gotAllAt = Vsync.NOW;
                            }

                            if (this.theToken.gotAllAt > 0 && (Vsync.NOW - this.theToken.gotAllAt > Vsync.VSYNC_DEFAULTTIMEOUT * 2)) {
                                this.theToken.inhibitResenderLoop = false;
                            }
                        }

                        using (var tmpLockObj1 = new LockAndElevate(this.theToken.slock)) {
                            this.theToken.stableTo = Math.Max(toke.stableTo, this.theToken.stableTo);
                            this.theToken.stableVID = Math.Max(toke.stableVID, this.theToken.stableVID);
                            if (this.theToken.stableTo > this.theToken.unstableVIDMID && this.theToken.unstableVIDMID > 0) {
                                this.theToken.stableVID = this.theToken.unstableVID;
                                if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENFLUSH)) != 0) {
                                    Vsync.WriteLine("New value of theToken.stableVID: " + this.theToken.stableVID);
                                }

                                this.theToken.unstableVIDMID = 0;
                            }

                            if (this.theToken.viewDeltas != null) {
                                this.theToken.fixVDS();
                            }
                        }
                    }

                    using (var tmpLockObj1 = new LockAndElevate(this.UnstableLock)) {
                        if (valid && this.watchingForStableTo && toke.stableTo != -1) {
                            // new group owner is active now and has announced the stableTo value that ends the multicasts from the prior sender
                            // Delete any messages that have larger msgid's and came from the old sender: there must have been a gap in the
                            // sequence and they are orphans (dangerous ones because, if delivered, they would cause confusion!)
                            this.gcollectedTo = toke.stableTo;
                            List<Msg> newUnstable = new List<Msg>();
                            foreach (Msg m in this.Unstable) {
                                if (m.msgid > toke.stableTo && m.sender == toke.groupOwner) {
                                    newUnstable.Add(m);
                                }
                            }

                            this.Unstable = newUnstable;
                            this.UnstableCount = this.Unstable.Count;
                        }
                    }

                    if (valid) {
                        this.updateSeenInfo();

                        // This is used in the token thread, but only by the "point guy" for each ring
                        bool hasBelow = true;
                        for (int level = 0; level < toke.tokenLevel; level++) {
                            if (this.theToken.StableByLevel[level] == -1) {
                                hasBelow = false;
                                break;
                            }
                        }

                        if (hasBelow) {
                            int min = toke.aggStable;
                            if (toke.tokenLevel > 0) {
                                min = Math.Min(min, this.theToken.StableByLevel[toke.tokenLevel - 1]);
                            }

                            if ((VsyncSystem.Debug & VsyncSystem.TOKENSTABILITY) != 0) {
                                Vsync.WriteLine("<" + this.gname + ">: LogicalClock=" + toke.logicalClock + ": Decided to set theToken.StableByLevel[" + toke.tokenLevel + "]=" + min + "(token is from " + toke.sender + ", has logical clock=" + toke.logicalClock + ", has level=" + toke.tokenLevel + ", has aggstable=" + toke.aggStable + ")");
                            }

                            this.theToken.StableByLevel[toke.tokenLevel] = min;
                        }

                        if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                            Vsync.WriteLine("After processIncoming incoming token: my " + this.theToken);
                        }
                    }
                }
            }
            catch (Exception e) {
                Vsync.WriteLine("processIncoming threw an exception! " + e);
            }
        }

        internal void gotNewViewDeltas(Vsync.ViewDelta[] vds) {
            tokenInfo theToken;
            View theView;
            using (var tmpLockObj = new LockAndElevate(this.TokenLock))
            using (var tmpLockObj1 = new LockAndElevate(this.ViewLock)) {
                theToken = this.theToken;
                theView = this.theView;
            }

            vds = vds.Select(vd => vd).Where(vd => vd.gaddr == this.gaddr && vd.prevVid >= (theView == null ? -1 : theView.viewid)).ToArray();
            if (vds.Length == 0) {
                return;
            }

            Group tg = doLookup(this.gaddr);
            if (tg != this) {
                // Use the true group, not the proxy...
                if (tg != null) {
                    tg.gotNewViewDeltas(vds);
                }

                return;
            }

            if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                Vsync.WriteLine("Token layer got new view deltas:");
                foreach (Vsync.ViewDelta vd in vds) {
                    Vsync.WriteLine("  " + vd);
                }
            }

            if (theToken != null) {
                int vid = theView.viewid;
                foreach (Vsync.ViewDelta vd in theToken.viewDeltas) {
                    if (vd.prevVid == vid) {
                        ++vid;
                    }
                }

                foreach (Vsync.ViewDelta vd in vds) {
                    if (vd.prevVid == vid) {
                        ++vid;
                    }
                    else if (vd.prevVid > vid) {
                        return;
                    }
                }

                theToken.applyViewDeltas(this, vds);
            }
        }

        internal void switchToNewOwner(tokenInfo toke) {
            tokenInfo theToken;
            using (var tmpLockObj = new LockAndElevate(this.TokenLock)) {
                theToken = this.theToken;
            }

            int oldOwnerRank = theToken.WorkingView.GetRankOf(theToken.groupOwner);
            int newOwnerRank = theToken.WorkingView.GetRankOf(toke.groupOwner);
            int r;
            if (oldOwnerRank >= newOwnerRank) {
                return;
            }

            for (r = 0; r < theToken.WorkingView.members.Length; r++) {
                if (!this.theView.hasFailed[r]) {
                    break;
                }
            }

            if (r != newOwnerRank) {
                if ((VsyncSystem.Debug & VsyncSystem.FAILURES) != 0) {
                    Vsync.WriteLine("WARNING: switch to New Owner but he doesn't seem to be the owner!  I compute rank " + r + ", he asserts rank " + newOwnerRank + "  (calling note-failed on lower-ranked procs)");
                }

                while (r != newOwnerRank) {
                    View.noteFailed(this, theToken.WorkingView.members[r++]);
                }
            }

            theToken.groupOwner = toke.groupOwner;
            ReliableSender.resetTheToken(this);
        }

        internal static LockObject flock = new LockObject("token.flock");

        private static void ForwardMsg(tokenInfo toke, List<ReliableSender.MsgDesc> mds) {
            if (mds.Count == 0) {
                return;
            }

            int cnt = 0;
            using (var tmpLockObj = new LockAndElevate(flock)) {
                foreach (ReliableSender.MsgDesc md in mds) {
                    if (ForwardFromPSB(toke, md)) {
                        ++cnt;
                    }
                }
            }

            using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                VsyncSystem.RTS.TTRet += cnt;
            }
        }

        private static bool ForwardMsg(tokenInfo toke, Msg m) {
            if (m.wasForwardedTo != null && m.wasForwardedTo == toke.sender) {
                return false;
            }

            int delta = m.msgid - toke.alsoSeenBase - 1;
            if (delta >= 0 && delta < 64 && (toke.alsoSeen & (1L << delta)) == 0) {
                if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.NACKS)) != 0) {
                    Vsync.WriteLine("[" + Vsync.MsToSecs(Vsync.NOW) + "]: Token-based recovery: forwarding unstable msg " + m.vid + ":" + m.msgid + " to " + toke.sender + " because delta=" + delta + " and alsoSeenBase=" + toke.alsoSeenBase + " and  alsoseen=" + toke.alsoSeen.ToString("X"));
                }

                m.wasForwardedTo = toke.sender;
                m.gaddr = toke.gaddr;
                ReliableSender.Forward(toke.sender, toke.gaddr, ReliableSender.ResendForm(m));
                return true;
            }

            return false;
        }

        private static bool ForwardFromPSB(tokenInfo toke, ReliableSender.MsgDesc md) {
            if (Vsync.NOW < md.resendTime) {
                return false;
            }

            int delta = md.MsgId - toke.alsoSeenBase - 1;
            if (delta >= 0 && delta < 64 && (toke.alsoSeen & (1L << delta)) == 0) {
                if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.NACKS)) != 0) {
                    Vsync.WriteLine("[" + Vsync.MsToSecs(Vsync.NOW) + "]: Token-based recovery: forwarding unstable msg from lg-pendingsend-buffer " + md.MsgVid + ":" + md.MsgId + " to " + toke.sender + " because delta=" + delta + " and alsoSeenBase=" + toke.alsoSeenBase + " and  alsoseen=" + toke.alsoSeen.ToString("X") + " and was last forwarded at " + Vsync.MsToSecs(md.resendTime));
                }

                md.resendTime = Vsync.NOW + 500;
                ReliableSender.ResendP2P(toke.sender, md);
                return true;
            }

            return false;
        }

        // In a large group, on learning of an unstable message, check to see if prior ring member lacked it
        // If so, forward it.  Also, check and forward when token arrives and I have something prior guy lacked
        internal void checkLastToken(Msg m) {
            tokenInfo theToken;
            using (var tmpLockObj = new LockAndElevate(this.TokenLock)) {
                theToken = this.theToken;
            }

            List<tokenInfo> ForwardTo = new List<tokenInfo>();
            using (var tmpLockObj = new LockAndElevate(this.UnstableLock)) {
                if (theToken == null) {
                    return;
                }

                for (int level = 0; level < theToken.nlevels; level++) {
                    if (theToken.lastToken[level] != null) {
                        ForwardTo.Add(theToken.lastToken[level]);
                    }
                }
            }

            if (ForwardTo.Count > 0) {
                foreach (tokenInfo ti in ForwardTo) {
                    ForwardMsg(ti, m);
                }
            }
        }

        internal LockObject GotAMsgLock = new LockObject("GotAMsgLock", ThreadPriority.Highest);

        internal bool GotAMsg(Msg m, byte type, string where) {
            m.toDoTime = Vsync.NOW;
            bool rval;
            using (var tmpLockObj = new LockAndElevate(this.GotAMsgLock)) {
                try {
                    rval = this._GotAMsg(m, type, where);
                }
                catch (VsyncException e) {
                    if ((!this.GroupOpen && this.WasOpen) || (!VsyncSystem.VsyncActive && VsyncSystem.VsyncWasActive)) {
                        return false;
                    }

                    throw new VsyncException("Uncaught VsyncException in group <" + this.gname + ">: " + e.Message, e);
                }
            }

            if (this.ToDoCount > 1000) {
                throw new VsyncException("After GotAMsg ToDo list had > 1000 msgs on it");
            }

            return rval;
        }

        internal bool _GotAMsg(Msg m, byte type, string where) {
            List<Msg> willDeliver = new List<Msg>();

            using (var tmpLockObj = new LockAndElevate(this.PendingQueueLock))
            using (var tmpLockObj1 = new LockAndElevate(this.ViewLock)) {
                int which = -1;
                int vid = m.vid - 2;
                if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                    using (var tmpLockObj2 = new LockAndElevate(ReliableSender.ackInfoLock)) {
                        ReliableSender.ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: GotAMsg(type=" + type + "): " + m + Environment.NewLine);
                    }
                }

                if (this.theView != null) {
                    if ((this.flags & G_ISLARGE) != 0) {
                        // In a large group, there is only one legal sender
                        which = 0;
                    }
                    else if ((m.flags & Msg.SENTBYORACLE) != 0 && this != Vsync.ORACLE) {
                        which = -1;
                    }
                    else {
                        which = this.theView.GetRankOf(m.sender);
                    }

                    vid = this.theView.viewid;
                    if ((this.flags & G_ISLARGE) != 0 && m.offWire != null && !this.theView.IAmLeader() && this.theToken != null && m.msgid > this.theToken.stableTo) {
                        ReliableSender.LgAdd(this, m, type);
                    }
                }

                if ((VsyncSystem.Debug & VsyncSystem.MESSAGELAYER) != 0 || (this.flags & G_TRACE) != 0) {
                    Vsync.WriteLine("GotAMsg<" + this.gname + ">: event type=" + Msg.mtypes[type] + ", sender " + m.sender + " rank is " + which + ", m.offWire is " + (m.offWire != null ? "non" : string.Empty) + "null" + Environment.NewLine + "   " + m);
                }

                if ((!this.GroupOpen && this.WasOpen) || (this.theView != null && this.theView.members.Length == 0 && this.theView.leavers.Contains(Vsync.my_address))) {
                    return true;
                }

                m.offWire = null;
                if (this.gname.Equals("ORACLE", StringComparison.Ordinal)) {
                    if (which == -1 && !m.sender.isMyAddress()) {
                        if (this.theView != null) {
                            if ((VsyncSystem.Debug & VsyncSystem.DELIVERY) != 0) {
                                Vsync.WriteLine("<" + this.gname + ">: GotAMsg/ORACLE delivering " + m);
                            }
                            this.doDeliveryCallbacks(m, "GotAMsg - ORACLE/-1 case", type);
                            return true;
                        }

                        if (Vsync.my_address.CompareTo(m.sender) < 0 && m.vid == 0 && m.msgid == -1) {
                            if ((VsyncSystem.Debug & VsyncSystem.STARTSEQ) != 0) {
                                Vsync.WriteLine("GotAMsg in ORACLE, sending a message to inhibit creation of new ORACLEs to " + m.sender);
                            }
                            Vsync.ORACLE.doPureP2PSend(m.sender, true, Vsync.JOIN, Vsync.my_address);
                            return true;
                        }

                        if (m.vid > 0 && m.msgid >= 0) {
                            // Arises when a message to v:id arrives in a joining process before initial view for ORACLE was seen
                            using (var tmpLockObj2 = new LockAndElevate(this.ToDoLock)) {
                                this.ToDo.Add(m);
                                this.ToDoCount++;
                            }
                        }

                        return true;
                    }

                    if (m.vid == 0 && m.msgid == -1) {
                        if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.DISCARDS)) != 0) {
                            Vsync.WriteLine("WARNING: VSYNC ignoring a duplicate ORACLE.JOIN: " + m);
                        }

                        using (var tmpLockObj2 = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                            VsyncSystem.RTS.Discarded++;
                        }

                        return true;
                    }
                }

                bool needsxfer;
                using (var tmpLockObj2 = new LockAndElevate(this.GroupFlagsLock)) {
                    needsxfer = (this.flags & G_NEEDSTATEXFER) != 0 && (m.flags & Msg.SENTBYORACLE) == 0;
                }

                if (!this.HasFirstView || (needsxfer && m.vid > 0)) {
                    List<Msg> newToDo = new List<Msg>();
                    using (var tmpLockObj2 = new LockAndElevate(this.ToDoLock)) {
                        foreach (Msg lm in this.ToDo) {
                            if (m == null) {
                                newToDo.Add(lm);
                            }
                            else if (lm == m) {
                                if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.DISCARDS)) != 0) {
                                    Vsync.WriteLine("WARNING: VSYNC ignoring a duplicate multicast already on ToDo list -- case 1 (" + m.sender + " sent to " + m.vid + ":" + m.msgid + ")");
                                }

                                using (var tmpLockObj3 = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                    VsyncSystem.RTS.Discarded++;
                                }

                                return true;
                            }
                            else {
                                if (lm.vid > m.vid || lm.msgid > m.msgid) {
                                    newToDo.Add(m);
                                    m = null;
                                }

                                newToDo.Add(lm);
                            }
                        }

                        if (m != null) {
                            newToDo.Add(m);
                        }

                        this.ToDo = newToDo;
                        this.ToDoCount = this.ToDo.Count;
                    }

                    return true;
                }

                if (m.vid == 0) {
                    using (var tmpLockObj2 = new LockAndElevate(this.GroupFlagsLock)) {
                        if ((this.flags & G_NEEDSTATEXFER) != 0) {
                            this.xferWait.Release();
                        }

                        this.flags &= ~G_NEEDSTATEXFER;
                    }
                }

                if (m.vid != vid && (this.flags & G_ISLARGE) == 0 && (m.flags & Msg.SENTBYORACLE) == 0) {
                    if (m.vid < vid) {
                        if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.DISCARDS)) != 0) {
                            Vsync.WriteLine("WARNING: VSYNC ignoring a multicast to an old view (" + m.sender + " sent to " + m.vid + ":" + m.msgid + " but current viewid is " + vid + ")" + m);
                        }

                        using (var tmpLockObj2 = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                            VsyncSystem.RTS.Discarded++;
                        }

                        return true;
                    }

                    using (var tmpLockObj2 = new LockAndElevate(this.ToDoLock)) {
                        List<Msg> newToDo = new List<Msg>();
                        foreach (Msg lm in this.ToDo) {
                            if (m == null) {
                                newToDo.Add(lm);
                            }
                            else if (lm == m) {
                                if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.DISCARDS)) != 0) {
                                    Vsync.WriteLine("WARNING: VSYNC ignoring a multicast already on ToDo list -- case 2 (" + m.sender + " sent to " + m.vid + ":" + m.msgid + ")");
                                }

                                using (var tmpLockObj3 = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                    VsyncSystem.RTS.Discarded++;
                                }

                                return true;
                            }
                            else {
                                if (m != null && (lm.vid > m.vid || (lm.vid == m.vid && lm.msgid > m.msgid))) {
                                    newToDo.Add(m);
                                    m = null;
                                }

                                newToDo.Add(lm);
                            }
                        }

                        if (m != null) {
                            newToDo.Add(m);
                        }

                        this.ToDo = newToDo;
                        this.ToDoCount = this.ToDo.Count;
                    }

                    return true;
                }

                if (this.PendingQueue == null) {
                    if ((this.flags & G_ISLARGE) != 0) {
                        if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                            using (var tmpLockObj2 = new LockAndElevate(ReliableSender.ackInfoLock)) {
                                ReliableSender.ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: GotAMsg -- willDeliver(1) " + m.sender + "::" + m.vid + ":" + m.msgid + Environment.NewLine);
                            }
                        }

                        willDeliver.Add(m);
                        do_delivery(willDeliver);
                        return true;
                    }

                    throw new VsyncException("*** WARNING: In GotAMsg but PendingQueue for<" + this.gname + "> is null!");
                }

                SortedList<long, Msg> MsgQ = this.PendingQueue[1 + which];
                if (MsgQ == null) {
                    if (m.vid == vid + 1 && m.msgid == 0) {
                        willDeliver.Add(m);
                        do_delivery(willDeliver);
                        return true;
                    }

                    if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.DISCARDS)) != 0) {
                        Vsync.WriteLine("WARNING: VSYNC ignoring an unexpected multicast[PendingQueue null] (" + m.sender + "sent to " + m.vid + ":" + m.msgid + ", but NextIncomingMsgID is " + vid + ":" + this.theView.NextIncomingMsgID[1 + which] + ").... " + m);
                    }

                    using (var tmpLockObj2 = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                        VsyncSystem.RTS.Discarded++;
                    }

                    return m.vid < vid;
                }

                bool foundKey = false;
                foreach (KeyValuePair<long, Msg> kvp in MsgQ) {
                    if (kvp.Key == m.key(this.flags)) {
                        Msg lm = kvp.Value;
                        if (lm.vid != m.vid) {
                            throw new VsyncException("PendingQueue[" + which + "] contained an entry for " + lm + " that confused me (wrong vid) when trying to insert " + m);
                        }

                        foundKey = true;
                        break;
                    }
                }

                if (!foundKey) {
                    MsgQ.Add(m.key(this.flags), m);
                    ++this.PendingQueueCount;
                    if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                        using (var tmpLockObj2 = new LockAndElevate(ReliableSender.ackInfoLock)) {
                            ReliableSender.ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: GotAMsg added to MsgQ[" + (1 + which) + "], new count=" + MsgQ.Count + Environment.NewLine);
                        }
                    }
                }
                else {
                    if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.DISCARDS)) != 0) {
                        string Known = " ";
                        foreach (KeyValuePair<long, Msg> kvp in MsgQ) {
                            Known += "(Key=" + (kvp.Key >> 32) + ":" + (kvp.Key & 0xFFFFFFFF) + ", Value=" + kvp.Value.sender + "::" + kvp.Value.vid + ":" + kvp.Value.msgid + ")";
                        }

                        Vsync.WriteLine("WARNING: VSYNC ignoring a duplicate multicast[2] (" + m.sender + " sent to " + m.vid + ":" + m.msgid + ", but NextIncomingMsgID is " + vid + ":" + this.theView.NextIncomingMsgID[1 + which] + "); known = " + Known);
                    }

                    using (var tmpLockObj2 = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                        VsyncSystem.RTS.Discarded++;
                    }

                    return true;
                }

                if ((this.flags & G_ISLARGE) == 0) {
                    Msg nxtM = null;
                    int rcnt = MsgQ.Count;
                    while (rcnt-- > 0 && (nxtM = MsgQ.ElementAt(0).Value) != null && (nxtM.vid < vid || (nxtM.vid == vid && nxtM.msgid < this.theView.NextIncomingMsgID[1 + which]))) {
                        if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.DISCARDS)) != 0) {
                            using (var tmpLockObj2 = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                VsyncSystem.RTS.Discarded++;
                            }
                        }

                        MsgQ.RemoveAt(0);
                        --this.PendingQueueCount;
                        if (which != -1 && this.theView.members[which] != nxtM.sender) {
                            throw new VsyncException("MsgQ was for sender " + this.theView.members[1 + which] + " (which=" + which + "), but found a message on it from " + nxtM.sender);
                        }

                        if (which == -1 && (nxtM.flags & Msg.SENTBYORACLE) == 0) {
                            throw new VsyncException("MsgQ was for ORACLE, but found a message on it from " + nxtM.sender + " with SENTBYORACLE=false");
                        }

                        if ((VsyncSystem.Debug & (VsyncSystem.MSGQS | VsyncSystem.DISCARDS)) != 0) {
                            Vsync.WriteLine("<" + this.gname + ">: DISCARD IN GOTMSG FOR " + nxtM.sender + "::" + nxtM.vid + ":" + nxtM.msgid + (((nxtM.flags & Msg.SENTBYORACLE) != 0) ? " * sent by Oracle" : string.Empty) + " because which=" + which + "and theView.NextIncomingMsgID[1+which]=" + this.theView.NextIncomingMsgID[1 + which]);
                        }

                        nxtM = null;
                    }

                    if (nxtM != null) {
                        if (nxtM.vid == vid && ((nxtM.nRaw > 0 && nxtM.msgid <= this.theView.NextIncomingMsgID[1 + which] + nxtM.nRaw) || nxtM.msgid > this.theView.NextIncomingMsgID[1 + which])) {
                            Address sendTo;
                            if ((this.flags & G_ISLARGE) == 0 || nxtM.msgid == this.theView.NextIncomingMsgID[1 + which] + 1) {
                                sendTo = this.theView.members[(this.theView.GetMyRank() + 1) % this.theView.members.Length];
                            }
                            else {
                                sendTo = this.theView.members[0];
                            }

                            ReliableSender.SendNack(this, sendTo, nxtM.sender, vid, this.theView.NextIncomingMsgID[1 + which]);
                        }
                    }
                }

                if (MsgQ.Count > 0) {
                    this.DequeueDeliverableMsgs(willDeliver, which, this.theView);
                }
            }
            do_delivery(willDeliver);
            return true;
        }

        private List<Msg> do_delivery(List<Msg> willDeliver) {
            while (willDeliver.Count > 0) {
                foreach (Msg dm in willDeliver) {
                    if ((VsyncSystem.Debug & VsyncSystem.MSGQS) != 0) {
                        Vsync.WriteLine("<" + this.gname + ">: incomingSends.put(" + dm.sender + "::" + dm.vid + ":" + dm.msgid);
                    }

                    this.incomingSends.put(dm);
                }

                willDeliver = new List<Msg>();
                using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                    for (int w = 0; w < this.PendingQueue.Length; w++) {
                        if (this.PendingQueue[w] != null) {
                            this.DequeueDeliverableMsgs(willDeliver, w - 1, this.theView);
                        }
                    }
                }
            }

            return willDeliver;
        }

        internal void doDelivery(BoundedBuffer from, string which) {
            try {
                object o;
                while (VsyncSystem.VsyncActive && (o = from.get()) != null) {
                    VsyncSystem.RTS.ThreadCntrs[12]++;
                    if (o.GetType() == typeof(Msg)) {
                        this.doMsgDelivery((Msg)o);
                    }
                    else if (o.GetType() == typeof(List<Msg>)) {
                        foreach (Msg m in (List<Msg>)o) {
                            this.doMsgDelivery(m);
                        }
                    }
                    else if (o.GetType() == typeof(View)) {
                        View v = (View)o;
                        if ((VsyncSystem.Debug & VsyncSystem.MSGQS) != 0 && this != Vsync.ORACLE && this != Vsync.VSYNCMEMBERS) {
                            Vsync.WriteLine("<" + this.gname + ">: DELIVERY VIEW " + v.viewid + ", " + v.members.Length + " members");
                        }

                        if (v.theChkptMakers != null) {
                            this.runChkptMakers(v);
                        }

                        List<VHCallBack> vhcbl = new List<VHCallBack>();
                        if (from == this.incomingSends) {
                            if ((this.flags & G_NEEDSTATEXFER) != 0) {
                                ILock.NoteThreadState("xferWait(doDelivery).WaitOne()");
                                this.xferWait.WaitOne();
                                ILock.NoteThreadState(null);
                                this.xferWait.Release();
                            }

                            using (var tmpLockObj = new LockAndElevate(this.ViewHandlers.vhListLock)) {
                                foreach (VHCallBack vhcb in this.ViewHandlers.vhList) {
                                    vhcbl.Add(vhcb);
                                }
                            }

                            foreach (VHCallBack vhcb in vhcbl) {
                                if (vhcb.withLock) {
                                    VHCallBack myVhcb = vhcb;
                                    new Thread(() => {
                                        try {
                                            using (new ILock(ILock.LLENTRY, this.gaddr)) {
                                                myVhcb.vhProc(v);
                                            }
                                        }
                                        catch (VsyncShutdownException) {
                                            VsyncSystem.CheckLocksHeld();
                                        }

                                        VsyncSystem.ThreadTerminationMagic();
                                    }) { Name = "Callback thread for viewhander in <" + this.gname + ">", IsBackground = true }.Start();
                                }
                                else {
                                    vhcb.vhProc(v);
                                }
                            }
                        }

                        if (v.members.Length == 0 && v.leavers.Length == 1 && v.leavers[0].isMyAddress()) {
                            return;
                        }

                        this.CallbacksDone = true;
                    }
                    else {
                        throw new VsyncException("doDelivery: didn't expect to find object of type " + o.GetType());
                    }
                }

                BoundedBuffer.unregister(from);
                if (VsyncSystem.VsyncActive && this.GroupOpen) {
                    throw new VsyncException("doDelivery<" + this.gname + ">");
                }
            }
            catch (VsyncShutdownException) {
                VsyncSystem.CheckLocksHeld();
            }
        }

        private void doMsgDelivery(Msg m) {
            if (((VsyncSystem.Debug & VsyncSystem.MSGQS) != 0 && this != Vsync.ORACLE && this != Vsync.VSYNCMEMBERS) || (VsyncSystem.Debug & VsyncSystem.DELIVERY) != 0) {
                Vsync.WriteLine("<" + this.gname + ">: DELIVERY " + m.sender + "::" + m.vid + ":" + m.msgid + (((m.flags & Msg.SENTBYORACLE) != 0) ? " * sent by Oracle" : string.Empty));
            }

            if (m.type == Msg.ISGRPP2P || m.type == Msg.ISRAWGRPP2P) {
                this.doAction(m);
            }
            else {
                this.doDeliveryCallbacks(m, "GotAMsg/From " + m.sender, m.type);
            }
        }

        private int lastChkptVid = -2;

        private void runChkptMakers(View v) {
            if (((v.joiners.Length == 0 || v.members.Length == 0) && !this.isPersistent()) || v.viewid == this.lastChkptVid) {
                return;
            }

            this.lastChkptVid = v.viewid;
            this.nextView = v;
            this.inhibitEOC = true;
            if (v.theChkptMakers.Count > 0) {
                foreach (ChkptMaker cpm in v.theChkptMakers) {
                    cpm(v);
                }
            }

            this.inhibitEOC = false;
            this.EndOfChkpt();
            this.nextView = null;
        }

        private void doAction(Msg m) {
            if ((m.flags & Msg.FRAGGED) != 0) {
                Group.deFragRdv(this, m);
                return;
            }

            object[] obs = Msg.MsgToObjects(m);
            if (obs[0].GetType() == typeof(Msg)) {
                m = (Msg)obs[0];
                obs = Msg.MsgToObjects(m);
            }

            this.setReplyTo(m);
            this.cbAction(m, m.vid, m.msgid, m.sender, obs);
            this.clearReplyTo();
        }

        internal static int Undelivered() {
            int cnt = 0;
            List<Group> gl = VsyncGroupsClone();
            foreach (Group g in gl) {
                if (!g.HasFirstView) {
                    continue;
                }

                cnt += g.PendingQueueCount;
            }

            return cnt;
        }


        private long lastSentNackAt;
        private int lastvid;
        private int lastmsgid;

        // Must be called while holding a lock on PendingQueue
        private void DequeueDeliverableMsgs(List<Msg> dq, int which, View v) {
            Msg m = null;
            SortedList<long, Msg> MsgQ = this.PendingQueue[1 + which];
            if (MsgQ == null) {
                return;
            }

            if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                using (var tmpLockObj = new LockAndElevate(ReliableSender.ackInfoLock)) {
                    ReliableSender.ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: DequeueDeliverableMsgs -- MsgQ count=" + MsgQ.Count + Environment.NewLine);
                }
            }

            int rcnt = MsgQ.Count;
            while (rcnt-- > 0 && (m = MsgQ.ElementAt(0).Value) != null && m.vid <= v.viewid && m.msgid <= v.NextIncomingMsgID[1 + which] + m.nRaw) {
                MsgQ.RemoveAt(0);
                --this.PendingQueueCount;
                if ((m.nRaw > 0 && m.msgid >= v.NextIncomingMsgID[1 + which] && (m.msgid <= v.NextIncomingMsgID[1 + which] + m.nRaw) || m.msgid == v.NextIncomingMsgID[1 + which])) {
                    if (m.vid != v.viewid && (this.flags & G_ISLARGE) == 0) {
                        if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.DISCARDS)) != 0) {
                            Vsync.WriteLine("WARNING<" + this.gname + ">: VSYNC ignoring a duplicate multicast[3] (" + m.sender + " sent to " + m.vid + ":" + m.msgid + ", but NextIncomingMsgID is " + this.theView.viewid + ":" + this.theView.NextIncomingMsgID[1 + which] + ")");
                        }

                        using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                            VsyncSystem.RTS.Discarded++;
                        }
                    }
                    else {
                        v.NextIncomingMsgID[1 + which] = m.msgid + 1;
                        if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                            using (var tmpLockObj = new LockAndElevate(ReliableSender.ackInfoLock)) {
                                ReliableSender.ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: DequeueDeliverableMsgs -- willDeliver " + m.sender + "::" + m.vid + ":" + m.msgid + Environment.NewLine);
                            }
                        }

                        dq.Add(m);
                        if ((VsyncSystem.Debug & VsyncSystem.MSGQS) != 0 && this != Vsync.ORACLE && this != Vsync.VSYNCMEMBERS) {
                            Vsync.WriteLine("< " + this.gname + ">: DQ " + m.sender + "::" + m.vid + ":" + m.msgid + (((m.flags & Msg.SENTBYORACLE) != 0) ? " * sent by Oracle" : string.Empty));
                        }

                        m = null;
                        if (which != -1 && v.LastMsg != null && v.NextIncomingMsgID[1 + which] == v.LastMsg[which]) {
                            this.PendingQueue[1 + which] = null;
                            this.PendingQueueCount -= MsgQ.Count;
                            break;
                        }
                    }
                }
                else {
                    if ((VsyncSystem.Debug & VsyncSystem.DISCARDS) != 0) {
                        Vsync.WriteLine("WARNING: in DequeueDeliverableMsgs<" + this.gname + ">, unexpectedly dequeued message with " + m.sender + " sent to " + m.vid + ":" + m.msgid + (((m.flags & Msg.SENTBYORACLE) != 0) ? " * sent by Oracle" : string.Empty) + ", yet expected msgid in the range " + this.theView.viewid + ":[" + v.NextIncomingMsgID[1 + which] + "-" + (v.NextIncomingMsgID[1 + which] + m.nRaw) + "]");
                    }

                    if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                        using (var tmpLockObj = new LockAndElevate(ReliableSender.ackInfoLock)) {
                            ReliableSender.ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: DequeueDeliverableMsgs, unexpectedly dequeued message with msgid=" + m.sender + " sent to " + m.vid + ":" + m.msgid + ", yet expected " + this.theView.viewid + ":" + v.NextIncomingMsgID[1 + which] + Environment.NewLine);
                        }
                    }
                }
                m = null;
            }

            if (m != null) {
                if ((lastvid != m.vid || lastmsgid != m.msgid || Vsync.NOW - lastSentNackAt > 1000L) && (m.vid > v.viewid || (m.vid == v.viewid && m.msgid > v.NextIncomingMsgID[1 + which] + m.nRaw))) {
                    ReliableSender.SendNack(this, m.sender, m.sender, m.vid, this.theView.NextIncomingMsgID[1 + which]);
                    lastSentNackAt = Vsync.NOW;
                    lastvid = m.vid;
                    lastmsgid = m.msgid;
                }
            }

            if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                using (var tmpLockObj = new LockAndElevate(ReliableSender.ackInfoLock)) {
                    if (m != null) {
                        ReliableSender.ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: DequeueDeliverableMsgs -- enqueued for later delivery " + m.sender + "::" + m.vid + ":" + m.msgid + Environment.NewLine);
                    }
                    else {
                        ReliableSender.ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: DequeueDeliverableMsgs -- delivery finished (MsgQ[" + (1 + which) + "].count=" + MsgQ.Count + "... queue is empty)" + Environment.NewLine);
                    }
                }
            }
        }

        private readonly LockObject LockIt = new LockObject("LockIt");

        private readonly Dictionary<int, Msg> replyMsgs = new Dictionary<int, Msg>(16);

        internal void setReplyTo(Msg m) {
            this.setReplyTo(m, Thread.CurrentThread);
        }

        internal void setReplyTo(Msg m, Thread t) {
            // DumpReplyTo("setReplyTo:"+m+"::"+t.ManagedThreadId);
            if ((m.flags & Msg.NEEDSREPLY) == 0) {
                return;
            }

            using (var tmpLockObj = new LockAndElevate(this.LockIt)) {
                if (this.replyMsgs.ContainsKey(t.ManagedThreadId)) {
                    this.replyMsgs[t.ManagedThreadId] = m;
                }
                else {
                    this.replyMsgs.Add(t.ManagedThreadId, m);
                }
            }
        }

        internal void clearReplyTo() {
            // DumpReplyTo("clearReplyTo");
            using (var tmpLockObj = new LockAndElevate(this.LockIt)) {
                if (this.replyMsgs.ContainsKey(Thread.CurrentThread.ManagedThreadId)) {
                    this.replyMsgs.Remove(Thread.CurrentThread.ManagedThreadId);
                }
            }
        }

        internal Msg getReplyTo() {
            // DumpReplyTo("getReplyTo::" + Thread.CurrentThread.ManagedThreadId);
            Msg rmsg;
            using (var tmpLockObj = new LockAndElevate(this.LockIt)) {
                this.replyMsgs.TryGetValue(Thread.CurrentThread.ManagedThreadId, out rmsg);
            }

            return rmsg;
        }

        internal Msg getReplyToAndClear() {
            // DumpReplyTo("getReplyToAndClear::" + Thread.CurrentThread.ManagedThreadId);
            Msg rmsg;
            using (var tmpLockObj = new LockAndElevate(this.LockIt)) {
                if (this.replyMsgs.TryGetValue(Thread.CurrentThread.ManagedThreadId, out rmsg)) {
                    this.replyMsgs.Remove(Thread.CurrentThread.ManagedThreadId);
                }
            }

            return rmsg;
        }

        internal void DumpReplyTo(string where) {
            using (var tmpLockObj = new LockAndElevate(this.LockIt)) {
                string s = " ";
                foreach (KeyValuePair<int, Msg> kvp in this.replyMsgs) {
                    s += "{" + kvp.Key + "::" + kvp.Value + "}";
                }

                Vsync.WriteLine(where + "[" + s + "]");
            }
        }

        /// <summary>
        /// Indicate to Vsync that the caller will not reply and asks that Vsync NOT send an automated NullReply
        /// </summary>
        /// <remarks>
        /// NoReply() is a risky API that must be used with real care.  We use it ourselves in the SafeSend logic but
        /// SafeSend has a mechanism (part of the new-view flush protocol) to terminate a pending SafeSend if the view changes.
        /// Lacking this, if you call NoReply, the Query sender might still be waiting for a reply from the process that just
        /// said it won't be replying: unlike NullReply, which actually sends a message to the Query sender, NoReply is totally
        /// local.
        /// 
        /// So several things can go wrong.  Suppose the Query asked for ALL replies.  Clearly, it will wedge and eventually
        /// timeout, taking some timeout action against this non-replying process.  Now imagine a Query on a group with N members
        /// thast asks for 1 reply.  Here N-1 members might call NoReply, but what if the 1 member who should send the reply now crashes?
        /// The Query sender will be watching the N-1 other members, and yet will never get the desired reply.  Again, it will timeout
        /// on one or more members.
        /// 
        /// A workaround would run roughly as follows: you could assign the Reply obligation to some thread using SetReplyThread,
        /// which is a bit like NoReply: it inhibits the automatic NullReply that Vsync normally sends.  Then, if the designated reply
        /// thread crashes, you can see this via a NewView upcall and then call Reply in that thread.  Otherwise, if (somehow) you can
        /// detect that the Reply was sent safely (e.g. perhaps you get some subsequent multicast and know that the sender must
        /// therefor have received the prior result), you would call NoReply() in your watcher thread, at which point the 
        /// watcher is unlinked from the old message and you can call SetReplyThread again for the new request.  Whew!
        /// </remarks>
        public void NoReply() {
            this.clearReplyTo();
        }

        /// <summary>
        /// Tells Vsync that thread other than the one called via a message-delivery upcall will send the reply.
        /// </summary>
        /// <param name="t">The thread that will send the reply (don't call t.start() until after you call SetReplyThread(t)!)</param>
        /// <remarks>
        /// Normally, Vsync assumes that the thread handling a Query will send the reply, and if it neglects to do so, sends an automatically-generated NullReply().  A call to SetReplyThread disables
        /// that functionality and tells Vsync that the reply will (definitely) be sent by the thread designated by the caller.  
        /// A given thread can only have one message assigned to it using SetReplyThread at a time; attempts to assign two messages
        /// trigger a dictionary exception (two entries with the same key).  
        /// 
        /// A thread becomes unliked from a message by calling Reply(), NullReply(), AbortReply() or NoReply().
        /// 
        /// Note: If you use SetReplyThread(t), and then thread t terminates without sending a reply, the Query caller will
        /// wait until a timeout occurs (perhaps indefinitely if the Query caller used a very big timeout value).  Moreover, Vsync will retain a copy of the Query() message
        /// itself, in effect leaking memory.  (The alternative would be for Vsync to fork a thread that would issue a t.join(), so as to sense the termination of t,
        /// but the overheads of doing so are too high for this to make sense).
        /// 
        /// Thus, if you elect to use this mechanism, the Query handler should fork a thread, register
        /// it via SetReplyThread, and then start it.  And that child thread MUST remember to call Reply(), NullReply(), NoReply() or AbortReply() before terminating.  
        /// 
        /// The main risk of an error arises in applications
        /// where the Query waits for just 1 reply, sent by "some other process."  In this kind of application, one could seemingly get away with calling SetReplyThread as a way to disable the
        /// mandatory NullReply and in that manner, avoid a coverge-cast at the sender.  This might seem to work, but in fact would be problematic in several ways: first, the Query() message itself will
        /// be retained, which means that such a design would actually leak memory.  Moreover, in a run where failures happen to kill the designated reply
        /// source, the Query caller could hang indefinitely or or timeout, perhaps killing other group members in the process (TO_FAILURE).
        /// </remarks>
        public void SetReplyThread(Thread t) {
            Msg rmsg = this.getReplyToAndClear();
            if (rmsg == null) {
                return;
            }

            this.setReplyTo(rmsg, t);
        }

        internal void doDeliveryCallbacks(Msg m, string where, byte type) {
            if (type == Msg.STABILITYINFO) {
                return;
            }

            if (m.vid != -1 && m.msgid != -1 && !m.sender.isMyAddress() && (m.flags & Msg.DEFRAGGED) == 0 && m.type != Msg.REDELIVERY && m.type != Msg.RAWMULTICAST && m.type != Msg.ISRAWGRPP2P && m.type != Msg.ISRAWREPLY) {
                using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                    int rank = -1;
                    if (this.theView != null) {
                        rank = this.theView.isLarge ? -1 : this.theView.GetRankOf(m.sender);
                    }

                    if (rank != -1 && m.msgid > this.theView.StableTo[rank + 1]) {
                        using (var tmpLockObj1 = new LockAndElevate(this.UnstableLock)) {
                            this.Unstable.Add(m);
                            this.UnstableCount++;
                            if (this.UnstableCount > 40 && Vsync.NOW - this.RequestedMinStableAt > 1000 && Vsync.VSYNCMEMBERS != null && Vsync.VSYNCMEMBERS.HasFirstView) {
                                this.inquireMinStable();
                            }
                        }
                    }
                }
            }

            if ((m.flags & Msg.FRAGGED) != 0) {
                Group.deFragRdv(this, m);
                return;
            }

            m.type = type;
            m.gaddr = this.gaddr;
            if ((this.flags & G_ISLARGE) != 0 && this.theView != null && this.theView.nLive() > 2 && !m.sender.isMyAddress() && m.msgid != -1) {
                this.checkLastToken(m);
            }

            Msg innerMsg;
            object[] obs;
            if (type == Msg.REDELIVERY) {
                innerMsg = m;
            }
            else {
                obs = Msg.MsgToObjects(m, typeof(Msg));
                innerMsg = (Msg)obs[0];
                if (innerMsg.payload == null) {
                    innerMsg = m;
                }
            }

            this.decipherMsg(innerMsg);
            obs = Msg.MsgToObjects(innerMsg);
            if (obs[0].GetType() == typeof(Msg) && (m.flags & Msg.CIPHER) == 0) {
                innerMsg = (Msg)obs[0];
                this.decipherMsg(innerMsg);
                obs = Msg.MsgToObjects(innerMsg);
            }

            this.CheckForFutureViews(innerMsg);
            if (this.myLoggingFcn != null && m.Lid != -1) {
                this.myLoggingFcn(IL_DELIVERY, IL_START, m.sender, m.Lid, obs);
            }

            this.setReplyTo(innerMsg);
            this.cbAction(innerMsg, innerMsg.vid, innerMsg.msgid, innerMsg.sender, obs);
            if (m.ct != null && this.durabilityMethod != null) {
                this.durabilityMethod.Done(m.ct);
            }

            if (this.myLoggingFcn != null && m.Lid != -1) {
                this.myLoggingFcn(IL_DELIVERY, IL_DONE, m.sender, m.Lid, obs);
            }

            this.clearReplyTo();
        }

        internal void inquireMinStable() {
            using (var tmpLockObj = new LockAndElevate(this.GroupFlagsLock)) {
                if ((this.flags & G_GETTINGMINSTABLE) == 0) {
                    this.flags |= G_GETTINGMINSTABLE;
                    Address who = this.Unstable.First().sender;
                    new Thread(() => {
                        try {
                            for (int tcnt = 0; tcnt < 2; tcnt++) {
                                this.RequestedMinStableAt = Vsync.NOW;
                                int vid;
                                using (var tmpLockObj1 = new LockAndElevate(this.ViewLock)) {
                                    vid = this.theView.viewid;
                                }

                                byte[] ba = Vsync.VSYNCMEMBERS.doP2PQuery(who, new Timeout(500, Timeout.TO_NULLREPLY), Vsync.INQUIRE, this.gaddr, vid);
                                object[] inqobs = Msg.BArrayToObjects(ba);
                                if (inqobs.Length == 1) {
                                    int minStable = (int)inqobs[0];
                                    if (minStable == -1) {
                                        continue;
                                    }

                                    this.isStable(who, minStable);
                                    break;
                                }
                            }

                            using (var tmpLockObj1 = new LockAndElevate(this.GroupFlagsLock)) {
                                this.flags &= ~G_GETTINGMINSTABLE;
                            }
                        }
                        catch (VsyncShutdownException) {
                            VsyncSystem.CheckLocksHeld();
                        }

                        VsyncSystem.ThreadTerminationMagic();
                    }) { Name = this.gname + ": Getting MinStable", IsBackground = true }.Start();
                }
            }
        }

        internal void SetCurMsg(Msg m) {
            using (var tmpLockObj = new LockAndElevate(this.curMsgListLock)) {
                foreach (KeyValuePair<Thread, Msg> kvp in this.curMsgList) {
                    if (kvp.Key == Thread.CurrentThread) {
                        this.curMsgList.Remove(kvp);
                        break;
                    }
                }

                if (m != null) {
                    this.curMsgList.Add(new KeyValuePair<Thread, Msg>(Thread.CurrentThread, m));
                }
            }
        }

        /// <summary>
        /// During an upcall, returns the message currently being delivered to the current thread
        /// </summary>
        /// <returns>Current message, or null if none</returns>
        public Msg curMsg() {
            using (var tmpLockObj = new LockAndElevate(this.curMsgListLock)) {
                foreach (KeyValuePair<Thread, Msg> kvp in this.curMsgList) {
                    if (kvp.Key == Thread.CurrentThread) {
                        return kvp.Value;
                    }
                }
            }

            return null;
        }

        /// <summary>
        /// During an upcall, returns the message-id used when the message currently being delivered to the current thread was sent
        /// </summary>
        /// <returns>Current message id, or -1 if none</returns>
        /// <remarks>The message id and viewid are set when the message is sent, and the view may have changed by the time delivery occurs</remarks>
        public int curMsgId() {
            using (var tmpLockObj = new LockAndElevate(this.curMsgListLock)) {
                foreach (KeyValuePair<Thread, Msg> kvp in this.curMsgList) {
                    if (kvp.Key == Thread.CurrentThread) {
                        return kvp.Value.msgid;
                    }
                }
            }

            return Msg.UNINITIALIZED;
        }

        /// <summary>
        /// Useful in C++/CLI
        /// </summary>
        /// <returns>Current group</returns>
        public static Group thisGroup() {
            List<Group> clone = VsyncGroupsClone();
            foreach (Group g in clone) {
                using (var tmpLockObj = new LockAndElevate(g.curMsgListLock)) {
                    foreach (KeyValuePair<Thread, Msg> kvp in g.curMsgList) {
                        if (kvp.Key == Thread.CurrentThread) {
                            return g;
                        }
                    }
                }
            }

            return null;
        }

        /// <summary>
        /// During an upcall, returns the view-id in which the message currently being delivered to the current thread was sent
        /// </summary>
        /// <returns>View id, or -1 if none</returns>
        /// <remarks>The message id and viewid are set when the message is sent, and the view may have changed by the time delivery occurs</remarks>
        public int curMsgVid() {
            using (var tmpLockObj = new LockAndElevate(this.curMsgListLock)) {
                foreach (KeyValuePair<Thread, Msg> kvp in this.curMsgList) {
                    if (kvp.Key == Thread.CurrentThread) {
                        return kvp.Value.vid;
                    }
                }
            }

            return Msg.UNINITIALIZED;
        }

        internal void enqueueForGroupDelivery(Msg m) {
            if (Vsync.ClientOf != null && this == Vsync.ORACLE && this.incomingP2P == null) {
                Vsync.ClientOf = null;
                using (var tmpLockObj = new LockAndElevate(VsyncGroupsLock)) {
                    VsyncGroups.Remove(this.gaddr);
                }
                Vsync.ORACLE = new Group("ORACLE");
                Vsync.SetupORACLE();
                Vsync.ORACLE.enqueueForGroupDelivery(m);
                this.ReplayToDo();
                this.replayP2PStash();
                replayStash(this);
                return;
            }

            int retry = 0;
            m.type = Msg.ISGRPP2P;
            while (this.incomingP2P == null && retry++ < 5) {
                Vsync.Sleep(500);
            }


            if (this.incomingP2P == null) {
                throw new VsyncException("Unable to enqueue for delivery: p2p message " + m + " in group <" + this.gname + ">");
            }

            if (Msg.checkView(m)) {
                this.incomingP2P.put(m);
            }
            else {
                using (var tmpLockObj = new LockAndElevate(this.P2PStashLock)) {
                    this.P2PStash.Add(m);
                }
            }
        }

        internal static void ReportCb(Callable ca, object[] args) {
            string sa = " ";
            foreach (object o in args) {
                if (o == null) {
                    sa += "null, ";
                }
                else {
                    sa += "(" + o.GetType() + " = " + o + "), ";
                }
            }

            Vsync.WriteLine("Callback < " + Thread.CurrentThread.Name + ">: " + (ca != null && ca.cb != null ? ca.cb.Method.ToString() : "method-unknown") + " with args = (" + sa + ")");
        }

        internal static void ReportCb(Type t, object[] args) {
            string sa = " ";
            foreach (object o in args) {
                if (o == null) {
                    sa += "null, ";
                }
                else {
                    sa += "(" + o.GetType() + " = " + o + "), ";
                }
            }

            Vsync.WriteLine("Calling " + t.Name + ".Constructor(" + sa + ")");
        }

        internal static void ReportCb(Type t, object o) {
            string sa = " ";
            if (o == null) {
                sa += "null ";
            }
            else {
                sa += "(" + o.GetType() + " = " + o + ") ";
            }

            Vsync.WriteLine("Calling " + t.Name + ".toBArray" + sa);
        }

        private void cbCheck(object[] obs) {
            for (int n = 0; n < obs.Length; n++)
                if (obs[n] == null) {
                    throw new VsyncException("null passed as argument " + n + " (counting after the request code) in an Vsync multicast");
                }

            if (this.isTrackingProxy || this.isClientProxy) {
                return;
            }

            if (obs.Length == 1 && obs[0].GetType() == typeof(object[])) {
                obs = (object[])obs[0];
            }

            if (obs.Length == 1 && obs[0].GetType() == typeof(Msg)) {
                return;
            }

            obs = fixObs(obs);
            int request = this.rcode(obs);
            if (request == Vsync.IM_DHT_GET) {
                // Special case for DHTGet
                return;
            }

            if (this.Handlers[request] == null) {
                throw new MissingMemberException("Group doesn't exist, or doesn't allow clients to issue request code " + Vsync.rToString(obs[0]));
            }

            List<CallBack> cblist = this.Handlers[request].hList;
            if (cblist != null) {
                foreach (CallBack cb in cblist) {
                    if (TypeMatch(obs, cb)) {
                        return;
                    }
                }
            }

            if (obs.Length == 1 && obs[0].GetType() == typeof(Msg)) {
                return;
            }

            string ts = " ", cbs = " ";
            if (obs.Length == 1) {
                ts += "<nil>";
            }
            else {
                for (int i = 1; i < obs.Length; i++) {
                    ts += obs[i].GetType() + " ";
                }
            }

            if (cblist != null) {
                foreach (CallBack cb in cblist) {
                    cbs += "handler[" + tlist(cb) + " ] ";
                }
            }

            throw new MissingMethodException("No handler for request " + Vsync.rToString(obs[0]) + " matches provided argument types { " + ts + "} (found " + cbs + ")");
        }

        private static object[] fixObs(object[] obs) {
            if (IsSubsetSend(obs[0])) {
                object[] newobs = new object[obs.Length - 1];
                for (int n = 1; n < obs.Length; n++) {
                    newobs[n - 1] = obs[n];
                }

                obs = newobs;
            }

            return obs;
        }

        private static string tlist(CallBack cb) {
            string tls = " ";
            for (int i = 0; i < cb.cbProc.ptypes.Length; i++) {
                tls += cb.cbProc.ptypes[i] + " ";
            }

            return tls;
        }

        internal class redeliveryInfo {
            internal int recentVid;

            internal int recentMsgid;

            internal Address recentSender;

            internal Thread recentThread;

            internal redeliveryInfo(int rvid, int rmid, Address rs, Thread rt) {
                this.recentVid = rvid;
                this.recentMsgid = rmid;
                this.recentSender = rs;
                this.recentThread = rt;
            }
        }

        internal LockObject rdiLock = new LockObject("rdiLock");

        internal List<redeliveryInfo> rdiList = new List<redeliveryInfo>();

        private void Redeliver(byte[] barray) {
            this.Redeliver(barray, this.rdiLock, this.rdiList);
        }

        private void Redeliver(byte[] barray, LockObject theRdiLock, List<redeliveryInfo> theRdiList) {
            redeliveryInfo myRdi = null;
            using (var tmpLockObj = new LockAndElevate(theRdiLock)) {
                foreach (redeliveryInfo rdi in theRdiList) {
                    if (rdi.recentThread == Thread.CurrentThread) {
                        myRdi = rdi;
                        break;
                    }
                }

                if (myRdi != null) {
                    theRdiList.Remove(myRdi);
                }
            }

            if (myRdi != null) {
                this.cbAction(null, myRdi.recentVid, myRdi.recentMsgid, myRdi.recentSender, Msg.BArrayToObjects(barray));
            }
            else {
                throw new VsyncException("Redeliver");
            }
        }

        private void cbAction(Msg m, int vid, int msgid, Address sender, object[] obs) {
            if (obs.Length == 0) {
                return;
            }

            while (obs.Length == 1 && obs[0].GetType() == typeof(Msg)) {
                // Special for sending INITIALVIEW via OOB, which show up in an unusual format because the receiver isn't yet
                // a member of any groups, forcing Vsync to use a form of pure p2p send that double-encapsulates the true message
                // This "hack" makes it possible for g.Reply() to work as if it was within a group...
                Vsync.Sleep(20);
                m = (Msg)obs[0];
                this.setReplyTo(m);
                obs = Msg.BArrayToObjects(m.payload);
            }

            try {
                this.SetCurMsg(m);
                obs = fixObs(obs);
                if (this.hasUniversalHandlers && this.isP2PThread) {
                    if (this.rcode(obs) >= 0) {
                        using (var tmpLockObj = new LockAndElevate(this.UniversalP2PHandlers.uhListLock)) {
                            foreach (UHCallBack uc in this.UniversalP2PHandlers.uhList) {
                                uc.uhProc(obs);
                            }
                        }
                    }
                }
                else if (this.hasUniversalHandlers) {
                    if (this.rcode(obs) >= 0) {
                        using (var tmpLockObj = new LockAndElevate(this.UniversalMHandlers.uhListLock)) {
                            foreach (UHCallBack uc in this.UniversalMHandlers.uhList) {
                                uc.uhProc(obs);
                            }
                        }
                    }
                }

                List<CallBack> cblist;
                int request = this.rcode(obs);
                int cbCnt = 0;
                if (request == Vsync.CRYPTOWRAPPED || request == Vsync.CLIENTWRAPPED) {
                    using (var tmpLockObj = new LockAndElevate(this.rdiLock)) {
                        this.rdiList.Add(new redeliveryInfo(vid, msgid, sender, Thread.CurrentThread));
                    }
                }

                try {
                    cblist = this.Handlers[request].hList;
                }
                catch {
                    cblist = null;
                }

                if (cblist == null) {
                    if ((VsyncSystem.Debug & VsyncSystem.DISCARDS) != 0) {
                        Vsync.WriteLine("WARNING: no registered callbacks known for request " + Vsync.rToString((int)obs[0]) + ", msg " + vid + ":" + msgid + " from " + sender);
                    }

                    using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                        VsyncSystem.RTS.Discarded++;
                    }

                    return;
                }

                object[] args = new object[obs.Length - 1];
                for (int i = 0; i < args.Length; i++) {
                    args[i] = obs[i + 1];
                }

                if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.CALLBACKS)) != 0) {
                    Vsync.WriteLine("In group " + this.gname + " about to do callbacks for request " + Vsync.rToString((int)obs[0]) + ", msg " + vid + ":" + msgid + " from " + sender);
                }

                List<CallBack> toDo = new List<CallBack>();
                foreach (CallBack cb in cblist) {
                    if (TypeMatch(obs, cb)) {
                        ++cbCnt;
                        toDo.Add(cb);
                    }
                }

                foreach (CallBack cb in toDo) {
                    if ((VsyncSystem.Debug & VsyncSystem.CALLBACKS) != 0) {
                        ReportCb(cb.cbProc, args);
                    }

                    long before = Vsync.NOW;
                    if (cb.withLock) {
                        Callable cbproc = cb.cbProc;
                        new Thread(() => {
                            try {
                                using (new ILock(ILock.LLENTRY, this.gaddr)) {
                                    cbproc.doUpcall(args);
                                }
                            }
                            catch (VsyncShutdownException) {
                                VsyncSystem.CheckLocksHeld();
                            }

                            VsyncSystem.ThreadTerminationMagic();
                        }) { Name = "Callback with lock", IsBackground = true }.Start();
                    }
                    else {
                        cb.cbProc.doUpcall(args);
                    }

                    if ((VsyncSystem.Debug & VsyncSystem.DELAYS) != 0 && (Vsync.NOW - before) > 500) {
                        Vsync.WriteLine("WARNING: Callback to request " + Vsync.rToString((int)obs[0]) + ", msg " + vid + ":" + msgid + " from " + sender + " took " + (Vsync.NOW - before) + "ms");
                    }
                }

                if (cbCnt == 0) {
                    string ts = " ";
                    for (int i = 1; i < obs.Length; i++) {
                        ts += obs[i].GetType() + " ";
                    }

                    Vsync.WriteLine("WARNING: No matching type signature for incoming msg " + vid + ":" + msgid + " from " + sender + "; [<" + this.gname + ">." + Vsync.rToString((int)obs[0]) + "(" + ts + ")");
                    return;
                }

                Msg replyTo = this.getReplyTo();
                if (replyTo != null) {
                    if ((VsyncSystem.Debug & VsyncSystem.MESSAGELAYER) != 0) {
                        Vsync.WriteLine("WARNING: Sending an automatic NULLREPLY " + (Thread.CurrentThread.Name ?? " (unnamed thread"));
                    }

                    this.doNullReply();
                }

                if ((VsyncSystem.Debug & VsyncSystem.MESSAGELAYER) != 0) {
                    Vsync.WriteLine("In group " + this.gname + " after callbacks for request " + Vsync.rToString((int)obs[0]) + ", msg " + vid + ":" + msgid + " from " + sender);
                }
            }
            finally {
                this.SetCurMsg(null);
            }
        }

        internal const int RT_REPLY = 1;

        internal const int RT_NULL = 2;

        internal const int RT_ABORT = 3;

        /// <summary>
        /// Invoked by a recipient of a Query to send this member's contribution towards the result of the Query.  
        /// </summary>
        /// <param name="obs">variable-length argument list of values to pass back to the caller.  The number and types of the
        /// objects passed as arguments to Reply must exactly match the number and types expected by the caller.  Additionally,
        /// the caller must use the same type "codes" for any user-defined object types.  </param>
        public void Reply(params object[] obs) {
            if (!this.VsyncCallStart()) {
                return;
            }

            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            this.doReply(obs);
            this.VsyncCallDone();
        }

        internal static LockObject Rlock = new LockObject("Rlock");

        internal void doReply(params object[] obs) {
            if (!this.GroupOpen && this.WasOpen) {
                if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                    Vsync.WriteLine("Can't reply (group isn't open)");
                }

                return;
            }

            foreach (object o in obs)
                if (o == null) {
                    throw new VsyncException("null passed as an argument to Reply!");
                }

            Msg replyTo;
            using (var tmpLockObj = new LockAndElevate(Rlock)) {
                replyTo = this.getReplyToAndClear();
            }

            if (replyTo == null) {
                throw new VsyncException("Attempted to reply twice to same message, or to a message that wasn't a query");
            }

            if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                Vsync.WriteLine("Sending reply to " + replyTo.sender + ", " + replyTo.vid + ":" + replyTo.msgid);
            }

            Type t;
            if (obs.Length > 16 && Msg.AllHaveSameType(obs, out t)) {
                obs = new object[] { obs };
            }

            byte[] result = Msg.toBArray(obs);
            bool enciphered = false;
            if ((this.flags & G_SECURE) != 0 && (replyTo.flags & Msg.ENCIPHEREDREPLY) != 0) {
                enciphered = true;
                result = this.cipherBuf(result);
            }

            bool deliverToOracle = (replyTo.flags & Msg.SENTBYORACLE) != 0;
            byte[] buffer = Msg.toBArray(RT_REPLY, replyTo.vid, replyTo.msgid, deliverToOracle, enciphered, result);
            Vsync.PendingLeaderOps plos;
            using (var tmpLockObj = new LockAndElevate(this.groupLock)) {
                plos = this.NotifyDALOnReply;
            }

            if (plos != null && plos.reqMsg == replyTo) {
                Vsync.DALReplyNotify(this, new Msg(this.gaddr, Msg.ISREPLY, replyTo.sender, Msg.NewMsgAsBArray(Vsync.my_address, this.gaddr, this.theView.viewid, -1, 0L, 0, 0, 0, buffer), this.theView.viewid, -1), plos, replyTo);
            }

            ReliableSender.SendP2P(Msg.ISREPLY, replyTo.sender, this.rgroup(replyTo.gaddr), this.theView == null ? 0 : this.theView.viewid, ReliableSender.P2PSequencer.NextP2PSeqn("reply/1", replyTo.sender), buffer, true, null, replyTo);
        }

        // This is a little trick to support the Client of a group logic.  If the reply message shows that the request was sent in VSYNCMEMBERS, make sure
        // the reply shows up listing VSYNCMEMBERS as the group so that the reply will match the reply-wait on the client side.
        internal Group rgroup(Address gaddr) {
            if (gaddr != null && gaddr == Vsync.VSYNCMEMBERS.gaddr) {
                return Vsync.VSYNCMEMBERS;
            }

            return this;
        }

        /// <summary>
        /// Invoked by the recipient of a Query if this member will not participate in performing the Query
        /// </summary>
        public void NullReply() {
            if (!this.VsyncCallStart()) {
                return;
            }

            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            this.doNullReply();
            this.VsyncCallDone();
        }

        internal void doNullReply() {
            Msg replyTo = this.getReplyToAndClear();
            if (!this.GroupOpen || replyTo == null || (replyTo.flags & Msg.NEEDSREPLY) == 0) {
                // Technically this would point to a bug in the application, but since a NullReply is a kind of no-op anyhow, we won't complain
                return;
            }

            if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                Vsync.WriteLine("NullReply to " + replyTo.sender + " msgid " + replyTo.vid + ":" + replyTo.msgid);
            }

            bool deliverToOracle = (replyTo.flags & Msg.SENTBYORACLE) != 0;
            ReliableSender.SendP2P(Msg.ISREPLY, replyTo.sender, this.rgroup(replyTo.gaddr), this.theView == null ? 0 : this.theView.viewid, ReliableSender.P2PSequencer.NextP2PSeqn("reply/2", replyTo.sender), Msg.toBArray(RT_NULL, replyTo.vid, replyTo.msgid, deliverToOracle, (this.flags & G_SECURE) != 0), true, null, replyTo);
        }

        /// <summary>
        /// Invoked by the recipient of a Query to force an VsyncAbort exception in the caller.
        /// </summary>
        /// <param name="reason">string giving the reason for aborting this query</param>
        public void AbortReply(string reason) {
            if (!this.VsyncCallStart()) {
                return;
            }

            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            this.doAbortReply(reason);
            this.VsyncCallDone();
        }

        internal void doAbortReply(string reason) {
            Msg replyTo = this.getReplyToAndClear();
            if (!this.GroupOpen || replyTo == null || (replyTo.flags & Msg.NEEDSREPLY) == 0) {
                throw new VsyncException("AbortReply: you already replied to this message, or it wasn't a query");
            }

            if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                Vsync.WriteLine("AbortReply to " + replyTo.vid + ":" + replyTo.msgid);
            }

            bool deliverToOracle = (replyTo.flags & Msg.SENTBYORACLE) != 0;
            ReliableSender.SendP2P(Msg.ISREPLY, replyTo.sender, this.rgroup(replyTo.gaddr), this.theView == null ? 0 : this.theView.viewid, ReliableSender.P2PSequencer.NextP2PSeqn("reply/3", replyTo.sender), Msg.toBArray(RT_ABORT, replyTo.vid, replyTo.msgid, deliverToOracle, (this.flags & G_SECURE) != 0, reason), true, null, replyTo);
        }

        internal static List<Address> RecentlyLeft = new List<Address>();

        internal LockObject RecentlyLeftLock = new LockObject("RecentlyLeftLock");

        /// <summary>
        /// Invoked by the caller to leave a particular group
        /// </summary>
        public void Leave() {
            if (!this.VsyncCallStart()) {
                return;
            }

            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            using (var tmpLockObj = new LockAndElevate(this.RecentlyLeftLock)) {
                RecentlyLeft.Add(this.gaddr);
            }

            Vsync.OnTimer(5 * 60 * 1000, () => {
                using (var tmpLockObj = new LockAndElevate(this.RecentlyLeftLock)) {
                    RecentlyLeft.Remove(this.gaddr);
                }
            });
            if (!this.HasFirstView) {
                this.GroupClose();
            }

            doLeave(0, new[] { this });
            this.VsyncCallDone();
        }

        /// <summary>
        /// Invoked by the caller to leave a set of groups in one atomic action
        /// </summary>
        /// <param name="groups">list of groups to leave</param>
        public static void multiLeave(Group[] groups) {
            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            foreach (Group g in groups) {
                if (!g.HasFirstView) {
                    throw new VsyncException("multiLeave: can only be called by a current member of <" + g.gname + ">");
                }
            }

            doLeave(0, groups);
        }

        /// <summary>
        /// Invoked by the master process to remove a set of workers from a set of groups in one atomic action
        /// </summary>
        /// <param name="workers">list of processes to remove from the list of groups</param>
        /// <param name="groups">list of groups</param>
        public static void multiLeave(Address[] workers, Group[] groups) {
            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            doLeave(0, workers, groups);
        }

        internal static void doLeave(int level, Address[] oldMembers, Group[] groups) {
            doLeave(level, virtualGroup(oldMembers), groups);
        }

        internal static void doLeave(int level, Group[] groups) {
            doLeave(level, Vsync.my_address, groups);
        }

        internal static void doLeave(int level, Address who, Group[] groups) {
            Address[] gaddrs = new Address[groups.Length];
            string[] gnames = new string[groups.Length];
            int[] flags = new int[groups.Length];
            int cnt = 0;
            foreach (Group g in groups) {
                g.Flush();
                flags[cnt] = g.flags;
                gnames[cnt] = g.gname;
                gaddrs[cnt++] = g.gaddr;
            }

            if (Vsync.ClientOf == null) {
                Vsync.ORACLE.QueryToBA(ALL, new Timeout(Vsync.VSYNC_DEFAULTTIMEOUT, Timeout.TO_FAILURE, "LEAVE"), Vsync.LEAVE, who, 0, gnames, gaddrs, flags, ++VsyncSystem.VsyncJoinCounter);
            }
            else {
                while (Vsync.ClientOf != null) {
                    if (Vsync.ORACLE.doP2PQuery(Vsync.ClientOf, new Timeout(Vsync.VSYNC_DEFAULTTIMEOUT, Timeout.TO_FAILURE, "RELAYLEAVE"), Vsync.RELAYLEAVE, who, Vsync.ORACLE.uids++, gnames, gaddrs, flags).Length != 0) {
                        break;
                    }
                }
            }

            TerminationWait(groups);
        }

        private static void TerminationWait(Group[] groups) {
            foreach (Group g in groups) {
                while (VsyncSystem.VsyncActive && g.GroupOpen) {
                    VsyncSystem.RTS.ThreadCntrs[13]++;
                    Vsync.Sleep(250);
                    ILock.ScanPWaits();
                }
            }
        }

        internal Address[] getLiveMembers() {
            if ((this.flags & G_ISLARGE) != 0) {
                return new[] { this.theView.members[0] };
            }

            return getLiveMembers(this.theView);
        }

        internal static Address[] getLiveMembers(View v) {
            if (v == null) {
                return new Address[0];
            }

            Address[] LiveGuys = new Address[v.nLive()];
            int i = 0;
            int j = 0;
            while (i < v.members.Length) {
                if (!v.hasFailed[i]) {
                    LiveGuys[j++] = v.members[i];
                }

                ++i;
            }

            return LiveGuys;
        }

        internal class gStashNode {
            internal Address sender;

            internal Address gaddr;

            internal int minStable;

            internal Msg m;

            internal int deliveryAttempts;

            internal gStashNode(Address s, Address ga, int ms, Msg msg) {
                this.sender = s;
                this.gaddr = ga;
                this.minStable = ms;
                this.m = msg;
            }
        }

        internal static List<gStashNode> stash = new List<gStashNode>();

        internal static LockObject stashLock = new LockObject("stashLock");

        internal static volatile bool stashNonEmpty = false;

        internal LockObject P2PStashLock = new LockObject("P2PStashLock");

        internal List<Msg> P2PStash = new List<Msg>();

        internal static void stashMsg(Address sender, Address gaddr, int minStable, Msg m) {
            using (var tmpLockObj = new LockAndElevate(stashLock)) {
                stash.Add(new gStashNode(sender, gaddr, minStable, m));
                stashNonEmpty = true;
            }
        }

        internal static void stashCheck() {
            bool nullGroup = false;
            List<Group> replayList = new List<Group>();
            using (var tmpLockObj = new LockAndElevate(stashLock)) {
                foreach (gStashNode gsn in stash) {
                    Group g = Group.doLookup(gsn.gaddr);
                    if (g != null && !replayList.Contains(g)) {
                        replayList.Add(g);
                    }
                    else if (gsn.gaddr.isNull()) {
                        nullGroup = true;
                    }
                }
            }

            if (nullGroup) {
                replayStash(null);
            }

            foreach (Group g in replayList) {
                replayStash(g);
                g.replayP2PStash();
            }
        }

        internal void replayP2PStash() {
            using (var tmpLockObj = new LockAndElevate(this.P2PStashLock)) {
                List<Msg> newList = new List<Msg>();
                foreach (Msg m in this.P2PStash) {
                    if (Msg.checkView(m)) {
                        this.incomingP2P.put(m);
                    }
                    else {
                        newList.Add(m);
                    }
                }

                this.P2PStash = newList;
            }
        }

        internal static void replayStash(Group g) {
            int ms = -1;
            List<gStashNode> cblist = new List<gStashNode>();
            List<gStashNode> nstash = new List<gStashNode>();
            using (var tmpLockObj = new LockAndElevate(stashLock)) {
                foreach (gStashNode gsn in stash) {
                    if (g == null ? gsn.gaddr.isNull() : g.gaddr == gsn.gaddr) {
                        ms = Math.Max(ms, gsn.minStable);
                        cblist.Add(gsn);
                    }
                    else {
                        nstash.Add(gsn);
                    }
                }

                stash = nstash;
                stashNonEmpty = stash.Count > 0;
            }

            foreach (gStashNode gsn in cblist) {
                if (!ReliableSender.doGotIncoming(Msg.ISGRPP2P, gsn.gaddr, gsn.sender, ms, gsn.m, g, false)) {
                    using (var tmpLockObj = new LockAndElevate(stashLock)) {
                        if (++gsn.deliveryAttempts > 10) {
                            Vsync.WriteLine("WARNING: giving up on delivery for stashed message: " + gsn.m);
                        }
                        else {
                            stash.Add(gsn);
                            stashNonEmpty = true;
                        }
                    }
                }
            }

            if ((g.flags & G_ISLARGE) != 0) {
                List<ReliableSender.MsgDesc> toReplay = new List<ReliableSender.MsgDesc>();
                using (var tmpLockObj = new LockAndElevate(g.GotAMsgLock))
                using (var tmpLockObj1 = new LockAndElevate(ReliableSender.PendingSendBufferLock)) {
                    foreach (ReliableSender.MsgDesc lgmd in ReliableSender.LgPendingSendBuffer) {
                        if (lgmd.group == g && (lgmd.MsgId == -1 || lgmd.MsgId >= g.nextMsgid)) {
                            toReplay.Add(lgmd);
                        }
                    }
                }

                foreach (ReliableSender.MsgDesc lgmd in toReplay) {
                    ReliableSender.RecvBB.put(lgmd.theBytes);
                }
            }
        }

        internal static string dumpStash() {
            if (stash.Count == 0) {
                return string.Empty;
            }

            string s = "LIST OF EARLY-RECEIVED GRP P2P MSGS:" + Environment.NewLine;
            using (var tmpLockObj = new LockAndElevate(stashLock)) {
                foreach (gStashNode gsn in stash) {
                    s += "  STASHED: " + gsn.m + Environment.NewLine;
                }
            }

            return s;
        }

        /// <summary>
        /// Called to register a new Aggregator method for this group. 
        /// </summary>
        /// <param name="hisAggregator">a method to perform aggregation computations, must implement the IAggregator interface</param>
        /// <typeparam name="KeyType">Type for keys (must be registered first via Msg.registerType, must implement IEqualityComparer)</typeparam>
        /// <typeparam name="ValueType">Type for values (must be registered first via Msg.registerType)</typeparam>
        /// <remarks> 
        /// Called to register a new Aggregator method for this group.  It must implement the IAggregator interface, which can
        /// also be accessed as an in-line delegate type of type AggregatorDel
        /// </remarks>
        public void RegisterAggregator<KeyType, ValueType>(Aggregator<KeyType, ValueType> hisAggregator) {
            this.RegisterAggregator(hisAggregator, new Timeout(Vsync.VSYNC_DEFAULTTIMEOUT, Timeout.TO_AGGFAILURE, "AGGFAILURE"));
        }

        /// <summary>
        /// Called to register a new Aggregator method for this group. 
        /// </summary>
        /// <param name="hisAggregator">a method to perform aggregation computations, must implement the IAggregator interface</param>
        /// <param name="AggTimeout">A timeout indicating the maximum delay before the aggregation fails and the action this triggers</param>
        /// <typeparam name="KeyType">Type for keys (must be registered first via Msg.registerType, must implement IEqualityComparer)</typeparam>
        /// <typeparam name="ValueType">Type for values (must be registered first via Msg.registerType)</typeparam>
        /// <remarks> 
        /// Called to register a new Aggregator method for this group.  It must implement the IAggregator interface, which can
        /// also be accessed as an in-line delegate type of type AggregatorDel
        /// </remarks>
        public void RegisterAggregator<KeyType, ValueType>(Aggregator<KeyType, ValueType> hisAggregator, Timeout AggTimeout) {
            if (AggTimeout.action != Timeout.TO_AGGFAILURE) {
                throw new ArgumentException("registerAggregation: Illegal failure action");
            }

            this.doRegisterAggregator(hisAggregator, AggTimeout);
            this.flags |= G_HASUAGG;
        }

        // Internal one is identical except it doesn't set the user-defined-aggregators flag, which affects token rate
        internal void doRegisterAggregator<KeyType, ValueType>(Aggregator<KeyType, ValueType> hisAggregator) {
            this.doRegisterAggregator(hisAggregator, new Timeout(Vsync.VSYNC_DEFAULTTIMEOUT * 2, Timeout.TO_AGGFAILURE, "REGISTER.AGGREGATOR"));
        }

        // Internal one is identical except it doesn't set the user-defined-aggregators flag, which affects token rate
        internal void doRegisterAggregator<KeyType, ValueType>(Aggregator<KeyType, ValueType> hisAggregator, Timeout AggTimeout) {
            Type KT = typeof(KeyType);
            Type VT = typeof(ValueType);
            if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                Vsync.WriteLine("registerAggregator<" + KT + "><" + VT + "> " + hisAggregator);
            }

            if (this.HasFirstView) {
                throw new VsyncException("Illegal to register aggregator after doing a group join");
            }

            if (this.isTrackingProxy) {
                throw new VsyncException("registerAggregator called in a tracking proxy");
            }

            Msg.ConfirmRegistered(KT);
            Msg.ConfirmRegistered(VT);
            foreach (AggInfo ag in this.AggTypes) {
                if (ag.KT == typeof(KeyType) && ag.VT == typeof(ValueType)) {
                    throw new VsyncException("Group.registerAggregator: Type signature <" + typeof(KeyType) + "," + typeof(ValueType) + "> already registered in Group " + this.gname + " (hint: disambiguate aggregator instances using a structured key instead of trying to re-register the type)");
                }
            }

            ConstructorInfo ci = typeof(Aggregation<KeyType, ValueType>).GetConstructor(new[] { typeof(Group), typeof(int), typeof(int), typeof(Aggregator<KeyType, ValueType>), typeof(Timeout) });
            if (ci == null) {
                throw new VsyncException("Aggregator " + this.GetType() + " lacks a constructor(Group g, Aggregator<KeyType, ValueType> del)");
            }

            if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                Vsync.WriteLine("Group <" + this.gname + ">... registerAggregator for type " + KT + ":" + VT);
            }

            this.AggTypes.Add(new AggInfo(KT, VT, ci, this, hisAggregator, AggTimeout));
        }

        internal string AggState() {
            string s = string.Empty;
            using (var tmpLockObj = new LockAndElevate(this.AggListLock)) {
                if (this.AggList != null) {
                    for (int l = 0; l < this.AggList.Length; l++) {
                        foreach (IAggregateEventHandler ae in this.AggList[l]) {
                            string astate = ae.AggState();
                            if (astate.Length > 0) {
                                s += "            Aggregator " + ae.AggName() + " level " + l + Environment.NewLine + astate;
                            }
                        }
                    }
                }
            }

            if (s.Length > 0) {
                return "         AGGREGATION STATE:" + Environment.NewLine + s;
            }

            return s;
        }

        internal void InterruptAggregationWaits() {
            if ((this.flags & G_ISLARGE) != 0) {
                tokenInfo theToken;
                using (var tmpLockObj = new LockAndElevate(this.TokenLock)) {
                    theToken = this.theToken;
                }

                if (theToken == null) {
                    return;
                }

                for (int level = 0; level < theToken.nlevels; level++) {
                    foreach (IAggregateEventHandler ae in theToken.theGroup.AggList[level]) {
                        try {
                            ae.AggEvent(BreakWaits);
                        }
                        catch (VsyncShutdownException) {
                            VsyncSystem.CheckLocksHeld();
                        }
                    }
                }
            }
            else {
                using (var tmpLockObj = new LockAndElevate(this.AggListLock)) {
                    if (this.AggList != null) {
                        foreach (LinkedList<object> item in this.AggList) {
                            foreach (IAggregateEventHandler ae in item) {
                                try {
                                    ae.AggEvent(BreakWaits);
                                }
                                catch (VsyncShutdownException) {
                                    VsyncSystem.CheckLocksHeld();
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Called by the user to set a local value for an aggregator.
        /// </summary>
        /// <typeparam name="KeyType">Type for keys (must be registered first via Msg.registerType)</typeparam>
        /// <typeparam name="ValueType">Type for values (must be registered first via Msg.registerType)</typeparam>
        /// <param name="key">the key identifying this aggregation</param>
        /// <param name="val">the value this process contributes towards the aggregation</param>
        /// <remarks>
        /// Called by the user to set a local value for an aggregator.  The key identifies the aggregation instance and the value is the local value.  Called just once for any
        /// particular key value.  If you need to have multiple episodes of aggregation for a single key type, encode the episode id into a keytype class.
        /// </remarks>
        public void SetAggregatorValue<KeyType, ValueType>(KeyType key, ValueType val) {
            if (!this.HasFirstView) {
                return;
            }

            if (this.myLoggingFcn != null) {
                this.myLoggingFcn(IL_AGGDVALUE, IL_START, Vsync.my_address, this.newLoggingId(), key, val);
            }

            this.SetAggregatorValueAndVID(this.theView.viewid, key, val);
        }

        // Internal version used ONLY in the flush algorithm
        internal void SetAggregatorValueAndVID<KeyType, ValueType>(int vid, KeyType key, ValueType val) {
            tokenInfo theToken = null;
            if ((this.flags & G_ISLARGE) != 0) {
                using (var tmpLockObj = new LockAndElevate(this.TokenLock)) {
                    theToken = this.theToken;
                }
            }

            if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                Vsync.WriteLine("SetAggregatorValueAndVID in <" + this.gname + "> for " + typeof(KeyType) + ":" + typeof(ValueType) + ", key=" + key + ", value=" + val + " and with VID=" + vid);
            }

            int idx = 0;
            this.interesting = true;
            foreach (AggInfo ai in this.AggTypes) {
                if (ai.KT == typeof(KeyType) && ai.VT == typeof(ValueType)) {
                    if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                        Vsync.WriteLine("SetAggregatorValueAndVID: idx " + idx + " matched ai.KT<" + ai.KT + "> == KeyType<" + typeof(KeyType) + "> and ai.VT<" + ai.VT + "> == ValueType<" + typeof(ValueType) + ">");
                    }

                    if ((this.flags & G_ISLARGE) != 0) {
                        ((Aggregation<KeyType, ValueType>)theToken.theGroup.AggList[0].ElementAt(idx)).Set(vid, key, val);
                    }
                    else {
                        using (var tmpLockObj = new LockAndElevate(this.AggListLock)) {
                            ((Aggregation<KeyType, ValueType>)this.AggList[0].ElementAt(idx)).Set(vid, key, val);
                        }
                    }

                    return;
                }

                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                    Vsync.WriteLine("SetAggregatorValueAndVID: ai.KT<" + ai.KT + "> != KeyType<" + typeof(KeyType) + "> or ai.VT<" + ai.VT + "> != ValueType<" + typeof(ValueType) + ">");
                }

                ++idx;
            }

            throw new VsyncException("SetAggregatorValue: No registered aggregator for group " + this.gname + " has type signature  <" + typeof(KeyType) + "," + typeof(ValueType) + ">");
        }

        /// <summary>
        /// Called by the group leader to obtain the result from an aggregation operation identified by a key.
        /// </summary>
        /// <typeparam name="KeyType">Type for keys in the aggregator</typeparam>
        /// <typeparam name="ValueType">Type for values in the aggregator</typeparam>
        /// <param name="key">A key identifying the aggregation of interest</param>
        /// <returns>The result of the aggregation</returns>
        /// <remarks>
        /// Called by the user to obtain the result from an aggregation operation identified by a key, but can only be performed in the large group leader, which is the zero-ranked member of the view.
        /// The leader should multicast the results to the members if you wish the members to also have this information.  Throws an exception if called in a non-leader.  A timeout will be posted 
        /// (see RegisterAggregator) and in the event that it triggers before the aggregation succeeds, this breaks the wait and returns an aggregation failure exception to the caller.
        /// </remarks>
        public ValueType GetAggregatorResult<KeyType, ValueType>(KeyType key) {
            if (!this.VsyncCallStart()) {
                return default(ValueType);
            }

            tokenInfo theToken = null;
            if ((this.flags & G_ISLARGE) != 0) {
                using (var tmpLockObj = new LockAndElevate(this.TokenLock)) {
                    theToken = this.theToken;
                }
            }

            long mylid = 0;
            if (this.myLoggingFcn != null) {
                this.myLoggingFcn(IL_AGGWAIT, IL_START, Vsync.my_address, mylid = this.newLoggingId(), key);
            }

            try {
                if ((this.flags & G_ISLARGE) != 0 && (theToken == null || !theToken.IAmLgOwner)) {
                    throw new VsyncException("GetAggregatorResult: Can only be called by the rank-zero member");
                }

                int idx = 0;
                foreach (AggInfo ai in this.AggTypes) {
                    if (ai.KT == typeof(KeyType) && ai.VT == typeof(ValueType)) {
                        ValueType val;
                        if ((this.flags & G_ISLARGE) != 0) {
                            val = ((Aggregation<KeyType, ValueType>)theToken.theGroup.AggList[theToken.nlevels - 1].ElementAt(idx)).Get(key);
                        }
                        else {
                            Aggregation<KeyType, ValueType> ag;
                            using (var tmpLockObj = new LockAndElevate(this.AggListLock)) {
                                ag = (Aggregation<KeyType, ValueType>)this.AggList[this.AggList.Length - 1].ElementAt(idx);
                            }

                            val = ag.Get(key);
                        }

                        if (val == null) {
                            throw new AggregationFailedException(2);
                        }

                        if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                            Vsync.WriteLine("GetAggregatorResult in <" + this.gname + "> for " + typeof(KeyType) + ":" + typeof(ValueType) + ", key=" + key + ", value=" + val);
                        }

                        if (this.myLoggingFcn != null) {
                            this.myLoggingFcn(IL_AGGWAIT, IL_DONE, Vsync.my_address, mylid, key, val);
                        }

                        this.VsyncCallDone();
                        return val;
                    }

                    ++idx;
                }

                throw new VsyncException("GetAggregatorResult: No registered aggregator for group " + this.gname + " has type signature  <" + typeof(KeyType) + "," + typeof(ValueType) + ">");
            }
            catch (VsyncShutdownException) {
                throw new AggregationFailedException(3);
            }
        }

        internal const int GotRValue = 0;

        internal const int GotDValue = 1;

        internal const int GotAggRes = 2;

        internal const int GetAggState = 3;

        internal const int GetRank0State = 4;

        internal const int BreakWaits = 5;

        internal const int LEN = 0;

        internal const int VIDS = 1;

        internal const int KEYS = 2;

        internal const int VALS = 3;

        internal class binfo {
            internal Type KT;

            internal Type VT;

            internal object theBarrier = new object();

            internal static List<KeyValuePair<object, object>> theResults = new List<KeyValuePair<object, object>>();

            internal static LockObject theBarrierLock = new LockObject("theBarrierLock");

            internal static List<binfo> theBarrierList = new List<binfo>();

            internal binfo(Type kt, Type vt) {
                this.KT = kt;
                this.VT = vt;
            }

            // Called while holding a Monitor lock on the AggResult object
            internal object getResult(object key) {
                if (key.GetType() != this.KT) {
                    throw new VsyncException("binfo: getResult with wrong key type");
                }

                foreach (KeyValuePair<object, object> res in theResults) {
                    if (res.Key == key) {
                        theResults.Remove(res);
                        return res.Value;
                    }
                }

                return null;
            }

            // Called while holding a Monitor lock on the AggResult object
            internal void saveResult(object key, object value) {
                if (key.GetType() != this.KT || value.GetType() != this.VT) {
                    throw new VsyncException("binfo: saveResult with wrong key or value type");
                }

                foreach (KeyValuePair<object, object> res in theResults) {
                    if (res.Key == key) {
                        theResults.Remove(res);
                        break;
                    }
                }

                theResults.Add(new KeyValuePair<object, object>(key, value));
            }

            internal static binfo getBarrierObject(Type kt, Type vt) {
                using (var tmpLockObj = new LockAndElevate(theBarrierLock)) {
                    foreach (binfo bi in theBarrierList) {
                        if (bi.KT == kt && bi.VT == vt) {
                            return bi;
                        }
                    }

                    binfo newBi = new binfo(kt, vt);
                    theBarrierList.Add(newBi);
                    return newBi;
                }
            }

            internal static void resetBarrierList() {
                using (var tmpLockObj = new LockAndElevate(theBarrierLock)) {
                    theBarrierList = new List<binfo>();
                }
            }
        }

        /// <exclude>
        /// <summary>
        /// Internal class used by Vsync to perform Aggregations, public only to comply with C# scope rules. 
        /// </summary>
        /// <typeparam name="KeyType">Type for keys</typeparam>
        /// <typeparam name="ValueType">Type for values</typeparam>
        /// </exclude>
        public class Aggregation<KeyType, ValueType> : IAggregateEventHandler {
            internal LockObject Alock = new LockObject("Alock"); // Used to protect shared variables

            internal binfo AggResult = binfo.getBarrierObject(typeof(KeyType), typeof(ValueType));

            internal Group myGroup;

            internal int myLevel;

            internal int myVid;

            private readonly Aggregator<KeyType, ValueType> theAggMethod;

            internal volatile bool registered = false;

            internal Timeout AggTimeout;

            internal Address[] Participants(KeyType key, View v) {
                if (!typeof(KeyType).IsGenericType || typeof(KeyType).GetGenericTypeDefinition() != typeof(QueryKey<>)) {
                    return v.members;
                }

                Address[] dests = ((QKD)key).GetDestsToArray(this.myGroup, this.myVid);
                if (dests != null) {
                    return dests;
                }

                // Occurs if the view we are asking about has become stale
                throw new AggregationFailedException(4);
            }

            /// <exclude></exclude>
            public Aggregation(Group g, int vid, int level, Aggregator<KeyType, ValueType> del, Timeout TO) {
                this.myGroup = g;
                this.myVid = vid;
                this.myLevel = level;
                this.theAggMethod = del;
                this.AggTimeout = TO;
                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                    Vsync.WriteLine("Aggregation constructor in <" + g.gname + "> for vid=" + vid + ": creating a new object for Aggregator " + del);
                }
            }

            /// <exclude></exclude>
            public Type GetKeyType() {
                return typeof(KeyType);
            }

            /// <exclude></exclude>
            public Type GetValueType() {
                return typeof(ValueType);
            }

            /// <exclude>
            /// <summary>
            /// Internal method used by Vsync as part of the Aggregation layer, public only to comply with C# scope rules.
            /// </summary>
            /// <returns>dictionary of ldTriples coerced to object type</returns>
            /// </exclude>
            public object GetDValues() {
                return this.ldValues;
            }

            /// <exclude>
            /// <summary>
            /// Internal method used by Vsync as part of the Aggregation layer, public only to comply with C# scope rules.
            /// </summary>
            /// <param name="fromBelow">dictionary of ldTriples from below</param>
            /// </exclude>
            public void LoadDValues(object fromBelow) {
                Dictionary<int, ldTuple<KeyType, ValueType>> belowldValues = (Dictionary<int, ldTuple<KeyType, ValueType>>)fromBelow;
                List<KeyValuePair<int, ldTuple<KeyType, ValueType>>> needDValue = new List<KeyValuePair<int, ldTuple<KeyType, ValueType>>>();
                using (var tmpLockObj = new LockAndElevate(this.Alock)) {
                    foreach (KeyValuePair<int, ldTuple<KeyType, ValueType>> kvp in belowldValues) {
                        if (kvp.Value.hasDValue) {
                            needDValue.Add(kvp);
                        }
                    }
                }

                foreach (KeyValuePair<int, ldTuple<KeyType, ValueType>> kvp in needDValue) {
                    this.SetDValue(kvp.Value.vid, kvp.Value.key, kvp.Value.dValue);
                }
            }

            /// <exclude>
            /// <summary>
            /// Internal method used by Vsync as part of the Aggregation layer, public only to comply with C# scope rules.
            /// </summary>
            /// <param name="etype">event type</param>
            /// <returns>byte[] in the case of GetAggState, else null</returns>
            /// </exclude>
            public byte[] AggEvent(int etype) {
                return this.AggEvent(etype, 0, null, null, 0);
            }

            /// <exclude>
            /// <summary>
            /// Internal method used by Vsync as part of the Aggregation layer, public only to comply with C# scope rules.
            /// </summary>
            /// <param name="etype">event type</param>
            /// <param name="key">key value</param>
            /// <param name="arg">associated argument, or null</param>
            /// <param name="offset">index into key/values array</param>
            /// <param name="vid">viewid if successful, -viewid if failed</param>
            /// <returns>byte[] in the case of GetAggState, else null</returns>
            /// </exclude>
            public byte[] AggEvent(int etype, int vid, object key, object arg, int offset) {
                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                    Vsync.WriteLine("Aggregator in <" + this.myGroup.gname + ">: AggEvent(type=" + etype + ")");
                }

                switch (etype) {
                    case GotRValue:
                        KeyType[] KTA = (KeyType[])key;
                        ValueType[] VTA = (ValueType[])arg;
                        if (KTA != null && KTA.Length > offset && VTA != null && VTA.Length > offset) {
                            this.SetRValue(vid, KTA[offset], VTA[offset]);
                            if (this.myGroup.myLoggingFcn != null) {
                                this.myGroup.myLoggingFcn(IL_AGGLVALUE, IL_START, Vsync.my_address, -1, KTA[offset], VTA[offset]);
                            }
                        }

                        break;

                    case GotDValue:
                        KTA = (KeyType[])key;
                        VTA = (ValueType[])arg;
                        if (KTA != null && KTA.Length > offset && VTA != null && VTA.Length > offset) {
                            this.SetDValue(vid, KTA[offset], VTA[offset]);
                            if (this.myGroup.myLoggingFcn != null) {
                                this.myGroup.myLoggingFcn(IL_AGGDVALUE, IL_START, Vsync.my_address, -1, KTA[offset], VTA[offset]);
                            }
                        }

                        break;

                    case GotAggRes:
                        KTA = (KeyType[])key;
                        VTA = (ValueType[])arg;
                        if (KTA != null && KTA.Length > offset && VTA != null && VTA.Length > offset) {
                            this.SetAggResult(vid, KTA[offset], VTA[offset]);
                        }

                        break;

                    case GetRank0State:

                        // Send known dvalues, and garbage collect them
                        int idx = 0;
                        List<KeyValuePair<int, ldTuple<KeyType, ValueType>>> toSend = new List<KeyValuePair<int, ldTuple<KeyType, ValueType>>>();
                        using (var tmpLockObj = new LockAndElevate(this.Alock)) {
                            Dictionary<int, ldTuple<KeyType, ValueType>> nldValues = new Dictionary<int, ldTuple<KeyType, ValueType>>(Group.tokenInfo.RINGSIZE * 2);

                            foreach (KeyValuePair<int, ldTuple<KeyType, ValueType>> kvp in this.ldValues) {
                                if (kvp.Value.hasDValue) {
                                    toSend.Add(new KeyValuePair<int, ldTuple<KeyType, ValueType>>(kvp.Key.GetHashCode(), kvp.Value));
                                }
                                else {
                                    nldValues.Add(kvp.Key.GetHashCode(), kvp.Value);
                                }
                            }

                            this.ldValues = nldValues;
                        }

                        int len = toSend.Count;
                        int[] vids = new int[len];
                        KeyType[] keys = new KeyType[len];
                        ValueType[] values = new ValueType[len];

                        foreach (AggInfo ai in this.myGroup.AggTypes) {
                            if (ai.KT == typeof(KeyType) && ai.VT == typeof(ValueType)) {
                                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                                    Vsync.WriteLine("Aggregator: GetRank0State<" + typeof(KeyType) + ":" + typeof(ValueType) + ">, computed a vector of length " + toSend.Count + " containing: ");
                                }

                                foreach (KeyValuePair<int, ldTuple<KeyType, ValueType>> kvp in toSend) {
                                    keys[idx] = kvp.Value.key;
                                    vids[idx] = kvp.Value.vid;
                                    values[idx] = kvp.Value.dValue;
                                    if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                                        Vsync.WriteLine("       { vid = " + vids[idx] + ", key=" + keys[idx] + ", value=" + values[idx] + " }");
                                    }

                                    ++idx;
                                }

                                return Msg.toBArray(idx, vids, keys, values);
                            }
                        }

                        break;

                    case GetAggState:

                        // Send values for which we know both the lvalue and the dvalue, and garbage collect them
                        idx = 0;
                        toSend = new List<KeyValuePair<int, ldTuple<KeyType, ValueType>>>();
                        using (var tmpLockObj = new LockAndElevate(this.Alock)) {
                            Dictionary<int, ldTuple<KeyType, ValueType>> nldValues = new Dictionary<int, ldTuple<KeyType, ValueType>>(Group.tokenInfo.RINGSIZE * 2);

                            foreach (KeyValuePair<int, ldTuple<KeyType, ValueType>> kvp in this.ldValues) {
                                if (kvp.Value.hasDValue && kvp.Value.hasRValue) {
                                    toSend.Add(new KeyValuePair<int, ldTuple<KeyType, ValueType>>(kvp.Key.GetHashCode(), kvp.Value));
                                }
                                else if (kvp.Value.hasDValue && Vsync.NOW - kvp.Value.DValueTime > this.AggTimeout.when) {
                                    Vsync.WriteLine("WARNING: Vsync Aggregation is discarding value from below with key=" + kvp.Value.key + " because of a timeout");
                                }
                                else if (kvp.Value.hasRValue && Vsync.NOW - kvp.Value.RValueTime > this.AggTimeout.when) {
                                    Vsync.WriteLine("WARNING: Vsync Aggregation is discarding value from left with key=" + kvp.Value.key + " because of a timeout");
                                }
                                else {
                                    nldValues.Add(kvp.Key.GetHashCode(), kvp.Value);
                                }
                            }

                            this.ldValues = nldValues;
                        }

                        len = toSend.Count;
                        vids = new int[len];
                        keys = new KeyType[len];
                        values = new ValueType[len];

                        foreach (AggInfo ai in this.myGroup.AggTypes) {
                            if (ai.KT == typeof(KeyType) && ai.VT == typeof(ValueType)) {
                                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                                    Vsync.WriteLine("Aggregator: GetAggState<" + typeof(KeyType) + ":" + typeof(ValueType) + ">, computed a vector of length " + toSend.Count + " containing: ");
                                }

                                foreach (KeyValuePair<int, ldTuple<KeyType, ValueType>> kvp in toSend) {
                                    keys[idx] = kvp.Value.key;
                                    vids[idx] = kvp.Value.vid;

                                    // Don't show the view id to the aggregator method; might confuse the developer
                                    long mylid = 0;
                                    if (this.myGroup.myLoggingFcn != null) {
                                        this.myGroup.myLoggingFcn(Group.IL_AGGREGATE, Group.IL_START, Vsync.my_address, mylid = this.myGroup.newLoggingId(), kvp.Value.key, kvp.Value.rValue, kvp.Value.dValue);
                                    }

                                    values[idx] = this.theAggMethod(kvp.Value.key, kvp.Value.rValue, kvp.Value.dValue);
                                    if (this.myGroup.myLoggingFcn != null) {
                                        this.myGroup.myLoggingFcn(Group.IL_AGGREGATE, Group.IL_DONE, Vsync.my_address, mylid, values[idx]);
                                    }

                                    if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                                        Vsync.WriteLine("       { vid = " + vids[idx] + ", key=" + keys[idx] + ", value=" + values[idx] + " }");
                                    }

                                    ++idx;
                                }

                                byte[] result = Msg.toBArray(idx, vids, keys, values);
                                return result;
                            }
                        }

                        throw new VsyncException("VsyncToken: Can't find Aggregate method for <" + typeof(KeyType) + "," + typeof(ValueType) + ">");

                    case BreakWaits:
                        this.BreakMyWaits(vid);
                        break;
                }

                return null;
            }

            /// <exclude></exclude>
            public string AggName() {
                return "VsyncAggregator<" + typeof(KeyType) + ", " + typeof(ValueType) + ">";
            }

            internal class wTI {
                internal Thread who;

                internal KeyType key;

                internal wTI(Thread t, KeyType k) {
                    this.who = t;
                    this.key = k;
                }
            }

            internal List<wTI> WaitingThreads = new List<wTI>();

            /// <exclude></exclude>
            public string AggState() {
                string s = string.Empty;
                using (var tmpLockObj = new LockAndElevate(this.Alock)) {
                    foreach (wTI wti in this.WaitingThreads) {
                        s += "            Thread " + (wti.who.Name ?? "(no name)") + " is waiting for Aggregation Result(Key=" + wti.key + ")" + Environment.NewLine;
                    }

                    foreach (KeyValuePair<int, ldTuple<KeyType, ValueType>> kvp in this.ldValues) {
                        if (kvp.Value.hasDValue) {
                            s += "            Value from below: (Key=" + kvp.Key + ", Value = " + kvp.Value.dValue + ", learned at " + Vsync.MsToSecs(kvp.Value.DValueTime) + ")" + Environment.NewLine;
                        }

                        if (kvp.Value.hasRValue) {
                            s += "            Value from right: (Key=" + kvp.Key + ", Value = " + kvp.Value.rValue + ", learned at " + Vsync.MsToSecs(kvp.Value.RValueTime) + ")" + Environment.NewLine;
                        }
                    }
                }

                return s;
            }

            internal object NULL = new object();

            internal class ldTuple<KT, VT> {
                internal int vid;

                internal bool hasRValue;

                internal long RValueTime;

                internal bool hasDValue;

                internal long DValueTime;

                internal KT key;

                internal VT rValue;

                internal VT dValue;

                internal ldTuple(int v, KT k, object lvalue, VT dvalue) {
                    this.vid = v;
                    this.key = k;
                    this.SetDValue(this.vid, dvalue);
                }

                internal void SetDValue(int v, VT dvalue) {
                    this.dValue = dvalue;
                    this.hasDValue = true;
                    this.DValueTime = Vsync.NOW;
                    if (this.vid == 0) {
                        this.vid = v;
                    }
                    else if (v != 0 && this.vid != v) {
                        this.vid = -v;
                    }
                }

                internal ldTuple(int v, KT k, VT lvalue, object dvalue) {
                    this.vid = v;
                    this.key = k;
                    this.SetRValue(this.vid, lvalue);
                }

                internal void SetRValue(int v, VT lvalue) {
                    this.rValue = lvalue;
                    this.hasRValue = true;
                    this.RValueTime = Vsync.NOW;
                    if (this.vid == 0) {
                        this.vid = v;
                    }
                    else if (v != 0 && this.vid != v) {
                        this.vid = -v;
                    }
                }
            }

            internal Dictionary<int, ldTuple<KeyType, ValueType>> ldValues = new Dictionary<int, ldTuple<KeyType, ValueType>>(Group.tokenInfo.RINGSIZE * 2);

            internal void SetRValue(int vid, KeyType id, ValueType lValue) {
                this.SetRValue(0, vid, id, lValue);
            }

            internal void SetRValue(int level, int vid, KeyType id, ValueType lValue) {
                int hc = id.GetHashCode();
                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                    Vsync.WriteLine("Aggregation: SetRValue for id=" + id + "(hashcode=" + id.GetHashCode() + "), vid = " + vid + ", level=" + level + ", value=" + lValue);
                }

                using (var tmpLockObj = new LockAndElevate(this.Alock)) {
                    ldTuple<KeyType, ValueType> ldp;
                    if (this.ldValues.TryGetValue(hc, out ldp)) {
                        this.detectCollisions(id, ldp.key);
                        ldp.SetRValue(vid, lValue);
                    }
                    else {
                        this.ldValues.Add(hc, new ldTuple<KeyType, ValueType>(vid, id, lValue, this.NULL));
                    }
                }

                this.SendAggIfBothReady(level, vid, id);
            }

            internal void SetDValue(int vid, KeyType id, ValueType dValue) {
                this.SetDValue(0, vid, id, dValue);
            }

            internal void SetDValue(int level, int vid, KeyType id, ValueType dValue) {
                int hc = id.GetHashCode();
                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                    Vsync.WriteLine("Aggregation: SetDValue for id=" + id + ", level=" + level + ", value=" + dValue);
                }

                using (var tmpLockObj = new LockAndElevate(this.Alock)) {
                    ldTuple<KeyType, ValueType> ldp;
                    if (this.ldValues.TryGetValue(hc, out ldp)) {
                        this.detectCollisions(id, ldp.key);
                        ldp.SetDValue(vid, dValue);
                    }
                    else {
                        this.ldValues.Add(hc, new ldTuple<KeyType, ValueType>(vid, id, this.NULL, dValue));
                    }
                }

                this.SendAggIfBothReady(level, vid, id);
            }

            private void detectCollisions(KeyType k1, KeyType k2) {
                if (k1.Equals(k2)) {
                    return;
                }

                throw new VsyncException("Keys " + k1 + " and " + k2 + " have same HashCode but aren't equal!");
            }

            internal void gotRValues(byte[] ba) {
                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                    Vsync.WriteLine("Aggregation: gotRValues");
                }

                object[] obs = Msg.BArrayToObjects(ba, typeof(int[]), typeof(KeyType[]), typeof(ValueType[]));
                int[] vids = (int[])obs[0];
                KeyType[] ids = (KeyType[])obs[1];
                ValueType[] aggs = (ValueType[])obs[2];
                for (int idx = 0; idx < ids.Length; idx++) {
                    this.SetRValue(vids[idx], ids[idx], aggs[idx]);
                }
            }

            internal void gotDValues(byte[] ba) {
                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                    Vsync.WriteLine("Aggregation: gotDValues");
                }

                object[] obs = Msg.BArrayToObjects(ba, typeof(int[]), typeof(KeyType[]), typeof(ValueType[]));
                int[] vids = (int[])obs[0];
                KeyType[] ids = (KeyType[])obs[1];
                ValueType[] aggs = (ValueType[])obs[2];
                for (int idx = 0; idx < ids.Length; idx++) {
                    this.SetDValue(vids[idx], ids[idx], aggs[idx]);
                }
            }

            internal void gotMyAggregates(byte[] ba) {
                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                    Vsync.WriteLine("Aggregation: gotMyAggregates");
                }

                object[] obs = Msg.BArrayToObjects(ba, typeof(int[]), typeof(KeyType[]), typeof(ValueType[]));
                int[] vids = (int[])obs[0];
                KeyType[] ids = (KeyType[])obs[1];
                ValueType[] aggs = (ValueType[])obs[2];
                for (int idx = 0; idx < ids.Length; idx++) {
                    this.SetAggResult(vids[idx], ids[idx], aggs[idx]);
                }
            }

            internal void SetAggResult(int vid, KeyType key, ValueType res) {
                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                    Vsync.WriteLine("Aggregation: SetAggResult for id=" + key + ", level=" + this.myLevel + ", value=" + res);
                }

                Monitor.Enter(this.AggResult.theBarrier);
                this.AggResult.saveResult(key, res);
                Monitor.PulseAll(this.AggResult.theBarrier);
                Monitor.Exit(this.AggResult.theBarrier);
            }

            internal void SendAggIfBothReady(int level, int vid, KeyType key) {
                if ((this.myGroup.flags & Group.G_ISLARGE) != 0) {
                    return;
                }

                View theView;
                using (var tmpLockObj = new LockAndElevate(this.myGroup.ViewLock)) {
                    theView = this.myGroup.theView;
                }

                Address[] participants = this.Participants(key, theView);
                int myRank = 0;
                while (myRank < participants.Length && !participants[myRank].isMyAddress()) {
                    myRank++;
                }

                if (myRank == participants.Length) {
                    throw new VsyncException("SendAggIfBothReady: I'm not in participant list!");
                }

                using (var tmpLockObj = new LockAndElevate(this.Alock)) {
                    ldTuple<KeyType, ValueType> ldp;
                    int id = key.GetHashCode();
                    if (this.ldValues.TryGetValue(id, out ldp)) {
                        if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                            Vsync.WriteLine(".... SendAggIfBothReady at level " + level + ", vid=" + vid + ", key=" + key + ", IAmRightMost=" + this.IAmRightMost(key, level, participants) + ", ldp.hasDValue=" + ldp.hasDValue + ", ldp.hasRValue=" + ldp.hasRValue);
                        }

                        if (this.IAmRightMost(key, level, participants) && ldp.hasDValue) {
                            level = this.AggLevelToSendAt(level, theView, myRank, participants);
                            if (level > this.myGroup.AggList.Length - 1) {
                                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                                    Vsync.WriteLine("SendAggIfBothReady<" + this.myGroup.gname + "> finalizing(1) value for key " + key + ", value " + ldp.dValue);
                                }

                                this.SetAggResult(vid, key, ldp.dValue);
                            }
                            else {
                                ValueType value = ldp.hasRValue ? this.theAggMethod(key, ldp.rValue, ldp.dValue) : ldp.dValue;
                                this.AggSendToNextOnLevel(level, vid, participants, key, value, theView, level, myRank, myRank);
                            }

                            this.ldValues.Remove(id);
                        }
                        else if (ldp.hasDValue && ldp.hasRValue) {
                            int target = myRank & ~(1 << level);
                            level = this.AggLevelToSendAt(level + 1, theView, target, participants);
                            if (level > this.myGroup.AggList.Length - 1) {
                                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                                    Vsync.WriteLine("SendAggIfBothReady<" + this.myGroup.gname + "> finalizing(2) value for key " + key + ", value " + ldp.dValue);
                                }

                                this.SetAggResult(vid, key, ldp.dValue);
                            }
                            else {
                                this.AggSendToNextOnLevel(level, vid, participants, key, this.theAggMethod(key, ldp.rValue, ldp.dValue), theView, level, myRank, target);
                            }

                            this.ldValues.Remove(id);
                        }
                        else if (ldp.hasRValue && level == this.myGroup.AggList.Length - 1) {
                            if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                                Vsync.WriteLine("SendAggIfBothReady<" + this.myGroup.gname + "> finalizing(3) value for key " + key + ", value " + ldp.rValue);
                            }

                            this.SetAggResult(vid, key, ldp.rValue);
                            this.ldValues.Remove(id);
                        }
                    }
                }
            }

            internal bool IAmRightMost(KeyType key, int level) {
                View theView;
                using (var tmpLockObj = new LockAndElevate(this.myGroup.ViewLock)) {
                    theView = this.myGroup.theView;
                }

                return this.IAmRightMost(key, level, this.Participants(key, theView));
            }

            internal bool IAmRightMost(KeyType key, int level, Address[] participants) {
                int rank = this.FindMe(key, participants);
                return ((rank >> level) & 1) != 0 || (rank + (1 << level) >= participants.Length);
            }

            internal bool IAmLeftMost(KeyType key, int level, Address[] participants) {
                return ((this.FindMe(key, participants) >> level) & 1) == 0;
            }

            private int FindMe(KeyType key, Address[] participants = null) {
                if (participants == null) {
                    View theView;
                    using (var tmpLockObj = new LockAndElevate(this.myGroup.ViewLock)) {
                        theView = this.myGroup.theView;
                    }

                    participants = this.Participants(key, theView);
                }

                int myRank = 0;
                while (myRank != participants.Length) {
                    if (participants[myRank].isMyAddress()) {
                        break;
                    }

                    ++myRank;
                }

                if (myRank == participants.Length) {
                    throw new VsyncException("FindMe");
                }

                return myRank;
            }

            private int AggLevelToSendAt(int level, View v, int rank, Address[] participants) {
                while (level < this.myGroup.AggList.Length - 1 && ((rank >> level) & 1) == 0 && (rank + (1 << level)) >= participants.Length) {
                    ++level;
                }

                return level;
            }

            // Sends to the node to the left (the "next" node) of the target, or to the target if there is no node to its left
            private void AggSendToNextOnLevel(int level, int vid, Address[] participants, KeyType key, ValueType value, View theView, int curLevel, int myRank, int targetRank, bool doSend = true) {
                targetRank &= ~(1 << level);
                Address next = (targetRank >= participants.Length) ? participants[0] : participants[targetRank];
                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                    Vsync.WriteLine("AggSendToNextOnLevel<" + this.myGroup.gname + ", key=" + key + ", value=" + value + "> currently level " + curLevel + ", sending  at level " + level + ((myRank >= targetRank) ? ", DValue" : ", RValue") + " to target=" + targetRank + ", id=" + next + " with participants=" + Address.VectorToString(participants));
                }

                if (doSend) {
                    this.myGroup.P2PSend(next, Vsync.SGAGGREGATE, Vsync.my_address, myRank > targetRank, level, vid, Msg.toBArray(key, value));
                }
            }

            /// <exclude>
            /// <summary>
            /// Used for small group aggregation
            /// </summary>
            /// <param name="level"></param>
            /// <param name="vid"></param>
            /// <param name="ko"></param>
            /// <param name="vo"></param>
            /// <param name="fromBelow"></param>
            /// </exclude>
            public void GotSGAggInfo(bool fromBelow, int level, int vid, object ko, object vo) {
                KeyType key = (KeyType)ko;
                ValueType value = (ValueType)vo;
                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                    Vsync.WriteLine("Aggregation: GotSAggInfo: fromBelow=" + fromBelow + ", level=" + level + ", vid=" + vid + ", key=" + key + ", value=" + value);
                }

                if (this.IAmRightMost(key, level) || fromBelow) {
                    this.SetRValue(level, vid, key, value);
                }
                else {
                    this.SetDValue(level, vid, key, value);
                }

                this.SendAggIfBothReady(level, vid, key);
            }

            internal volatile bool unwinding = false;

            internal void BreakMyWaits(int vid) {
                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                    Vsync.WriteLine("Aggregation: Unwinding waits in aggregator for vid=" + this.myVid + " prior to view-driven reinitialization vid=" + vid);
                }

                Monitor.Enter(this.AggResult.theBarrier);

                // Once unwinding is set to true, we're in the midst of discarding this entire
                // aggregation object and creating a new one for the next group view.
                this.unwinding = true;
                Monitor.PulseAll(this.AggResult.theBarrier);
                Monitor.Exit(this.AggResult.theBarrier);
            }

            internal void Set(int vid, KeyType id, ValueType value) {
                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                    Vsync.WriteLine("Aggregation: Set for id=" + id + ", value=" + value);
                }

                Address[] participants;
                using (var tmpLockObj = new LockAndElevate(this.myGroup.ViewLock)) {
                    participants = this.Participants(id, this.myGroup.theView);
                }

                if (participants.Length == 1) {
                    // Special situation: I'm the only member
                    this.SetAggResult(vid, id, value);
                    return;
                }

                this.SetDValue(vid, id, value);
            }

            internal ValueType Get(KeyType id) {
                wTI wti = new wTI(Thread.CurrentThread, id);
                ValueType v = default(ValueType);
                try {
                    using (var tmpLockObj = new LockAndElevate(this.Alock)) {
                        this.WaitingThreads.Add(wti);
                    }

                    if (!VsyncSystem.VsyncActive) {
                        throw new VsyncException("Vsync inactive");
                    }

                    if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                        Vsync.WriteLine("Aggregation: Entry to get for id=" + id);
                    }

                    Monitor.Enter(this.AggResult.theBarrier);
                    while (!this.unwinding && VsyncSystem.VsyncActive) {
                        object theResult = this.AggResult.getResult(id);
                        if (theResult == null) {
                            v = default(ValueType);
                            if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                                Vsync.WriteLine("Await Aggregation result for id=" + id);
                            }

                            if (!Monitor.Wait(this.AggResult.theBarrier, this.AggTimeout.when)) {
                                break;
                            }
                        }
                        else {
                            v = (ValueType)theResult;
                            break;
                        }
                    }

                    Monitor.Exit(this.AggResult.theBarrier);
                    if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                        Vsync.WriteLine("Aggregation: Get for id=" + id + " will return " + ((this.unwinding || v == null) ? "AggregationFailedException exception or timeout" : v.ToString()));
                    }

                    if (this.unwinding || v == null) {
                        throw new AggregationFailedException(1);
                    }
                }
                finally {
                    using (var tmpLockObj = new LockAndElevate(this.Alock)) {
                        this.WaitingThreads.Remove(wti);
                    }
                }

                return v;
            }
        }

        /* A note about the OOB logic.  This code actually always (only) runs in the Vsync.VSYNCMEMBERS group.  However, it can be called
         * from other groups, and when that is done, it records the associated gaddr.  The encipher/decipher logic then uses that gaddr
         * for encryption purposes.  But there really is just one OOB layer for the system, running in VSYNCMEMBERS, and this is why I've
         * declared the Map and Lock objects static -- I wanted to underscore the reasoning so that correctness would be more clear.
         * 
         * The fields of this class are typically updated only through totally ordered multicasts to the OUTOFBAND entry point.  I do
         * use the OOBMapLock when accessing the OOBMap and some care should be taken when printing the obi structure since the Vsync GetState
         * method could run concurrently with some sort of update.  But setting that to the side, the key insight is that this is NOT
         * a good place to put temporary variables while an OOB xfer is underway, because they can pipeline.  In general the state of the
         * OOBInfo variables reflects the OUTOFBAND multicasts processed up to this point in time.  Meanwhile the actual transfers (which
         * can take a while if objects are really big) are occuring in the background, often in threads of their own, and those threads
         * would often be using their own local variables.
         * 
         * Any flags need to be modified or looked at only while in the OUTOFBAND handler methods.  If you just look at them at some
         * random instant in time, you may be seeing a kind of transient state that has no real meaning outside of the step by step
         * progression of the OOB state machine.  This is especially important to understand if looking at code that might somehow
         * effect the state, and that would be non-deterministic if it looked at the flags outside of an OUTOFBAND event upcall!
         */

        internal sealed class OOBInfo : IDisposable {
            internal class wrappedMMF : IDisposable {
                internal MemoryMappedFile mmf;
                internal MemoryMappedViewAccessor mmva;
                internal volatile bool disposed = false;
                internal string fname;

                internal wrappedMMF(string s) {
                    this.fname = s;
                }

                public void Dispose() {
                    Dispose(true);
                }

                public void Dispose(bool disposing) {
                    if (disposed) {
                        return;
                    }

                    disposed = true;
                    if (this.mmva != null) {
                        this.mmva.Dispose();
                        this.mmva = null;
                    }

                    if (this.mmf != null) {
                        this.mmf.Dispose();
                        this.mmf = null;
                    }
                }
            }

            internal volatile int flags;

            internal OBIDeleted OOBdi = new OBIDeleted();

            internal string OOBFname;

            internal long len = -1;

            internal Address gaddr;

            internal wrappedMMF wmmf;

            internal LockObject wmmfLock;

            // Wrapped by Ken to get control over disposal of the mmf pointer
            internal MemoryMappedFile mmf
            {
                get
                {
                    using (var tmpLockObj = new LockAndElevate(wmmfLock))
                        return wmmf == null ? null : wmmf.mmf;
                }
                set
                {
                    using (var tmpLockObj = new LockAndElevate(wmmfLock)) {
                        if (wmmf == null)
                            return;
                        else if (wmmf.mmf != null && value != null)
                            Vsync.WriteLine("WARNING: Wrapped MMF code detected overwrite of an open mmf mapping");
                        else if (value == null && wmmf.mmf != null) {
                            wrappedMMF oldV = wmmf;
                            wmmf = null;
                            //  This is the key step.  Forces immediate Dispose, which closes the mapped file.  
                            //  The entire obi object will be disposed too, soon but this logic doesn't wait for that to happen.
                            oldV.Dispose();
                        }
                        else {
                            wmmf.mmf = value;
                        }
                    }
                }
            }

            // Wrapped by Ken to get control over disposal of the mmva unsafe pointer
            internal MemoryMappedViewAccessor mmva
            {
                get
                {
                    using (var tmpLockObj = new LockAndElevate(wmmfLock))
                        return wmmf == null ? null : wmmf.mmva;
                }
                set
                {
                    using (var tmpLockObj = new LockAndElevate(wmmfLock))
                        if (wmmf != null)
                            wmmf.mmva = value;
                }
            }

            internal List<IPAddress> replicaHomes = new List<IPAddress>();   // Node IP addresses where the mapped file is replicated

            internal List<Address> replicaOwners = new List<Address>();      // One-to-one matched; these are the group members who own each

            internal List<List<IPAddress>> newHomes = new List<List<IPAddress>>();  // Nodes requiring a replica in a ReReplicate operation

            internal List<IPAddress> currentlySendingTo;  // While a transfer is underway, this is a list of where we are sending data

            internal bool[] OOBStatus;  // While transfer is underway, this is a list of block status for the current transfer.  Protected by OOBMapLock

            internal Semaphore mmfReady = new Semaphore(0, int.MaxValue);

            internal static Semaphore xfActive = new Semaphore(1, int.MaxValue);  // By making this static, we ensure that only one transfer can occur at a time

            internal Semaphore busy = new Semaphore(1, int.MaxValue);            // Used (only) to avoid disposing of an OOBInfo object while a transfer is finishing up

            internal volatile Semaphore xfDone;                    // Used as an interlock while doing an RDMA transfer

            public Action<string, MemoryMappedFile> WhenDone;

            internal const int OBI_MASTER = 0x0001;        // Site where OOBRegister was issued.  No need to check that all blocks are ready at that site

            internal const int OBI_FETCHWAIT = 0x0002;     // Mostly for debugging.  Set while someone is waiting on mmfReady

            internal const int OBI_SNDWAIT = 0x0004;       // Mostly for debugging.  Set while someone is waiting on doneSemaphore

            internal const int OBI_DELETE = 0x0008;        // Mostly for debugging.  Set while someone is waiting on xfDone in OOBDelete

            internal const int OBI_SENDING = 0x0010;       // Mostly for debugging.  Set while someone is actively sending

            internal const int OBI_RCVING = 0x0020;        // Mostly for debugging.  Set while someone is actively receiving

            internal const int OBI_INITIALVIEW = 0x0040;   // Used for an OOB transfer of an initial view.  This is tricky: the group itself may not be "live" yet

            internal static string[] fnames = { "MASTER", "Fetch-wait", "Send-wait", "DELETING", "Sending", "Recieving", "xfer-initialview" };

            internal OOBInfo(string OOBFname, View theView)
                : this(OOBFname, false, null, -1, new List<Address>(), null, theView) {
            }

            internal OOBInfo(string OOBFname, bool ready, MemoryMappedFile mmf, long len, List<Address> replicas, Address gaddr, View theView)
                : this(OOBFname, ready, mmf, len, OwnersToIPAddrs(replicas), gaddr, theView) {
            }

            internal OOBInfo(string OOBFname, bool ready, MemoryMappedFile mmf, long len, List<IPAddress> homes, Address gaddr, View theView) {
                bool alreadyAvailable = false;
                this.OOBFname = OOBFname;
                this.len = Math.Max(this.len, len);
                wmmfLock = new LockObject("wmmfLock::" + OOBFname);
                this.wmmf = new wrappedMMF(OOBFname);
                this.gaddr = gaddr;
                this.replicaHomes = homes;
                this.replicaOwners = IPAddrsToOwners(this.replicaHomes, theView);
                if (this.replicaHomes.Contains(Vsync.my_IPaddress)) {
                    if (mmf == null) {
                        try {
#if !__MonoCS__
                            mmf = MemoryMappedFile.OpenExisting(OOBFname);
#else
                            mmf = OpenExisting(OOBFname, len);
#endif
                            this.mmva = mmf.CreateViewAccessor();
                            this.len = OOBGetLength(this);
                            alreadyAvailable = true;
                            this.mmfReady.Release();
                        }
                        catch (NotImplementedException) {
                            // Mono gives this error when it is unable to open a file that actually does exist 
                            // Generally this is a sign of a leak of MMF objects
                            throw new VsyncException("Unable to map file " + OOBFname + "(too many are open)");
                        }
                        catch (IOException e) {
                            if (mmf != null) {
                                mmf.Dispose();
                            }

                            throw new VsyncException("Unable to map file " + OOBFname + " (Mono IOException" + e + ")");
                        }

                        this.OOBStatus = new bool[(int)((this.mmva.Capacity + Vsync.VSYNC_OOBCHUNKSIZE) / Vsync.VSYNC_OOBCHUNKSIZE)];
                        for (int b = 0; b < this.OOBStatus.Length; b++) {
                            this.OOBStatus[b] = true;
                        }
                    }
                }

                if ((this.mmf = mmf) != null && !alreadyAvailable) {
                    this.mmva = mmf.CreateViewAccessor();
                    this.OOBStatus = new bool[(int)((this.mmva.Capacity + Vsync.VSYNC_OOBCHUNKSIZE) / Vsync.VSYNC_OOBCHUNKSIZE)];
                    this.len = OOBGetLength(this);
                }

                if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                    Vsync.WriteLine("Creating a new OOBInfo object: " + OOBFname + ", replicas at " + Address.VectorToString(this.replicaHomes.ToArray()));
                }
            }

            // Caller must hold OOBMapLock
            public override string ToString() {
                string whenDone = this.WhenDone == null ? "(no action)" : "upcall to user-defined method";
                string fstr = " ";
                for (int b = 0; (1 << b) <= this.flags; b++) {
                    if ((this.flags & (1 << b)) != 0) {
                        fstr += fnames[b] + " ";
                    }
                }

                string bvec = ", block-status=[";
                if (this.OOBStatus != null) {
                    if (this.OOBStatus.All(b => !b))
                        bvec += "0 ... 0 (len=" + this.OOBStatus.Length + ")";
                    else if (this.OOBStatus.All(b => b))
                        bvec += "1 ... 1 (len=" + this.OOBStatus.Length + ")";
                    else foreach (bool b in this.OOBStatus) {
                            bvec += b ? "1" : "0";
                        }
                    bvec += "]";
                }

                return "    [" + this.OOBFname + "]: " + ((this.mmf != null) ? "locally-mapped" : "no local replica") +
                    (fstr.Length > 1 ? ", flags=[" + fstr + "]" : string.Empty) + (this.OOBStatus != null ? bvec : string.Empty) +
                    ", current replication pattern=" + Address.VectorToString(this.replicaHomes.ToArray()) +
                    (this.newHomes.Count == 0 ? "" : " future=" + Address.VectorToString(this.newHomes)) +
                    (whenDone ?? (", when done: " + whenDone));
            }

            /// <exclude></exclude>
            public void Dispose() {
                this.Dispose(true);
            }

            private bool disposed;

            /// <exclude></exclude>
            private void Dispose(bool disposing) {
                if (this.disposed) {
                    return;
                }

                this.disposed = true;
                this.mmfReady.Dispose();
                this.busy.Dispose();
                if (this.xfDone != null) {
                    this.xfDone.Dispose();
                    this.xfDone = null;
                }
                this.mmf = null;
            }
        }

        internal static Dictionary<string, OOBInfo> OOBMap = new Dictionary<string, OOBInfo>(1000);

        internal static LockObject OOBMapLock = new LockObject("OOBMapLock");

        /// <summary>
        /// Used to create a new OutOfBand object representing the designated memory-mapped file.  Called only once,
        /// by the first group member to map the object.
        /// </summary>
        /// <param name="OOBFname">The file name</param>
        /// <param name="mmf">The memory mapped file handle</param>
        public void OOBRegister(string OOBFname, MemoryMappedFile mmf) {
            this.OOBRegister(OOBFname, this.gaddr, mmf);
        }

        private void OOBRegister(string OOBFname, Address gaddr, MemoryMappedFile mmf) {
            this.flags |= G_USESOOB;
            if (this != Vsync.VSYNCMEMBERS) {
                Vsync.VSYNCMEMBERS.OOBRegister(OOBFname, gaddr, mmf);
                return;
            }

            this.OOBRegister(false, OOBFname, gaddr, mmf, new List<Address> { Vsync.my_address });
        }

        /// <summary>
        /// Register a memory-mapped ax-file and a list of locations where copies exist.  Called only once, by a member.
        /// MMf should be null if the caller itself isn't in the "where" list
        /// </summary>
        /// <param name="OOBFname">The file name</param>
        /// <param name="mmf">The memory mapped object</param>
        /// <param name="where">Where copies can be found</param>
        public void OOBRegister(string OOBFname, MemoryMappedFile mmf, List<Address> where) {
            this.OOBRegister(false, OOBFname, this.gaddr, mmf, where);
        }

        internal void OOBRegister(bool registerSpecial, string OOBFname, Address gaddr, MemoryMappedFile mmf, List<Address> where) {
            long len = -1;
            this.flags |= G_USESOOB;
            if (this != Vsync.VSYNCMEMBERS) {
                Vsync.VSYNCMEMBERS.OOBRegister(false, OOBFname, gaddr, mmf, where);
                return;
            }

            View theView;
            using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.ViewLock)) {
                theView = Vsync.VSYNCMEMBERS.theView;
            }

            using (var tmpLockObj = new LockAndElevate(OOBMapLock)) {

                if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                    Vsync.WriteLine("OOBUpdateRegistry:" + Environment.NewLine + OOBState(null, true));
                }

                OOBInfo obi = null;
                if (!OOBMap.TryGetValue(OOBFname, out obi)) {
                    if (where.Count > 0) {
                        OOBMap.Add(OOBFname, obi = new OOBInfo(OOBFname, mmf != null, mmf, -1, where, gaddr, theView));
                    }

                    for (int n = 0; n < obi.OOBStatus.Length; n++) {
                        obi.OOBStatus[n] = true;
                    }
                }
                else {
                    if (where.Count == 0) {
                        if ((obi.flags & ~OOBInfo.OBI_MASTER) != 0) {
                            Vsync.WriteLine("WARNING: Internal logic for OOBDelete is running but a prior OOB request on this file is still active!" + obi);
                        }

                        obi.mmf = null;
                        if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                            Vsync.WriteLine("Delete existing OOBInfo object: " + OOBFname);
                        }
                    }
                    else {
                        obi.replicaHomes = obi.replicaHomes.Union(OwnersToIPAddrs(where)).ToList();
                        obi.replicaOwners = IPAddrsToOwners(obi.replicaHomes, theView);
                    }
                }

                if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                    Vsync.WriteLine("Update existing OOBInfo object: " + OOBFname + " set MASTER mode, release mmf-ready semaphore, replicas at " + Address.VectorToString(obi.replicaHomes.ToArray()));
                }

                obi.flags |= OOBInfo.OBI_MASTER;
                obi.mmfReady.Release();
                len = OOBGetLength(obi);
            }

            if (!registerSpecial) {
                this.OrderedSend(Vsync.OUTOFBAND, OOBFname, gaddr, len, where);
            }
            else {
                // Special for initial view state transfer only
                this.doOOBUpdateRegistry(OOBFname, gaddr, len, where);
            }
        }

        /// <summary>
        /// OOB subsystem will do an upcall to this method when a new OOB file is received, if the method is specified.
        /// </summary>
        /// <param name="OOBFname">Filename of the received OOB file</param>
        /// <param name="mmf">Memory mapped file handle for it</param>
        public delegate void OOBCompletionNotifier(string OOBFname, MemoryMappedFile mmf);

        internal static OOBCompletionNotifier theNotifier;

        /// <summary>
        /// OOB subsystem will do an upcall to this method when a new OOB file is received, if the method is specified.
        /// </summary>
        /// <param name="tn">The method to call</param>
        public static void OOBSetCompletionNotifier(OOBCompletionNotifier tn) {
            theNotifier = tn;
        }

        /// <summary>
        /// Modify the replication pattern for the designated object using the new list of desired locations
        /// </summary>
        /// <param name="OOBFname">File name</param>
        /// <param name="where">New pattern</param>
        public void OOBReReplicate(string OOBFname, List<Address> where) {
            this.OOBReReplicate(OOBFname, where, null, this.gaddr);
        }

        /// <summary>
        /// Modify the replication pattern for the designated object using the new list of desired locations
        /// </summary>
        /// <param name="OOBFname">File name</param>
        /// <param name="where">New pattern</param>
        /// <param name="whenDone">Callback when rereplication is finished</param>
        /// <remarks>It is important for the caller to be aware that the whenDone callback occurs as soon as the file copies reach the remote nodes; 
        /// there is no built-in barrier to wait until OOBFetch has actually been called by all the remote receivers.  Thus if you plan to call
        /// OOBDelete inside your whenDone method, you should also be careful to implement any needed barrier (otherwise, a race would occur
        /// between the delete operation and the OOBFetch operation).   </remarks>
        public void OOBReReplicate(string OOBFname, List<Address> where, Action<string, MemoryMappedFile> whenDone) {
            this.OOBReReplicate(OOBFname, where, whenDone, this.gaddr);
        }

        private void OOBReReplicate(string OOBFname, List<Address> where, Action<string, MemoryMappedFile> whenDone, Address gaddr) {
            if (this != Vsync.VSYNCMEMBERS) {
                Vsync.VSYNCMEMBERS.OOBReReplicate(OOBFname, where, whenDone, gaddr);
                return;
            }

            this.OOBReReplicate(false, new List<OOBRepInfo> { new OOBRepInfo(OOBFname, gaddr, -1, where.Select(a => a.home).Distinct().ToList()) }, whenDone);
        }

        /// <summary>
        /// Modify the replication pattern for the designated objects using the new list of desired locations
        /// </summary>
        /// <param name="repInfo">Summary of a set of desired rereplication actions</param>
        /// <param name="whenDone">Callback when rereplication finishes. </param>
        /// <remarks>It is important for the caller to be aware that the whenDone callback occurs as soon as the file copies reach the remote nodes; 
        /// there is no built-in barrier to wait until OOBFetch has actually been called by all the remote receivers.  Thus if you plan to call
        /// OOBDelete inside your whenDone method, you should also be careful to implement any needed barrier (otherwise, a race would occur
        /// between the delete operation and the OOBFetch operation).   </remarks>
        public void OOBReReplicate(List<OOBRepInfo> repInfo, Action<string, MemoryMappedFile> whenDone) {
            this.OOBReReplicate(false, repInfo, whenDone);
        }

        internal void OOBReReplicate(bool registerSpecial, List<OOBRepInfo> repInfo, Action<string, MemoryMappedFile> whenDone) {
            if (this != Vsync.VSYNCMEMBERS) {
                Vsync.VSYNCMEMBERS.OOBReReplicate(repInfo, whenDone);
                return;
            }

            if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                foreach (OOBRepInfo ri in repInfo) {
                    Vsync.WriteLine("    OOBReReplicate: file " + ri.OOBFname + ", ...  New replica pattern=[ " + Address.VectorToString(ri.OOBHomes.ToArray()) + " ]");
                    if (ri.OOBHomes.Count == 0)
                        Vsync.WriteLine("... DELETION WAS INITIATED FROM " + Vsync.ExtractStackTrace());
                }
            }

            foreach (OOBRepInfo ri in repInfo) {
                using (var tmpLockObj = new LockAndElevate(OOBMapLock)) {
                    OOBInfo obi;
                    if (OOBMap.TryGetValue(ri.OOBFname, out obi)) {
                        if (ri.OOBHomes.Count > 0 && !ri.OOBHomes.Intersect(obi.replicaHomes).Any()) {
                            throw new VsyncException("OOBReReplicate: New replicas " + Address.VectorToString(ri.OOBHomes.ToArray()) + " are required to overlap with locations of old replicas " + Address.VectorToString(obi.replicaHomes.ToArray()) + "(consider splitting the request into two subrequests)");
                        }
                    }
                    else {
                        throw new VsyncException("OOBReReplicate: File name " + ri.OOBFname + " must be registered before ReReplication is requested");
                    }

                    if (registerSpecial) {
                        obi.flags |= OOBInfo.OBI_INITIALVIEW;
                    }

                    obi.WhenDone = whenDone;
                }
            }

            this.OrderedSend(Vsync.OUTOFBAND, repInfo);
        }

        internal static int OOBInUse;

        internal static List<OOBInfo> OOBWaitList = new List<OOBInfo>();

        internal void doOOBUpdateRegistry(string OOBFname, Address gaddr, long len, List<Address> where) {
            this.doOOBUpdateRegistry(new List<OOBRepInfo> { new OOBRepInfo(OOBFname, gaddr, len, OwnersToIPAddrs(where)) });
        }

        // Normally called via a totally ordered multicast to Vsync.OUTOFBAND hence runs as a state machine.
        // Special case: also called on an initial view, but that's handled in a kind of clunky way
        internal void doOOBUpdateRegistry(List<OOBRepInfo> repInfo) {
            View theView;
            using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.ViewLock)) {
                theView = Vsync.VSYNCMEMBERS.theView;
            }

            this.flags |= G_USESOOB;
            foreach (OOBRepInfo ri in repInfo) {
                bool createdNew = false;
                List<IPAddress> newCopies = new List<IPAddress>();
                List<IPAddress> unNeeded = new List<IPAddress>();
                // We do use the OOBMapLock but keep in mind that the thing that really matters is that the fields
                // of the obi object are updated state-machine style triggered by totally ordered multicasts
                using (var tmpLockObj = new LockAndElevate(OOBMapLock)) {
                    OOBInfo obi;
                    if (!OOBMap.TryGetValue(ri.OOBFname, out obi)) {
                        if (ri.OOBHomes.Count == 0) {
                            continue;
                        }

                        obi = new OOBInfo(ri.OOBFname, false, null, ri.len, ri.OOBHomes, ri.gaddr, theView);
                        OOBMap.Add(ri.OOBFname, obi);
                        createdNew = true;
                        obi.replicaHomes = ri.OOBHomes;
                        obi.replicaOwners = IPAddrsToOwners(obi.replicaHomes, theView);
                    }
                    else if (ri.OOBHomes.Count == 0) {
                        this.OOBRemoveObi(obi);
                        continue;
                    }
                    else {
                        obi.len = Math.Max(obi.len, ri.len);
                        if (obi.replicaHomes.Count == 0) {
                            createdNew = true;
                            obi.replicaHomes = ri.OOBHomes;
                            obi.replicaOwners = IPAddrsToOwners(obi.replicaHomes, theView);
                        }
                    }

                    if (!createdNew) {
                        foreach (IPAddress w in ri.OOBHomes) {
                            if (!obi.replicaHomes.Contains(w)) {
                                newCopies.Add(w);
                            }
                        }

                        foreach (IPAddress w in obi.replicaHomes) {
                            if (!ri.OOBHomes.Contains(w)) {
                                unNeeded.Add(w);
                            }
                        }
                    }

                    if (obi.mmf != null) {
                        if (unNeeded.Contains(Vsync.my_address.home)) {
                            obi.flags = 0;
                            OOBRemoveObi(obi);
                        }
                    }

                    if (newCopies.Count > 0) {
                        obi.newHomes.Add(newCopies);
                        OOBWaitList.Add(obi);
                    }
                    else {
                        if ((obi.flags & OOBInfo.OBI_FETCHWAIT) != 0) {
                            OOBOpenLocalReplica(obi);
                        }
                        OOBWhenDoneCallback(obi);
                    }

                    if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                        Vsync.WriteLine(OOBState(null, true));
                    }
                }
            }

            this.OOBCheckQ();
        }

        internal static LockObject obiCBLock = new LockObject("obiCBLock");

        private static void OOBWhenDoneCallback(OOBInfo obi) {
            using (var tmpLockObj = new LockAndElevate(obiCBLock)) {
                if (obi.WhenDone != null) {
                    var WhenDone = obi.WhenDone;
                    new Thread(delegate () { Thread.CurrentThread.Name = "OOB WhenDone caller thread"; WhenDone(obi.OOBFname, obi.mmf); }).Start();
                    obi.WhenDone = null;
                }
            }
        }

        // Caller holds lock on OOBMapLock
        private void OOBRemoveObi(OOBInfo obi) {
            if (!OOBMap.ContainsKey(obi.OOBFname)) {
                return;
            }

            OOBMap.Remove(obi.OOBFname);
            new Thread(() => {
                if ((obi.flags & (OOBInfo.OBI_FETCHWAIT | OOBInfo.OBI_SENDING)) != 0) {
                    Vsync.WriteLine("WARNING: OOBDelete while transfer was active");
                }

                ILock.NoteThreadState(obi.OOBFname + ".busy (OOBRemoveOBI).WaitOne()");
                obi.busy.WaitOne();
                ILock.NoteThreadState(null);
                obi.busy.Dispose();
                obi.busy = null;
                obi.mmf = null;

                if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                    Vsync.WriteLine("doOOBUpdateRegistry/Delete existing OOBInfo object: " + obi.OOBFname);
                }
            }) { Name = "OOB Cleanup Thread for " + obi.OOBFname, IsBackground = true }.Start();
        }

        internal static string OOBState(Group g, bool locked) {
            Dictionary<string, OOBInfo> copyOfOOBMap = null;
            List<OOBInfo> copyOfOOBWaitList = null;
            if (locked) {
                copyOfOOBMap = new Dictionary<string, OOBInfo>(OOBMap);
                copyOfOOBWaitList = new List<OOBInfo>(OOBWaitList);
            }
            else {
                using (Semaphore copyReady = new Semaphore(0, 1)) {
                    new Thread(() => {
                        Thread.CurrentThread.Name = "OOBMapCloner";
                        try {
                            using (var tmpLockObj = new LockAndElevate(OOBMapLock)) {
                                copyOfOOBMap = new Dictionary<string, OOBInfo>(OOBMap);
                                copyOfOOBWaitList = new List<OOBInfo>(OOBWaitList);
                                try { copyReady.Release(); }
                                catch (ObjectDisposedException) { }
                            }
                        }
                        catch (Exception e) {
                            throw new VsyncException("OOBMapCloner: " + e);
                        }

                        VsyncSystem.ThreadTerminationMagic();
                    }).Start();
                    if (!copyReady.WaitOne(30000)) {
                        return "Unable to report OOBState";
                    }
                }
            }

            string s = string.Empty;
            if (g == Vsync.VSYNCMEMBERS || g == null) {
                s += "OOBWaitList: { ";
                foreach (OOBInfo obi in copyOfOOBWaitList) {
                    s += obi.OOBFname + " ";
                }

                s += "}" + Environment.NewLine;
                foreach (KeyValuePair<string, OOBInfo> kvp in copyOfOOBMap) {
                    s += kvp.Value + Environment.NewLine;
                }
            }
            else {
                bool matched = false;
                s += "OOB files associated with this group: { ";
                foreach (KeyValuePair<string, OOBInfo> kvp in copyOfOOBMap) {
                    if (kvp.Value.gaddr == g.gaddr) {
                        matched = true;
                        s += kvp.Value.OOBFname + " ";
                    }
                }

                if (!matched) {
                    return string.Empty;
                }

                s += "}" + Environment.NewLine;
            }

            return s;
        }

        private const int CHUNKSPERTRY = 75;

        private const int LOWATERMARK = 20;

        private readonly List<byte[]> RecycledBuffers = new List<byte[]>();

        internal delegate int qmethod(int nr, params object[] obs);

        // Called from someone who received an OrderedSend.  
        internal void OOBCheckQ() {
            OOBCheckQ(null);
        }

        internal static void OOBCheckQ(OOBInfo obi) {
            List<Address> newOwners;
            View theView;
            using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.ViewLock)) {
                theView = Vsync.VSYNCMEMBERS.theView;
            }

            using (var tmpLockObj = new LockAndElevate(OOBMapLock)) {
                if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                    string allofem = " ";
                    foreach (OOBInfo oobi in OOBWaitList) {
                        allofem += oobi.OOBFname + " ";
                    }

                    if (allofem.Length > 1) {
                        allofem = "waitlist={" + allofem + "}, Count=" + OOBWaitList.Count;
                    }

                    Vsync.WriteLine("**** Entered checkOOBQ[" + (obi == null ? allofem : obi.OOBFname) + "]: OOBInUse=" + OOBInUse + " (limit is " + (Vsync.OOBMAXIPMCADDRS - 1) + "), WaitList.Count=" + OOBWaitList.Count + Environment.NewLine + OOBState(null, true));
                }

                if (OOBInUse == Vsync.OOBMAXIPMCADDRS - 1) {
                    return;
                }

                if (obi == null) {
                    int which;
                    int nWaiting = OOBWaitList.Count;
                    for (which = 0; which < nWaiting; which++) {
                        obi = OOBWaitList[which];
                        bool overlapsActiveXfer = false;
                        foreach (KeyValuePair<string, OOBInfo> oobi in OOBMap) {
                            if (oobi.Value.currentlySendingTo != null && (oobi.Value.currentlySendingTo.Intersect(obi.newHomes[0]).Any() || obi.newHomes.Count == 0)) {
                                overlapsActiveXfer = true;
                                break;
                            }
                        }

                        if (!overlapsActiveXfer) {
                            break;
                        }
                    }

                    if (which == nWaiting) {
                        // Don't schedule it now: there is an already-active transfer that has an overlapping participant set
                        return;
                    }

                    OOBWaitList.Remove(obi);
                    newOwners = IPAddrsToOwners(obi.newHomes[0], theView);
                    obi.currentlySendingTo = obi.newHomes[0];
                    obi.newHomes.RemoveAt(0);
                }
                else {
                    newOwners = IPAddrsToOwners(obi.currentlySendingTo, theView);
                }
            }

            ILock.NoteThreadState("While loop in OOBCheckQ");
            while (!(newOwners.Contains(Vsync.my_address) || obi.replicaHomes.Contains(Vsync.my_IPaddress) || !Vsync.VSYNCMEMBERS.theView.GetHomeRep(Vsync.my_IPaddress).isMyAddress()) ||
                (!Vsync.VSYNC_UNICAST_ONLY && !Vsync.VSYNC_INFINIBAND && (!obi.replicaHomes.Contains(Vsync.my_address.home) || (obi.flags & OOBInfo.OBI_MASTER) == 0)) ||
                (obi.flags & OOBInfo.OBI_SENDING) != 0) {
                if (obi.replicaHomes.Contains(Vsync.my_IPaddress)) {
                    Address owner = IPAddrsToOwners(new List<IPAddress>() { Vsync.my_IPaddress }, theView)[0];
                    if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                        Vsync.WriteLine("**** checkOOBQ: Someone else is the replica owner.  Sync against that other member... I am " + Vsync.my_address + ", he is " + owner);
                    }

                    if (Vsync.VSYNCMEMBERS.P2PQuery(owner, Vsync.OUTOFBAND, Vsync.my_IPaddress, obi.OOBFname, Group.EOL, new List<bool>())) {
                        ILock.NoteThreadState(null);
                        // In this case, someone else was the IP leader.  We just waited for transfer to finish on that node.  Now map it, and then consider the object safe on this node
                        OOBSetupmmf(obi);
                        OOBReplicaIsReady(obi, true);
                        OOBWhenDoneCallback(obi);
                        return;
                    }

                    // If we reach this line, a failure of the owner changed the replication pattern.  Recheck the replication pattern (after checking for a new view)
                    using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.ViewLock)) {
                        theView = Vsync.VSYNCMEMBERS.theView;
                    }
                    if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                        Vsync.WriteLine("**** checkOOBQ: a failure impacted the replication pattern.  Looping");
                    }

                    continue;
                }

                obi.replicaHomes = obi.replicaHomes.Union(obi.currentlySendingTo).ToList();
                if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                    Vsync.WriteLine("**** checkOOBQ: Decided to take no action: newCopies.Contains(Vsync.my_address)=" + newOwners.Contains(Vsync.my_address) + " || !obi.replicas.Contains(Vsync.my_address)=" + obi.replicaHomes.Contains(Vsync.my_address.home) + " || !Vsync.VSYNCMEMBERS.theView.GetHomeRep(Vsync.my_IPaddress).isMyAddress()=" + !Vsync.VSYNCMEMBERS.theView.GetHomeRep(Vsync.my_IPaddress).isMyAddress() + "|| (obi.flags&OOBInfo.OBI_MASTER) == 0 (actually " + (obi.flags & OOBInfo.OBI_MASTER) + ") || (obi.flags&OBI_SENDING)=" + (obi.flags & OOBInfo.OBI_SENDING));
                }

                ILock.NoteThreadState(null);
                if (obi.WhenDone != null) {
                    obi.WhenDone(obi.OOBFname, obi.mmf);
                    obi.WhenDone = null;
                }

                return;
            }

            ILock.NoteThreadState("Launch thread in OOBCheckQ");
            new Thread(() => {
                ILock.NoteThreadState("xfActive");
                OOBInfo.xfActive.WaitOne();
                ILock.NoteThreadState(obi.OOBFname + ".busy(send thread).WaitOne()");
                obi.busy.WaitOne();
                ILock.NoteThreadState(null);
                if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                    Vsync.WriteLine("**** checkOOBQ setting ACTIVE flag for " + obi.OOBFname + "... newCopies=" + Address.VectorToString(newOwners.ToArray()));
                }

                try {
                    obi.flags |= OOBInfo.OBI_SENDING;
                    ++OOBInUse;
                    long len = OOBGetLength(obi);
                    if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                        Vsync.WriteLine("**** checkOOBQ: Thread launch with len=" + len);
                    }

                    List<IPAddress> currentCopies = new List<IPAddress>(obi.replicaHomes);
                    // Caution: This code runs in a separate thread, concurrently with the thread that created it.  Fields in obi can change and we have no lock on them!
                    int nchunks = (int)((len + Vsync.VSYNC_OOBCHUNKSIZE - 1) / Vsync.VSYNC_OOBCHUNKSIZE);
                    if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                        Vsync.WriteLine("Initiating OOBXFER for " + obi.OOBFname + "(nchunks=" + nchunks + ", total file size = " + OOBGetLength(obi) + ")");
                    }

                    qmethod QueryMethod;
                    if ((obi.flags & OOBInfo.OBI_INITIALVIEW) != 0) {
                        QueryMethod = Vsync.VSYNCMEMBERS.doPlatformLevelQuery;
                    }
                    else {
                        QueryMethod = Vsync.VSYNCMEMBERS.Query;
                    }

                    if (Vsync.VSYNC_INFINIBAND) {
                        if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                            Vsync.WriteLine("OOB INFINIBAND case: newCopies=" + Address.VectorToString(newOwners.ToArray()));
                        }

                        ILock.NoteThreadState("OOBViaRDMA");
                        OOBViaRDMA(obi, len, nchunks, currentCopies, newOwners, QueryMethod, theView);
                        ILock.NoteThreadState(null);
                    }
                    else if (Vsync.VSYNC_UNICAST_ONLY) {
                        if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                            Vsync.WriteLine("OOB UNICAST case: newCopies=" + Address.VectorToString(newOwners.ToArray()));
                        }

                        ILock.NoteThreadState("OOBViaUnicast");
                        OOBViaUnicast(obi, currentCopies, newOwners, len, nchunks);
                        ILock.NoteThreadState(null);
                    }
                    else {
                        if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                            Vsync.WriteLine("OOB multicast (IPMC) case: newCopies=" + Address.VectorToString(newOwners.ToArray()));
                        }

                        bool[] chunkAcked = new bool[nchunks];
                        int allAckedTo = -1;
                        IPEndPoint remoteEP = null;
                        Socket sendSock = null;
                        int ipmcaddr = MCMDSocket.AllocateAddr();
                        string mcaddr = MCMDSocket.PMCAddr(ipmcaddr);
                        List<bool[]> outcomes = new List<bool[]>();

                        // We'll ignore the INFINIBAND-relayed aspects of the response but we do need
                        // to collect them because Vsync will complain if we don't...
                        QueryMethod(ALL, new Timeout(5000, Timeout.TO_FAILURE), newOwners, Vsync.OUTOFBAND, mcaddr, obi.OOBFname, obi.gaddr ?? Vsync.VSYNCMEMBERS.gaddr,
                            nchunks, len, currentCopies, Vsync.NULLADDRESS, new Address[0], new int[0], 0, EOL,
                            outcomes, new List<int>(), new List<int>(), new List<IPAddress>());
                        chunkAcked = OOBUpdateStatus("initialization", obi, newOwners, nchunks, ref allAckedTo, outcomes);
                        IPAddress physIP = Vsync.LastIPv4(mcaddr);
                        remoteEP = MCMDSocket.GetIPEndPoint(physIP);
                        sendSock = MCMDSocket.MCMDSockSetup(physIP);
                        ILock.NoteThreadState("While loop calling OOBViaIPMC in sub-thread launched from OOBCheckQ");
                        while (chunkAcked != null && chunkAcked.Contains(false) && VsyncSystem.VsyncActive) {
                            OOBViaIPMC(obi, nchunks, chunkAcked, remoteEP, sendSock, allAckedTo);
                            outcomes = new List<bool[]>();
                            if (QueryMethod(ALL, new Timeout(600000, Timeout.TO_FAILURE), newOwners, Vsync.OUTOFBAND, obi.OOBFname, nchunks, EOL, outcomes) == 0) {
                                break;
                            }

                            chunkAcked = OOBUpdateStatus("query status", obi, newOwners, nchunks, ref allAckedTo, outcomes);
                            if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                                string ostr = string.Empty;
                                foreach (bool[] oc in outcomes) {
                                    ostr += Environment.NewLine + "---         [";
                                    for (int b = 0; b < chunkAcked.Length; b++) {
                                        ostr += oc[b] ? "1" : "0";
                                    }

                                    ostr += "]";
                                }

                                Vsync.WriteLine("Sender for " + obi.OOBFname + " expected " + newOwners.Count + " replies, got " + outcomes.Count + "; allAckedTo=" + allAckedTo + ", chunkAcked=" + ostr);
                            }
                        }

                        ILock.NoteThreadState(null);
                        MCMDSocket.DeAllocateAddr(ipmcaddr);
                        sendSock.Close();
                    }
                }
                catch (IOException) {
                }
                catch (SocketException) {
                }


                if ((VsyncSystem.Debug & VsyncSystem.IBDB) != 0) {
                    Vsync.WriteLine("After loop: finished with IB send!");
                }

                if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                    Vsync.WriteLine("Successful completion of OOBXFER for " + obi.OOBFname);
                }

                ILock.NoteThreadState("Finalizing status in subthread in OOBCheckQ");
                --OOBInUse;
                obi.flags &= ~OOBInfo.OBI_SENDING;
                OOBInfo.xfActive.Release();
                obi.busy.Release();

                OOBReplicaIsReady(obi, false);
                Vsync.VSYNCMEMBERS.OrderedSend(Vsync.OUTOFBAND, obi.OOBFname);
                if (obi.WhenDone != null) {
                    obi.WhenDone(obi.OOBFname, obi.mmf);
                    obi.WhenDone = null;
                }
                ILock.NoteThreadState(null);
            }) { Name = "OOB file send thread for " + obi.OOBFname, IsBackground = true }.Start();
            ILock.NoteThreadState(null);
        }

        internal static void OOBSetupmmf(OOBInfo obi) {
            OOBSetupmmf(obi, obi.OOBFname, obi.len);
            if (obi.mmf == null) {
                throw new VsyncException("OOBSetupmmf unsuccessful");
            }
        }

        // The absurd paranoia and odd structure here tries to overcome bugs in the Mono implementation of mapped files
        // I'm sure that if I really had a deep understanding of the problem in Mono I could clean this up a lot!
        internal static void OOBSetupmmf(OOBInfo obi, string OOBFname, long len) {
            if (obi.mmf != null) {
                return;
            }

            try {
                File.Delete(OOBFname);
            }
            catch (FileNotFoundException) {
            }

            if (len == -1) {
#if __MonoCS__
                    obi.mmf = OpenExisting(OOBFname, len);
#else
                obi.mmf = MemoryMappedFile.OpenExisting(OOBFname);
#endif
            }
            else {
                try {
                    obi.mmf = CreateNew(OOBFname, len);
                }
                catch (FileNotFoundException) {
                }
                catch (IOException) {
                }
            }

            if (obi.mmf == null) {
                throw new VsyncException("Vsync OOB xfer was unable to open/memory-map file " + OOBFname);
            }

            obi.mmva = obi.mmf.CreateViewAccessor();
            if (len > 0)
                obi.mmva.WriteArray(len - 1, new byte[] { 0 }, 0, 1);

        }

        internal static List<Address> IPAddrsToOwners(List<IPAddress> homes, View theView) {
            List<Address> Owners = new List<Address>();
            foreach (IPAddress ipa in homes) {
                bool fnd = false;
                for (int r = 0; !fnd && r < theView.members.Length; r++) {
                    Address a = theView.members[r];
                    if (a.home.Equals(ipa) && !theView.hasFailed[r]) {
                        using (var tmpLockObj = new LockAndElevate(Vsync.RIPLock))
                            if (Vsync.RIPList.Contains(a)) {
                                // In fact this should never happen and it seems a bit paranoid to even check.  Remove this if the warning never prints... fix it
                                // if it ever does print!  My intention is to avoid any risk of an infinite loop in OOBCheckQ
                                Vsync.WriteLine("WARNING: IPAddrsToOwners: " + a + " is live in " + theView.gaddr + ", but failed in the Vsync.RIPList!");
                                continue;
                            }

                        Owners.Add(a);
                        fnd = true;
                    }
                }
            }

            return Owners;
        }

        internal static List<IPAddress> OwnersToIPAddrs(List<Address> owners) {
            return owners.Select(a => a.home).Distinct().ToList<IPAddress>();
        }

        /// <summary>
        ///  A normal multicast-based OOB send.  This will generally be slower than RDMA because of marshalling and copying
        /// </summary>
        private static void OOBViaIPMC(OOBInfo obi, int nchunks, bool[] chunkAcked, IPEndPoint remoteEP, Socket sendSock, int allAckedTo) {
            if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                Vsync.WriteLine("In OOBViaIPMC case for OOB rereplicate(nchunks=" + nchunks + ")");
            }

            int toSend = 0;
            for (int n = nchunks - 1; n >= allAckedTo && toSend < CHUNKSPERTRY; --n) {
                if (!chunkAcked[n]) {
                    ++toSend;
                }
            }

            try {
                // Don't send more than LOWATERMARK at a time, to avoid overloading the UDP send layer
                // The semaphore MUST be consumed by doneSemaphore.WaitOne().
                using (Semaphore doneSemaphore = new Semaphore(LOWATERMARK, int.MaxValue)) {
                    int hashcode = obi.OOBFname.GetHashCode();
                    List<SocketAsyncEventArgs> aes = new List<SocketAsyncEventArgs>();
                    try {
                        for (int n = allAckedTo; n < nchunks && toSend > 0; n++) {
                            if (!chunkAcked[n]) {
                                obi.flags |= OOBInfo.OBI_SNDWAIT;
                                ILock.NoteThreadState("OOB-doneSemaphore.WaitOne()");
                                doneSemaphore.WaitOne();
                                ILock.NoteThreadState(null);
                                obi.flags &= ~OOBInfo.OBI_SNDWAIT;
                                byte[] buffer = Msg.toBArray(hashcode, OOBGetOffset(n), OOBGetChunk(obi.mmva, n));
                                Group g = Group.doLookup(obi.gaddr);
                                if (g != null && g.myAes != null) {
                                    buffer = g.cipherBuf(buffer);
                                }

                                if (buffer.Length > Vsync.VSYNC_MAXMSGLEN) {
                                    throw new VsyncException("OOB: Generated an object of length " + buffer.Length + ", but limit is " + Vsync.VSYNC_MAXMSGLEN);
                                }

                                SocketAsyncEventArgs ae = new SocketAsyncEventArgs();
                                aes.Add(ae);
                                ae.SetBuffer(buffer, 0, buffer.Length);
                                ae.RemoteEndPoint = remoteEP;
                                ae.SendPacketsSendSize = (int)Vsync.VSYNC_MAXMSGLEN;
                                ae.UserToken = doneSemaphore;
                                ae.Completed += AsyncSendDone;
                                if (!sendSock.SendToAsync(ae)) {
                                    AsyncSendDone(null, ae);
                                }

                                --toSend;
                            }
                        }

                        // Consume the semaphore.
                        for (int n = 0; n < LOWATERMARK; n++) {
                            ILock.NoteThreadState("OOB-doneSemaphore(lo-water).WaitOne()");
                            doneSemaphore.WaitOne();
                            ILock.NoteThreadState(null);
                        }
                    }
                    finally {
                        foreach (SocketAsyncEventArgs ae in aes) {
                            ae.Dispose();
                        }
                    }
                }
            }
            catch (SocketException e) {
                Vsync.WriteLine("OOBViaIPMC: Async sender thread threw a socket exception with inner code: " + e.ErrorCode);
            }
            catch (ObjectDisposedException) {
            }
        }

        /// <summary>
        /// When multicast isn't available, we just send the data in chunks but use a binary-tree structure to forward it
        /// </summary>
        private static void OOBViaUnicast(OOBInfo obi, List<IPAddress> currentCopies, List<Address> newOwners, long len, int nchunks) {
            if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                Vsync.WriteLine("In Unicast (via UDP) case for OOB rereplicate(nchunks=" + nchunks);
            }

            View theView;
            using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.ViewLock)) {
                theView = Vsync.VSYNCMEMBERS.theView;
            }
            if (Vsync.VSYNC_OOBVIATCP) {
                if (newOwners.Contains(Vsync.my_address))
                    if (!OOBRcvViaTCP(obi))
                        return;
            }
            else {
                OOBFetchWait(obi);
            }

            List<IPAddress> ISendTo = OOBTreeSend(obi, currentCopies, OwnersToIPAddrs(newOwners));
            if (ISendTo.Count == 0) {
                return;
            }

            List<Address> dests = IPAddrsToOwners(ISendTo, theView);
            Socket[] tcpSocks = new Socket[dests.Count];
            if (Vsync.VSYNC_OOBVIATCP) {
                Vsync.VSYNCMEMBERS.Query(ALL, dests, Vsync.OUTOFBAND, Group.EOL);
                bool tryAgain = true;
                for (int retry = 0; retry < 5; retry++) {
                    tryAgain = false;
                    for (int idx = 0; idx < dests.Count; idx++) {
                        if (tcpSocks[idx] != null)
                            continue;
                        Address dest = dests[idx];
                        try {
                            tcpSocks[idx] = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                            tcpSocks[idx].Connect(new IPEndPoint(dest.home, dest.p2pPort + 2));
                            tcpSocks[idx].NoDelay = true;
                            tcpSocks[idx].Blocking = true;
                            tcpSocks[idx].SendBufferSize = (int)(Math.Min(1024 * 1024, Vsync.VSYNC_OOBCHUNKSIZE * 10));
                            tcpSocks[idx].LingerState.LingerTime = 120;
                            tcpSocks[idx].LingerState.Enabled = true;
                        }
                        catch (Exception) {
                            tcpSocks[idx] = null;
                            tryAgain = true;
                            Vsync.Sleep(250);
                        }
                    }
                }
                if (tryAgain) {
                    for (int idx = 0; idx < dests.Count; idx++) {
                        if (tcpSocks[idx] != null)
                            continue;
                        Address dest = dests[idx];
                        if ((VsyncSystem.Debug & VsyncSystem.FAILURES) != 0) {
                            Vsync.NodeHasFailed(dest, "Vsync/OOB unable to make a TCP connection", false);
                        }
                    }
                }
            }

            // The outer loop needs to be over the TCP connection list, because we want to complete our send to the first guy in the
            // the list before starting to send to the second guy, etc.  This is important because it gives greater parallelism:
            // the first guy we send to will turn around and will do a bunch of additional sends, etc.  If we sent block by block
            // the sender code might perform a bit better (right now we pay the overhead of serializing each chunk K times...) but
            // in actuality the overall transmission would be slower!
            int nSent = 0;
            foreach (var tcpc in tcpSocks) {
                int cn = 0;
                if (tcpc == null) {
                    continue;
                }
                while (cn < nchunks) {
                    if (!Vsync.VSYNC_OOBVIATCP && ++nSent % 50 == 0) {
                        //  pause periodically until pending sends have finished
                        Vsync.VSYNCMEMBERS.Flush();
                    }
                    if (Vsync.VSYNC_OOBVIATCP) {
                        byte[] ba = Msg.toBArray(obi.OOBFname, OOBGetOffset(cn), len, OOBGetChunk(obi.mmva, cn), cn == (nchunks - 1));
                        byte[] lba = intAsBA(ba.Length);
                        try { writeAll(tcpc, lba); writeAll(tcpc, ba); }
                        catch (IOException) { }
                    }
                    else {
                        Vsync.VSYNCMEMBERS.doSend(false, false, dests, Vsync.OUTOFBAND, obi.OOBFname, OOBGetOffset(cn), len, OOBGetChunk(obi.mmva, cn), cn == (nchunks - 1));
                    }

                    ++cn;
                }

            }

            if (Vsync.VSYNC_OOBVIATCP) {
                foreach (var tcpc in tcpSocks)
                    if (tcpc != null) {
                        byte[] ack = new byte[1];
                        try {
                            readAll(tcpc, ack);
                        }
                        catch (SocketException) { }
                        tcpc.Close();
                    }
            }
        }

        private static void writeAll(Socket s, byte[] ba) {
            try {
                int wrote = 0;
                while (wrote < ba.Length)
                    wrote += s.Send(ba, wrote, ba.Length - wrote, SocketFlags.None);
            }
            catch (SocketException) {
            }
        }

        private static Socket tcpListener = null;
        private static LockObject rtcpcLock = new LockObject("rtcpcLock");

        internal static void doOOBSetupTCPListener() {
            using (var tmpLockObj = new LockAndElevate(rtcpcLock))
                if (tcpListener == null) {
                    try {
                        tcpListener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                        tcpListener.Bind(new IPEndPoint(IPAddress.Any, Vsync.my_address.p2pPort + 2));
                        tcpListener.Listen(4);
                    }
                    catch (Exception e) {
                        throw new VsyncException("Unable to start a listener: throws " + e);
                    }
                }
        }

        private static bool OOBRcvViaTCP(OOBInfo obi) {
            doOOBSetupTCPListener();
            Socket rtcps = null;
            try {
                bool done = false;
                rtcps = tcpListener.Accept();
                rtcps.NoDelay = true;
                rtcps.ReceiveBufferSize = (int)(Math.Min(1024 * 1024, Vsync.VSYNC_OOBCHUNKSIZE * 10));
                rtcps.LingerState.LingerTime = 120;
                rtcps.LingerState.Enabled = true;
                rtcps.Blocking = true;
                do {
                    byte[] lba = new byte[4];
                    if (readAll(rtcps, lba) == 4) {
                        int len = baAsInt(lba);
                        if (len > 0 && len <= Vsync.VSYNC_OOBCHUNKSIZE + 512) {
                            byte[] buffer = new byte[len];
                            if (readAll(rtcps, buffer) == len) {
                                Msg.InvokeFromBArray(buffer, new Action<string, long, long, byte[], bool>((OOBFname, offset, oobFileLength, ba, lastOne) => {
                                    doOOBGotChunk(obi, OOBFname, offset, oobFileLength, ba, lastOne);
                                    if (done = lastOne) {
                                        writeAll(rtcps, new byte[1] { 1 });
                                    }
                                }));
                            }
                        }
                        else {
                            done = true;
                        }
                    }
                }
                while (!done);
                return true;
            }
            catch (IOException e) {
                Vsync.WriteLine("WARNING: In OOBRcvViaTCP threw Exception " + e);
                return false;
            }
            finally {
                if (rtcps != null) {
                    rtcps.Disconnect(false);
                    rtcps.Dispose();
                }
            }
        }

        private static int readAll(Socket s, byte[] ba) {
            try {
                ILock.NoteThreadState("OOBViaTCP.Receive");
                int read = 0;
                while (read < ba.Length)
                    read += s.Receive(ba, read, ba.Length - read, SocketFlags.None);
                return ba.Length;
            }
            catch (SocketException) {
                for (int n = 0; n < ba.Length; n++)
                    ba[n] = 0;
                return 0;
            }
            finally {
                ILock.NoteThreadState(null);
            }
        }


        private static byte[] intAsBA(int len) {
            byte[] ba = new byte[4];
            if (len > int.MaxValue)
                throw new VsyncException("intAsBA");
            int idx = 0;
            ba[idx++] = (byte)(len & 0xFF); len >>= 8;
            ba[idx++] = (byte)(len & 0xFF); len >>= 8;
            ba[idx++] = (byte)(len & 0xFF); len >>= 8;
            ba[idx++] = (byte)(len & 0xFF); len >>= 8;
            return ba;
        }

        private static int baAsInt(byte[] ba) {
            int len = 0, idx = 4;
            len |= ba[--idx]; len <<= 8;
            len |= ba[--idx]; len <<= 8;
            len |= ba[--idx]; len <<= 8;
            len |= ba[--idx];
            return len;
        }

        private static void OOBViaRDMA(OOBInfo obi, long len, int nchunks, List<IPAddress> currentCopies, List<Address> newCopies, qmethod QueryMethod, View theView) {
            List<IPAddress> IPaddrs = new List<IPAddress>();
            List<int> qps = new List<int>();
            List<int> lids = new List<int>();
            List<IPAddress> ISendTo = OOBTreeSend(obi, currentCopies, OwnersToIPAddrs(newCopies));
            List<Address> MatchingOwners = IPAddrsToOwners(ISendTo, theView);
            IntPtr[] ibkeys = new IntPtr[nchunks * MatchingOwners.Count];
            int[] qpss = new int[theView.members.Length];
            int[] qpnos = new int[theView.members.Length];
            long limit = (len * 8000) / (50000000);
            int rv;
            int ibqgrp = PickIBGroupNo();
            try {
                if ((VsyncSystem.Debug & (VsyncSystem.IBDB | VsyncSystem.OOBXFERS)) != 0) {
                    Vsync.WriteLine("OOB/VSYNC_INFINIBAND for " + obi.OOBFname + ": OOB rereplicate(nchunks=" + nchunks + ", ibgrp=" + ibqgrp + ")");
                }

                if (ISendTo.Count == 0) {
                    if ((VsyncSystem.Debug & (VsyncSystem.IBDB | VsyncSystem.OOBXFERS)) != 0) {
                        Vsync.WriteLine("VSYNC_INFINIBAND for " + obi.OOBFname + ": no work to do for this transfer on this node.");
                    }

                    return;
                }

                for (int k = 0; k < theView.members.Length; k++) {
                    if (!theView.members[k].isMyAddress()) {
                        qpnos[k] = IB.IB_get_qp_num(qpss[k] = IB.IB_create_qp(ibqgrp, nchunks, nchunks));
                        if ((VsyncSystem.Debug & (VsyncSystem.IBDB | VsyncSystem.OOBXFERS)) != 0) {
                            Vsync.WriteLine("qpnos[k] = " + qpnos[k] + ", for qp=" + qpss[k]);
                        }
                    }
                }

                List<bool[]> outcomes = new List<bool[]>();
                QueryMethod(ALL, new Timeout(10000, Timeout.TO_FAILURE), MatchingOwners, Vsync.OUTOFBAND, string.Empty, obi.OOBFname, obi.gaddr ?? Vsync.VSYNCMEMBERS.gaddr,
                    nchunks, len, currentCopies, Vsync.my_address, theView.members, qpnos, Vsync.VSYNC_LID, EOL,
                    outcomes, qps, lids, IPaddrs);
                if ((VsyncSystem.Debug & VsyncSystem.IBDB) != 0) {
                    string qs = " ", ls = " ";
                    foreach (int v in qps) {
                        qs += v + " ";
                    }

                    foreach (int v in lids) {
                        ls += v + " ";
                    }

                    Vsync.WriteLine("After Query in OOBRereplicate got " + outcomes.Count + " responses: qps = { " + qs + "}, lids = {" + ls + "}, addrs = { " + Address.VectorToString(IPaddrs.ToArray()) + "}");
                }

                ILock.NoteThreadState("OOBViaRDMA -- making IB connections");
                for (int k = 0; k < qps.Count; k++) {
                    int r = theView.GetHomeRepRank(IPaddrs[k]);
                    if (r == -1) {
                        throw new VsyncException("OOB/IB");
                    }

                    rv = IB.IB_connect(qpss[r], qps[k], lids[k]);
                    if ((VsyncSystem.Debug & (VsyncSystem.IBDB | VsyncSystem.OOBXFERS)) != 0) {
                        Vsync.WriteLine("ib_connect: rank=" + r + ", my qpss[r] = " + qpss[r] + ", his qps[k] = " + qps[k] + ", lid = " + lids[k] + "... rv=" + rv);
                    }
                }

                IntPtr baseptr = obi.mmva.SafeMemoryMappedViewHandle.DangerousGetHandle();
                if ((VsyncSystem.Debug & (VsyncSystem.IBDB | VsyncSystem.OOBXFERS)) != 0) {
                    Vsync.WriteLine("OOBGetLength: sending nb=" + len + " base=" + baseptr);
                }

                int nposted = 0;
                int nkeys = 0;
                for (int n = 0; n < nchunks; n++) {
                    ILock.NoteThreadState("OOBViaRDMA -- sending chunk " + n);
                    int chlen = (int)((len % Vsync.VSYNC_OOBCHUNKSIZE == 0) ? Vsync.VSYNC_OOBCHUNKSIZE : (len % Vsync.VSYNC_OOBCHUNKSIZE));
                    for (int who = 0; who < qps.Count; who++) {
                        IntPtr key = IB.IB_register(baseptr, chlen);
                        ibkeys[nkeys++] = key;
                        int r = theView.GetHomeRepRank(IPaddrs[who]);
                        rv = IB.IB_post_send(qpss[r], baseptr, key, chlen);
                        if ((VsyncSystem.Debug & (VsyncSystem.IBDB | VsyncSystem.OOBXFERS)) != 0) {
                            Vsync.WriteLine("IB.IB_post_send(qpss[" + r + "]=" + qpss[r] + "), baseptr=" + baseptr + ", ibkeys[n]=" + key + ", len=" + chlen + ") returns rv=" + rv);
                        }

                        if (rv == 0) {
                            ++nposted;
                        }
                        else if ((VsyncSystem.Debug & VsyncSystem.IBDB) != 0) {
                            Vsync.WriteLine("Warning: IB_post_send returned " + rv);
                        }
                    }

                    baseptr = new IntPtr(baseptr.ToInt64() + Vsync.VSYNC_OOBCHUNKSIZE);
                    len -= Vsync.VSYNC_OOBCHUNKSIZE;
                }

                int nc = 0, retries = 0;
                long startAt = Vsync.NOW;
                rv = IB.WC_UNKNOWN;
                while (nc < nposted && (VsyncSystem.VsyncActive || !VsyncSystem.VsyncWasActive) && (retries < 3 || Vsync.NOW - startAt > limit)) {
                    ILock.NoteThreadState("OOBViaRDMA -- wait completion (ncompleted=" + nc + ", nposted=" + nposted + ")");
                    if ((rv = IB.IB_wait_for_completion(ibqgrp - 1, 250)) != IB.WC_SUCCESS) {
                        ++retries;
                        if (rv == IB.WC_ERROR) {
                            Vsync.WriteLine("Vsync/IB: WARNING, ib_wait_for_completion failed!");
                            ++nc;
                        }

                        continue;
                    }

                    IntPtr dpa = IB.IB_poll_completedsends(ibqgrp);
                    if ((VsyncSystem.Debug & VsyncSystem.IBDB) != 0) {
                        Vsync.WriteLine("poll_completed_sends: " + IB.IB_clen(dpa));
                    }

                    if (dpa != IntPtr.Zero) {
                        nc += IB.IB_clen(dpa);
                        IB.IB_free(dpa);
                    }
                }

                if ((VsyncSystem.Debug & (VsyncSystem.IBDB | VsyncSystem.OOBXFERS)) != 0) {
                    Vsync.WriteLine("Sending OOBDone for transfer of " + obi.OOBFname);
                }

                ILock.NoteThreadState("OOBViaRDMA -- terminate IB send");
                Vsync.VSYNCMEMBERS.Send(MatchingOwners, Vsync.OUTOFBAND, obi.OOBFname, true);
                if (qpss != null) {
                    foreach (int ibqp in qpss) {
                        if (ibqp != 0) {
                            IB.IB_destroy_qp(ibqp);
                        }
                    }
                }

                for (int n = 0; n < nkeys; n++) {
                    IB.IB_unregister(ibkeys[n]);
                }

                OOBReplicaIsReady(obi, true);
            }
            finally {
                ReleaseIBGroup(ibqgrp);
                ILock.NoteThreadState(null);
            }
        }

        // For a given list of members and information on who currently has a copy, OOBTreeSend 
        // populates ISendTo with a list of destinations to which this node should send a copy.
        // It then returns true if this node needs block fetching an incoming copy.
        // The underlying pattern is a multi-rooted binary tree: in the first "stage" everyone with a copy
        // sends to a distinct receiver who lacks one.  In the second stage, we repeat this process:
        // athe number of copies can double at each stage.  Failures can leave some receivers
        // without copies, but we handle that risk elsewhere by restarting those transfers after a new View event
        internal static List<IPAddress> OOBTreeSend(OOBInfo obi, List<IPAddress> currentCopies, List<IPAddress> newCopies) {
            List<IPAddress> FullList = new List<IPAddress>(currentCopies);
            // Append the new copies to the end of the list.  Don't use the LINQ Union operator: it has set semantics
            // and might change the ordering, but this code is order sensitive.
            foreach (var ip in newCopies)
                if (!FullList.Contains(ip))
                    FullList.Add(ip);
            IPAddress[] members = FullList.ToArray();
            bool[] hasCopy = new bool[FullList.Count];
            for (int b = 0; b < currentCopies.Count; b++) {
                hasCopy[b] = true;
            }

            bool AWaitIncomingOOB = false;
            int N = members.Length;
            List<IPAddress> ISendTo = new List<IPAddress>();
            bool[] willHaveCopy = new bool[N];
            bool[] couldBeASender = new bool[N];
            int nsenders = hasCopy.Count(b => b);
            bool didSomething = true;
            ILock.NoteThreadState("OOBTreeSend");
            while (nsenders < N) {
                Array.Copy(hasCopy, 0, willHaveCopy, 0, N);
                Array.Copy(hasCopy, 0, couldBeASender, 0, N);
                do {
                    int sender = -1;
                    int receiver = -1;
                    didSomething = false;
                    for (int which = 0; which < N; which++) {
                        // Looks for the left-most sender, and left-most receiver in the vector
                        if (sender == -1 && couldBeASender[which]) {
                            sender = which;
                        }

                        if (receiver == -1 && !willHaveCopy[which]) {
                            receiver = which;
                        }

                        if (sender != -1 && receiver != -1) {
                            // As soon as we found an elegible sender and receiver, schedule the send:
                            //    If I'm the sender, put this receiver on my list of sends to do
                            //    If I'm the receiver, make note of that: this node should wait if needed later
                            //    Update the list of eligible senders and needy receivers
                            if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                                Vsync.WriteLine("OOBTreeSend: Sender " + members[sender] + " to Receiver " + members[receiver]);
                            }

                            if (members[sender].Equals(Vsync.my_address.home)) {
                                ISendTo.Add(members[receiver]);
                            }
                            else if (members[receiver].Equals(Vsync.my_IPaddress)) {
                                AWaitIncomingOOB = true;
                            }

                            ILock.NoteThreadState("OOBTreeSend (sender=" + sender + "; receiver=" + receiver + ")");
                            couldBeASender[sender] = false;
                            willHaveCopy[receiver] = true;
                            sender = receiver = -1;
                            didSomething = true;
                            ++nsenders;
                        }
                    }
                }
                while (didSomething);
                Array.Copy(willHaveCopy, 0, hasCopy, 0, N);
            }

            ILock.NoteThreadState(null);
            if (AWaitIncomingOOB) {
                try {
                    ILock.NoteThreadState("OOBTreeSend (OOBFetchWait)");
                    OOBFetchWait(obi);
                }
                catch (ObjectDisposedException) {
                }
                finally {
                    ILock.NoteThreadState(null);
                }
            }

            return ISendTo;
        }

        private static void OOBFetchWait(OOBInfo obi) {
            using (var tmpLockObj = new LockAndElevate(OOBMapLock)) {
                if (obi.mmf == null && obi.replicaHomes.Contains(Vsync.my_IPaddress)) {
                    OOBOpenLocalReplica(obi);
                    return;
                }

                obi.flags |= OOBInfo.OBI_FETCHWAIT;
            }
            ILock.NoteThreadState("mmfReady.WaitOne()");
            obi.mmfReady.WaitOne();
            ILock.NoteThreadState(null);
            using (var tmpLockObj = new LockAndElevate(OOBMapLock))
                obi.flags &= ~OOBInfo.OBI_FETCHWAIT;
            obi.mmfReady.Release();
        }

        private static void OOBOpenLocalReplica(OOBInfo obi) {
            try {
                obi.mmf = MemoryMappedFile.OpenExisting(obi.OOBFname);
                obi.mmva = obi.mmf.CreateViewAccessor();
                OOBReplicaIsReady(obi, true);
            }
            catch (IOException e) {
                throw new VsyncException("OOBFetch: The mapped file should be locally accessible, but attempt to map it returned " + e);
            }
        }

        private static int PickIBGroupNo() {
            ILock.NoteThreadState("ibcntr.WaitOne()");
            IB.ibcntr.WaitOne();
            ILock.NoteThreadState(null);
            using (var tmpLockObj = new LockAndElevate(IB.ibgrouplock)) {
                int max = IB.IB_maxqpgroups();
                for (int n = 2; n < max; n++) {
                    if (!IB.ibgroupnos[n]) {
                        IB.ibgroupnos[n] = true;
                        return n;
                    }
                }
            }

            throw new VsyncException("PickIBGroupNo");
        }

        private static int counter;

        // Used only for state transfer of initial view to a joining member
        private int doPlatformLevelQuery(int nreplies, params object[] given) {
            Timeout timeout;
            object[] resRefs;
            splitObs(this, out timeout, ref given, out resRefs);
            List<Address> dests = new List<Address>();
            foreach (Address dest in (List<Address>)given[0]) {
                if (!dest.isMyAddress()) {
                    dests.Add(dest);
                }
            }

            given = fixObs(given);
            int nreplies2 = dests.Count;
            this.cbCheck(given);
            Msg m = new Msg(given) { vid = 0, msgid = ++counter };
            m.flags |= Msg.NEEDSREPLY;
            List<byte[]> barrays = this._Query(m.vid, m.msgid, 0, false, false, obs => {
                foreach (Address dest in dests) {
                    this.doPureP2PSend(dest, true, obs[0]);
                }
            }, nreplies2, timeout, new object[] { m });
            Msg.BArraysToLists(resRefs, barrays);
            return barrays.Count;
        }

        private static bool[] OOBUpdateStatus(string where, OOBInfo obi, List<Address> newOwners, int nchunks, ref int allAckedTo, List<bool[]> outcomes) {
            int nl = Vsync.CountLive(newOwners);
            if (outcomes.Count != nl) {
                Vsync.WriteLine("WARNING: OOBUpdateStatus(" + where + ") expected " + nl + ", but only found " + outcomes.Count + " responses... NewOwners=" + Address.VectorToString(newOwners) + ", RIP=" + Address.VectorToString(Vsync.RIPList));
                return new bool[nchunks];
            }

            bool[] chunkAcked = null;
            foreach (bool[] oc in outcomes) {
                if (oc == null || oc.Length != nchunks) {
                    throw new VsyncException("Unexpected outcome length in OOBUpdateStatus");
                }

                if (chunkAcked == null) {
                    chunkAcked = oc;
                }
                else {
                    for (int b = 0; b < chunkAcked.Length; b++) {
                        chunkAcked[b] &= oc[b];
                    }
                }
            }
            if (chunkAcked != null) {
                while (allAckedTo < nchunks && (allAckedTo == -1 || chunkAcked[allAckedTo])) {
                    ++allAckedTo;
                }
            }

            using (var tmpLockObj = new LockAndElevate(OOBMapLock))
                obi.OOBStatus = chunkAcked;
            if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                Vsync.WriteLine("OOB update status: " + obi);
            }

            return chunkAcked;
        }

        private static void AsyncSendDone(object sender, SocketAsyncEventArgs ae) {
            Semaphore doneSemaphore = (Semaphore)ae.UserToken;
            try {
                doneSemaphore.Release();
            }
            catch (ObjectDisposedException) {
            }

            ae.SetBuffer(null, 0, 0);
        }

        // Called at the end of a transfer 
        private void doOOBDone(string OOBFname) {
            using (var tmpLockObj = new LockAndElevate(OOBMapLock)) {
                OOBInfo obi;
                if (!OOBMap.TryGetValue(OOBFname, out obi)) {
                    return;
                }

                if (obi.currentlySendingTo != null) {
                    obi.replicaHomes = obi.replicaHomes.Union(obi.currentlySendingTo).ToList();
                    obi.currentlySendingTo = null;
                }

                if ((obi.flags & OOBInfo.OBI_SENDING) != 0) {
                    // The test is needed because during state transfer of the initial view  the processes being
                    // initialized won't yet belong to the group and hence won't have OBI_ACTIVE set yet
                    obi.flags &= ~OOBInfo.OBI_SENDING;
                    OOBInfo.xfActive.Release();
                    obi.busy.Release();
                    --OOBInUse;
                }
            }

            if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                Vsync.WriteLine("*** OOBDone for " + OOBFname + ", new OOBInUse=" + OOBInUse);
            }

            this.OOBCheckQ();
        }

        // This version is used in the RDMA case to signal that the receivers can safely tear down their connections
        // For consistency, the non-RDMA methods just call doOOBDone as well, to prevent blocking.  The effect is that
        // the semaphore could actually increment to a larger value, but this has no significance in those cases
        private void doOOBDone(string OOBFname, bool done) {
            using (var tmpLockObj = new LockAndElevate(OOBMapLock)) {
                OOBInfo obi;
                if (OOBMap.TryGetValue(OOBFname, out obi) && obi.xfDone != null) {
                    obi.xfDone.Release();
                    obi.xfDone = null;
                }
            }
        }

        private void doReportChunkStatus(string OOBFname, int nc) {
            if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                Vsync.WriteLine("doReportChunkStatus sending status for " + OOBFname + " at time " + new TimeSpan(Vsync.TICKS));
            }

            OOBInfo obi = null;
            using (var tmpLockObj = new LockAndElevate(OOBMapLock)) {
                OOBMap.TryGetValue(OOBFname, out obi);
            }

            if (obi != null && (obi.OOBStatus != null && obi.OOBStatus.Length == nc)) {
                this.doReply(obi.OOBStatus);
                return;
            }

            if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                Vsync.WriteLine("WARNING: doReportChunkStatus can't find OOBMap for " + OOBFname + ", or found it but the status had the wrong length");
            }

            bool[] cs = new bool[nc];
            for (int i = 0; i < nc; i++)
                cs[i] = true;
            this.doReply(cs);
        }

        internal class OBIDeleted {
            volatile internal bool hasBeenDeleted = false;
        }

        internal class AsyncReadInfo {
            internal byte[] buffer;

            internal OBIDeleted obiDI;

            internal MemoryMappedViewAccessor mmva;

            internal OOBInfo obi;

            internal int hashcode;

            internal static int cnt;

            internal int uid = ++cnt;

            internal Semaphore rSema;

            internal Socket rSock;

            internal AsyncReadInfo(OOBInfo obi, byte[] buffer, MemoryMappedViewAccessor mmva, Socket rSock, Semaphore rSema) {
                this.obiDI = obi.OOBdi;
                this.obi = obi;
                this.buffer = buffer;
                this.mmva = mmva;
                this.hashcode = obi.OOBFname.GetHashCode();
                this.rSock = rSock;
                this.rSema = rSema;
            }
        }

        private void doOOBPrepare(string mcaddr, string OOBFname, Address gaddr, int nchunks, long len, List<IPAddress> where, Address initiatedBy, Address[] who, int[] qpnos, int lid) {
            int chunksRcvd = 0;
            int allRcvd = 0;
            OOBInfo obi;
            View theView;
            using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.ViewLock)) {
                theView = Vsync.VSYNCMEMBERS.theView;
            }

            using (var tmpLockObj = new LockAndElevate(OOBMapLock)) {
                if (!OOBMap.TryGetValue(OOBFname, out obi)) {
                    OOBMap.Add(OOBFname, obi = new OOBInfo(OOBFname, false, null, -1, where, gaddr, theView));
                }

                if (obi.OOBStatus == null) {
                    obi.OOBStatus = new bool[nchunks];
                }
            }

            if (obi.mmf == null) {
                obi.len = Math.Max(len, obi.len);
                OOBSetupmmf(obi, OOBFname, obi.len);
            }

            obi.flags |= OOBInfo.OBI_RCVING;
            obi.len = Math.Max(len, obi.len);
            int ibqp = 0;
            int ibqgrp = 0;
            if (Vsync.VSYNC_INFINIBAND) {
                OOBRDMARcvConnectionLogic(nchunks, initiatedBy, who, qpnos, lid, out ibqp, out ibqgrp);
            }

            CheckReceived(nchunks, obi, ref chunksRcvd, ref allRcvd);
            Semaphore readyToReceive = new Semaphore(0, 1);
            if (!Vsync.VSYNC_INFINIBAND) {
                new Thread(() => this.OOBIPMCReceiveLogic(initiatedBy, mcaddr, OOBFname, nchunks, chunksRcvd, allRcvd, obi, readyToReceive)) { Name = "doOOBPreparee <" + OOBFname + ">: Receive thread", IsBackground = true }.Start();
            }
            else {
                Semaphore xfDone = new Semaphore(0, int.MaxValue);
                obi.xfDone = xfDone;
                new Thread(() => OOBRDMAReceiveLogic(OOBFname, nchunks, obi.len, obi, ibqp, ibqgrp, readyToReceive, xfDone)) { Name = "doOOBPrepare <" + OOBFname + ">: IB Receive thread", IsBackground = true }.Start();
            }

            ILock.NoteThreadState("readyToReceive.WaitOne()");
            readyToReceive.WaitOne();
            ILock.NoteThreadState(null);
            readyToReceive.Dispose();
            if ((VsyncSystem.Debug & VsyncSystem.IBDB) != 0) {
                if (Vsync.VSYNC_INFINIBAND) {
                    Vsync.WriteLine("doReply for prepare to receive: my qpno=" + IB.IB_get_qp_num(ibqp) + ", my LID=" + Vsync.VSYNC_LID + ", my_address=" + Vsync.my_address);
                }
                else {
                    Vsync.WriteLine("doReply for prepare to receive: after prepare, tell sender I'm ready");
                }
            }

            this.doReply(obi.OOBStatus ?? new bool[0], Vsync.VSYNC_INFINIBAND ? IB.IB_get_qp_num(ibqp) : 0, Vsync.VSYNC_LID, Vsync.my_IPaddress);
        }

        private static void OOBRDMARcvConnectionLogic(int nchunks, Address initiatedBy, Address[] who, int[] qpnos, int lid, out int ibqp, out int ibqgrp) {
            ibqgrp = PickIBGroupNo();
            ibqp = IB.IB_create_qp(ibqgrp, 0, nchunks);
            View theView;
            using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.ViewLock)) {
                theView = Vsync.VSYNCMEMBERS.theView;
            }

            bool fnd = false;
            for (int r = 0; r < who.Length; r++) {
                if (who[r].isMyAddress()) {
                    int irank = theView.GetRankOf(initiatedBy);
                    if (irank != -1) {
                        int rv = IB.IB_connect(ibqp, qpnos[r], lid);
                        if ((VsyncSystem.Debug & VsyncSystem.IBDB) != 0) {
                            Vsync.WriteLine("OOB IB receive: IB_connect using ibgrp=" + ibqgrp + ", using ibqp=" + ibqp + ", remote qpno = " + qpnos[r] + ", remote lid=" + lid + ", rv= " + rv);
                        }

                        fnd = true;
                    }

                    break;
                }
            }

            if (!fnd) {
                throw new VsyncException("OOB IB Setup failed");
            }
        }

        private static void OOBRDMAReceiveLogic(string OOBFname, int nchunks, long len, OOBInfo obi, int ibqp, int ibqgrp, Semaphore readyToReceive, Semaphore xfDone) {
            try {
                ILock.NoteThreadState("OOBRDMAReceive: get memory-mapped handle");
                IntPtr baseptr = obi.mmva.SafeMemoryMappedViewHandle.DangerousGetHandle();
                Dictionary<IntPtr, int> chunks = new Dictionary<IntPtr, int>();
                List<IntPtr> keys = new List<IntPtr>();
                if (len == 0) {
                    throw new VsyncException("OOBReReplicate: len=0!");
                }

                for (int n = 0; n < nchunks; n++) {
                    ILock.NoteThreadState("OOBRDMAReceive: in receive for-loop with n=" + n + ", nchunks=" + nchunks);
                    long chlen = (len % Vsync.VSYNC_OOBCHUNKSIZE == 0) ? Vsync.VSYNC_OOBCHUNKSIZE : (len % Vsync.VSYNC_OOBCHUNKSIZE);
                    if ((VsyncSystem.Debug & (VsyncSystem.IBDB | VsyncSystem.OOBXFERS)) != 0) {
                        Vsync.WriteLine("before IB.IB_register(baseptr=" + baseptr + ", len=" + chlen + ")");
                    }

                    IntPtr key = IB.IB_register(baseptr, (int)chlen);
                    if (key == IntPtr.Zero) {
                        throw new VsyncException("Unable to register base " + baseptr + ", len " + chlen);
                    }

                    chunks[baseptr] = n;
                    keys.Add(key);
                    if ((VsyncSystem.Debug & (VsyncSystem.IBDB | VsyncSystem.OOBXFERS)) != 0) {
                        Vsync.WriteLine("before IB.IB_post_rcv(grp=" + ibqgrp + "), baseptr=" + baseptr + ", key=" + key + ", len=" + chlen + ")");
                    }

                    int rval = IB.IB_post_recv(ibqgrp, baseptr, key, (int)chlen);
                    if ((VsyncSystem.Debug & (VsyncSystem.IBDB | VsyncSystem.OOBXFERS)) != 0) {
                        Vsync.WriteLine("IB.IB_post_rcv(grp=" + ibqgrp + ", baseptr=" + baseptr + ", key=" + key + ", len=" + chlen + ") returns rv=" + rval);
                    }

                    baseptr = new IntPtr(baseptr.ToInt64() + (int)chlen);
                }

                readyToReceive.Release();
                if ((VsyncSystem.Debug & (VsyncSystem.IBDB | VsyncSystem.OOBXFERS)) != 0) {
                    Vsync.WriteLine("starting to receive");
                }

                while (nchunks > 0 && (VsyncSystem.VsyncActive || !VsyncSystem.VsyncWasActive)) {
                    int rv;
                    ILock.NoteThreadState("OOBRDMAReceive: in while loop, ready to receive with nchunks=" + nchunks + "... wait for completion");
                    if ((VsyncSystem.Debug & (VsyncSystem.IBDB | VsyncSystem.OOBXFERS)) != 0) {
                        Vsync.WriteLine("wait for completions on channel " + (ibqgrp - 1));
                    }

                    if ((rv = IB.IB_wait_for_completion(ibqgrp - 1, 250)) != IB.WC_SUCCESS) {
                        ILock.NoteThreadState("OOBRDMAReceive:must loop: rv=" + rv);
                        if (rv == IB.WC_ERROR) {
                            Vsync.WriteLine("Vsync/IB: WARNING, ib_wait_for_completion failed!");
                        }

                        continue;
                    }

                    if ((VsyncSystem.Debug & (VsyncSystem.IBDB | VsyncSystem.OOBXFERS)) != 0) {
                        Vsync.WriteLine("poll for completion records on channel " + (ibqgrp - 1));
                    }

                    ILock.NoteThreadState("OOBRDMAReceive: poll completed receives");
                    IntPtr dpa = IB.IB_poll_completedrcvs(ibqgrp);
                    int nc = IB.IB_clen(dpa);
                    if ((VsyncSystem.Debug & (VsyncSystem.IBDB | VsyncSystem.OOBXFERS)) != 0) {
                        Vsync.WriteLine(nc + " completed receives!");
                    }

                    ILock.NoteThreadState("OOBRDMAReceive: " + nc + " received have completed");
                    if (nc > 0) {
                        nchunks -= nc;
                        for (int k = 0; k < nc; k++) {
                            IntPtr dp = IB.IB_dpAt(dpa, k);
                            int cn;
                            if (!chunks.TryGetValue(dp, out cn)) {
                                throw new VsyncException("IB doOOB Receive: completion for " + dp + " didn't correspond to any known active transfer");
                            }

                            if ((VsyncSystem.Debug & (VsyncSystem.IBDB | VsyncSystem.OOBXFERS)) != 0) {
                                Vsync.WriteLine("Successful completion of chunk " + cn + ")");
                            }

                            obi.OOBStatus[cn] = true;
                        }
                    }

                    IB.IB_free(dpa);
                }

                ILock.NoteThreadState("OOBRDMAReceive: unregister keys");
                foreach (IntPtr key in keys) {
                    IB.IB_unregister(key);
                }

                // Now block until the RDMA sender says we can tear down the connection
                // doOOBDone will set obi.xfDone back to null, so we need a pointer to the Semaphore
                // so as to properly dispose of it once the wait finishes.
                ILock.NoteThreadState("OOBRDMAReceive: Finished receiving, calling xfDone.WaitOne() prior to breaking down connection");
                xfDone.WaitOne();
                ILock.NoteThreadState(null);
                ILock.NoteThreadState("OOBRDMAReceive: xfDone.Dispose, IB_destroy_qp, OOBReplicaIsReady()");
                xfDone.Dispose();
                IB.IB_destroy_qp(ibqp);
                obi.flags &= ~OOBInfo.OBI_RCVING;
                if ((VsyncSystem.Debug & (VsyncSystem.IBDB | VsyncSystem.OOBXFERS)) != 0) {
                    Vsync.WriteLine("doOOBPrepare: receive logic successful, toggling mmf-ready semaphore");
                }

                OOBReplicaIsReady(obi, true);
                ILock.NoteThreadState(null);
            }
            finally {
                ReleaseIBGroup(ibqgrp);
            }
        }

        internal void reportWhenXferDone(IPAddress ipa, string OOBFname) {
            if (!ipa.Equals(Vsync.my_IPaddress)) {
                this.AbortReply("reportWhenXferDone(" + OOBFname + "): I'm not on host " + ipa);
            }

            OOBInfo obi;
            using (var tmpLockObj = new LockAndElevate(OOBMapLock)) {
                if (!OOBMap.TryGetValue(OOBFname, out obi)) {
                    this.AbortReply("reportWhenXferDone(" + OOBFname + "): I' don't have a replica of this file");
                }
            }

            OOBFetchWait(obi);
            this.Reply(true);
        }

        private static void OOBReplicaIsReady(OOBInfo obi, bool toggleSema) {
            if (obi.currentlySendingTo != null) {
                obi.replicaHomes = obi.replicaHomes.Union(obi.currentlySendingTo).ToList();
            }

            if (toggleSema) {
                obi.mmfReady.Release();
            }

            if (theNotifier != null) {
                theNotifier(obi.OOBFname, obi.mmf);
            }
        }

        private void OOBIPMCReceiveLogic(Address initiatedBy, string mcaddr, string OOBFname, int nchunks, int chunksRcvd, int allRcvd, OOBInfo obi, Semaphore readyToReceive) {
            IPAddress physIP = Vsync.LastIPv4(mcaddr);
            EndPoint remoteEP = MCMDSocket.GetIPEndPoint(physIP);
            Socket rcvSock = MCMDSocket.MCMDSockSetup(physIP);
            bool firstTime = true;
            Watcher watchInitiator = ev => {
                try {
                    rcvSock.Close();
                }
                catch (SocketException) {
                }
                catch (ObjectDisposedException) {
                }
            };

            this.Watch[initiatedBy] += watchInitiator;
            try {
                if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                    Vsync.WriteLine("doOOBPrepare: chunksRcvd=" + chunksRcvd + ", nchunks=" + nchunks);
                }

                using (Semaphore rSema = new Semaphore(CHUNKSPERTRY, int.MaxValue)) {
                    List<SocketAsyncEventArgs> aes = new List<SocketAsyncEventArgs>();
                    try {
                        while (chunksRcvd < nchunks && (VsyncSystem.VsyncActive || VsyncSystem.VsyncRestarting)) {
                            int lim = Math.Min(CHUNKSPERTRY, nchunks - chunksRcvd);

                            // The semaphore MUST be consumed by rSema.WaitOne().
                            for (int n = 0; n < lim; n++) {
                                byte[] buffer;
                                using (var tmpLockObj = new LockAndElevate(OOBMapLock)) {
                                    if (this.RecycledBuffers.Count == 0) {
                                        buffer = new byte[Vsync.VSYNC_MAXMSGLEN];
                                    }
                                    else {
                                        buffer = this.RecycledBuffers[0];
                                        this.RecycledBuffers.Remove(buffer);
                                    }
                                }

                                ILock.NoteThreadState("rSema.WaitOne()");
                                rSema.WaitOne();
                                ILock.NoteThreadState(null);
                                AsyncReadInfo ari = new AsyncReadInfo(obi, buffer, obi.mmva, rcvSock, rSema);
                                SocketAsyncEventArgs ae = new SocketAsyncEventArgs();
                                aes.Add(ae);
                                ae.SetBuffer(buffer, 0, (int)Vsync.VSYNC_MAXMSGLEN);
                                ae.RemoteEndPoint = remoteEP;
                                ae.UserToken = ari;
                                ae.SetBuffer(buffer, 0, buffer.Length);
                                ae.Completed += this.AsyncRcvDone;
                                if (!rcvSock.ReceiveFromAsync(ae)) {
                                    this.AsyncRcvDone(null, ae);
                                }
                            }

                            if (firstTime) {
                                readyToReceive.Release();
                            }

                            firstTime = false;

                            int nrcvd = 0;
                            int oldchunksRcvd = chunksRcvd;
                            bool justChecked = false;
                            for (int n = 0; n < lim && chunksRcvd < nchunks; n++) {
                                justChecked = false;

                                // The logic that follow is a bit tortured.  The issue is this: if packets are dropped and retransmitted,
                                // we should break out of this loop "early" once all needed chunks are received.  But if an OOB object is really
                                // big, the check that all were received could be slow, so the code that follows avoids calling CheckReceived
                                // chunk by chunk unless the number received could actually push us over the limit
                                ++nrcvd;
                                if (chunksRcvd + nrcvd >= nchunks) {
                                    CheckReceived(nchunks, obi, ref chunksRcvd, ref allRcvd);
                                    nrcvd -= chunksRcvd - oldchunksRcvd;
                                    oldchunksRcvd = chunksRcvd;
                                    justChecked = true;
                                }
                            }

                            if (!justChecked) {
                                CheckReceived(nchunks, obi, ref chunksRcvd, ref allRcvd);
                            }
                        }
                    }
                    finally {
                        foreach (SocketAsyncEventArgs ae in aes) {
                            ae.Dispose();
                        }
                    }
                }
            }
            catch (SocketException) {
            }
            finally {
                obi.flags &= ~OOBInfo.OBI_RCVING;
                this.Watch[initiatedBy] -= watchInitiator;

                // Triggers cleanup of posted buffers, which end up on the recycled buffer list to speed up future allocation
                // Normally we don't do that in Vsync, but we wanted this logic to be exceptionally fast
                rcvSock.Close();
                rcvSock.Dispose();
                if (chunksRcvd == nchunks) {
                    if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                        Vsync.WriteLine("doOOBPrepare: receive logic successful, toggling mmf-ready semaphore");
                    }

                    OOBReplicaIsReady(obi, true);
                    if (theNotifier != null) {
                        theNotifier(obi.OOBFname, obi.mmf);
                    }
                }
                else if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                    Vsync.WriteLine("doOOBPrepare: receive logic unsuccessful, exit doOOBPrepare");
                }
            }
        }

        private static void ReleaseIBGroup(int ibqgrp) {
            IB.ibgroupnos[ibqgrp] = false;
            IB.ibcntr.Release();
        }

        // This method hacks around a problem I've had with the Mono CreateNew and CreateOrOpen methods, which are buggy as of Mono 10.9...
        internal static MemoryMappedFile CreateNew(string OOBFname, long len) {
#if __MonoCS__
            if (File.Exists(OOBFname))
            {
                // This occurs if there are two receivers on the same machine and they end up in a race.
                Vsync.Sleep(1000);
            }
            else
            {
                using (Stream stream = File.Create(OOBFname))
                {
                    if (stream.Length < len)
                    {
                        stream.Seek((long)len - 1, SeekOrigin.Begin);
                        stream.Write(new byte[1], 0, 1);
                    }

                    stream.Flush();
                }
            }

            for (int retry = 0; retry < 5; retry++)
            {
                try
                {
                    return MemoryMappedFile.CreateOrOpen(OOBFname, len);
                }
                catch (ArgumentException)
                {
                    Vsync.Sleep(1000);
                }
            }

            throw new VsyncException("CreateNew: repeatedly throw ArgumentException");

#else
            return MemoryMappedFile.CreateNew(OOBFname, len);
#endif
        }

        // This method hacks around a problem I've had with the Mono CreateNew and CreateOrOpen methods, which are buggy as of Mono 10.9...
        internal static MemoryMappedFile OpenExisting(string OOBFname, long len) {
            if (!File.Exists(OOBFname)) {
                throw new IOException("File not found");
            }

            return MemoryMappedFile.CreateOrOpen(OOBFname, len);
        }

        private static void CheckReceived(int nchunks, OOBInfo obi, ref int chunksRcvd, ref int allRcvd) {
            while (allRcvd < nchunks && obi.OOBStatus[allRcvd]) {
                ++chunksRcvd;
                ++allRcvd;
            }

            chunksRcvd = allRcvd;
            for (int n = allRcvd; n < nchunks; n++) {
                if (obi.OOBStatus[n]) {
                    ++chunksRcvd;
                }
            }
        }

        private void AsyncRcvDone(object sender, SocketAsyncEventArgs ae) {
            AsyncReadInfo ari = (AsyncReadInfo)ae.UserToken;
            OOBInfo obi = ari.obi;
            MemoryMappedViewAccessor mmva = ari.mmva;
            if (ari.obiDI.hasBeenDeleted)
                return;
            byte[] buffer = ari.buffer;
            Group g = Group.doLookup(obi.gaddr);
            if (g != null && g.myAes != null) {
                buffer = g.decipherBuf(buffer);
            }

            bool success = Msg.InvokeFromBArray(buffer, new Action<int, long, byte[]>((hashcode, offset, payload) => {
                if (hashcode != ari.hashcode) {
                    if ((VsyncSystem.Debug & VsyncSystem.DISCARDS) != 0) {
                        Vsync.WriteLine("WARNING: discard a packet in AsyncRcvDone (hashcode incorrect)");
                    }

                    return;
                }

                mmva.WriteArray(offset, payload, 0, payload.Length);
                if (obi.OOBStatus == null) {
                    throw new VsyncException("OOBStatus null in AsyncRcvDone");
                }

                int cn = (int)(offset / Vsync.VSYNC_OOBCHUNKSIZE);
                obi.OOBStatus[cn] = true;
            }));
            if (!success && (VsyncSystem.Debug & VsyncSystem.DISCARDS) != 0) {
                Vsync.WriteLine("WARNING: discard a packet in AsyncRcvDone (msg corruption)");
            }

            try {
                ari.rSema.Release();
                if (ari.rSock.ReceiveFromAsync(ae)) {
                    return;
                }
            }
            catch (ObjectDisposedException) {
            }
            catch (SocketException) {
            }

            using (var tmpLockObj = new LockAndElevate(OOBMapLock)) {
                this.RecycledBuffers.Add(buffer);
            }
        }

        private static long OOBGetLength(OOBInfo obi) {
            if (obi.mmva != null) {
                obi.len = obi.mmva.Capacity;
            }

            return obi.len;
        }

        private static byte[] OOBGetChunk(MemoryMappedViewAccessor mmva, int cn) {
            byte[] payload = new byte[(int)Vsync.VSYNC_OOBCHUNKSIZE];
            int nb = mmva.ReadArray(OOBGetOffset(cn), payload, 0, (int)Vsync.VSYNC_OOBCHUNKSIZE);
            if (nb < (int)Vsync.VSYNC_OOBCHUNKSIZE) {
                Vsync.ArrayResize(ref payload, nb);
            }

            return payload;
        }

        private static long OOBGetOffset(int cn) {
            return cn * Vsync.VSYNC_OOBCHUNKSIZE;
        }

        internal static void doOOBGotChunk(string OOBFname, long offset, long len, byte[] data, bool isLast) {
            OOBInfo obi;
            using (var tmpLockObj = new LockAndElevate(OOBMapLock))
                if (!OOBMap.TryGetValue(OOBFname, out obi))
                    throw new VsyncException("doOOBGotChunk");
            doOOBGotChunk(obi, OOBFname, offset, len, data, isLast);
        }

        private static void doOOBGotChunk(OOBInfo obi, string OOBFname, long offset, long len, byte[] data, bool isLast) {
            obi.len = Math.Max(len, obi.len);
            OOBSetupmmf(obi, OOBFname, len);
            obi.mmva.WriteArray(offset, data, 0, data.Length);
            if (isLast) {
                OOBReplicaIsReady(obi, true);
            }
        }

        /// <summary>
        /// OOBDelete causes the OOB logic to close the MemoryMappedFile reference associated with OOBFname and to 
        /// dispose of its internal data structure for this mapped file <i>at all locations in the group</i>.  As for the file itself, OOB takes no action,
        /// hence it will continue to exist if backed by a disk file and will be closed and removed from the O/S
        /// mapped files memory if not.
        /// </summary>
        /// <param name="OOBFname"></param>
        /// <remarks>It is important to understand that this is a distributed action. The deletion will occur at every member of the group.
        /// To "unmap" a file at some single location, use OOBReReplicate and just remove that group member from the list at which a replica
        /// is desired.  However, if other applications have the file open and mapped on the same machines where an OOBDelete runs, those
        /// other applications will not be effected by the deletion operation. It only applies within the code linked to Vsync.</remarks>
        public void OOBDelete(string OOBFname) {
            if (this != Vsync.VSYNCMEMBERS) {
                Vsync.VSYNCMEMBERS.OOBDelete(OOBFname);
                return;
            }

            this.OOBReReplicate(OOBFname, new List<Address>());
        }

        /// <summary>
        /// Find the MemoryMappedFile object associated with this OOBFname.  Blocks until file is fully transferred
        /// </summary>
        /// <returns>MemoryMappedFile reference</returns>
        /// <param name="OOBFname"></param>
        /// <remarks>The OOB subsystem will hold a MemoryMappedFile reference until you call OOBDelete(fname)</remarks>
        public MemoryMappedFile OOBFetch(string OOBFname) {
            if (this != Vsync.VSYNCMEMBERS) {
                return Vsync.VSYNCMEMBERS.OOBFetch(OOBFname);
            }

            View theView;
            using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.ViewLock)) {
                theView = Vsync.VSYNCMEMBERS.theView;
            }

            OOBInfo obi;
            using (var tmpLockObj = new LockAndElevate(OOBMapLock)) {
                if (!OOBMap.TryGetValue(OOBFname, out obi)) {
                    OOBMap.Add(OOBFname, obi = new OOBInfo(OOBFname, theView));
                }
            }

            if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                Vsync.WriteLine("OOBFetch: checking to see if " + OOBFname + " is ready to access");
            }

            try {
                OOBFetchWait(obi);
            }
            catch (ObjectDisposedException) {
                return null;
            }

            if ((obi.flags & OOBInfo.OBI_MASTER) == 0) {
                if (obi.OOBStatus != null) {
                    foreach (bool b in obi.OOBStatus) {
                        if (!b) {
                            throw new VsyncException("OOBFetch synchronization error: not all blocks have transferred" + obi);
                        }
                    }
                }
            }

            if ((VsyncSystem.Debug & VsyncSystem.OOBXFERS) != 0) {
                Vsync.WriteLine("OOBFetch: " + OOBFname + " is ready to access");
            }

            return obi.mmf;
        }

        /// <summary>
        /// Information record returned by OOBGetRep
        /// </summary>
#if PROTOCOL_BUFFERS
        [ProtoContract(SkipConstructor = true)]
#else
        [AutoMarshalled]
#endif
        public class OOBRepInfo {
            /// <summary>
            /// Mapped file name
            /// </summary>
            [ProtoMember(1)]
            public string OOBFname;

            /// <summary>
            /// Group with which file is associated
            /// </summary>
            [ProtoMember(2)]
            public Address gaddr;

            /// <summary>
            /// Length of the mapped object
            /// </summary>
            [ProtoMember(3)]
            public long len;

            /// <summary>
            /// Locations where it can be found, based on members in current group view
            /// </summary>
            [ProtoMember(4)]
            public List<IPAddress> OOBHomes;

#if PROTOCOL_BUFFERS
            [ProtoAfterDeserialization]
            private void AfterDeserialize()
            {
                if (this.OOBHomes == null)
                {
                    this.OOBHomes = new List<IPAddress>(0);
                }
            }
#else
            /// <exclude></exclude>
            public OOBRepInfo() {
            }
#endif

            /// <exclude></exclude>
            public OOBRepInfo(string OOBFname, Address gaddr, long len, List<IPAddress> OOBHomes) {
                this.OOBFname = OOBFname;
                this.gaddr = gaddr;
                this.len = len;
                this.OOBHomes = OOBHomes;
            }
        }

        /// <summary>
        /// Used when a new leader is taking over; returns the current replication pattern for the mapped objects
        /// </summary>
        /// <returns></returns>
        public List<OOBRepInfo> OOBGetRepInfo() {
            if (this != Vsync.VSYNCMEMBERS) {
                return Vsync.VSYNCMEMBERS.OOBGetRepInfo();
            }

            View theView;
            using (var tmpLockObj = new LockAndElevate(this.ViewLock)) {
                theView = this.theView;
            }

            if (theView == null) {
                return null;
            }

            List<OOBRepInfo> theRes = new List<OOBRepInfo>();
            using (var tmpLockObj = new LockAndElevate(OOBMapLock)) {
                foreach (KeyValuePair<string, OOBInfo> oobi in OOBMap) {
                    theRes.Add(new OOBRepInfo(oobi.Key, oobi.Value.gaddr, oobi.Value.len, oobi.Value.replicaHomes));
                }
            }

            return theRes;
        }

        // Called (in VSYNCMEMBERS) when view changes; any pending multicasts will have been delivered by now
        internal void OOBNewView(View v) {
            bool recheck = false;
            OOBInfo obi = null;
            using (var tmpLockObj = new LockAndElevate(OOBMapLock)) {
                foreach (KeyValuePair<string, OOBInfo> kvp in OOBMap) {
                    IPAddress oldLeadersIPAddress = null;
                    obi = kvp.Value;
                    int oldCount = obi.replicaHomes.Count;
                    if (obi.replicaHomes.Count > 0) {
                        oldLeadersIPAddress = obi.replicaHomes[0];
                        obi.replicaHomes = obi.replicaHomes.Intersect(v.members.Select(a => a.home)).ToList();
                        obi.replicaOwners = IPAddrsToOwners(obi.replicaHomes, v);
                    }

                    if (obi.replicaHomes.Count == 0 && oldCount != 0) {
                        this.OOBRemoveObi(obi);
                        continue;
                    }

                    if ((obi.flags & OOBInfo.OBI_SENDING) != 0 && v.leavers.Select(a => a.home).Contains(oldLeadersIPAddress) && obi.replicaHomes[0].Equals(Vsync.my_IPaddress)) {
                        recheck = true;
                    }
                }
            }

            if (recheck) {
                OOBCheckQ(obi);
            }
        }

        /// <summary>
        /// Callback used on completion of an OOBBeginFetch
        /// </summary>
        /// <param name="OOBFname"></param>
        /// <param name="mmf"></param>
        public delegate void OOBAsyncCallback(string OOBFname, MemoryMappedFile mmf);

        /// <summary>
        /// Asynchronously find the MemoryMappedFile object for this OOBFname.  Callback occurs when the file is fully transferred
        /// </summary>
        /// <param name="acb"></param>
        /// <param name="OOBFname"></param>
        public void OOBBeginFetch(string OOBFname, OOBAsyncCallback acb) {
            if (this != Vsync.VSYNCMEMBERS) {
                Vsync.VSYNCMEMBERS.OOBBeginFetch(OOBFname, acb);
                return;
            }

            new Thread(() => {
                for (int retry = 0; retry < 5; retry++) {
                    using (var tmpLockObj = new LockAndElevate(OOBMapLock)) {
                        OOBInfo obi;
                        if (OOBMap.TryGetValue(OOBFname, out obi)) {
                            acb(OOBFname, obi.mmf);
                            return;
                        }
                    }

                    Vsync.Sleep(10000);
                }

                throw new VsyncException("OOBBeginFetch didn't find an entry for < " + OOBFname + ">");
            }) { Name = "OOBBeginFetch callback thread for <" + OOBFname + ">", IsBackground = true }.Start();
        }

        private bool disposed;

        /// <summary>
        /// Because Group uses some unmanaged resources, C# requires an explicit "Dispose" API
        /// </summary>
        public void Dispose() {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing) {
            if (!disposing) {
                return;
            }

            lock (this) {
                if (this.disposed) {
                    return;
                }

                this.disposed = true;
            }

            if (this.waitForPutSema != null) {
                this.waitForPutSema.Dispose();
            }

            if (this.xferWait != null) {
                this.xferWait.Dispose();
            }

            if (this.quiesceWait != null) {
                this.quiesceWait.Dispose();
            }

            if (this.interruptLockWaits != null) {
                this.interruptLockWaits.Dispose();
            }

            if (this.gsdhNotEmpty != null) {
                this.gsdhNotEmpty.Dispose();
            }

            if (this.ddhNotEmpty != null) {
                this.ddhNotEmpty.Dispose();
            }

            if (this.Wedged != null) {
#if !__MonoCS__
                this.Wedged.Dispose();
#endif // !__MonoCS__
                this.Wedged = null;
            }

            if (this.myChkptStream != null) {
                this.myChkptStream.Dispose();
                this.myChkptStream = null;
            }

            if (this.AesSeed != null) {
                this.AesSeed.Dispose();
                this.AesSeed = null;
            }
        }
    }

    /// <summary>
    /// The Address object represents a process or group within the Vsync system
    /// </summary>
    /// <remarks>
    /// The Address object represents a process or group within the Vsync system
    /// Encoded within it are the IP address of the node on which the process lives, its process-id
    /// and the port numbers used to send to it.  However, although this information is printed by the
    /// pretty-print routines, it is not normally needed by Vsync users and is not accessible other than
    /// in print form.
    /// </remarks>
#if PROTOCOL_BUFFERS
        [ProtoContract(SkipConstructor = true)]
#endif
    public class Address : IComparable, IComparable<Address>, IEquatable<Address> {
        [ProtoMember(1)]
        internal IPAddress home; // Node on which this process is running

        [ProtoMember(2)]
        internal int pid; // Process identifier for a process; 0 for a group

        [ProtoMember(3)]
        internal int p2pPort; // Personal port number for point-to-point messages

        [ProtoMember(4)]
        internal int ackPort; // Personal port number for acks

        [ProtoMember(5)]
        internal int cachedHashCode; // To speed up the computation of the hashcode.

        internal static int GroupNameHash(string gname) {
            if (gname == null) {
                throw new GroupNotFoundException("VSYNC can't join anonymous groups" + Environment.NewLine + VsyncSystem.GetState());
            }

            if (gname.Equals("ORACLE", StringComparison.Ordinal)) {
                return 0;
            }

            int the_hash = 0;
            foreach (char character in gname) {
                unchecked {
                    the_hash = (the_hash * 37) + character;
                }
            }

            if ((the_hash &= 0xFFFF) == 0) {
                the_hash = 1;
            }

            return the_hash % (Vsync.VSYNC_MCRANGE_HIGH - Vsync.VSYNC_MCRANGE_LOW);
        }

        /// <exclude></exclude>
        public static bool operator <(Address first, Address second) {
            return Compare(first, second) < 0;
        }

        /// <exclude></exclude>
        public static bool operator >(Address first, Address second) {
            return Compare(first, second) > 0;
        }

        /// <exclude></exclude>
        public static bool operator <=(Address first, Address second) {
            return Compare(first, second) <= 0;
        }

        /// <exclude></exclude>
        public static bool operator >=(Address first, Address second) {
            return Compare(first, second) >= 0;
        }

        /// <exclude></exclude>
        public static bool operator ==(Address first, Address second) {
            return Compare(first, second) == 0;
        }

        /// <exclude></exclude>
        public static bool operator !=(Address first, Address second) {
            return Compare(first, second) != 0;
        }

        /// <summary>
        /// Implements the C# comparison API for Address objects
        /// </summary>
        /// <param name="first">First address to compare with</param>
        /// <param name="second">Second address to compare with</param>
        /// <returns>-1, 0 or 1 on the basis of an Address sort rule</returns>
        public static int Compare(Address first, Address second) {
            if (object.ReferenceEquals(first, second)) {
                return 0;
            }

            if (object.ReferenceEquals(first, null)) {
                return -1;
            }

            if (object.ReferenceEquals(second, null)) {
                return 1;
            }

            byte[] hb1 = first.home.GetAddressBytes();
            byte[] hb2 = second.home.GetAddressBytes();

            // For a group, pid is always 0 and we compare virtual IPMC IP address number and port numbers.  For a process, we use the host and pid numbers.
            int h1 = (hb1[0] << 24) | (hb1[1] << 16) | (hb1[2] << 8) | hb1[3];
            int h2 = (hb2[0] << 24) | (hb2[1] << 16) | (hb2[2] << 8) | hb2[3];
            int comparison = h1.CompareTo(h2);
            if (comparison != 0) {
                return comparison;
            }

            comparison = first.pid.CompareTo(second.pid);
            if (comparison != 0) {
                return comparison;
            }

            comparison = first.ackPort.CompareTo(second.ackPort);
            if (comparison != 0) {
                return comparison;
            }

            comparison = first.p2pPort.CompareTo(second.p2pPort);
            return comparison;
        }

        /// <summary>
        /// Implements the C# equality API for Address objects
        /// </summary>
        /// <param name="other">the address to compare against</param>
        /// <returns>true if the addresses refer to the same process or same group</returns>
        public override bool Equals(object other) {
            return Compare(this, other as Address) == 0;
        }

        /// <summary>
        /// Implements the C# equality API for Address objects
        /// </summary>
        /// <param name="other">the address to compare against</param>
        /// <returns>true if the addresses refer to the same process or same group</returns>
        public bool Equals(Address other) {
            return Compare(this, other) == 0;
        }

        /// <summary>
        /// Implements the C# comparison API for Address objects
        /// </summary>
        /// <param name="other">address to compare with</param>
        /// <returns>-1, 0 or 1 on the basis of an Address sort rule</returns>
        public int CompareTo(object other) {
            return Compare(this, other as Address);
        }

        /// <summary>
        /// Implements the C# comparison API for Address objects
        /// </summary>
        /// <param name="other">address to compare with</param>
        /// <returns>-1, 0 or 1 on the basis of an Address sort rule</returns>
        public int CompareTo(Address other) {
            return Compare(this, other);
        }

        /// <summary>
        /// Tests to see if some address b is included in some list of addresses alist
        /// </summary>
        /// <param name="alist">list of addresses</param>
        /// <param name="b">process we are looking for</param>
        /// <returns>true if the list includes the designated process, else false</returns>
        public static bool Includes(Address[] alist, Address b) {
            foreach (Address a in alist) {
                if (a == b) {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Tests to see if the target Address is the caller's address
        /// </summary>
        /// <returns>true if the Address is the address of the calling process, false if not</returns>
        public bool isMyAddress() {
            return this == Vsync.my_address;
        }

        /// <summary>
        /// Tests to see if the target Address is the NULL address
        /// </summary>
        /// <returns>true if the Address is the NULL address, false if not</returns>
        public bool isNull() {
            return this == Vsync.NULLADDRESS;
        }

        /// <summary>
        /// Tests to see if the caller is in some list of Addresses
        /// </summary>
        /// <param name="list">address list to scan</param>
        /// <returns>true if the list includes the caller, false if not</returns>
        public static bool IncludesMe(Address[] list) {
            foreach (Address a in list) {
                if (a == Vsync.my_address) {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Overrides GetHashCode for Address comparisons
        /// </summary>
        /// <returns>unique hashcode for the Address</returns>
        public override int GetHashCode() {
            if (this.cachedHashCode != 0) {
                return this.cachedHashCode;
            }

            byte[] hb = this.home.GetAddressBytes();

            // For a group, pid is always 0 and we compare virtual IPMC IP address number and port numbers.  For a process, we use the host and pid numbers.
            if (this.pid == 0) {
                this.cachedHashCode = (this.ackPort * 171) + (this.p2pPort * 133) + ((hb[0] * 13) << 24) | ((hb[1] * 13) << 16) | ((hb[2] * 13) << 8) | (hb[3] * 13);
            }
            else {
                this.cachedHashCode = (this.pid * 370037) + (this.pid & 1) + ((this.pid >> 2) & 1) + ((hb[0] * 13) << 24) | ((hb[1] * 13) << 16) | ((hb[2] * 13) << 8) | (hb[3] * 13);
            }

            this.cachedHashCode &= 0x7FFFFFFF;
            return this.cachedHashCode;
        }

        internal Address(IPAddress h, int p) {
            this.home = h;
            this.pid = p;
        }

        internal Address(Address a) {
            this.home = a.home;
            this.pid = a.pid;
            this.ackPort = a.ackPort;
            this.p2pPort = a.p2pPort;
            this.cachedHashCode = a.cachedHashCode;
        }

        /// <summary>
        /// This method is used to turn a string formatted Address back into an Vsync Address object.
        /// </summary>
        /// <param name="aStr">The address in the printed outform used by Vsync</param>
        /// <remarks>Used in large configurations for Master/Worker batch starts.   Requires long-form address from toString().  
        /// If the VsyncSystem.Debug VERBOSEADDRS bit isn't enabled, the Address.ToString() output will be in a short-hand form that makes for
        /// concise printouts but lacks some of the required fields and hence will cause Address(targetAddress) to throw an exception. </remarks>
        public Address(string aStr) {
            string PID;
            string b0;
            string b1;
            string b2;
            string b3;
            string P2PPORT;

            do {
                // Verbose address format:  "(" + pid.ToString() + ":" + b[0] + "." + b[1] + "." + b[2] + "." + b[3] + "/" + p2pPort + ":" + ackPort + ")";
                // Address can also be called with an IP address.  Lacks the () and should be in IPv4 string format
                if (aStr[0] != '(' || aStr[aStr.Length - 1] != ')') {
                    // If we're just given the IP address, use PID=0 and the defaults for the P2P and ACK port numbers
                    b0 = aChunk(ref aStr, '.');
                    if (b0 == null) {
                        break;
                    }

                    b1 = aChunk(ref aStr, '.');
                    if (b1 == null) {
                        break;
                    }

                    b2 = aChunk(ref aStr, '.');
                    if (b2 == null) {
                        break;
                    }

                    b3 = aStr;
                    PID = "0";
                    P2PPORT = Vsync.VSYNC_DEFAULT_PORTNOp.ToString(CultureInfo.InvariantCulture);
                    aStr = Vsync.VSYNC_DEFAULT_PORTNOa.ToString(CultureInfo.InvariantCulture);
                }
                else {
                    aStr = aStr.Substring(1, aStr.Length - 2);
                    PID = aChunk(ref aStr, ':');
                    if (PID == null) {
                        break;
                    }

                    b0 = aChunk(ref aStr, '.');
                    if (b0 == null) {
                        break;
                    }

                    b1 = aChunk(ref aStr, '.');
                    if (b1 == null) {
                        break;
                    }

                    b2 = aChunk(ref aStr, '.');
                    if (b2 == null) {
                        break;
                    }

                    b3 = aChunk(ref aStr, '/');
                    if (b3 == null) {
                        break;
                    }

                    P2PPORT = aChunk(ref aStr, ':');
                    if (P2PPORT == null) {
                        break;
                    }
                }

                if (!int.TryParse(PID, out this.pid)) {
                    break;
                }

                byte first;
                if (!byte.TryParse(b0, out first)) {
                    break;
                }

                byte second;
                if (!byte.TryParse(b1, out second)) {
                    break;
                }

                byte third;
                if (!byte.TryParse(b2, out third)) {
                    break;
                }

                byte fourth;
                if (!byte.TryParse(b3, out fourth)) {
                    break;
                }

                if (!int.TryParse(P2PPORT, out this.p2pPort)) {
                    break;
                }

                if (!int.TryParse(aStr, out this.ackPort)) {
                    break;
                }

                this.home = new IPAddress(new[] { first, second, third, fourth });
                this.cachedHashCode = 0;
                return;
            }
            while (false);
            throw new ArgumentException("Address format should be \"(pid:wwww.xxxx.yyyy.zzzz/pport:aport)\"");
        }

        // Eats a chunk of text up to a delimiter character, returns the text, truncates the string and leaves the remainder
        private static string aChunk(ref string aStr, char c) {
            int i = aStr.IndexOf(c);
            if (i == -1) {
                return null;
            }

            string pid = aStr.Substring(0, i);
            aStr = aStr.Substring(i + 1);
            return pid;
        }

        internal const int lengthOfAddress = 16;

        internal void toBArray(byte[] b, int off) {
            byte[] myIP = this.home.GetAddressBytes();
            int myPID = this.pid;
            int myP2P = this.p2pPort;
            int myAP = this.ackPort;
            for (int i = 0; i < 4; i++) {
                b[off + i] = myIP[i];
                b[off + 4 + i] = (byte)(myP2P & 0xFF);
                b[off + 8 + i] = (byte)(myAP & 0xFF);
                b[off + 12 + i] = (byte)(myPID & 0xFF);
                myP2P >>= 8;
                myAP >>= 8;
                myPID >>= 8;
            }
        }

        internal Address(byte[] b, int off) {
            byte[] myIP = new byte[4];
            int myPID = 0;
            int myP2P = 0;
            int myAP = 0;
            for (int i = 0; i < 4; i++) {
                myIP[i] = b[off + i];
                myP2P = (myP2P << 8) | b[off + 7 - i];
                myAP = (myAP << 8) | b[off + 11 - i];
                myPID = (myPID << 8) | b[off + 15 - i];
            }

            this.home = new IPAddress(myIP);
            this.pid = myPID;
            this.p2pPort = myP2P;
            this.ackPort = myAP;
        }

        internal byte[] toBArray() {
            byte[] b = new byte[lengthOfAddress];
            this.toBArray(b, 0);
            return b;
        }

        internal static byte[] toBArray(Address[] al) {
            byte[] b = new byte[al.Length * lengthOfAddress];
            for (int off = 0; off < al.Length; off++) {
                Address a = al[off] ?? Vsync.NULLADDRESS;
                a.toBArray(b, off * lengthOfAddress);
            }

            return b;
        }

        internal static Address[] ToAddresses(byte[] ba, int off, int nb) {
            int na = nb / lengthOfAddress;
            if (na * lengthOfAddress != nb) {
                return new Address[0];
            }

            Address[] av = new Address[na];
            for (int n = 0; n < na; n++) {
                av[n] = new Address(ba, off);
                off += lengthOfAddress;
            }

            return av;
        }

        internal static bool SameAddrs(Address[] a, Address[] b) {
            bool same = true;
            if (a.Length != b.Length) {
                return false;
            }

            for (int i = 0; i < a.Length && same; i++) {
                if (a[i] != b[i]) {
                    same = false;
                }
            }

            if (same) {
                return true;
            }

            foreach (Address aa in a) {
                same = false;
                foreach (Address ba in b) {
                    if (aa == ba) {
                        same = true;
                        break;
                    }
                }

                if (!same) {
                    return false;
                }
            }

            return true;
        }

        internal static bool SameNames(string[] a, string[] b) {
            bool same = true;
            if (a.Length != b.Length) {
                return false;
            }

            for (int i = 0; i < a.Length && same; i++) {
                if (!a[i].Equals(b[i], StringComparison.Ordinal)) {
                    same = false;
                }
            }

            if (same) {
                return true;
            }

            foreach (string astr in a) {
                same = false;
                foreach (string bstr in b) {
                    if (astr.Equals(bstr, StringComparison.Ordinal)) {
                        same = true;
                        break;
                    }
                }

                if (!same) {
                    return false;
                }
            }

            return true;
        }

        internal Address() {
            this.home = new IPAddress(0);
        }

        /// <summary>
        /// Pretty-print a single Address
        /// </summary>
        /// <returns>string representation of the Address</returns>
        public override string ToString() {
            if ((VsyncSystem.Debug & VsyncSystem.VERBOSEADDRS) != 0 || (this.pid == 0 && !this.isNull())) {
                return this.ToStringVerboseFormat();
            }

            return "(" + this.pid.ToString(CultureInfo.InvariantCulture) + ")";
        }

        /// <summary>
        /// Returns true if this is a group address, false if it is a process address
        /// </summary>
        /// <returns></returns>
        public bool isGroupAddress() {
            return this != Vsync.NULLADDRESS && this.pid == 0;
        }

        /// <summary>
        /// Pretty-print a single Address in the detailed format required for parsing back into an Address via new Address(str)
        /// </summary>
        /// <returns>string representation of the Address</returns>
        /// <remarks>To keep our traces short, we normally print addresses in a very short format</remarks>
        public string ToStringVerboseFormat() {
            byte[] b = this.home.GetAddressBytes();
            return "(" + this.pid + ":" + b[0] + "." + b[1] + "." + b[2] + "." + b[3] + "/" + this.p2pPort + ":" + this.ackPort + ")";
        }

        /// <summary>
        /// Pretty-print a vector of Addresses
        /// </summary>
        /// <param name="a">the address vector</param>
        /// <returns>string representation of the vector</returns>
        public static string VectorToString(Address[] a) {
            if (a == null) {
                return string.Empty;
            }

            string theString = string.Empty;
            for (int i = 0; i < a.Length; i++) {
                theString += a[i].ToString();
            }

            return "[" + theString + "]";
        }

        internal static string VectorToString(List<Address> a) {
            return VectorToString(a.ToArray());
        }

        // Same idea but for a vector of IP Addresses
        internal static string VectorToString(IPAddress[] a) {
            if (a == null) {
                return string.Empty;
            }

            string theString = string.Empty;
            for (int i = 0; i < a.Length; i++) {
                byte[] b = a[i].GetAddressBytes();
                theString += "(" + b[0] + "." + b[1] + "." + b[2] + "." + b[3] + ")";
            }

            return "[" + theString + "]";
        }

        internal static string VectorToString(List<IPAddress> a) {
            return VectorToString(a.ToArray());
        }

        internal static string VectorToString(List<List<IPAddress>> la) {
            string lls = "[ ";
            foreach (var a in la)
                lls += VectorToString(a) + " ";
            return lls + "]";
        }

        internal static Address[] Merge(Address[] a, Address b) {
            return Merge(a, new[] { b });
        }

        internal static Address[] Merge(Address[] a, Address[] b) {
            if (a == null) {
                a = new Address[0];
            }

            if (b == null) {
                b = new Address[0];
            }

            Address[] Merged = new Address[a.Length + b.Length];
            int n = 0;
            foreach (Address address in a) {
                bool dup = false;
                for (int j = 0; j < n; j++) {
                    if (Merged[j] == address) {
                        dup = true;
                        break;
                    }
                }

                if (!dup) {
                    Merged[n++] = address;
                }
            }

            foreach (Address address in b) {
                bool dup = false;
                for (int j = 0; j < a.Length; j++) {
                    if (a[j] == address) {
                        dup = true;
                        break;
                    }
                }

                if (!dup) {
                    Merged[n++] = address;
                }
            }

            if (n != Merged.Length) {
                Vsync.ArrayResize(ref Merged, n);
            }

            return Merged;
        }

        internal static Address[] Diff(Address[] a, Address[] b) {
            if (a == null || b == null) {
                return a;
            }

            Address[] r = new Address[a.Length];
            int n = 0;
            for (int i = 0; i < r.Length; i++) {
                bool fnd = false;
                for (int j = 0; j < b.Length; j++) {
                    if (a[i] == b[j]) {
                        fnd = true;
                        break;
                    }
                }

                if (!fnd) {
                    r[n++] = a[i];
                }
            }

            if (r.Length != n) {
                Vsync.ArrayResize(ref r, n);
            }

            return r;
        }
    }

    /*
     *  This slightly messy logic allows the View members structure to switch back and forth between being indexed for fast
     *  search (needed with large groups) and acting like a totally normal vector of Address objects (for small ones).  Users
     *  of the v.members property shouldn't be aware of the underlying logic because it mimics a vector API.
     */

    /// <exclude></exclude>
    public class indexedMVector {
        private Address[] _members = new Address[0];

        private Dictionary<Address, int> index;

        /// <exclude></exclude>
        public Address[] members
        {
            get
            {
                return this._members;
            }

            set
            {
                this._members = value;
                if (this._members.Length > Vsync.VSYNC_INDEXMEMBERS) {
                    this.index = new Dictionary<Address, int>(1000);
                    for (int i = 0; i < this._members.Length; i++) {
                        if (this._members[i] != null && !this._members[i].isNull()) {
                            this.index.Add(this._members[i], i);
                        }
                    }
                }
            }
        }

        /// <exclude></exclude>
        public Address this[int i]
        {
            get
            {
                return this._members[i];
            }

            set
            {
                if (this.index != null) {
                    if (this._members[i] != null && !this._members[i].isNull()) {
                        this.index.Remove(this._members[i]);
                    }

                    if (value == null && !value.isNull()) {
                        this.index.Add(value, i);
                    }
                }

                this._members[i] = value;
            }
        }

        /// <exclude></exclude>
        public int IndexOf(Address a) {
            if (this.index == null || a.isNull()) {
                for (int i = 0; i < this.members.Length; i++) {
                    if (this.members[i] == a) {
                        return i;
                    }
                }

                return -1;
            }

            int where;
            if (this.index.TryGetValue(a, out where)) {
                return where;
            }

            return -1;
        }
    }

    /// <summary>
    /// The View structure for an Vsync Group.  This is a central abstraction for the system with many useful
    /// guarantees.  Read about the <it>virtual synchrony model</it> to learn more.
    /// </summary>
    /// <remarks>
    /// The core abstraction in the Vsync platform is the virtual synchrony model, which provides a unique, globally observed ordering on
    /// messages and membership changes, which are reported through new "View" events.  The view structure encodes all the information
    /// needed to coordinate a set of processes.  Views are reported via callback from a per-group thread created by Vsync.
    /// 
    /// All members of the view see the same view, with members in the same order.  That order is from oldest (longest resident in the group)
    /// to youngest, with ties broken by the order in which the join requests reached the core Vsync system.  The list of joiners indicates the
    /// members that just joined, as a convenience to the called view monitor.  The list of leavers, similarly, lists members that belonged to the
    /// prior view but are no longer in the group (e.g. they failed, or voluntarily departed).
    /// 
    /// The view is uniquely numbered by a sequential id value.  Once view K has been reported, no further 
    /// multicasts will be delivered in view K-1, and all operational members of view K-1 has received the identical messages.
    /// </remarks>
    public class View : IEquatable<View>, ISelfMarshalled {
        /// <summary>
        /// Vsync-assigned Address representing this group
        /// </summary>
        public readonly Address gaddr;

        /// <summary>
        /// Group name, if known
        /// </summary>
        public string gname = "unknown";

        private readonly indexedMVector _members = new indexedMVector();

        /// <summary>
        /// List of the current members of this group
        /// </summary>
        public Address[] members
        {
            get
            {
                return this._members.members;
            }

            set
            {
                this._members.members = value;
            }
        }

        /// <summary>
        /// List of the processes that joined this group since the last view was reported
        /// </summary>
        public Address[] joiners = new Address[0];

        /// <summary>
        /// List of processes that departed this group since the last view was reported
        /// </summary>
        public Address[] leavers = new Address[0];

        /// <summary>
        /// If members are joining, this offset is an optional long offset value that "indexes" into the
        /// state to be transferred.  The checkpoint creation routine can use this value to omit state that
        /// the joining process already has obtained (somehow)
        /// </summary>
        public long offset;

        /// <summary>
        /// Non-empty only in VSYNCMEMBERS and only when using INFINIBAND.  The lids of the current members
        /// </summary>
        public int[] remotelids = new int[0];

        internal List<ChkptMaker> theChkptMakers;

        internal bool isFinal = false;

        internal bool isLarge = false;

        internal int leaderId;

        internal bool[] hasFailed = new bool[0];

        internal bool hasFailedHasChanged;

        internal int[] NextIncomingMsgID;

        internal int minStable = -1;

        internal int lastStabilitySent = -1;

        internal class PSTuple {
            internal int vid;

            internal int msgid;

            internal int count;

            internal PSTuple(int vid, int mid, int cnt) {
                this.vid = vid;
                this.msgid = mid;
                this.count = cnt;
            }
        }

        internal LinkedList<PSTuple> PendingSends = new LinkedList<PSTuple>();

        internal int[] StableTo;

        internal int[] LastMsg;

        internal int[] myVT = new int[0];

        internal int myClock = 0;

        /// <summary>
        /// View id for the group
        /// </summary>
        public int viewid;

        /// <summary>
        /// Used to initialize the seqn of a joining member in a large group.  Group.nextMsgid is the "real" nextMsgid counter.
        /// </summary>
        internal int nextMsgid;

        /// <exclude></exclude>
        public static bool operator ==(View first, View second) {
            return Equals(first, second);
        }

        /// <exclude></exclude>
        public static bool operator !=(View first, View second) {
            return !Equals(first, second);
        }

        /// <summary>
        /// View equality comparison method
        /// </summary>
        /// <param name="first">the first view to compare with</param>
        /// <param name="second">the second view to compare with</param>
        /// <returns>true if the two views have the same view-id, else false</returns>
        public static bool Equals(View first, View second) {
            if (object.ReferenceEquals(first, second)) {
                return true;
            }

            if (object.ReferenceEquals(first, null) || object.ReferenceEquals(second, null)) {
                return false;
            }

            return first.gaddr == second.gaddr && first.viewid == second.viewid;
        }

        /// <summary>
        /// View equality comparison method
        /// </summary>
        /// <param name="other">the view to compare against</param>
        /// <returns>true if the two views have the same view-id, else false</returns>
        public override bool Equals(object other) {
            return Equals(this, other as View);
        }

        /// <summary>
        /// View equality comparison method
        /// </summary>
        /// <param name="other">the view to compare against</param>
        /// <returns>true if the two views have the same view-id, else false</returns>
        public bool Equals(View other) {
            return Equals(this, other);
        }

        /// <summary>
        /// Hashcode for this view
        /// </summary>
        /// <returns>hash code for a group view</returns>
        public override int GetHashCode() {
            return this.gaddr.GetHashCode() ^ this.viewid.GetHashCode();
        }

        /// <summary>
        /// A public method for pretty-printing a group view
        /// </summary>
        /// <returns>string representation of a group view</returns>
        public override string ToString() {
            string hf = "*", mid, stableto = string.Empty;
            bool someoneFailed = false;
            if (!this.isLarge) {
                mid = " <" + this.viewid + ":" + this.NextIncomingMsgID[0] + "> ";
            }
            else {
                mid = string.Empty;
            }

            for (int i = 1; i < this.hasFailed.Length + 1; i++) {
                hf += this.hasFailed[i - 1] ? "+" : "-";
                someoneFailed |= this.hasFailed[i - 1];
                if (i < this.NextIncomingMsgID.Length) {
                    mid += (!this.isLarge ? (this.viewid + ":") : string.Empty) + this.NextIncomingMsgID[i] + " ";
                    if (!this.isLarge) {
                        stableto += this.StableTo[i] + " ";
                    }
                }
            }

            if (stableto.Length > 0) {
                stableto = ", StableTo={ ** " + stableto + "}";
            }

            string rv = this.ViewSummary() + (someoneFailed ? ", hasFailed=[" + hf + "]" : string.Empty) + ", nextIn={ " + mid + "}" + ", minStable=" + this.minStable + " (last sent " + this.lastStabilitySent + ")" + stableto + ", joining={ " + Address.VectorToString(this.joiners) + "}, leaving={ " + Address.VectorToString(this.leavers) + "}";
            if (!this.isLarge) {
                rv += ", IamLeader = " + this.IAmLeader();
            }

            return rv;
        }

        internal string ViewSummary() {
            return "View[gname=<" + this.gname + ">, gaddr=" + this.gaddr + ", viewid=" + this.viewid + ";  " + this.members.Length + " members={ " + Address.VectorToString(this.members) + "}";
        }

        /// <summary>
        /// Returns the current view id for this view
        /// </summary>
        /// <returns>id of the current view</returns>
        public int GetViewid() {
            return this.viewid;
        }

        /// <summary>
        /// Returns the rank of the calling process in the view, or -1 if the caller is not a member of the group
        /// </summary>
        /// <returns>rank of the caller</returns>
        public int GetMyRank() {
            return this.GetRawRankOf(Vsync.my_address);
        }

        /// <summary>
        /// Obtains the current rank of a specified process within the current view, but returns -1 if the process has failed.
        /// </summary>
        /// <remarks>
        /// GetRankOf returns the value that <see cref="GetRawRankOf"/> would have returned except that if the process in question has failed, it returns -1.  Thus, calls to
        /// GetRankOf on a view {x,y,z} where y has failed would return 0 for x, -1 for y, and 1 for z.  Returns -1 if the
        /// member is not in the group at all, hence also returns -1 for w in this example.</remarks>
        /// <param name="a">address of the member</param>
        /// <returns>rank of the designated member</returns>
        public int GetRankOf(Address a) {
            int which = this._members.IndexOf(a);
            if (which != -1 && !this.hasFailed[which]) {
                return which;
            }

            return -1;
        }

        internal Address GetHomeRep(IPAddress a) {
            for (int which = 0; which < this.members.Length; which++) {
                if (this.members[which].home.Equals(a)) {
                    return this.members[which];
                }
            }

            return null;
        }

        internal int GetHomeRepRank(IPAddress a) {
            for (int which = 0; which < this.members.Length; which++) {
                if (this.members[which].home.Equals(a)) {
                    return which;
                }
            }

            return -1;
        }

        /// <summary>
        /// Obtains the rank of a specified process within the current view, returning an index into the current view even if the process has failed.  
        /// </summary>
        /// <remarks>
        /// Rank is defined from
        /// 0 (oldest) to n-1 (youngest) for a group with n members.  Ties are broken by using the original order in which Vsync was
        /// told to add a set of members: if the system was asked to add x, y and z all at once, x will rank lower than y, etc.
        /// Returns -1 if the specified process is not a member of the view.</remarks>
        /// <param name="a">address of the member</param>
        /// <returns>rank of that member</returns>
        public int GetRawRankOf(Address a) {
            return this._members.IndexOf(a);
        }

        /// <summary>
        /// True if the caller is the leader (oldest, lowest-ranked) member of this view.
        /// </summary>
        /// <remarks>
        /// This member is often used as the leader in tasks where a single unambiguous leader is needed.
        /// </remarks>
        /// <returns>true if this member is the leader, false if not</returns>
        public bool IAmLeader() {
            int i;
            for (i = 0; i < this.members.Length; i++) {
                if (!this.hasFailed[i]) {
                    break;
                }
            }

            if (i == this.members.Length) {
                return false;
            }

            return this.members[i].isMyAddress();
        }

        internal bool IAmRank0() {
            return this.members.Length > 0 && this.members[0].isMyAddress();
        }

        /// <summary>
        /// Obtains a vector of Addresses[] giving the current membership of this group
        /// </summary>
        /// <returns></returns>
        public Address[] GetMembers() {
            return this.members;
        }

        /// <summary>
        /// Returns the number of members in the current view of this group
        /// </summary>
        /// <returns></returns>
        public int GetSize() {
            return this.members.Length;
        }

        /// <summary>
        /// Obtains the current view for the group corresponding to Address gaddr.  Returns null if the caller is not a member of the group.
        /// </summary>
        /// <param name="gaddr"></param>
        /// <returns></returns>
        public static View Lookup(Address gaddr) {
            Group g = Group.doLookup(gaddr);
            if (g == null) {
                return null;
            }

            return g.theView;
        }

        internal View(string gn, Address ga, Address[] m, int vid, bool lg) {
            this.gname = gn;
            this.gaddr = ga;
            this.members = (Address[])m.Clone();
            this.myVT = new int[this.members.Length];
            this.viewid = vid;
            this.isLarge = lg;
            if (!this.isLarge) {
                this.NextIncomingMsgID = new int[this.members.Length + 1];
                this.StableTo = new int[this.members.Length + 1];
            }
            else {
                this.NextIncomingMsgID = new int[2];
                this.StableTo = new int[2];
            }

            this.LastMsg = new int[this.members.Length + 1];
            for (int i = 0; i < this.members.Length; i++) {
                this.LastMsg[i] = -1;
            }

            this.hasFailed = new bool[this.members.Length];
            this.hasFailedHasChanged = false;
        }

        internal View(int len, bool isLarge) {
            this.gaddr = Vsync.NULLADDRESS;
            this.members = new Address[len];
            this.myVT = new int[len];
            if (!isLarge) {
                this.NextIncomingMsgID = new int[len + 1];
                this.StableTo = new int[len + 1];
            }
            else {
                this.NextIncomingMsgID = new int[2];
                this.StableTo = new int[2];
            }

            this.LastMsg = new int[len];
            for (int i = 0; i < len; i++) {
                this.LastMsg[i] = -1;
            }

            this.hasFailed = new bool[len];
            this.hasFailedHasChanged = false;
        }

        /// <summary>
        /// Notes that the r'th ranked member of the current view has failed.  For internal use only
        /// </summary>
        /// <param name="r">rank of the member that failed</param>
        public void noteFailed(int r) {
            if (r < 0 || r >= this.hasFailed.Length) {
                return;
            }

            if (!this.hasFailed[r]) {
                this.hasFailed[r] = true;
                this.hasFailedHasChanged = true;
            }

            AwaitReplies.doNoteFailure(this.members[r]);
            if (this.hasFailedHasChanged && this.gaddr.Equals(Vsync.ORACLE.gaddr))
                Vsync.PendingLeaderViewChange(this);
        }

        /// <summary>
        /// Notes that the r'th ranked member of group g has failed.  Intended primarily for use in the Vsync system.
        /// </summary>
        /// <param name="g">group in which the failure was observed.</param>
        /// <param name="a">member that failed</param>
        public static void noteFailed(Group g, Address a) {
            // A bit cautious due to possible races against changing views
            View v;
            using (var tmpLockObj = new LockAndElevate(g.ViewLock)) {
                v = g.theView;
            }

            int r = v.GetRankOf(a);
            v.noteFailed(r);
            if (!g.isTrackingProxy) {
                Group tpg = Group.TrackingProxyLookup(g.gaddr);
                if (tpg == null) {
                    return;
                }

                using (var tmpLockObj = new LockAndElevate(tpg.ViewLock)) {
                    v = tpg.theView;
                }

                if (v != null && (r = tpg.theView.GetRankOf(a)) != -1) {
                    v.noteFailed(r);
                }
            }
        }

        internal int nLive() {
            int n = this.members.Length;
            foreach (bool b in this.hasFailed) {
                if (b) {
                    --n;
                }
            }

            return Math.Max(0, n);
        }

        internal int nFailed() {
            int n = 0;
            foreach (bool b in this.hasFailed) {
                if (b) {
                    ++n;
                }
            }

            return Math.Min(this.members.Length, n);
        }

        internal Address[] GetFailedMembers() {
            Address[] list = new Address[this.nFailed()];
            int idx = 0;
            for (int i = 0; i < this.members.Length; i++) {
                if (this.hasFailed[i]) {
                    list[idx++] = this.members[i];
                }
            }

            return list;
        }

        internal Address[] GetLiveMembers() {
            Address[] list = new Address[this.nLive()];
            int idx = 0;
            for (int i = 0; i < this.members.Length; i++) {
                if (!this.hasFailed[i]) {
                    list[idx++] = this.members[i];
                }
            }

            return list;
        }

        /// <summary>
        /// Converts View objects to an external form for transmission.  Not normally needed by end users
        /// </summary>
        /// <returns></returns>
        public byte[] toBArray() {
            int[] rl;
            if (Vsync.VSYNC_INFINIBAND && this.gname.Equals("VSYNCMEMBERS", StringComparison.Ordinal)) {
                rl = IB.remotelids ?? new int[0];
                if (rl.Length < this.members.Length) {
                    Vsync.ArrayResize(ref rl, this.members.Length);
                }

                rl[this.GetMyRank()] = Vsync.VSYNC_LID;
            }
            else {
                rl = new int[0];
            }

            byte[] ba = Msg.toBArray(Vsync.LeaderId, this.gname, this.gaddr, this.members, this.hasFailed, this.viewid, this.NextIncomingMsgID, this.isLarge, rl);
            return ba;
        }

        /// <summary>
        /// Constructor for new View objects received as byte arrays.  Not normally needed by end users.
        /// </summary>
        /// <param name="ba"></param>
        public View(byte[] ba) {
            object[] obs = Msg.BArrayToObjects(ba, typeof(int), typeof(string), typeof(Address), typeof(Address[]), typeof(bool[]), typeof(int), typeof(int[]), typeof(bool), typeof(int[]));
            int idx = 0;
            this.leaderId = (int)obs[idx++];
            this.gname = (string)obs[idx++];
            this.gaddr = (Address)obs[idx++];
            this.members = (Address[])obs[idx++];
            this.myVT = new int[this.members.Length];
            this.hasFailed = (bool[])obs[idx++];
            this.viewid = (int)obs[idx++];
            this.NextIncomingMsgID = (int[])obs[idx++];
            this.StableTo = new int[this.NextIncomingMsgID.Length];
            this.isLarge = (bool)obs[idx++];
            this.remotelids = (int[])obs[idx];
            if (this.remotelids.Length > 0 && (VsyncSystem.Debug & VsyncSystem.IBDB) != 0) {
                Vsync.Write("Recieved a view containing LIDS = {");
                foreach (int x in this.remotelids) {
                    Vsync.Write(" " + x);
                }

                Vsync.WriteLine("}");
            }
        }
    }

    internal class AwaitReplies {
        private static readonly LockObject UIDLock = new LockObject("UIDLock");

        private static int UID;

        internal class ReplyInfo {
            internal View rdvView;

            internal Address gaddr;

            internal string gname;

            internal bool enciphered;

            internal int uid;

            internal int rdvVid;

            internal int rdvMid;

            internal bool queryByOracle;

            internal List<byte[]> rdvReplies;

            internal bool[] gotReply;

            internal int replies_wanted;

            internal int replies_received = 0;

            internal int reply_waitid;

            internal string theReason = "<AbortReply>";

            internal int delay;

            internal int tid;

            internal ILock ilock;

            internal Group.VHCallBack vhcb;

            internal static int riCNTR;

            internal int ricntr = ++riCNTR;

            internal LockObject Lock = new LockObject("RdvInfo.Lock");

            internal ReplyInfo(Group g, int vid, int mid, bool sentByOracle, bool crypto, View v, List<Address> dests, int nr, int d, Group.VHCallBack vcb) {
                using (var tmpLockObj = new LockAndElevate(UIDLock)) {
                    this.uid = UID++;
                }

                if ((this.rdvView = v) != null) {
                    this.gotReply = new bool[v.members.Length];
                    if (dests != null) {
                        for (int r = 0; r != v.members.Length; r++) {
                            this.gotReply[r] = true;
                        }

                        int wc = 0;
                        foreach (Address waitFor in dests) {
                            int rank;
                            if ((rank = v.GetRankOf(waitFor)) != -1 && this.gotReply[rank]) {
                                ++wc;
                                this.gotReply[rank] = false;
                            }
                        }

                        nr = Math.Min(nr, wc);
                    }
                }
                else {
                    this.gotReply = new bool[nr];
                }

                if (g != null) {
                    this.gaddr = g.gaddr;
                    this.gname = g.gname;
                }
                else {
                    this.gaddr = Vsync.NULLADDRESS;
                    this.gname = "<null>";
                }

                this.rdvVid = vid;
                this.rdvMid = mid;
                this.queryByOracle = sentByOracle;
                this.enciphered = crypto;
                this.replies_wanted = nr;
                this.delay = d;
                this.rdvReplies = new List<byte[]>();
                if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                    Vsync.WriteLine("Allocate RdvInfo[" + this.ricntr + "]: " + this.rdvVid + ":" + this.rdvMid + " in group " + this.gaddr + ".... ri.wanted=" + this.replies_wanted);
                }

                this.vhcb = vcb;
                g.doRegisterViewCB(vcb);
            }

            // Caller has a lock on ri
            internal void UpdateRepliesWanted(int from) {
                this.UpdateRepliesWanted(false, from);
            }

            // Caller has a lock on ri
            internal void UpdateRepliesWanted(bool isNullreply, int from) {
                if (this.gotReply[from]) {
                    return;
                }

                this.gotReply[from] = true;
                if (isNullreply) {
                    int cnt = 0;
                    foreach (bool b in this.gotReply) {
                        if (!b) {
                            ++cnt;
                        }
                    }

                    this.replies_wanted = Math.Min(cnt, this.replies_wanted);
                }
                else {
                    --this.replies_wanted;
                }

                if (this.replies_wanted == 0 && this.ilock != null) {
                    this.ilock.BarrierRelease(1);
                    this.ilock = null;
                }

                if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                    Vsync.WriteLine("UpdateRepliesWanted[" + this.ricntr + ": from " + from + "]: " + this.rdvVid + ":" + this.rdvMid + " in group " + this.gaddr + ".... --ri.wanted=" + this.replies_wanted);
                }
            }
        }

        private static readonly List<ReplyInfo> RendezVous = new List<ReplyInfo>();

        private static readonly LockObject RendezVousLock = new LockObject("RendezVousLock");

        internal static string GetState() {
            string s = "AwaitReplies State:" + Environment.NewLine;
            using (var tmpLockObj = new LockAndElevate(RendezVousLock)) {
                foreach (ReplyInfo ri in RendezVous) {
                    using (var tmpLockObj1 = new LockAndElevate(ri.Lock)) {
                        string from = string.Empty, needed = string.Empty;
                        if (ri.rdvView.members.Length == ri.gotReply.Length) {
                            for (int i = 0; i < ri.gotReply.Length; i++) {
                                if (ri.gotReply[i]) {
                                    from += ri.rdvView.members[i];
                                }
                                else {
                                    needed += ri.rdvView.members[i];
                                }
                            }
                        }

                        s += "  Rendezvous[" + ri.uid + "]: <" + ri.gname + ">, using lock " + ILock.PLock(ri.ilock) + ", " + ri.rdvVid + ":" + ri.rdvMid + ", tid = " + ri.tid + " Need " + ri.replies_wanted + " additional replies (got " + ri.replies_received + " replies from <" + from + ">";
                        if (ri.replies_wanted > 0) {
                            s += ", waiting for replies from <" + needed + ">)";
                        }

                        s += ", reply wait-id " + ri.reply_waitid + Environment.NewLine;
                    }
                }
            }

            return s;
        }

        private static int maxRdvId;

        // Used in P2P queries
        internal static ReplyInfo registerP2PWait(Group who, int vid, int msgid, bool expectCiphered, Address dest, int delay) {
            return registerWait(who, vid, msgid, false, expectCiphered, 1, new List<Address> { dest }, delay);
        }

        internal static ReplyInfo registerGroupWait(Group who, int vid, int msgid, List<Address> destList, bool sentByOracle, bool expectCiphered, int nreplies, int delay) {
            return registerWait(who, vid, msgid, sentByOracle, expectCiphered, nreplies, destList, delay);
        }

        internal static ReplyInfo registerWait(Group who, int vid, int msgid, bool sentByOracle, bool expectCiphered, int nreplies, List<Address> dests, int delay) {
            ReplyInfo ri = null;
            if (nreplies == 0) {
                return null;
            }

            View theView = null;
            if (who != null) {
                using (var tmpLockObj = new LockAndElevate(who.ViewLock)) {
                    theView = who.theView;
                }
            }

            ri = new ReplyInfo(who, vid, msgid, sentByOracle, expectCiphered, theView, dests, nreplies, delay, new Group.VHCallBack(false, v => {
                // This code will be executed on new-view events for the group; needed in case someone voluntarily leaves a group while a request is pending
                if (ri == null) {
                    throw new VsyncException("View Callback in registerWait: ri unexpectedly null");
                }

                using (var tmpLockObj = new LockAndElevate(ri.Lock)) {
                    if (v.gaddr != ri.gaddr) {
                        Vsync.WriteLine("WARNING: View handler callback to RdvInfo.registerWait but for wrong group!");
                    }
                    else {
                        foreach (Address a in v.leavers) {
                            int i = ri.rdvView.GetRawRankOf(a);
                            if (i != -1 && !ri.gotReply[i]) {
                                ri.UpdateRepliesWanted(i);
                                if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                                    Vsync.WriteLine("[0]: ri.wanted=" + ri.replies_wanted + ", crashed: " + ri.rdvView.members[i]);
                                }
                            }
                        }
                    }
                }
            }));

            View whoView;
            using (var tmpLockObj = new LockAndElevate(who.ViewLock)) {
                whoView = who.theView;
            }

            using (var tmpLockObj = new LockAndElevate(RendezVousLock))
            using (var tmpLockObj1 = new LockAndElevate(ri.Lock)) {
                if (dests == null) {
                    for (int m = 0; m < whoView.members.Length; m++) {
                        if (whoView.hasFailed[m]) {
                            int n = ri.rdvView.GetRawRankOf(whoView.members[m]);
                            if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                                Vsync.WriteLine("[5]: ri.wanted=" + ri.replies_wanted + ", already dead " + ri.rdvView.members[n]);
                            }

                            ri.UpdateRepliesWanted(true, n);
                        }
                    }
                }
                else {
                    foreach (Address dest in dests) {
                        int m = whoView.GetRawRankOf(dest);
                        if (m != -1 && whoView.hasFailed[m]) {
                            int n = ri.rdvView.GetRawRankOf(whoView.members[m]);
                            if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                                Vsync.WriteLine("[5]: ri.wanted=" + ri.replies_wanted + ", already dead " + dest);
                            }

                            if (n != -1) {
                                ri.UpdateRepliesWanted(true, n);
                            }
                        }
                    }
                }

                if (ri.replies_wanted > 0) {
                    bool[] Ids = new bool[maxRdvId + 2];
                    foreach (ReplyInfo oldri in RendezVous) {
                        Ids[oldri.reply_waitid] = true;
                    }

                    int newId = 0;
                    while (Ids[newId]) {
                        ++newId;
                    }

                    if (newId > maxRdvId) {
                        maxRdvId = newId;
                    }

                    ri.reply_waitid = newId;
                    RendezVous.Add(ri);
                }
            }

            return ri;
        }

        // destList is only non-null for subset Query operations
        internal static void awaitReplies(ReplyInfo ri, Group g, Timeout timeout, List<Address> destList) {
            using (var tmpLockObj = new LockAndElevate(Vsync.RIPLock)) {
                if (destList != null) {
                    foreach (Address dest in destList) {
                        int i = ri.rdvView.GetRawRankOf(dest);
                        if (i != -1 && Vsync.RIPList.Contains(ri.rdvView.members[i]) && !ri.gotReply[i]) {
                            ri.UpdateRepliesWanted(i);
                        }
                    }
                }
                else {
                    for (int i = 0; i < ri.rdvView.members.Length; i++) {
                        if (!ri.gotReply[i] && Vsync.RIPList.Contains(ri.rdvView.members[i])) {
                            ri.UpdateRepliesWanted(i);
                        }
                    }
                }
            }

            ILock theILock;
            using (var tmpLockObj = new LockAndElevate(ri.Lock)) {
                if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                    Vsync.WriteLine("BEFORE rdvWait[" + ri.ricntr + "]: " + ri.rdvVid + ":" + ri.rdvMid + " in group " + ri.gaddr + ".... ri.wanted=" + ri.replies_wanted + ", ri.replies_received=" + ri.replies_received);
                }

                if (ri.replies_wanted > 0) {
                    ri.ilock = ILock.Barrier(ILock.LLREPLY, ri.reply_waitid);
                }

                theILock = ri.ilock;
            }

            if (theILock != null) {
                int tid = Vsync.OnTimerThread(Math.Max(100, timeout.when), () => {
                    try {
                        rdvTimeout(ri, timeout.action, timeout.origin);
                    }
                    catch (VsyncShutdownException) {
                        VsyncSystem.CheckLocksHeld();
                    }
                });
                ri.tid = tid;
                if ((g.flags & Group.G_TERMINATING) == 0) {
                    theILock.BarrierWait(g);
                }

                Vsync.TimerCancel(tid);
            }

            if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                Vsync.WriteLine("AFTER rdvWait[" + ri.ricntr + "]: " + ri.rdvVid + ":" + ri.rdvMid + " in group " + ri.gaddr + ".... ri.wanted=" + ri.replies_wanted + ", ri.replies_received=" + ri.replies_received);
            }

            using (var tmpLockObj = new LockAndElevate(RendezVousLock))
            using (var tmpLockObj1 = new LockAndElevate(ri.Lock)) {
                RendezVous.Remove(ri);
            }

            using (var tmpLockObj = new LockAndElevate(g.ViewHandlers.vhListLock)) {
                g.ViewHandlers.vhList.Remove(ri.vhcb);
            }

            if (ri.replies_received == -1) {
                throw new VsyncAbortReplyException(ri.theReason);
            }
        }

        internal static void gotReply(Msg rm) {
            if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                Vsync.WriteLine("In gotReply " + rm);
            }

            if ((rm.flags & Msg.FRAGGED) != 0) {
                rm.flags |= Msg.HASREPLY;
                Group.deFragRdv(Vsync.VSYNCMEMBERS, rm);
                return;
            }

            using (var tmpLockObj = new LockAndElevate(RendezVousLock)) {
                object[] obs = Msg.BArrayToObjects(rm.payload);
                if (obs.Length < 5 || obs.Length > 6 || obs[0].GetType() != typeof(int) || obs[1].GetType() != typeof(int) || obs[2].GetType() != typeof(int) || obs[3].GetType() != typeof(bool) || obs[4].GetType() != typeof(bool) || (obs.Length == 6 && obs[5].GetType() != typeof(byte[]) && obs[5].GetType() != typeof(string))) {
                    throw new VsyncException("gotReply: misformatted RT_REPLY object");
                }

                int idx = 0;
                int rtype = (int)obs[idx++];
                int vid = (int)obs[idx++];
                int msgid = (int)obs[idx++];
                bool asOracle = (bool)obs[idx++];
                bool enciphered = (bool)obs[idx++];
                object theReply = null;
                if (obs.Length > 5) {
                    theReply = obs[idx];
                }

                ReplyInfo theRi = null;
                foreach (ReplyInfo ri in RendezVous) {
                    using (var tmpLockObj1 = new LockAndElevate(ri.Lock)) {
                        if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                            Vsync.WriteLine("Scanning RI structure: " + ri.gaddr + "//" + ri.rdvVid + ":" + ri.rdvMid + ", I'm looking for " + rm.dest + "//" + vid + ":" + msgid);
                        }

                        if (ri.gaddr == rm.dest && ri.rdvVid == vid && ri.rdvMid == msgid && ri.queryByOracle == asOracle && (theRi == null || theRi.uid < ri.uid)) {
                            theRi = ri;
                        }
                    }
                }

                if (theRi != null) {
                    if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                        Vsync.WriteLine("... a match!");
                    }

                    using (var tmpLockObj1 = new LockAndElevate(theRi.Lock)) {
                        doGotReply(theRi, rm.dest, rm.sender, rtype, vid, msgid, enciphered, theReply);
                    }

                    return;
                }

                // Falls through if the reply just isn't expected
                if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                    Vsync.WriteLine("WARNING: gotReply not sure what to do with reply: " + rm);
                }
            }
        }

        // Called with a lock on ri
        internal static void doGotReply(ReplyInfo ri, Address gaddr, Address sender, int rtype, int vid, int mid, bool enciphered, object theReply) {
            bool found = false;
            int i = ri.rdvView.GetRawRankOf(sender);
            if (i != -1) {
                if (ri.replies_wanted > 0 && !ri.gotReply[i]) {
                    if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                        Vsync.WriteLine("In doGotReply with rtype " + rtype + " from target " + i);
                    }

                    switch (rtype) {
                        case Group.RT_REPLY:
                            if (enciphered != ri.enciphered) {
                                Vsync.WriteLine("WARNING: rejecting a reply: mismatched cipher status");
                                return;
                            }

                            ri.replies_received++;
                            ri.rdvReplies.Add((byte[])theReply);
                            if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                                Vsync.WriteLine("ISAREPLY: currently need " + ri.replies_wanted + ", this was number " + ri.replies_received);
                            }

                            ri.UpdateRepliesWanted(i);
                            if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                                Vsync.WriteLine("[1]: ri.wanted=" + ri.replies_wanted + ", data reply from " + sender);
                            }

                            found = true;
                            if (ri.gaddr != gaddr) {
                                throw new VsyncException("doGotReply");
                            }

                            break;

                        case Group.RT_ABORT:
                            ri.theReason = (string)theReply;
                            ri.replies_wanted = 0;
                            ri.replies_received = -1;
                            if (ri.ilock != null) {
                                ri.ilock.BarrierRelease(1);
                                ri.ilock = null;
                            }

                            if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                                Vsync.WriteLine("[2]: ri.wanted=" + ri.replies_wanted + ", abortreply from " + sender);
                            }

                            found = true;
                            break;

                        case Group.RT_NULL:
                            ri.UpdateRepliesWanted(true, i);
                            if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                                Vsync.WriteLine("[3]: ri.wanted=" + ri.replies_wanted + ", nullreply from " + sender);
                            }

                            found = true;
                            break;
                    }
                }
            }

            if (!found && (VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                string rig = " ";
                for (i = 0; i < ri.rdvView.members.Length; i++) {
                    rig += ri.gotReply[i] ? "+ " : "- ";
                }

                Vsync.WriteLine("**** WARNING IGNORING A REPLY, I was looking for " + sender + " in " + Address.VectorToString(ri.rdvView.members) + ", ri.gotReply [" + rig + "], ri.replies_wanted " + ri.replies_wanted);
            }
        }

        internal static void doNoteFailure(Address who) {
            using (var tmpLockObj = new LockAndElevate(RendezVousLock)) {
                foreach (ReplyInfo ri in RendezVous) {
                    using (var tmpLockObj1 = new LockAndElevate(ri.Lock)) {
                        int i = ri.rdvView.GetRawRankOf(who);
                        if (i != -1 && !ri.gotReply[i]) {
                            ri.UpdateRepliesWanted(i);
                            if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                                Vsync.WriteLine("[4]: ri.wanted=" + ri.replies_wanted + ", reply from " + who);
                            }

                            break;
                        }
                    }
                }
            }
        }

        internal static void InterruptReplyWaits(Group g) {
            using (var tmpLockObj = new LockAndElevate(RendezVousLock)) {
                foreach (ReplyInfo ri in RendezVous) {
                    if (ri.gaddr != g.gaddr) {
                        continue;
                    }

                    using (var tmpLockObj1 = new LockAndElevate(ri.Lock)) {
                        if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                            Vsync.WriteLine("[terminate] ri=" + ri);
                        }

                        ri.theReason = "g.Terminate";
                        ri.replies_wanted = 0;
                        ri.replies_received = 0;
                        if (ri.ilock != null) {
                            ri.ilock.BarrierRelease(1);
                            ri.ilock = null;
                        }
                    }
                }
            }
        }

        internal static void rdvTimeout(ReplyInfo ri, int action, string origin) {
            List<Address> hasFailed = new List<Address>();
            using (var tmpLockObj = new LockAndElevate(ri.Lock)) {
                for (int i = 0; i < ri.rdvView.members.Length && ri.replies_wanted > 0; i++) {
                    if (!ri.gotReply[i]) {
                        switch (action) {
                            case Timeout.TO_NULLREPLY:
                                ri.UpdateRepliesWanted(i);
                                if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                                    Vsync.WriteLine("[5]: ri.wanted=" + ri.replies_wanted + ", timeout(action=nullreply) " + ri.rdvView.members[i]);
                                }

                                break;

                            case Timeout.TO_ABORTREPLY:
                                ri.theReason = "timeout";
                                ri.replies_wanted = 0;
                                ri.replies_received = -1;
                                if (ri.ilock != null) {
                                    ri.ilock.BarrierRelease(1);
                                    ri.ilock = null;
                                }

                                if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                                    Vsync.WriteLine("[6]: ri.wanted=" + ri.replies_wanted + ", timeout(action=abortreply) " + ri.rdvView.members[i]);
                                }

                                break;

                            case Timeout.TO_FAILURE:
                                hasFailed.Add(ri.rdvView.members[i]);
                                break;
                        }
                    }
                }
            }

            if (hasFailed.Count == 0) {
                return;
            }

            string where = "(from timeout";
            if (origin != null) {
                where += "/" + origin;
            }

            foreach (Address who in hasFailed) {
                Vsync.NodeHasFailed(who, where + ": <" + ri.gname + ">:" + ri.rdvVid + ":" + ri.rdvMid + "; delay=" + ri.delay + ")", false);
            }

            using (var tmpLockObj = new LockAndElevate(ri.Lock)) {
                for (int i = 0; i < ri.rdvView.members.Length; i++) {
                    if (!ri.gotReply[i]) {
                        ri.UpdateRepliesWanted(i);
                    }
                }
            }
        }
    }

    internal class FlowControl {
        internal static LockObject FCLock = new LockObject(false, "FClock");

        internal static long MsgCountNum; // Counts messages that the system is "holding"; numerator

        internal static long MsgCountDenom = 1; // Denominator

        internal static volatile int Waiting;

        internal static long GCD(long a, long b) {
            if (a < 0) {
                a = -a;
            }

            if (b < 0) {
                b = -b;
            }

            while (a != 0 && b != 0) {
                if (a > b) {
                    a %= b;
                }
                else {
                    b %= a;
                }
            }

            if (a == 0) {
                return b;
            }

            return a;
        }

        private static void UpdateMsgCount(int num, int denom) {
            long tmpNum = (MsgCountNum * denom) + (num * MsgCountDenom);
            long tmpDenom = MsgCountDenom * denom;
            long gcd = GCD(tmpNum, tmpDenom);
            if (gcd != 1) {
                tmpNum /= gcd;
                tmpDenom /= gcd;
            }

            MsgCountNum = tmpNum;
            MsgCountDenom = tmpDenom;
            if (MsgCountNum < 0) {
                throw new VsyncException("UpdateMsgCount");
            }
        }

        internal static void FCStartSend(int num, int denom) {
            using (var tmpLockObj = new LockAndElevate(FCLock)) {
                UpdateMsgCount(num, denom);
            }

            if ((VsyncSystem.Debug & VsyncSystem.FLOWCONTROL) != 0) {
                Vsync.WriteLine("After FCStartSend(" + num + "/" + denom + ")");
            }
        }

        internal static void FCEndSend(int num, int denom) {
            int toAwaken;
            using (var tmpLockObj = new LockAndElevate(FCLock)) {
                if (num > 0) {
                    UpdateMsgCount(-num, denom);
                }

                toAwaken = Waiting;
                Waiting = 0;
            }

            if (toAwaken > 0) {
                if (FCMustBlock(2, 3)) {
                    using (var tmpLockObj = new LockAndElevate(FCLock)) {
                        Waiting += toAwaken; // No luck for them: we're still above the low-water mark
                    }
                }
                else {
                    ILock.Barrier(ILock.LLWAIT, ILock.LFLOWCNTRL).BarrierRelease(toAwaken);
                }
            }

            if ((VsyncSystem.Debug & VsyncSystem.FLOWCONTROL) != 0) {
                Vsync.WriteLine("After FCEndSend(" + num + "/" + denom + ")");
            }
        }

        internal static void FCBarrierCheck() {
            FCBarrierCheck(null);
        }

        internal static void FCBarrierCheck(List<Address> dests) {
            ReliableSender.RemoteBacklogWait(dests);
            bool mustBlock = FCMustBlock(1, 1);
            using (var tmpLockObj = new LockAndElevate(FCLock)) {
                if ((VsyncSystem.Debug & VsyncSystem.FLOWCONTROL) != 0) {
                    Vsync.WriteLine("Before FCBarrierCheck[" + Thread.CurrentThread.ManagedThreadId + "]: " + (mustBlock ? " WILL BLOCK " : " WON'T BLOCK ") + GetState());
                }

                if (!mustBlock) {
                    return;
                }

                ++Waiting;
            }

            FlowControl.FCEndSend(0, 1);
            ILock.Barrier(ILock.LLWAIT, ILock.LFLOWCNTRL).BarrierWait();
            if ((VsyncSystem.Debug & VsyncSystem.FLOWCONTROL) != 0) {
                Vsync.WriteLine("After FCBarrierCheck(WAITED!)[" + Thread.CurrentThread.ManagedThreadId + "]: " + GetState());
            }
        }

        // Uses hwn and hwd as a highwater/lowater threshold
        internal static bool FCMustBlock(int hwn, int hwd) {
            return (Backlog(null) >= (Vsync.VSYNC_ASYNCMTOTALLIMIT * hwn) / hwd) || Group.Undelivered() > (64 * hwn) / hwd || Group.nInUDPTunnel() > (32 * hwn) / hwd || Group.nInIPMCTunnel() > (32 * hwn) / hwd || ReliableSender.P2PSequencer.CountP2PSeqn() > (32 * hwn) / hwd;
        }

        internal static int Backlog(Group g) {
            if (VsyncSystem.shuttingDown) {
                return 0;
            }

            int bl = CountBacklogs();
            if (g != null) {
                using (var tmpLockObj = new LockAndElevate(g.GroupFlagsLock)) {
                    g.CurrentBacklog = Math.Max(g.CurrentBacklog, bl);
                }
            }

            return bl + ReliableSender.P2PSequencer.CountP2PSeqn() + (int)(MsgCountNum / MsgCountDenom);
        }

        private static int CountBacklogs() {
            int backlog = 0;
            List<Group> myCopy = Group.VsyncGroupsClone();
            foreach (Group g in myCopy) {
                backlog += g.UnstableCount + g.ToDoCount + g.PendingQueueCount + g.OutOfOrderQueueCount + g.CausalOrderListCount +
                    g.OrderedSubsetPQCount + BoundedBuffer.FullSlots(g.incomingSends) + (BoundedBuffer.FullSlots(g.incomingP2P) + (ReliableSender.LBBcnt() / 2));
            }

            return backlog;
        }

        internal static string GetState() {
            int fs = (ReliableSender.RecvBB == null) ? 0 : ReliableSender.RecvBB.fullSlots;
            return "Flow Control: " + (MsgCountNum / MsgCountDenom) + "+" + (MsgCountNum % MsgCountDenom) + "/" + MsgCountDenom +
                " + " + CountBacklogs() + " outgoing/unstable/on-todo-list/etc, " + ReliableSender.P2PSequencer.CountP2PSeqn() +
                " on P2P or callback queues, " + Backlog(null) + " backlog, " + fs + " full RecvBB slots, " + Group.Undelivered() +
                " undelivered, " + Group.nInUDPTunnel() + " in UDP tunnel, " + Group.nInIPMCTunnel() + " in IPMC tunnel, remote backlog=" +
                ReliableSender.RemoteBacklogCount() + " (limit=" + Vsync.VSYNC_MAXRBACKLOG + ")" + Environment.NewLine + "              " +
                Waiting + " threads waiting on local congestion, " + ReliableSender.rWaiting + " waiting on remote congestion" + Environment.NewLine;
        }
    }

    internal class ReliableSender {
        internal class msgWaiter {
            internal int threshold;

            internal Semaphore waitSema;

            internal msgWaiter(int t, Semaphore w) {
                this.threshold = t;
                this.waitSema = w;
            }
        }

        internal class activeMsg {
            internal Group g;

            internal int vid;

            internal int msgid;

            internal int StableCnt; // Counts number of acks received

            internal int SentCnt; // This is how many destinations it had in the first place

            internal List<msgWaiter> Waiters; // When non-null, lists threads waiting on this message

            internal activeMsg(Group g, int vid, int msgid) {
                this.g = g;
                this.vid = vid;
                this.msgid = msgid;
            }
        }

        internal static List<activeMsg> activeMsgs = new List<activeMsg>();

        internal static LockObject activeMsgLock = new LockObject("activeMsgLock");

        internal class MsgDesc {
            internal byte type;

            internal Address dest;

            internal bool done;

            internal bool isp2p;

            internal bool isP2POrGroup;

            internal bool isLarge;

            internal bool alreadyCleanedUp;

            internal bool dontAutoResend;

            internal Group group;

            internal int UID;

            internal int MsgVid;

            internal int MsgId;

            internal byte[] theBytes;

            internal int retryCnt;

            internal int retryLimit;

            internal int retryDelay;

            internal long resendTime;

            internal long firstSentAt;

            internal long lastSentAt;

            internal int num;

            internal int denom;

            internal bool localSender;

            internal Action p2pdcb;

            internal List<Semaphore> CPSList = new List<Semaphore>();

            internal activeMsg am;

            internal MsgDesc(byte type, int limit, Group group, Address dest, bool isp2p, bool isLarge, int uid, byte[] buffer, int vid, int MsgID, int rtd, int num, int denom, bool localSender, Action dcb, activeMsg am) {
                this.firstSentAt = this.lastSentAt = Vsync.NOW;
                this.resendTime = Vsync.NOW + rtd;
                this.type = type;
                this.retryLimit = limit;
                this.dest = dest;
                this.done = false;
                this.isp2p = isp2p;
                this.isP2POrGroup = isp2p || (!dest.isNull() && !dest.isGroupAddress());
                this.isLarge = isLarge;
                this.group = group;
                this.UID = uid;
                this.MsgVid = vid;
                this.MsgId = MsgID;
                this.theBytes = buffer;
                this.retryDelay = Math.Max(50, rtd);
                if (type == Msg.STABILITYINFO) {
                    num = 0;
                }

                this.num = num;
                this.denom = denom;
                this.localSender = localSender;
                this.p2pdcb = dcb;
                this.am = am;
                FlowControl.FCStartSend(num, denom);
                if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                    using (var tmpLockObj = new LockAndElevate(ackInfoLock)) {
                        ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: Remember " + dest + "::" + this.MsgVid + ":" + this.MsgId + " -- UID " + uid + Environment.NewLine);
                    }
                }
            }

            public override string ToString() {
                return this.dest + "::" + this.MsgVid + ":" + this.MsgId + " (UID=" + this.UID + ", done=" + this.done + ", alreadyCleanedUp=" + this.alreadyCleanedUp + ")";
            }
        }

        internal static LinkedList<MsgDesc> PendingSendBuffer = new LinkedList<MsgDesc>();

        internal static LinkedList<MsgDesc> P2PPendingSendBuffer = new LinkedList<MsgDesc>();

        internal static LinkedList<MsgDesc> LgPendingSendBuffer = new LinkedList<MsgDesc>();

        internal static LockObject PendingSendBufferLock = new LockObject("PendingSendBufferLock");

        internal static string GetState() {
            string s = string.Empty;
            bool showRecords = (VsyncSystem.Debug & VsyncSystem.PENDINGSENDS) != 0;
            if (!showRecords) {
                using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                    showRecords = P2PPendingSendBuffer.Count + PendingSendBuffer.Count + LgPendingSendBuffer.Count < 15;
                }
            }

            if (showRecords) {
                // This part of the report can be bulky and slow to generate if there are a lot of pending sends; enable the PENDINGSENDS flag only if genuinely needed
                s = "Pending Send Buffer: " + Environment.NewLine;
                List<MsgDesc> ps = new List<MsgDesc>(), pls = new List<MsgDesc>();
                using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                    foreach (MsgDesc md in P2PPendingSendBuffer) {
                        ps.Add(md);
                    }

                    foreach (MsgDesc md in PendingSendBuffer) {
                        ps.Add(md);
                    }

                    foreach (MsgDesc md in LgPendingSendBuffer) {
                        pls.Add(md);
                    }
                }

                foreach (MsgDesc md in ps) {
                    s += " Dest " + md.dest + (md.localSender ? string.Empty : "(forwarded)") + "<" + (md.group == null ? "(no-group)" : md.group.gname) + " isp2p=" + md.isp2p + ">, counts as " + md.num + "/" + md.denom + " for flow control, msgid " + md.MsgVid + ":" + md.MsgId + ", uid " + md.UID + ", first sent at " + Vsync.MsToSecs(md.firstSentAt) + "... retry at " + Vsync.MsToSecs(md.resendTime) + ", retryCnt " + md.retryCnt + Msg.PPayload(md.theBytes) + Environment.NewLine;
                }

                s += "Large-Group Pending Send Buffer:" + Environment.NewLine;
                foreach (MsgDesc md in pls) {
                    s += " Dest " + md.dest + (md.localSender ? string.Empty : "(forwarded)") + " isp2p=" + md.isp2p + ", counts as " + md.num + "/" + md.denom + " for flow control, msgid " + md.MsgVid + ":" + md.MsgId + ", uid " + md.UID + " first sent at " + Vsync.MsToSecs(md.firstSentAt) + ", last sent at " + Vsync.MsToSecs(md.lastSentAt) + ", retry at " + Vsync.MsToSecs(md.resendTime) + ", retryCnt " + md.retryCnt + Msg.PPayload(md.theBytes) + (md.p2pdcb == null ? " (no callback)" : " (callback on completion)") + Environment.NewLine;
                }
            }
            else {
                int nps;
                using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                    nps = PendingSendBuffer.Count + P2PPendingSendBuffer.Count + LgPendingSendBuffer.Count;
                }

                s += "Pending-Send Buffer and Large-Group Pending-Send Buffers jointly contain " + nps + " records" + Environment.NewLine;
            }

            s += P2PSequencer.GetState();
            return s;
        }

        private static readonly LockObject RateLimLock = new LockObject("RateLimLock", ThreadPriority.Highest);

        private static long lastSendTime;

        private static long avgSpacing;

        internal static void CheckLenAndRate(byte[] buffer) {
            CheckLenAndRate(buffer, true);
        }

        internal static void CheckLenAndRate(byte[] buffer, bool limitRate) {
            if (limitRate) {
                using (var tmpLockObj = new LockAndElevate(RateLimLock)) {
                    if (lastSendTime > 0 && Vsync.VSYNC_RATELIM > 0) {
                        long dt = Vsync.NOW - lastSendTime;
                        avgSpacing = ((avgSpacing * 9) + dt) / 10;
                        if (avgSpacing == 0 || 1000 / avgSpacing > Vsync.VSYNC_RATELIM) {
                            Vsync.Sleep((int)Math.Max((1000 / Vsync.VSYNC_RATELIM) - dt, 1));
                            avgSpacing = 1000 / Vsync.VSYNC_RATELIM;
                        }
                    }

                    lastSendTime = Vsync.NOW;
                }
            }

            if (buffer.Length % Vsync.VSYNC_LEN_ROUNDUP != 0) {
                // Force the system to round up to next VSYNC_LEN_ROUNDUP-byte multiple
                Vsync.ArrayResize(ref buffer, ((buffer.Length / Vsync.VSYNC_LEN_ROUNDUP) + 1) * Vsync.VSYNC_LEN_ROUNDUP);
            }

            if (buffer.Length > Vsync.VSYNC_MAXMSGLEN) {
                throw new VsyncException("Trying to send an object of size " + buffer.Length + " yet Vsync_MAXMSGLEN is " + Vsync.VSYNC_MAXMSGLEN);
            }
        }

        internal static int getPendingP2PCount(List<Address> dests) {
            int ms = 0;
            List<P2PSequencer> currentP2PDests = new List<P2PSequencer>();
            using (var tmpLockObj = new LockAndElevate(P2PSequencer.PSListLock)) {
                if (dests == null) {
                    currentP2PDests = P2PSequencer.PSIndex.Values.ToList();
                }
                else {
                    foreach (Address dest in dests) {
                        P2PSequencer p2ps;
                        if (P2PSequencer.PSIndex.TryGetValue(dest, out p2ps)) {
                            using (var tmpLockObj1 = new LockAndElevate(p2ps.Lock)) {
                                currentP2PDests.Add(p2ps);
                            }
                        }
                    }
                }
            }

            foreach (P2PSequencer p2ps in currentP2PDests) {
                ms = Math.Max(ms, getRBacklog(p2ps));
            }

            return ms;
        }

        internal static int getRBacklog(P2PSequencer p2ps) {
            long now = Vsync.NOW;
            int gap;
            using (var tmpLockObj = new LockAndElevate(P2PSequencer.PSListLock)) {
                gap = EstimatedRemoteBacklog(p2ps);
            }

            using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                foreach (MsgDesc md in P2PPendingSendBuffer) {
                    if (now - md.firstSentAt > 50 && md.dest == p2ps.dest && md.type != Msg.ISFILLER) {
                        gap = Math.Max(gap, p2ps.nonrawSeqn - md.MsgId);
                    }
                }
            }

            return gap;
        }

        private static int EstimatedRemoteBacklog(P2PSequencer p2ps) {
            const long window = 2500;

            // A window during which the remote backlog is assumed to steadily shrink (unless we get a new report of a big backlog)
            long age = window - (Vsync.NOW - p2ps.whenReported);
            if (age < 0) {
                return 0;
            }

            long bl = (p2ps.remoteBacklog * age) / window;
            return (int)Math.Max(0, bl);
        }

        internal static void noteRemoteBacklog(Address who, int remoteBacklog) {
            if (who.isMyAddress()) {
                return;
            }

            using (var tmpLockObj = new LockAndElevate(P2PSequencer.PSListLock)) {
                P2PSequencer p2ps;
                if (P2PSequencer.PSIndex.TryGetValue(who, out p2ps)) {
                    using (var tmpLockObj1 = new LockAndElevate(p2ps.Lock)) {
                        p2ps.remoteBacklog = remoteBacklog;
                        p2ps.whenReported = Vsync.NOW;
                    }
                }
            }
        }

        internal class AddrAndGroup : IEquatable<AddrAndGroup> {
            internal readonly Address who;

            internal readonly Address gaddr;

            internal AddrAndGroup(Address p, Address g) {
                this.who = p;
                this.gaddr = g;
            }

            public static bool operator ==(AddrAndGroup first, AddrAndGroup second) {
                return Equals(first, second);
            }

            public static bool operator !=(AddrAndGroup first, AddrAndGroup second) {
                return !Equals(first, second);
            }

            public static bool Equals(AddrAndGroup first, AddrAndGroup second) {
                if (object.ReferenceEquals(first, second)) {
                    return true;
                }

                if (object.ReferenceEquals(first, null) || object.ReferenceEquals(second, null)) {
                    return false;
                }

                return first.who == second.who && first.gaddr == second.gaddr;
            }

            public override bool Equals(object other) {
                return Equals(this, other as AddrAndGroup);
            }

            public bool Equals(AddrAndGroup other) {
                return Equals(this, other);
            }

            public override int GetHashCode() {
                return (this.who.GetHashCode() * 37) + this.gaddr.GetHashCode();
            }
        }

        internal static int getPendingIPMCCount() {
            using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                foreach (MsgDesc md in PendingSendBuffer) {
                    if (md.localSender && !md.isP2POrGroup) {
                        return ReliableSender.Counter - md.UID;
                    }
                }
            }

            return 0;
        }

        internal static int getRIPMCBacklog(AddrAndGroup ag) {
            int sum = 0;
            List<int> WorkingVidList = new List<int>();
            using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                foreach (MsgDesc md in PendingSendBuffer) {
                    if (md.dest == ag.who && !md.isP2POrGroup && md.group != null && md.group.gaddr == ag.gaddr && (md.MsgVid != 0 || md.MsgId != -1)) {
                        if (!WorkingVidList.Contains(md.MsgVid)) {
                            WorkingVidList.Add(md.MsgVid);
                        }
                    }
                }

                foreach (int workingVid in WorkingVidList) {
                    // For each active dest, for each group in which it sends, for each view with active messages, compute the number of active messages in the PSB
                    int maxMsgid = int.MinValue;
                    int minMsgid = int.MaxValue;
                    foreach (MsgDesc md in PendingSendBuffer) {
                        if (md.MsgVid == workingVid && md.dest == ag.who && !md.isP2POrGroup && md.group != null && md.group.gaddr == ag.gaddr) {
                            minMsgid = Math.Min(md.MsgId, minMsgid);
                            maxMsgid = Math.Max(md.MsgId, maxMsgid);
                        }
                    }

                    if (maxMsgid != int.MinValue) {
                        sum += maxMsgid - minMsgid + 1;
                    }
                }
            }

            return sum;
        }

        internal static void CleanLgCallbacks(Group g) {
            using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                foreach (MsgDesc lgmd in LgPendingSendBuffer) {
                    if (lgmd.p2pdcb != null && lgmd.group == g) {
                        lgmd.p2pdcb = null;
                    }
                }
            }
        }

        internal static void Shutdown() {
            List<Group> IG = Group.VsyncGroupsClone();
            foreach (Group g in IG) {
                if (g.GroupOpen) {
                    g.Flush();
                }
            }

            my_acksocket.Close();
            my_p2psocket.Close();
        }

        internal static LockObject rWaitLock = new LockObject("rWaitLock");

        internal static volatile int rWaiting; // Sometimes checked without the lock, but never unsafely

        internal static bool shouldWait;

        internal static void RemoteBacklogWait(List<Address> dests) {
            while (!VsyncSystem.VsyncWasActive) {
                Vsync.Sleep(250);
            }

            while (VsyncSystem.VsyncActive) {
                VsyncSystem.RTS.ThreadCntrs[14]++;
                int backlog = RemoteBacklogCount(dests);
                if (backlog < Vsync.VSYNC_MAXRBACKLOG) {
                    shouldWait = false;
                    return;
                }

                using (var tmpLockObj = new LockAndElevate(rWaitLock)) {
                    if (!shouldWait) {
                        // Blocks the second time in a row, but allows sending the first time
                        // This makes the rWait condition more conservative and avoids a problem associated with
                        // slow reporting when remote backlogs finally ease up (fast reporting causes too much overhead)
                        shouldWait = true;
                        return;
                    }

                    ++rWaiting;
                }

                ILock.Barrier(ILock.LLWAIT, ILock.LFLOWCNTRLB).BarrierWait();
                using (var tmpLockObj = new LockAndElevate(rWaitLock)) {
                    --rWaiting;
                }
            }
        }

        internal static void recheckRwaiting() {
            using (var tmpLockObj = new LockAndElevate(ReliableSender.rWaitLock)) {
                if (rWaiting > 0 && RemoteBacklogCount() < Vsync.VSYNC_MAXRBACKLOG * 7 / 10) {
                    ILock.Barrier(ILock.LLWAIT, ILock.LFLOWCNTRLB).BarrierReleaseAll();
                }
            }
        }

        internal static int RemoteBacklogCount() {
            return RemoteBacklogCount(null);
        }

        internal static int RemoteBacklogCount(List<Address> dests) {
            return ReliableSender.getPendingP2PCount(dests) + ReliableSender.getPendingIPMCCount();
        }

        internal static string rWorst() {
            List<Address> rwl = new List<Address>();
            string rw = string.Empty;
            int worst = -1;
            List<P2PSequencer> currentP2PDests = new List<P2PSequencer>();
            using (var tmpLockObj = new LockAndElevate(P2PSequencer.PSListLock)) {
                currentP2PDests = P2PSequencer.PSIndex.Values.ToList();
            }

            foreach (P2PSequencer p2ps in currentP2PDests) {
                const long window = 2500;

                // A window during which the remote backlog is assumed to steadily shrink (unless we get a new report of a big backlog)
                long age = window - (Vsync.NOW - p2ps.whenReported);
                int bl = getRBacklog(p2ps);
                if (bl < worst) {
                    continue;
                }

                worst = bl;
                rw = p2ps.dest + ":" + bl + string.Empty;
                rwl.Add(p2ps.dest);
                if (age >= 0) {
                    rw += "((" + p2ps.remoteBacklog + "*" + age + ")/" + window + ")";
                }
            }

            return rw;
        }

        internal static void CompletePendingSends(Group g, int cpscnt, Semaphore CPSSema) {
            g.CPSSema = CPSSema;
            while (cpscnt > 0) {
                ILock.NoteThreadState("CPSSema.WaitOne()");
                CPSSema.WaitOne();
                ILock.NoteThreadState(null);
                --cpscnt;
            }

            g.CPSSema = null;
        }

        internal static void PendingSendCleanup(Address[] goodbye) {
            PendingSendCleanup(null, goodbye);
        }

        internal static void PendingSendCleanup(Group g, Address[] goodbye) {
            List<MsgDesc> cleanup = new List<MsgDesc>();
            using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                doPSCleanup(g, goodbye, cleanup, PendingSendBuffer);
                doPSCleanup(g, goodbye, cleanup, P2PPendingSendBuffer);
            }

            foreach (MsgDesc md in cleanup) {
                GotAnAck(md.dest, md.UID);
            }
        }

        private static void doPSCleanup(Group g, Address[] goodbye, List<MsgDesc> cleanup, LinkedList<MsgDesc> theBuffer) {
            foreach (MsgDesc md in theBuffer) {
                if (md.isP2POrGroup) {
                    continue;
                }

                bool shouldRemove = false;
                if (goodbye == null) {
                    shouldRemove = true;
                }
                else {
                    foreach (Address a in goodbye) {
                        if (md.dest == a && (g == null || md.group == g)) {
                            shouldRemove = true;
                            break;
                        }
                    }
                }

                if (shouldRemove) {
                    cleanup.Add(md);
                }
            }
        }

        internal static void lgPendingSendCleanup(Group g) {
            List<MsgDesc> cleanup = new List<MsgDesc>();
            using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                LinkedList<MsgDesc> newPSB = new LinkedList<MsgDesc>();
                foreach (MsgDesc lgmd in LgPendingSendBuffer) {
                    if (lgmd.group != g && lgmd.dest != g.gaddr) {
                        newPSB.AddLast(lgmd);
                    }
                    else {
                        cleanup.Add(lgmd);
                    }
                }
            }

            int cnt = cleanup.Count;
            foreach (MsgDesc lgmd in cleanup) {
                lgmd.done = true;
                mdRemove(lgmd, "lgmd.lgPendingSendCleanup", --cnt == 0);
            }
        }

        internal static void LgAdd(Group g, Msg m, byte type) {
            using (var tmpLockObj = new LockAndElevate(Group.GroupRIPLock)) {
                if (Group.GroupRIPList.Contains(g.gaddr)) {
                    return;
                }
            }

            using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                bool copyAll = false;
                LinkedList<MsgDesc> newLgPendingSendBuffer = new LinkedList<MsgDesc>();
                foreach (MsgDesc lgmd in LgPendingSendBuffer) {
                    if (lgmd.group == g && lgmd.MsgVid == m.vid && lgmd.MsgId == m.msgid) {
                        return;
                    }

                    if (lgmd.group != g || copyAll || lgmd.MsgVid < m.vid || lgmd.MsgId < m.msgid) {
                        newLgPendingSendBuffer.AddLast(lgmd);
                    }
                    else {
                        newLgPendingSendBuffer.AddLast(new MsgDesc(type, 5, g, g.gaddr, false, true, m.msgid, m.offWire, m.vid, m.msgid, 0, 1, 5, false, null, null));
                        newLgPendingSendBuffer.AddLast(lgmd);
                        copyAll = true;
                    }
                }

                if (!copyAll) {
                    newLgPendingSendBuffer.AddLast(new MsgDesc(type, 5, g, g.gaddr, false, true, m.msgid, m.offWire, m.vid, m.msgid, 0, 1, 5, false, null, null));
                }

                LgPendingSendBuffer = newLgPendingSendBuffer;
            }
        }

        internal static Thread AckThread;

        internal static Thread ReplyThread;

        internal static Socket my_acksocket;

        internal static Socket my_p2psocket;

        internal static Socket SetSocketUp(out Socket s, ref int port, RcvrDel rd, out Thread t, ThreadPriority pri, string name) {
            s = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            s.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, 0);

            // Tryto keep these fairly small....
            try {
                s.ReceiveBufferSize = (int)Math.Min(128 * Vsync.VSYNC_MAXMSGLEN, int.MaxValue);
                s.SendBufferSize = (int)Math.Min(32 * Vsync.VSYNC_MAXMSGLEN, int.MaxValue);
            }
            catch (Exception e) {
                Vsync.WriteLine("When trying to set Send/Receive buffer size<" + name + "> threw exception " + e);
            }

            if (Vsync.VSYNC_UDPCHKSUM) {
                s.SetSocketOption(SocketOptionLevel.Udp, SocketOptionName.ChecksumCoverage, 1);
            }

            IPEndPoint localEndPoint = new IPEndPoint(Vsync.my_IPaddress, 0);
            if (Vsync.VSYNC_UNICAST_ONLY) {
                if (name.Equals("ack-socket", StringComparison.Ordinal)) {
                    port = Vsync.VSYNC_DEFAULT_PORTNOa;
                }
                else if (name.Equals("p2p-socket", StringComparison.Ordinal)) {
                    port = Vsync.VSYNC_DEFAULT_PORTNOp;
                }

                try {
                    localEndPoint.Port = port;
                    s.Bind(localEndPoint);
                }
                catch {
                    localEndPoint.Port = 0;
                    s.Bind(localEndPoint);
                }
            }
            else {
                s.Bind(localEndPoint);
            }

            port = ((IPEndPoint)s.LocalEndPoint).Port;

#if !__MonoCS__

            // Clumsy mechanism to prevent forcible socket reset events when an Vsync application exits
            const uint IOC_IN = 0x80000000;
            const uint IOC_VENDOR = 0x18000000;
            const uint SIO_UDP_CONNRESET = IOC_IN | IOC_VENDOR | 12;

            s.IOControl(unchecked((int)SIO_UDP_CONNRESET), new[] { Convert.ToByte(false) }, null);
#endif // !__MonoCS__
            s.ReceiveTimeout = 2500;
            t = StartSocketReader(s, rd, pri, name);
            return s;
        }

        internal delegate void RcvrDel(object s);

        internal static Thread myP2PThread;

        internal static Thread myAckThread;

        internal static Thread StartSocketReader(Socket s, RcvrDel rd, ThreadPriority p, string name) {
            Thread t = new Thread(o => {
                try {
                    while (!VsyncSystem.VsyncActive) {
                        Vsync.Sleep(250);
                    }

                    while (VsyncSystem.VsyncActive) {
                        VsyncSystem.RTS.ThreadCntrs[15]++;
                        rd(s);
                    }
                }
                catch (VsyncShutdownException) {
                    VsyncSystem.CheckLocksHeld();
                }
                catch (ThreadInterruptedException) {
                }
                catch (Exception e) {
                    if (VsyncSystem.VsyncActive) {
                        VsyncSystem.WriteLine("P2P or ACK  SocketReader threw an exception: " + e);
                        throw new VsyncException("P2P or ACK thread fault");
                    }
                }

                VsyncSystem.ThreadTerminationMagic();
            }) { Name = "Vsync " + name + " socket reader", IsBackground = true };

            // t.Priority = p;
            t.Start();
            if (s == my_acksocket) {
                myAckThread = t;
            }
            else {
                myP2PThread = t;
            }

            return t;
        }

        internal static void Init() {
            if (my_p2psocket == null) {
                my_p2psocket = SetSocketUp(out my_p2psocket, ref Vsync.my_address.p2pPort, ReliableSender.SReceive, out ReplyThread, ThreadPriority.AboveNormal, "p2p-socket");
            }

            if (my_acksocket == null) {
                my_acksocket = SetSocketUp(out my_acksocket, ref Vsync.my_address.ackPort, AckSocketReader, out AckThread, ThreadPriority.Highest, "ack-socket");
            }

            if (Vsync.VSYNC_UNICAST_ONLY && (Vsync.my_address.p2pPort != Vsync.VSYNC_DEFAULT_PORTNOp || Vsync.my_address.ackPort != Vsync.VSYNC_DEFAULT_PORTNOa)) {
                // A process that doesn't have the default port numbers can't be allowed to join the ORACLE since nobody could connect with it...
                Vsync.VSYNC_CANJOINORACLE = false;
            }
        }

        internal static void StartGroupReader(Group g) {
            if (g.groupReaderThread != null) {
                return;
            }

            try {
                if (g.my_socket != null || (!g.isTrackingProxy && !g.GroupOpen && g.WasOpen)) {
                    return;
                }

                int hash = Address.GroupNameHash(g.gname);
                g.myVirtIPAddr = Vsync.CLASSD + Vsync.VSYNC_MCRANGE_LOW + hash;
                IPAddress theIPAddr = Vsync.LastIPv4(MCMDSocket.PMCAddr(g.myVirtIPAddr));
                if (g == Vsync.ORACLE) {
                    g.myPhysIPAddr = Vsync.VSYNC_UNICAST_ONLY ? MCMDSocket.USEUNICAST : g.myVirtIPAddr;
                    g.my_socket = new MCMDSocket(g.gname, g.isTrackingProxy, g.myVirtIPAddr, g.myPhysIPAddr);
                }
                else {
                    g.my_socket = new MCMDSocket(g.gname, g.isTrackingProxy, g.myVirtIPAddr);
                }

                g.gaddr = new Address(theIPAddr, 0);
                if (g.isTrackingProxy) {
                    return;
                }

                g.groupReaderThread = new Thread(o => {
                    try {
                        while (VsyncSystem.VsyncActive && (g.GroupOpen || !g.WasOpen)) {
                            VsyncSystem.RTS.ThreadCntrs[16]++;
                            ReliableSender.Receive(g);
                        }
                    }
                    catch (VsyncShutdownException) {
                        VsyncSystem.CheckLocksHeld();
                    }

                    VsyncSystem.ThreadTerminationMagic();
                }) { Name = "Vsync <" + g.gname + "> incoming thread", IsBackground = true };
                g.groupReaderThread.Start();
            }
            catch (VsyncShutdownException) {
                VsyncSystem.CheckLocksHeld();
            }
        }

        internal static List<int> getNetworkInterfaces(string[] which) {
            int minMTU = int.MaxValue;
            List<int> InterfaceList = new List<int>();
            Vsync.VSYNC_MY_IPADDRS = new List<IPAddress>();
            NetworkInterface[] nics = NetworkInterface.GetAllNetworkInterfaces();
            if (nics != null) {
                foreach (NetworkInterface nic in nics) {
                    if (which != null) {
                        int idx;
                        for (idx = 0; idx < which.Length; idx++) {
                            if (nic.Name.Equals(which[idx], StringComparison.Ordinal)) {
                                break;
                            }
                        }

                        if (idx == which.Length) {
                            continue;
                        }
                    }

                    if ((VsyncSystem.Debug & VsyncSystem.INTERFACES) != 0) {
                        PhysicalAddress address = nic.GetPhysicalAddress();
                        byte[] bytes = address.GetAddressBytes();
                        string pas = string.Empty;
                        for (int i = 0; i < bytes.Length; i++) {
                            pas += bytes[i].ToString("X2");
                            if (i != bytes.Length - 1) {
                                pas += "-";
                            }
                        }

                        Vsync.WriteLine("Success!  [" + nic.Name + "]: Checking status=" + nic.OperationalStatus + ", supports multicast=" + nic.SupportsMulticast + ",  adapter.Supports(NetworkInterfaceComponent.IPv4)=" + nic.Supports(NetworkInterfaceComponent.IPv4) + ", physaddr=" + pas + ", description=" + nic.Description);
                    }

                    if (nic.OperationalStatus != OperationalStatus.Up || !nic.Supports(NetworkInterfaceComponent.IPv4) || nic.NetworkInterfaceType.ToString().Contains("Loopback") || nic.NetworkInterfaceType.ToString().Contains("Tunnel")) {
                        continue;
                    }

                    IPv4InterfaceProperties p = nic.GetIPProperties().GetIPv4Properties();
                    if (p == null) {
                        continue;
                    }

                    bool allowed = false;
                    foreach (UnicastIPAddressInformation addr in nic.GetIPProperties().UnicastAddresses) {
                        if (addr.Address.AddressFamily == AddressFamily.InterNetwork && Vsync.IPv4AddressIsAllowed(addr.Address)) {
                            Vsync.VSYNC_MY_IPADDRS.Add(addr.Address);
                            allowed = true;
                        }
                    }

                    if (!allowed) {
                        continue;
                    }

                    if ((VsyncSystem.Debug & VsyncSystem.INTERFACES) != 0) {
                        Vsync.WriteLine("  [" + nic.Name + "]: got IPv4Properties!  index=" + p.Index + ", MTU=" + p.Mtu + ", forwards=" + p.IsForwardingEnabled);
                    }

                    minMTU = Math.Max(1400, Math.Min(p.Mtu, minMTU));
                    if (nic.SupportsMulticast || Vsync.VSYNC_UNICAST_ONLY) {
                        InterfaceList.Add(p.Index);
                    }

                    if (nic.Name.ToUpperInvariant().Contains("IB")) {
                        if (Vsync.VSYNC_INFINIBAND) {
                            throw new VsyncException("Error: Vsync only supports a single Infiniband NIC");
                        }

                        Vsync.VSYNC_INFINIBAND = true;
                        Vsync.VSYNC_OOBCHUNKSIZE = 2L * 1024L * 1024L * 1024L;
                    }

                    foreach (UnicastIPAddressInformation addr in nic.GetIPProperties().UnicastAddresses) {
                        if (addr.Address.AddressFamily == AddressFamily.InterNetwork) {
                            Vsync.my_IPaddress = addr.Address;
                        }
                    }
                }
            }

            if (minMTU != int.MaxValue) {
                Vsync.VSYNC_MAXMSGLEN = minMTU << 2;
            }

            if (Vsync.VSYNC_INFINIBAND) {
                Vsync.VSYNC_MAXMSGLEN = 64 * 1024;
            }

            return InterfaceList;
        }

        internal static Thread ReplayerThread;

        internal static Thread ResenderThread;

        internal static Semaphore ReplayerSleepLock = new Semaphore(0, int.MaxValue);

        internal static Semaphore ResenderSleepLock = new Semaphore(0, int.MaxValue);

        // Launches replayer and resender threads
        internal static void ResenderThreadLaunch() {
            ReplayerThread = new Thread(Replayer) { Name = "Vsync Replayer thread", IsBackground = true };
            ReplayerThread.Start();
            ResenderThread = new Thread(Resender) { Name = "Vsync Resender thread", Priority = ThreadPriority.AboveNormal, IsBackground = true };
            ResenderThread.Start();
        }

        internal static void TickleResenderThread() {
            ReplayerSleepLock.Release();
            ResenderSleepLock.Release();
        }

        private static readonly Random rand = new Random();

        private static List<MsgDesc> Scramble(List<MsgDesc> list) {
            List<MsgDesc> newList = new List<MsgDesc>();
            MsgDesc[] mda = list.ToArray();
            for (int n = mda.Length - 1; n >= 0; n--) {
                int off = (n < 2) ? n : rand.Next(n + 1);
                newList.Add(mda[off]);
                mda[off] = mda[n];
            }

            return newList;
        }

        // Replays Stashed and ToDo lists
        internal static void Replayer() {
            while (!VsyncSystem.VsyncActive) {
                Vsync.Sleep(250);
            }

            try {
                while (VsyncSystem.VsyncActive) {
                    VsyncSystem.RTS.ThreadCntrs[17]++;
                    ReliableSender.P2PSequencer.CheckP2PSeqn();
                    ReliableSender.recheckRwaiting();
                    VsyncSystem.RTS.check();
                    if (Group.stashNonEmpty) {
                        Group.stashCheck();
                    }

                    Group.fiCleanup();
                    List<Group> theGroups = Group.VsyncGroupsClone();
                    foreach (Group g in theGroups) {
                        g.ReplayToDo();
                        g.CheckRetainedOpqINodes();
                        g.CheckCausalWaitQueue();
                        if (g.UnstableCount > 50 && Vsync.NOW - g.RequestedMinStableAt > 1000 && Vsync.VSYNCMEMBERS != null && Vsync.VSYNCMEMBERS.HasFirstView) {
                            g.inquireMinStable();
                        }
                    }

                    ReplayerSleepLock.WaitOne(1000);
                    string allCntrs = " ";
                    for (int ctr = 0; ctr < VsyncSystem.RTS.ThreadCntrs.Length; ctr++) {
                        if (VsyncSystem.RTS.ThreadCntrs[ctr] > 10000) {
                            allCntrs += ctr + ":" + VsyncSystem.RTS.ThreadCntrs[ctr] + " ";
                        }

                        VsyncSystem.RTS.ThreadCntrs[ctr] = 0;
                    }

                    if (allCntrs.Length > 1) {
                        Vsync.WriteLine("WARNING: Thread loop counter(s) advanced rapidly: " + allCntrs);
                    }
                }
            }
            catch (VsyncShutdownException) {
                VsyncSystem.CheckLocksHeld();
            }

            VsyncSystem.ThreadTerminationMagic();
        }

        // Be very careful with locking in this code; it needs to be blazingly fast and to never pause
        internal static void Resender() {
            try {
                while (!VsyncSystem.VsyncActive) {
                    ResenderSleepLock.WaitOne(250);
                }

                int rsCount = 0;
                int szeroCount = 0;
                while (VsyncSystem.VsyncActive) {
                    VsyncSystem.RTS.ThreadCntrs[18]++;
                    CleanSentNack();
                    Group.SendStability();
                    if (FlowControl.Waiting > 0) {
                        FlowControl.FCEndSend(0, 1);
                    }

                    List<MsgDesc> ToResend, lgToResend, toRemove;
                    int sleep_until = 1000;
                    List<MsgDesc> destDied = new List<MsgDesc>();
                    using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                        ToResend = new List<MsgDesc>();
                        long now = Vsync.NOW;
                        PendingSendBuffer = PSweep(ToResend, destDied, now, PendingSendBuffer);
                        P2PPendingSendBuffer = PSweep(ToResend, destDied, now, P2PPendingSendBuffer);
                        int npsb = ToResend.Count;
                        if (npsb < 10 && PendingSendBuffer.Count > 5) {
                            foreach (MsgDesc md in PendingSendBuffer) {
                                if (now > md.resendTime && !ToResend.Contains(md)) {
                                    ToResend.Add(md);
                                    if (++npsb == 10) {
                                        break;
                                    }
                                }
                            }
                        }

                        lgToResend = new List<MsgDesc>();
                        LinkedList<MsgDesc> newLgPSB = new LinkedList<MsgDesc>();
                        toRemove = new List<MsgDesc>();
                        using (var tmpLockObj1 = new LockAndElevate(Group.GroupRIPLock)) {
                            foreach (MsgDesc md in LgPendingSendBuffer) {
                                if (md.retryCnt < Vsync.VSYNC_MAXLGRETRIES) {
                                    lgToResend.Add(md);
                                }

                                if (!md.isP2POrGroup && Group.GroupRIPList.Contains(md.dest)) {
                                    toRemove.Add(md);
                                }
                                else {
                                    newLgPSB.AddLast(md);
                                }
                            }
                        }

                        LgPendingSendBuffer = newLgPSB;
                    }

                    ToResend = Scramble(ToResend);
                    lgToResend = Scramble(lgToResend);
                    int cnt = toRemove.Count + destDied.Count;
                    foreach (MsgDesc md in destDied) {
                        md.done = true;
                        mdRemove(md, "resender: found dest on RIPList", --cnt == 0);
                    }

                    foreach (MsgDesc md in toRemove) {
                        md.done = true;
                        mdRemove(md, "resender: found dest on GroupRIPList", --cnt == 0);
                    }

                    foreach (MsgDesc md in ToResend) {
                        long tryingFor = Vsync.NOW - md.firstSentAt;
                        if (Vsync.NOW < md.resendTime && tryingFor < Vsync.VSYNC_DEFAULTTIMEOUT / 4) {
                            continue;
                        }

                        if (!md.localSender) {
                            md.done = true;
                            mdRemove(md, "Forwarded message, tried once", true);
                            sleep_until = 0;
                        }
                        else if (!HeardFromRecently(md.dest) && (md.retryCnt >= md.retryLimit && tryingFor > Vsync.VSYNC_DEFAULTTIMEOUT * 2 / 3)) {
                            md.done = true;
                            mdRemove(md, "from resender.sendto because dest has failed", true);
                            string howDiscovered = "from resender.sendto for dest " + md.dest + ", ID " + md.UID + "/" + md.MsgVid + ":" + md.MsgId + " (retried for " + Vsync.MsToSecs(tryingFor) + " secs)";
                            Vsync.NodeHasFailed(md.dest, howDiscovered, false);
                            sleep_until = 50;
                            break;
                        }
                        else {
                            if (++rsCount > Vsync.VSYNC_ASYNCMTOTALLIMIT) {
                                rsCount = 0;
                                if (!ResenderSleepLock.WaitOne(10)) {
                                    sleep_until = 0;
                                }
                            }

                            if ((VsyncSystem.Debug & VsyncSystem.MESSAGELAYER) != 0) {
                                Vsync.WriteLine("Resender.sendto[Now:" + Vsync.NOW + ", md.resendTime:" + md.resendTime + "]: dest " + md.dest + ", ID " + md.UID + "/" + md.MsgVid + ":" + md.MsgId + ", len " + md.theBytes.Length + " bytes");
                            }

                            if (!md.dontAutoResend && Resend(md)) {
                                if (++md.retryCnt >= md.retryLimit) {
                                    md.dontAutoResend = true;
                                }

                                md.retryDelay = Math.Max(Vsync.VSYNC_MIN2NDRTSEND, md.retryDelay << 1);
                                md.resendTime = Vsync.NOW + md.retryDelay;
                                if (md.retryDelay < sleep_until) {
                                    sleep_until = md.retryDelay;
                                }
                            }
                        }
                    }

                    foreach (MsgDesc lgmd in lgToResend) {
                        if (Vsync.NOW < lgmd.resendTime || !lgmd.group.GroupOpen) {
                            continue;
                        }

                        Group.tokenInfo theToken = lgmd.group.theToken;
                        if (theToken == null) {
                            continue;
                        }

                        if (++rsCount > Vsync.VSYNC_ASYNCMTOTALLIMIT) {
                            rsCount = 0;
                            if (!ResenderSleepLock.WaitOne(10)) {
                                sleep_until = 0;
                            }
                        }

                        if (((lgmd.retryCnt < 5 && (Vsync.NOW - lgmd.lastSentAt) > 1000) || (Vsync.NOW - lgmd.lastSentAt) > 5000) && lgReMulticast(lgmd)) {
                            ++lgmd.retryCnt;
                        }

                        if (lgmd.retryDelay < sleep_until) {
                            sleep_until = lgmd.retryDelay * lgmd.retryCnt;
                        }

                        lgmd.resendTime = Vsync.NOW + Math.Max(1000, Math.Max(500 + (Math.Min(4, lgmd.retryCnt) * 250), lgmd.retryDelay * lgmd.retryCnt));
                    }

                    if (sleep_until != 0) {
                        szeroCount = 0;
                        ResenderSleepLock.WaitOne(Math.Min(1000, sleep_until));
                    }
                    else if (++szeroCount == 5) {
                        // After sending a burst of 25 retransmissions, with 10ms pauses every 5 messages send, pause for 100ms
                        szeroCount = 0;
                        ResenderSleepLock.WaitOne(100);
                    }
                }

                if ((VsyncSystem.Debug & VsyncSystem.MESSAGELAYER) != 0) {
                    Vsync.WriteLine("VsyncActive false: Resender exiting.");
                }
            }
            catch (VsyncShutdownException) {
            }
            catch (SocketException e) {
                if (VsyncSystem.VsyncActive) {
                    throw new VsyncException("Vsync terminating due to socket exception in resender thread", e);
                }
            }

            if (VsyncSystem.VsyncActive) {
                throw new VsyncException("Resender thread has crashed");
            }

            VsyncSystem.ThreadTerminationMagic();
        }

        private static LinkedList<MsgDesc> PSweep(List<MsgDesc> ToResend, List<MsgDesc> destDied, long now, LinkedList<MsgDesc> psb) {
            LinkedList<MsgDesc> newPSB = new LinkedList<MsgDesc>();
            foreach (MsgDesc md in psb) {
                using (var tmpLockObj = new LockAndElevate(Vsync.RIPLock)) {
                    if (Vsync.RIPList.Contains(md.dest)) {
                        destDied.Add(md);
                        continue;
                    }
                }

                if (md.group != null && (md.type == Msg.STABILITYINFO || !md.isP2POrGroup)) {
                    using (var tmpLockObj = new LockAndElevate(Group.GroupRIPLock)) {
                        if (Group.GroupRIPList.Contains(md.group.gaddr)) {
                            destDied.Add(md);
                            continue;
                        }
                    }
                }

                newPSB.AddLast(md);
                if (md.dontAutoResend && (Vsync.NOW - md.lastSentAt) > 2000) {
                    md.dontAutoResend = false;
                }

                if (!md.dontAutoResend && now > md.resendTime) {
                    int sameDestCnt = 0;
                    MsgDesc leastUrgent = null;
                    foreach (MsgDesc mmd in ToResend) {
                        if (mmd.dest == md.dest) {
                            ++sameDestCnt;
                            if (mmd.retryCnt > md.retryCnt || (mmd.retryCnt == md.retryCnt && mmd.resendTime > md.resendTime)) {
                                leastUrgent = mmd;
                            }
                        }
                    }

                    if (sameDestCnt >= 5) {
                        if (leastUrgent != null) {
                            ToResend.Remove(leastUrgent);
                            ToResend.Add(md);
                        }

                        // else md is "less urgent" to resend than the ones already on the list, so don't add it
                    }
                    else {
                        ToResend.Add(md);
                    }
                }
            }

            return newPSB;
        }

        internal const int RECVBB = 0;

        internal const int ACKBB = 1;

        internal static long dotTime = long.MaxValue;

        // Used by Ken for debugging: appStillHealthy() is a dead-man switch.  If not pressed often enough, appDetectedAnomaly() becomes true
        internal static void appStillHealthy() {
            dotTime = Vsync.NOW;
        }

        internal static void appDisableHealthCheck() {
            dotTime = long.MaxValue;
        }

        internal static bool appDetectedAnomaly() {
            return (Vsync.NOW - dotTime) > 1200;
        }

        internal static void P2PSend(Address dest, int port, byte[] data, int which) {
            IPEndPoint remoteEP = new IPEndPoint(dest.home, port);
            try {
                if (which == RECVBB) {
                    int bs = ReliableSender.my_p2psocket.SendTo(data, remoteEP);
                    using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                        VsyncSystem.RTS.UDPBsent += bs;
                        VsyncSystem.RTS.UDPsent++;
                    }
                }
                else {
                    ReliableSender.CheckLenAndRate(data);
                    if (!Vsync.VSYNC_INFINIBAND || IB.ib_send(ACKBB, dest, data) == -1) {
                        ReliableSender.my_acksocket.SendTo(data, remoteEP);
                    }

                    using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                        VsyncSystem.RTS.ACKsent++;
                    }
                }
            }
            catch (Exception) {
            }
        }

        private static readonly LockObject ResendLock = new LockObject("ResendLock", ThreadPriority.Highest);

        internal static bool Resend(MsgDesc md) {
            using (var tmpLockObj = new LockAndElevate(ResendLock)) {
                if (Vsync.NOW - md.lastSentAt < 150) {
                    return false;
                }

                md.lastSentAt = Vsync.NOW;
            }

            try {
                IPEndPoint target = new IPEndPoint(md.dest.home, md.dest.p2pPort);
                ReliableSender.CheckLenAndRate(md.theBytes);
                int bs;
                if (!Vsync.VSYNC_INFINIBAND || (bs = IB.ib_send(RECVBB, md.dest, md.theBytes)) == -1) {
                    bs = ReliableSender.my_p2psocket.SendTo(md.theBytes, target);
                }

                if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                    using (var tmpLockObj = new LockAndElevate(ackInfoLock)) {
                        ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: Resend to " + target + " for " + md.dest + " UID " + md.UID + Environment.NewLine);
                    }
                }

                using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                    VsyncSystem.RTS.UDPBsent += bs;
                    VsyncSystem.RTS.UDPsent++;
                }
            }
            catch (IOException) {
            }
            catch (SocketException) {
            }
            catch (ObjectDisposedException) {
                throw new VsyncShutdownException("socket disposed");
            }

            return true;
        }

        internal static void ResendP2P(Address dest, MsgDesc md) {
            try {
                IPEndPoint remoteEP = new IPEndPoint(dest.home, dest.p2pPort);
                ReliableSender.CheckLenAndRate(md.theBytes);
                int bs;
                if (!Vsync.VSYNC_INFINIBAND || (bs = IB.ib_send(RECVBB, dest, md.theBytes)) == -1) {
                    bs = ReliableSender.my_p2psocket.SendTo(md.theBytes, remoteEP);
                }

                using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                    VsyncSystem.RTS.UDPBsent += bs;
                    VsyncSystem.RTS.UDPsent++;
                }
            }
            catch (Exception) {
            }
        }

        internal static bool lgReMulticast(MsgDesc lgmd) {
            if ((Vsync.NOW - lgmd.lastSentAt < 500) || lgmd.group == null || lgmd.group.gaddr == null || lgmd.group.my_socket == null || lgmd.theBytes == null) {
                return false;
            }

            if (!lgMulticast(lgmd.group, lgmd.theBytes)) {
                return false;
            }

            lgmd.lastSentAt = Vsync.NOW;
            lgmd.retryDelay = Math.Min(5000, Math.Max(50, lgmd.retryDelay));
            lgmd.resendTime = Vsync.NOW + lgmd.retryDelay;
            return true;
        }

        internal static bool lgMulticast(Group g, byte[] ba) {
            if (g.myPhysIPAddr != MCMDSocket.USEUNICAST) {
                return g.my_socket.NBSendTo(ba);
            }

            if (g.theView.members.Length > Vsync.VSYNC_MAXDIRECTSENDS) {
                Vsync.VSYNCMEMBERS.IPMCTunnel(g.gaddr, ba);
                return true;
            }

            foreach (Address dest in g.theView.members) {
                if (dest.isMyAddress()) {
                    continue;
                }

                IPEndPoint remoteEP = new IPEndPoint(dest.home, dest.p2pPort);
                ReliableSender.CheckLenAndRate(ba);
                int bs = my_p2psocket.SendTo(ba, remoteEP);
                using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                    VsyncSystem.RTS.UDPBsent += bs;
                    VsyncSystem.RTS.UDPsent++;
                }
            }

            return true;
        }

        private static bool tokenThreadActive;

        internal static void resetTheToken(Group g) {
            if ((g.flags & Group.G_ISLARGE) != 0) {
                Group.tokenInfo theToken;
                using (var tmpLockObj = new LockAndElevate(g.TokenLock)) {
                    Group.tokenInfo.newToken(g);
                    theToken = g.theToken;
                }

                if (g == Vsync.VSYNCMEMBERS && g.IAmRank0()) {
                    g.becomeGroupOwner();
                }

                theToken.inhibitResenderLoop = true;
                theToken.gotAllAt = 0;
                theToken.logicalClock++;
                theToken.resetStableByLevel(g);
                using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                    foreach (MsgDesc md in LgPendingSendBuffer) {
                        if (md.group == g) {
                            md.retryCnt = 0;
                            md.retryDelay = Math.Max(250, Math.Min(20, md.retryDelay));
                            md.resendTime = Vsync.NOW + md.retryDelay;
                        }
                    }
                }
            }
        }

        internal class TThreadTuple {
            internal volatile Group.tokenInfo theToken;

            internal Group theGroup;

            internal int TheNextMsgID;

            internal TThreadTuple(Group.tokenInfo t, Group g, int n) {
                this.theToken = t;
                this.theGroup = g;
                this.TheNextMsgID = n;
            }
        }

        internal static long lastGCTime = 0;

        internal static void TokenThread() {
            try {
                beTokenThread();
            }
            catch (VsyncShutdownException) {
                return;
            }
            catch (Exception e) {
                if (!VsyncSystem.VsyncActive) {
                    VsyncSystem.ThreadTerminationMagic();
                    return;
                }

                Vsync.WriteLine("WARNING: Token thread exited abnormally with exception " + e);
                throw new VsyncException("Dead token thread", e);
            }
            VsyncSystem.ThreadTerminationMagic();
        }

        internal static void beTokenThread() {
            while (!VsyncSystem.VsyncActive) {
                Vsync.Sleep(250);
            }

            try {
                if (tokenThreadActive) {
                    return;
                }

                tokenThreadActive = true;
                int loopCnt = 0;
                while (VsyncSystem.VsyncActive) {
                    VsyncSystem.RTS.ThreadCntrs[20]++;
                    loopCnt++;
                    int tokenDelay = Vsync.VSYNC_TOKEN_DELAY;
                    if ((Vsync.NOW - lastGCTime) > Vsync.VSYNC_GCFREQ && FlowControl.MsgCountNum > 10) {
                        lastGCTime = Vsync.NOW;
                        GC.Collect();
                    }

                    List<TThreadTuple> tokenList = new List<TThreadTuple>();

                    // minimizes lock hold time and also avoids a deadlock scenario...
                    List<Group> glist = Group.VsyncGroupsClone();
                    foreach (Group g in glist) {
                        if ((g.flags & Group.G_ISLARGE) != 0 && (loopCnt % 20 == 0 || g.interesting)) {
                            using (new ILock(ILock.LLBRIEF, g.gaddr)) {
                                Group.tokenInfo theToken;
                                g.interesting = false;
                                using (var tmpLockObj = new LockAndElevate(g.TokenLock)) {
                                    theToken = g.theToken;
                                }

                                if (theToken != null) {
                                    g.updateSeenInfo();
                                    int nm = g.theView.NextIncomingMsgID[1];
                                    using (var tmpLockObj = new LockAndElevate(g.ViewLock)) {
                                        if (g.nextMsgid != -1) {
                                            nm = Math.Min(g.nextMsgid, g.theView.NextIncomingMsgID[1]);
                                        }
                                    }

                                    tokenList.Add(new TThreadTuple(theToken, g, nm));
                                }
                            }
                        }
                    }

                    foreach (TThreadTuple ttt in tokenList) {
                        Group.tokenInfo theToken;
                        using (var tmpLockObj = new LockAndElevate(ttt.theGroup.TokenLock))
                        using (var tmpLockObj1 = new LockAndElevate(ttt.theGroup.ViewLock)) {
                            theToken = ttt.theToken;
                            View theView = ttt.theGroup.theView;
                            if (theToken.viewid < theView.viewid || theToken.WorkingView.viewid < theView.viewid) {
                                // To maximize asynchrony, theView might sometimes be updated before WorkingView.  During such a period, don't send tokens
                                continue;
                            }

                            // Basically, we want to keep advancing stableTo to the maximum value confirmed by the other ring members, which would be 
                            // tp.StableByLevel[tp.next.Length-1] (the looped-back value for ring level n-1, if I'm at level n)
                            // Complications arise because during LgFlush, the value sent out is int.MaxValue, hence one or both of 
                            // tp.stableTo and tp.StableByLevel could be pegged at infinity.  So we need to trim that down to size.
                            // So: take the max; if a sensible number, done.  Else if it was infinity, take the min (assuming one of the two was
                            // pegged at infinity).  If no longer infinity, done.  Else just whatever my own next incoming msgID happens to be
                            if (theToken.IAmLgOwner) {
                                if ((VsyncSystem.Debug & VsyncSystem.TOKENSTABILITY) != 0) {
                                    Vsync.WriteLine("In token thread I am the lgOwner for group <" + ttt.theGroup.gname + "> at time " + Vsync.MsToSecs(Vsync.NOW) + " (logicalClock=" + theToken.logicalClock + ") and stableTo = " + theToken.stableTo + " and tp.StableByLevel[tp.StableByLevel.Length=" + theToken.StableByLevel.Length + " - 1]=" + theToken.StableByLevel[theToken.StableByLevel.Length - 1] + " and members.length=" + theToken.WorkingView.members.Length + " and nextIncoming=" + (theView.NextIncomingMsgID[1] - 1));
                                }

                                int old = theToken.stableTo;
                                if (theToken.StableByLevel[theToken.StableByLevel.Length - 1] != int.MaxValue) {
                                    theToken.stableTo = Math.Max(theToken.stableTo, theToken.StableByLevel[theToken.StableByLevel.Length - 1]);
                                }
                                else if (theToken.WorkingView.members.Length == 1) {
                                    theToken.stableTo = theView.NextIncomingMsgID[1] - 1;
                                }

                                if ((VsyncSystem.Debug & VsyncSystem.TOKENSTABILITY) != 0 && theToken.stableTo != old) {
                                    Vsync.WriteLine("<" + ttt.theGroup.gname + ">: Decided to set stableTo to " + theToken.stableTo + " (was " + old + ") in <" + ttt.theGroup.gname + ">; this is because tp.StableByLevel[" + (theToken.next.Length - 1) + "]=" + theToken.StableByLevel[theToken.next.Length - 1]);
                                }
                            }
                        }

                        if (ttt.theGroup.gcollectedTo < theToken.stableTo) {
                            ttt.theGroup.gcollectedTo = theToken.stableTo;
                            if ((VsyncSystem.Debug & VsyncSystem.TOKENLAYER) != 0) {
                                Vsync.WriteLine("LgOwner: LgGCollect to: " + ttt.theGroup.gcollectedTo);
                            }

                            ReliableSender.gotLgAck(ttt.theGroup, theToken.stableTo);
                        }

                        for (int slevel = 0; slevel < theToken.next.Length; slevel++) {
                            using (var tmpLockObj = new LockAndElevate(theToken.tokenInMotionLock)) {
                                if (theToken.tokenInMotion[slevel] > 2) {
                                    // Only two can be pending at a time to any given (target,level) pair...
                                    continue;
                                }
                            }

                            if ((VsyncSystem.Debug & VsyncSystem.TOKENSTABILITY) != 0) {
                                Vsync.WriteLine("In token thread deciding to send a token in group <" + ttt.theGroup.gname + "> at time " + Vsync.MsToSecs(Vsync.NOW));
                            }

                            Address nextInRing = theToken.next[slevel];
                            theToken.tokenLevel = slevel;
                            if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                                Vsync.WriteLine("In TokenThread computing tp.token for level " + slevel + ", sv=" + theToken.stableAtSender + ", nextInRing " + ((nextInRing == null) ? "NULL" : nextInRing.ToString()));
                            }

                            if (nextInRing == null || nextInRing.isMyAddress()) {
                                // Special case for a degenerate ring.  Might not be degenerate at some higher level
                                if ((VsyncSystem.Debug & VsyncSystem.TOKENSTABILITY) != 0) {
                                    Vsync.WriteLine("Stability logic[slevel=" + slevel + "]: TokenThread encountered special case for a degenerate ring (setting StableByLevel[" + slevel + "] by copying from below)");
                                }

                                theToken.StableByLevel[slevel] = (slevel == 0) ? theToken.stableAtSender : theToken.StableByLevel[slevel - 1];
                                if ((VsyncSystem.Debug & VsyncSystem.AGGREGATION) != 0) {
                                    Vsync.WriteLine("Aggregation logic[slevel=" + slevel + "]: TokenThread encountered special case for a degenerate ring (copying DValues up to next level)");
                                }

                                if (slevel < theToken.theGroup.AggList.Length - 1) {
                                    int idx = 0;
                                    foreach (IAggregateEventHandler ae in theToken.theGroup.AggList[slevel]) {
                                        int ndx = 0;
                                        foreach (IAggregateEventHandler nlae in theToken.theGroup.AggList[slevel + 1]) {
                                            if (idx == ndx) {
                                                // Copies DValues from level k to level k+1
                                                nlae.LoadDValues(ae.GetDValues());
                                                break;
                                            }

                                            ++ndx;
                                        }

                                        ++idx;
                                    }
                                }

                                continue;
                            }

                            if (theToken.myOffset[slevel] != 0) {
                                // An inner node in some ring: outgoing value of aggStable is the smaller of last value received in a valid token
                                // and my own value.  for level 0, this simply reflects my own delivered messages queue.  For levels>0, this will be the stability aggregated
                                // at the next level down.  The token will also contain my value of myStable but that's just to let the next guy in the ring do NACK-triggered retransmissions
                                if ((VsyncSystem.Debug & VsyncSystem.TOKENSTABILITY) != 0) {
                                    int localStabilityValue = theToken.stableAtSender;
                                    if (slevel > 0) {
                                        localStabilityValue = Math.Min(localStabilityValue, theToken.StableByLevel[slevel - 1]);
                                    }

                                    Vsync.WriteLine("<" + ttt.theGroup.gname + ">: Setting tp.aggStable = Math.Min(tp.StableByLevel[" + slevel + "]=" + theToken.StableByLevel[slevel] + ", localStabilityValue=" + localStabilityValue + ")");
                                }

                                theToken.aggStable = Math.Min(theToken.StableByLevel[slevel], theToken.stableAtSender);
                            }
                            else {
                                // The "point man" in some ring.  At level zero you use your own value if on the left since there is no input from the left
                                if (slevel == 0) {
                                    theToken.aggStable = theToken.stableAtSender;
                                    if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENSTABILITY)) != 0) {
                                        Vsync.WriteLine("<" + ttt.theGroup.gname + ">: ring leader logic: I " + (theToken.IAmLgOwner ? "am" : "am not") + " the group owner, setting theToken.aggStable to " + theToken.aggStable);
                                    }
                                }
                                else {
                                    // Higher levels use the aggregated value from lower ones as their "starting proposal".  This is retained from the last valid token received down there
                                    theToken.aggStable = theToken.StableByLevel[slevel - 1];
                                    if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.TOKENSTABILITY)) != 0) {
                                        Vsync.WriteLine("<" + ttt.theGroup.gname + ">: ring leader logic: I " + (theToken.IAmLgOwner ? "am" : "am not") + " the group owner, setting theToken.aggStable to triple.theToken.StableByLevel[" + (slevel - 1) + "]= " + theToken.aggStable);
                                    }
                                }
                            }

                            if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                                Vsync.WriteLine("Sending tp.token with callback requested for level " + slevel + " to " + nextInRing + ", value " + theToken);
                            }

                            using (var tmpLockObj = new LockAndElevate(theToken.tokenInMotionLock)) {
                                theToken.tokenInMotion[slevel]++;
                            }

                            if (!nextInRing.isMyAddress()) {
                                int mylevel = slevel;
                                SendP2P(Msg.ISTOKEN, nextInRing, ttt.theGroup, theToken.toBArray(), true, () => {
                                    if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                                        Vsync.WriteLine("Token-sent callback for group <" + theToken.theGroup.gname + ">, level " + mylevel + " (legal range: 0.." + theToken.tokenInMotion.Length + ")");
                                    }

                                    using (var tmpLockObj = new LockAndElevate(theToken.tokenInMotionLock)) {
                                        theToken.tokenInMotion[mylevel]--;
                                    }
                                });
                                using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                    VsyncSystem.RTS.TokensSent++;
                                }
                            }

                            if (ttt.theToken != theToken) {
                                continue;
                            }

                            if (theToken.lastToken[slevel] == null || theToken.lastToken[slevel].sender != theToken.last[slevel]) {
                                if (!theToken.pinged[slevel]) {
                                    pingLast(theToken, ttt, slevel);
                                }

                                theToken.pinged[slevel] = true;
                            }
                            else {
                                theToken.pinged[slevel] = false;
                            }
                        }
                    }

                    if (PendingSendBuffer.Count + P2PPendingSendBuffer.Count > Vsync.VSYNC_ASYNCMTOTALLIMIT) {
                        tokenDelay = Math.Max(tokenDelay, 250);
                    }

                    Vsync.Sleep(Math.Max(2, tokenDelay));
                }
            }
            catch (VsyncShutdownException) {
                VsyncSystem.CheckLocksHeld();
            }
        }

        private static void pingLast(Group.tokenInfo tp, TThreadTuple tokenSummary, int slevel) {
            if (!tp.sentAToken[slevel] && !tp.last[slevel].isMyAddress()) {
                tp.sentAToken[slevel] = true;

                // This will be treated as an "invalid" token (I'm not the guy he expected tokens from) but the view deltas piggybacked on it still get processed
                SendP2P(Msg.ISTOKEN, tp.last[slevel], tokenSummary.theGroup, tp.toBArray(), true);
            }
        }

        internal static void gotToken(Msg m) {
            Group g;
            using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                VsyncSystem.RTS.TokensRcvd++;
            }

            if ((m.flags & Msg.FRAGGED) != 0) {
                // This code cheats, stashing the gaddr in the token dest field because m.gaddr isn't part of the wire representation of a message
                // This won't confuse the message ordering layers because tokens are handled by special logic that doesn't worry about sequencing
                g = Group.Lookup(m.dest);
                if (g == null) {
                    if ((VsyncSystem.Debug & VsyncSystem.DISCARDS) != 0) {
                        Vsync.WriteLine("WARNING: Discarding a fragmented token that references group " + m.dest + " because I'm not a member of that group");
                    }

                    return;
                }

                m.flags |= Msg.TOKEN;
                Group.deFragRdv(g, m);
                return;
            }

            Group.tokenInfo toke = new Group.tokenInfo(m.payload) { whenReceived = Vsync.NOW };
            g = toke.theGroup;
            Group.tokenInfo theToken = null;
            if (g != null) {
                using (var tmpLockObj = new LockAndElevate(g.TokenLock)) {
                    theToken = g.theToken;
                }
            }

            if (g == null || theToken == null) {
                if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.DISCARDS)) != 0) {
                    Vsync.WriteLine("gotToken: I'm not in group " + toke.gaddr + "(or it has no token)!");
                }

                using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                    VsyncSystem.RTS.Discarded++;
                }

                return;
            }

            if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                Vsync.WriteLine("gotToken: call processIncoming: " + toke);
            }

            g.processIncoming(m.sender, toke);
        }

        internal static void NodeHasFailed(Address who) {
            List<MsgDesc> toRemove = new List<MsgDesc>();
            using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                PendingSendBuffer = PSBRemoveFailedDest(who, toRemove, PendingSendBuffer);
                P2PPendingSendBuffer = PSBRemoveFailedDest(who, toRemove, P2PPendingSendBuffer);
            }

            int cnt = toRemove.Count;
            foreach (MsgDesc md in toRemove) {
                md.done = true;
                mdRemove(md, "NodeHasFailed", --cnt == 0);
            }

            AwaitReplies.doNoteFailure(who);
            ReliableSender.P2PSequencer.Failed(who);
            VsyncSystem.WriteAckInfo();
        }

        private static LinkedList<MsgDesc> PSBRemoveFailedDest(Address who, List<MsgDesc> toRemove, LinkedList<MsgDesc> psb) {
            LinkedList<MsgDesc> newPSB = new LinkedList<MsgDesc>();
            foreach (MsgDesc md in psb) {
                if (md.dest != who) {
                    newPSB.AddLast(md);
                }
                else {
                    toRemove.Add(md);
                }
            }

            return newPSB;
        }

        internal static void gotLgAck(Group g, int low) {
            if ((VsyncSystem.Debug & VsyncSystem.TOKENLOGIC) != 0) {
                Vsync.WriteLine("->->  in gotLgAck group " + g.gname + ", g.lastLgAckID=" + g.lastLgAckID + ", low=" + low);
            }

            if (low < 0 || g.lastLgAckID == low) {
                return;
            }

            g.lastLgAckID = low;
            List<MsgDesc> toRemove = new List<MsgDesc>();
            using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                LinkedList<MsgDesc> newLgPendingSendBuffer = new LinkedList<MsgDesc>();
                foreach (MsgDesc lgmd in LgPendingSendBuffer) {
                    if (lgmd.dest == g.gaddr && lgmd.UID <= low) {
                        toRemove.Add(lgmd);
                    }
                    else {
                        newLgPendingSendBuffer.AddLast(lgmd);
                    }
                }

                LgPendingSendBuffer = newLgPendingSendBuffer;
            }

            int cnt = toRemove.Count;
            foreach (MsgDesc lgmd in toRemove) {
                lgmd.done = true;
                mdRemove(lgmd, "lgmd.gotLgAck", --cnt == 0);
            }
        }

        internal static void mdRemove(MsgDesc md, string where, bool checkBarrier) {
            List<Semaphore> theCPSList;
            lock (md) {
                if (md.alreadyCleanedUp) {
                    return;
                }

                md.alreadyCleanedUp = true;
                theCPSList = md.CPSList;
                md.CPSList = null;
                if (md.group != null) {
                    md.group.interesting = true;
                }
            }

            if (!md.isp2p && md.group != null && md.group.HasFirstView) {
                updateStability(md.group, md.MsgVid, md.MsgId);
            }

            FlowControl.FCEndSend(md.num, md.denom);
            if (theCPSList != null) {
                lock (theCPSList) {
                    foreach (Semaphore cps in theCPSList) {
                        cps.Release();
                    }
                }
            }

            if (checkBarrier) {
                using (var tmpLockObj = new LockAndElevate(ReliableSender.rWaitLock)) {
                    int rbc = RemoteBacklogCount();
                    if (rWaiting > 0 && rbc < Vsync.VSYNC_MAXRBACKLOG * 7 / 10) {
                        ILock.Barrier(ILock.LLWAIT, ILock.LFLOWCNTRLB).BarrierReleaseAll();
                    }
                }
            }

            if (md.am != null) {
                using (var tmpLockObj = new LockAndElevate(activeMsgLock)) {
                    md.am.StableCnt++;
                    List<msgWaiter> newList = new List<msgWaiter>();
                    if (md.am.Waiters != null) {
                        foreach (msgWaiter mw in md.am.Waiters) {
                            if (md.am.StableCnt >= mw.threshold) {
                                mw.waitSema.Release();
                            }
                            else {
                                newList.Add(mw);
                            }
                        }

                        md.am.Waiters = newList.Count > 0 ? newList : null;
                    }

                    if (md.am.StableCnt == md.am.SentCnt) {
                        if (md.am.Waiters != null) {
                            throw new VsyncException("About to remove activeMsg object yet wait queue is non-null!");
                        }

                        activeMsgs.Remove(md.am);
                    }
                }
            }

            if (md.p2pdcb != null) {
                md.p2pdcb();
            }
        }

        internal static void notePendingSend(Group g, int vid, int msgid) {
            if (vid < 0 || msgid < 0) {
                return;
            }

            using (var tmpLockObj = new LockAndElevate(g.ViewLock)) {
                if (g.theView.viewid > vid || !g.HasFirstView || (g.theView.members.Length == 1 && g.theView.members[0].isMyAddress())) {
                    return;
                }

                if (vid > g.theView.viewid || g.theView.minStable >= msgid) {
                    Vsync.WriteLine("WARNING:  notePendingSend: theView.viewid=" + g.theView.viewid + ", with theView.minStable= " + g.theView.minStable + ", but called with " + vid + "::" + msgid);
                    g.theView.minStable = msgid;
                }

                View.PSTuple newNode = new View.PSTuple(vid, msgid, g.theView.members.Length - (g.theView.GetMyRank() == -1 ? 0 : 1));
                if (g.theView.PendingSends.Count == 0) {
                    g.theView.PendingSends.AddLast(newNode);
                    return;
                }

                for (LinkedListNode<View.PSTuple> pst = g.theView.PendingSends.Last; pst != null; pst = pst.Previous) {
                    if (pst.Value.msgid < msgid) {
                        g.theView.PendingSends.AddAfter(pst, newNode);
                        return;
                    }
                }

                g.theView.PendingSends.AddFirst(newNode);
            }
        }

        internal static void updateStability(Group g, int vid, int msgid) {
            if (!g.HasFirstView || vid < 0 || msgid < 0) {
                return;
            }

            using (var tmpLockObj = new LockAndElevate(g.ViewLock)) {
                if (g.theView.viewid > vid) {
                    return;
                }

                for (LinkedListNode<View.PSTuple> pst = g.theView.PendingSends.First; pst != null; pst = pst.Next) {
                    if (pst.Value.vid == vid && pst.Value.msgid == msgid) {
                        --pst.Value.count;
                        break;
                    }
                }

                while (g.theView.PendingSends.Count > 0 && g.theView.PendingSends.First.Value.count == 0) {
                    g.theView.minStable = g.theView.PendingSends.First.Value.msgid;
                    g.theView.PendingSends.RemoveFirst();
                }
            }
        }

        internal static int getMinStable(Address gaddr, int vid) {
            Group g = Group.doLookup(gaddr);
            if (g != null && g.HasFirstView) {
                using (var tmpLockObj = new LockAndElevate(g.ViewLock)) {
                    if (g.theView.viewid == vid) {
                        return g.theView.minStable;
                    }
                }
            }

            return -1;
        }

        internal static void waitForStability(int threshold) {
            List<Semaphore> slist = new List<Semaphore>();
            try {
                using (var tmpLockObj = new LockAndElevate(activeMsgLock)) {
                    foreach (activeMsg am in activeMsgs) {
                        if (am.StableCnt < Math.Min(threshold, am.SentCnt)) {
                            Semaphore s = new Semaphore(0, int.MaxValue);
                            slist.Add(s);
                            if (am.Waiters == null) {
                                am.Waiters = new List<msgWaiter>();
                            }

                            am.Waiters.Add(new msgWaiter(Math.Min(threshold, am.SentCnt), s));
                        }
                    }
                }

                foreach (Semaphore s in slist) {
                    ILock.NoteThreadState("waitForStability.WaitOne()");
                    s.WaitOne();
                    ILock.NoteThreadState(null);
                }
            }
            finally {
                foreach (Semaphore s in slist) {
                    s.Dispose();
                }
            }
        }

        internal class P2PSequencer {
            internal delegate void P2PCB(Msg m);

            internal class P2PCBList {
                internal Msg theMsg;

                internal P2PCB theCB;

                internal P2PCBList(Msg m, P2PCB cb) {
                    this.theMsg = m;
                    this.theCB = cb;
                }
            }

            internal Address dest;

            internal int outSeqn;

            internal int nonrawSeqn;

            // The outSeqn value of the most recently sent non-raw packet.  Needed because raw packets aren't acknowledged and don't count towards remote backlogs
            internal int inSeqn;

            internal int remoteBacklog;

            internal long whenReported;

            internal LockObject Lock = new LockObject("P2PSequencer.Lock");

            internal SortedList<int, P2PCBList> outOfOrder = new SortedList<int, P2PCBList>();

            internal List<KeyValuePair<int, P2PCBList>> callbacksToDo = new List<KeyValuePair<int, P2PCBList>>();

            internal static Dictionary<Address, P2PSequencer> PSIndex = new Dictionary<Address, P2PSequencer>(1000);

            internal static LockObject PSListLock = new LockObject("PSListLock", ThreadPriority.Highest);

            internal long lastCallbackTime;

            internal P2PSequencer(Address who) {
                this.dest = who;
            }

            internal string GetP2PSState() {
                string s = psprint(this);
                foreach (KeyValuePair<int, P2PCBList> kvp in this.outOfOrder) {
                    s += "  **  " + kvp.Value.theMsg + Environment.NewLine;
                }

                if (this.callbacksToDo.Count > 0) {
                    s += "  ++ Doing a p2p callback, when it finishes will deliver: " + Environment.NewLine;
                    foreach (KeyValuePair<int, P2PCBList> kvp in this.callbacksToDo) {
                        s += "  **  " + kvp.Value.theMsg + Environment.NewLine;
                    }
                }

                return s;
            }

            internal static string psprint(P2PSequencer p2ps) {
                return "-- P2PS [" + p2ps.dest + "], inseqn " + p2ps.inSeqn + ", outseqn " + p2ps.outSeqn +
                    ", non-raw outseqn " + p2ps.nonrawSeqn + ", backlog " + P2PSequencer.CountP2PSeqn() +
                    ", last callback @ " + Vsync.MsToSecs(p2ps.lastCallbackTime) + ", remote backlog=" + getRBacklog(p2ps) + Environment.NewLine;
            }

            internal static string GetState() {
                using (var tmpLockObj = new LockAndElevate(PSListLock)) {
                    if (PSIndex.Count == 0) {
                        return string.Empty;
                    }

                    string s = "P2PSequencer states" + Environment.NewLine;
                    foreach (KeyValuePair<Address, P2PSequencer> kvp in PSIndex) {
                        s += kvp.Value.GetP2PSState();
                    }

                    return s;
                }
            }

            internal static void Failed(Address who) {
                using (var tmpLockObj = new LockAndElevate(PSListLock)) {
                    P2PSequencer p2ps;
                    if (P2PSequencer.PSIndex.TryGetValue(who, out p2ps)) {
                        using (var tmpLockObj1 = new LockAndElevate(p2ps.Lock)) {
                            PSIndex.Remove(p2ps.dest);
                        }
                    }
                }
            }

            internal static void FixUp(Address oldAddr, Address newAddr) {
                if (oldAddr == newAddr) {
                    return;
                }

                using (var tmpLockObj = new LockAndElevate(PSListLock)) {
                    P2PSequencer p2ps;
                    if (oldAddr != null && PSIndex != null && PSIndex.TryGetValue(oldAddr, out p2ps)) {
                        using (var tmpLockObj1 = new LockAndElevate(p2ps.Lock)) {
                            PSIndex.Remove(oldAddr);
                            if (!PSIndex.ContainsKey(newAddr)) {
                                p2ps.dest = newAddr;
                                PSIndex.Add(newAddr, p2ps);
                            }
                            else if (PSIndex[newAddr] != p2ps) {
                                P2PSequencer op2ps = PSIndex[newAddr];

                                // Vsync.WriteLine("WARNING: in ReliableSender.Fixup(" + oldAddr + ", " + newAddr + "), found " + psprint(op2ps) +
                                // ", keeping it and discarding p2ps =" + psprint(p2ps));
                                op2ps.inSeqn = Math.Max(op2ps.inSeqn, p2ps.inSeqn);
                                op2ps.outSeqn = Math.Max(op2ps.outSeqn, p2ps.outSeqn);
                                op2ps.nonrawSeqn = Math.Max(op2ps.nonrawSeqn, p2ps.nonrawSeqn);
                                op2ps.lastCallbackTime = Math.Max(op2ps.lastCallbackTime, p2ps.lastCallbackTime);
                                op2ps.whenReported = Math.Max(op2ps.whenReported, p2ps.whenReported);
                                op2ps.remoteBacklog = Math.Max(op2ps.remoteBacklog, p2ps.remoteBacklog);
                                foreach (KeyValuePair<int, P2PCBList> x in p2ps.outOfOrder) {
                                    op2ps.outOfOrder.Add(x.Key, x.Value);
                                }
                            }
                        }
                    }
                }

                using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                    foreach (MsgDesc md in PendingSendBuffer) {
                        if (md.dest == oldAddr) {
                            md.dest = newAddr;
                        }
                    }

                    foreach (MsgDesc md in P2PPendingSendBuffer) {
                        if (md.dest == oldAddr) {
                            md.dest = newAddr;
                        }
                    }

                    foreach (MsgDesc md in LgPendingSendBuffer) {
                        if (md.dest == oldAddr) {
                            md.dest = newAddr;
                        }
                    }
                }
            }

            internal static int NextP2PSeqn(string why, Address who) {
                using (var tmpLockObj = new LockAndElevate(Vsync.RIPLock)) {
                    if (Vsync.RIPList.Contains(who)) {
                        return -1;
                    }
                }

                using (var tmpLockObj = new LockAndElevate(PSListLock)) {
                    P2PSequencer p2ps;
                    if (!PSIndex.TryGetValue(who, out p2ps)) {
                        PSIndex.Add(who, p2ps = new P2PSequencer(who));
                    }

                    using (var tmpLockObj1 = new LockAndElevate(p2ps.Lock)) {
                        if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.P2PLAYER)) != 0) {
                            Vsync.WriteLine("NextP2PSeqn<" + why + "> dest " + who + ", using P2P seqn " + p2ps.outSeqn);
                        }

                        return p2ps.outSeqn++;
                    }
                }
            }

            internal static void CheckP2PSeqn() {
                List<Address> nhf = new List<Address>();
                using (var tmpLockObj = new LockAndElevate(PSListLock)) {
                    foreach (KeyValuePair<Address, P2PSequencer> kvp in PSIndex) {
                        P2PSequencer p2ps = kvp.Value;
                        using (var tmpLockObj1 = new LockAndElevate(p2ps.Lock)) {
                            if (p2ps.outOfOrder.Count > 0 && p2ps.lastCallbackTime > 0 && (Vsync.NOW - p2ps.lastCallbackTime) > Vsync.VSYNC_DEFAULTTIMEOUT * 2 && !HeardFromRecently(kvp.Value.dest)) {
                                nhf.Add(p2ps.dest);
                            }
                        }
                    }
                }

                foreach (Address d in nhf) {
                    NodeHasFailed(d);
                }
            }

            internal static int CountP2PSeqn() {
                int cnt = 0;
                using (var tmpLockObj = new LockAndElevate(PSListLock)) {
                    foreach (KeyValuePair<Address, P2PSequencer> kvp in PSIndex) {
                        using (var tmpLockObj1 = new LockAndElevate(kvp.Value.Lock)) {
                            cnt += kvp.Value.outOfOrder.Count + kvp.Value.callbacksToDo.Count;
                        }
                    }
                }

                return cnt;
            }

            internal static LockObject CBWRLock = new LockObject("CBWRLock");

            internal static bool Active = false;

            internal static LockObject P2PCBLock = new LockObject("P2PCBLock", ThreadPriority.AboveNormal);

            internal static void P2PCBWhenReady(Address sender, Msg m, P2PCB cb) {
                using (var tmpLockObj = new LockAndElevate(Vsync.RIPLock)) {
                    if (Vsync.RIPList.Contains(sender)) {
                        if ((VsyncSystem.Debug & VsyncSystem.DISCARDS) != 0) {
                            Vsync.WriteLine("Discarding a message in P2PCBWhenReady: sender " + sender + " is on RIP list");
                        }

                        using (var tmpLockObj1 = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                            VsyncSystem.RTS.Discarded++;
                        }

                        return;
                    }
                }

                using (var tmpLockObj = new LockAndElevate(P2PCBLock)) {
                    if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.P2PLAYER)) != 0) {
                        Vsync.WriteLine("CBWhenReady called for " + m);
                    }

                    P2PSequencer p2ps;
                    using (var tmpLockObj1 = new LockAndElevate(PSListLock)) {
                        if (!P2PSequencer.PSIndex.TryGetValue(sender, out p2ps)) {
                            PSIndex.Add(sender, p2ps = new P2PSequencer(sender));
                        }
                    }

                    using (var tmpLockObj1 = new LockAndElevate(p2ps.Lock)) {
                        if (m.msgid < p2ps.inSeqn) {
                            if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.P2PLAYER | VsyncSystem.DISCARDS)) != 0) {
                                Vsync.WriteLine("CBWhenReady ignoring this message: p2ps.inSeqn was " + p2ps.inSeqn + Environment.NewLine + " --" + m);
                            }

                            using (var tmpLockObj2 = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                VsyncSystem.RTS.Discarded++;
                            }

                            return;
                        }

                        if (p2ps.outOfOrder.ContainsKey(m.msgid)) {
                            if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.P2PLAYER | VsyncSystem.DISCARDS)) != 0) {
                                Vsync.WriteLine("CBWhenReady ignoring this message: p2ps.inSeqn already lists it" + Environment.NewLine + " --" + m);
                            }

                            using (var tmpLockObj2 = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                VsyncSystem.RTS.Discarded++;
                            }

                            return;
                        }

                        if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.P2PLAYER)) != 0) {
                            Vsync.WriteLine("CBWhenReady invoked (p2p sequencer for sender " + sender + "): msgid " + m.msgid + ", p2ps.inseqn " + p2ps.inSeqn);
                        }

                        if (p2ps.outOfOrder.Count == 0) {
                            p2ps.lastCallbackTime = Vsync.NOW;
                        }

                        p2ps.outOfOrder.Add(m.msgid, new P2PCBList(m, cb));

                        // Deliver messages in order
                        KeyValuePair<int, P2PCBList> kvp;
                        while ((kvp = p2ps.outOfOrder.ElementAtOrDefault(0)).Value != null && kvp.Key - kvp.Value.theMsg.nRaw <= p2ps.inSeqn) {
                            p2ps.outOfOrder.Remove(kvp.Key);
                            if ((kvp.Value.theMsg.nRaw > 0 && kvp.Key >= p2ps.inSeqn && kvp.Key <= p2ps.inSeqn + kvp.Value.theMsg.nRaw) || kvp.Key == p2ps.inSeqn) {
                                // If it isn't a duplicate and it is in order with no gaps, deliver it
                                if (kvp.Value.theCB != null) {
                                    if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.P2PLAYER)) != 0) {
                                        Msg dqm = kvp.Value.theMsg;
                                        Vsync.WriteLine("CBWhenReady dequeue and deliver: " + dqm.sender + "::" + dqm.vid + ":" + dqm.msgid + ", p2ps.inseqn " + p2ps.inSeqn);
                                    }

                                    p2ps.callbacksToDo.Add(kvp);
                                }

                                if (kvp.Value.theMsg.nRaw > 0) {
                                    p2ps.inSeqn = kvp.Key;
                                }
                                else if (p2ps.inSeqn != kvp.Key) {
                                    throw new VsyncException("P2PS.inseqn for " + p2ps.dest + " jumped from " + p2ps.inSeqn + " to " + kvp.Key);
                                }

                                p2ps.inSeqn++;
                            }
                            else if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.P2PLAYER | VsyncSystem.DISCARDS)) != 0) {
                                Vsync.WriteLine("CBWhenReady ignoring this message: when removing it from p2p queue, noticed that p2ps.inseqn=" + p2ps.inSeqn + "but msg = " + m);
                            }
                        }

                        if (p2ps.callbacksToDo.Count == 0 && kvp.Value != null && kvp.Key > p2ps.inSeqn) {
                            for (int seqn = p2ps.inSeqn; seqn < Math.Min(p2ps.inSeqn + 2, kvp.Key); seqn++) {
                                SendP2PNack(sender, seqn);
                            }
                        }
                    }

                    if (p2ps.callbacksToDo.Count == 0) {
                        return;
                    }

                    while (true) {
                        List<KeyValuePair<int, P2PCBList>> cblist;
                        using (var tmpLockObj1 = new LockAndElevate(p2ps.Lock)) {
                            cblist = p2ps.callbacksToDo;
                            if (cblist.Count == 0) {
                                break;
                            }

                            p2ps.callbacksToDo = new List<KeyValuePair<int, P2PCBList>>();
                        }

                        foreach (KeyValuePair<int, P2PCBList> kvp in cblist) {
                            if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.P2PLAYER)) != 0) {
                                Vsync.WriteLine("CBWhenReady calling " + kvp.Value.theCB.Method.Name + " (p2p sequencer for sender " + sender + "): msgid " + kvp.Value.theMsg.vid + ":" + kvp.Value.theMsg.msgid + ", p2ps.inseqn " + p2ps.inSeqn);
                            }

                            using (var tmpLockObj1 = new LockAndElevate(p2ps.Lock)) {
                                p2ps.lastCallbackTime = Vsync.NOW;
                            }

                            kvp.Value.theCB(kvp.Value.theMsg);
                        }

                        using (var tmpLockObj1 = new LockAndElevate(p2ps.Lock)) {
                            if (p2ps.outOfOrder.Count == 0) {
                                p2ps.lastCallbackTime = 0;
                            }
                        }
                    }
                }
            }

            internal static void remoteFailed(Address who) {
                if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.P2PLAYER)) != 0) {
                    Vsync.WriteLine("remoteFailed called for " + who);
                }

                using (var tmpLockObj = new LockAndElevate(PSListLock)) {
                    PSIndex.Remove(who);
                }
            }
        }

        // This is for internal use by Msg.Send(), which is a public interface
        internal static void SendP2P(byte type, Address destProc, Group g, byte[] buffer, bool localSender) {
            SendP2P(type, destProc, g, buffer, localSender, null);
        }

        internal static void SendP2P(byte type, Address destProc, Group g, byte[] buffer, bool localSender, Action dcb) {
            if ((VsyncSystem.Debug & VsyncSystem.P2PLAYER) != 0) {
                Vsync.WriteLine("Calling SendP2P from the internal SendP2P method");
            }

            SendP2P(type, destProc, g, 0, P2PSequencer.NextP2PSeqn("sendp2p", destProc), buffer, localSender, dcb, null);
        }

        internal static byte[] QueryP2P(byte type, Address destProc, Timeout timeout, Group g, byte[] buffer) {
            return QueryP2P(type, destProc, timeout, g, 0, P2PSequencer.NextP2PSeqn("queryp2p", destProc), Msg.NEEDSREPLY, buffer);
        }

        internal static byte[] QueryP2P(byte type, Address destProc, Group g, byte[] buffer) {
            return QueryP2P(type, destProc, new Timeout(Vsync.VSYNC_DEFAULTTIMEOUT, Timeout.TO_ABORTREPLY, "QueryP2P/1"), g, 0, P2PSequencer.NextP2PSeqn("queryp2p/2", destProc), Msg.NEEDSREPLY, buffer);
        }

        internal static void SendP2P(byte type, Address destProc, Group g, int vid, int MsgID, byte[] buffer, bool localSender, Action dcb, Msg replyTo) {
            Address gaddr = (g == null) ? Vsync.NULLADDRESS : g.gaddr;
            if ((VsyncSystem.Debug & VsyncSystem.P2PLAYER) != 0) {
                Vsync.WriteLine("SendP2P: type " + type + " dest " + destProc + " group " + (g == null ? "<null>" : g.gname) + " id " + vid + ":" + MsgID);
            }

            doSend(true, my_p2psocket, g, type, destProc, Msg.NewMsgAsBArray(Vsync.my_address, gaddr, vid, MsgID, 0L, 0, 0, 0, buffer), vid, MsgID, localSender, dcb);
        }

        internal static byte[] QueryP2P(byte type, Address destProc, Group g, int vid, int MsgID, byte flags, byte[] buffer) {
            return QueryP2P(type, destProc, new Timeout(Vsync.VSYNC_DEFAULTTIMEOUT, Timeout.TO_ABORTREPLY, "QUERYP2P/2"), g, vid, MsgID, flags, buffer);
        }

        internal static byte[] QueryP2P(byte type, Address destProc, Timeout timeout, Group g, int vid, int MsgID, byte flags, byte[] buffer) {
            Address gaddr = (g == null || type == Msg.ISPUREP2P) ? Vsync.NULLADDRESS : g.gaddr;
            bool ExpectCiphered = g != null && (g.flags & Group.G_SECURE) != 0;
            if (ExpectCiphered) {
                flags |= Msg.ENCIPHEREDREPLY;
            }

            if ((VsyncSystem.Debug & (VsyncSystem.REPLYWAIT | VsyncSystem.P2PLAYER)) != 0) {
                Vsync.WriteLine("QueryP2P: Registering a wait structure... " + vid + ":" + MsgID);
            }

            AwaitReplies.ReplyInfo ri = AwaitReplies.registerP2PWait(g, vid, MsgID, ExpectCiphered, destProc, timeout.when);
            if ((VsyncSystem.Debug & (VsyncSystem.REPLYWAIT | VsyncSystem.P2PLAYER)) != 0) {
                Vsync.WriteLine("QueryP2P: Sending the query...");
            }

            doSend(true, my_p2psocket, g, type, destProc, Msg.NewMsgAsBArray(Vsync.my_address, gaddr, vid, MsgID, 0L, 0, 0, flags, buffer), vid, MsgID, true, null);
            if ((VsyncSystem.Debug & (VsyncSystem.REPLYWAIT | VsyncSystem.P2PLAYER)) != 0) {
                Vsync.WriteLine("QueryP2P: Collecting the replies...");
            }

            AwaitReplies.awaitReplies(ri, g, timeout, null);
            if ((VsyncSystem.Debug & VsyncSystem.REPLYWAIT) != 0) {
                Vsync.WriteLine("QueryP2P: Collected replies, list contains " + ri.rdvReplies.Count);
            }

            if ((g.flags & Group.G_SECURE) != 0) {
                g.DecipherReplies(ri);
            }

            if (ri.rdvReplies.Count > 0) {
                return ri.rdvReplies[0];
            }

            return new byte[0];
        }

        internal static void SendGroup(byte type, Group g, int vid, int MsgID, byte flag, byte[] buffer, int nRaw) {
            long Lid = 0;
            if (g != null) {
                Lid = g.lookupLoggingId();
            }

            doSend(false, g.my_socket, g, type, Vsync.NULLADDRESS, Msg.NewMsgAsBArray(Vsync.my_address, g.gaddr, vid, MsgID, Lid, nRaw, 0, flag, buffer), vid, MsgID, true, null);
        }

        internal static void SendGroup(byte type, Group g, Msg m, bool localSender) {
            doSend(false, g.my_socket, g, type, Vsync.NULLADDRESS, Msg.NewMsgAsBArray(m.sender, g.gaddr, m.vid, m.msgid, m.Lid, 0, 0, m.flags, m.payload), m.vid, m.msgid, localSender, null);
        }

        internal static void SendP2P(byte type, Address destProc, Group g, Msg m, bool localSender) {
            doSend(true, g.my_socket, g, type, destProc, Msg.NewMsgAsBArray(m.sender, g.gaddr, m.vid, m.msgid, m.Lid, 0, 0, m.flags, m.payload), m.vid, m.msgid, localSender, null);
        }

        internal static void Forward(Address who, Address gaddr, Msg m) {
            if (who == null || gaddr == null || m == null) {
                throw new VsyncException("Bum arg to Forward");
            }

            doSend(true, my_p2psocket, null, Msg.MULTICAST, who, m.toBArray(), m.vid, m.msgid, m.sender.isMyAddress(), null);
        }

        internal const byte ISCOMP = 0x01;

        internal const byte ISFRAG = 0x02;

        internal const byte SENTBYFRAGGER = 0x04;

        internal static void doSend(bool p2p, object s, Group g, byte type, Address dest, byte[] buffer, int vid, int MsgID, bool localSender, Action dcb) {
            if (!VsyncSystem.VsyncActive && VsyncSystem.VsyncWasActive) {
                return;
            }

            if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                using (var tmpLockObj = new LockAndElevate(ackInfoLock)) {
                    ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: doSend p2p=" + p2p + ", g=" + (g == null ? "null" : g.gname) + ", " + dest + "::" + vid + ":" + MsgID + Environment.NewLine);
                }
            }

            if (type == Msg.MULTICAST && g != null && g.HasFirstView && localSender) {
                notePendingSend(g, vid, MsgID);
            }

            if (s == null) {
                // This can happen during OOB transfer of the initial view when nodes are joining
                s = ReliableSender.my_p2psocket;
            }

            if (g != null) {
                Group.tokenInfo theToken;
                using (var tmpLockObj = new LockAndElevate(g.TokenLock)) {
                    theToken = g.theToken;
                }

                if ((type == Msg.MULTICAST || type == Msg.RAWMULTICAST || type == Msg.UNORDERED) && (g.flags & Group.G_ISLARGE) != 0 && theToken != null && !theToken.IAmLgOwner) {
                    throw new VsyncException("doSend was asked to multicast to a large group, but isn't the owner!");
                }
            }

            byte[] original_buffer = null;
            Address gaddr = (g == null || type == Msg.ISPUREP2P) ? Vsync.NULLADDRESS : g.gaddr;

            // First handle loop-back sends
            if (p2p && dest.isMyAddress()) {
                if (type != Msg.ISPING && (VsyncSystem.Debug & VsyncSystem.MESSAGELAYER) != 0) {
                    Vsync.WriteLine("[0] Loopback and return in doSend");
                }

                LoopBack(type, gaddr, Vsync.my_address, 0, new Msg(buffer));
                if (dcb != null) {
                    dcb();
                }

                if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                    using (var tmpLockObj = new LockAndElevate(ackInfoLock)) {
                        ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: doSend loopback case" + Environment.NewLine);
                    }
                }

                return;
            }

            if (!p2p && g != null && g.theView != null && g.theView.GetMyRank() != -1) {
                original_buffer = buffer;
            }

            // Now send to remote destinations, if there were some
            byte mode = 0;
            byte[] bufferAsGiven = null;
            if (buffer.Length > Vsync.VSYNC_MAXMSGLEN) {
                byte[] bc;
                if (!Vsync.VSYNC_DONT_COMPRESS && (bc = Compress(buffer)) != null) {
                    bufferAsGiven = buffer;
                    buffer = bc;
                    mode |= ISCOMP;
                }
            }

            socketSend(p2p, s, dest, g, type, mode, buffer, bufferAsGiven, vid, MsgID, localSender, dcb);
            if (original_buffer != null) {
                if (type != Msg.ISPING && (VsyncSystem.Debug & VsyncSystem.MESSAGELAYER) != 0) {
                    Vsync.WriteLine("[2] Loopback and return in doSend");
                }

                LoopBack(type, gaddr, Vsync.my_address, 0, new Msg(original_buffer));
                if (dcb != null) {
                    dcb();
                }
            }

            if (type != Msg.ISPING && (VsyncSystem.Debug & VsyncSystem.MESSAGELAYER) != 0) {
                Vsync.WriteLine("finished in doSend");
            }
        }

        internal static bool doSendStability(Group g) {
            if ((g.flags & Group.G_ISLARGE) != 0 || !g.HasFirstView) {
                return true;
            }

            using (var tmpLockObj = new LockAndElevate(g.GroupFlagsLock)) {
                if ((g.flags & Group.G_SENDINGSTABILITY) != 0 || (Vsync.NOW - g.SentStableAt) < 100) {
                    return false;
                }

                g.flags |= Group.G_SENDINGSTABILITY;
            }

            MCMDSocket s = g.my_socket;
            if ((g.GroupOpen || !g.WasOpen) && s != null) {
                View v;
                using (var tmpLockObj = new LockAndElevate(g.ViewLock)) {
                    v = g.theView;
                }

                byte[] mba = Msg.NewMsgAsBArray(Vsync.my_address, g.gaddr, 0, -1, 0L, 0, 0, 0, new byte[0]);
                using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                    VsyncSystem.RTS.StabilitySent++;
                }

                if (!Vsync.VSYNC_UNICAST_ONLY) {
                    socketSend(false, s, g.gaddr, g, Msg.STABILITYINFO, 0, mba, null, 0, -1, true, null);
                }
                else {
                    foreach (Address dest in v.members) {
                        if (!dest.isMyAddress()) {
                            socketSend(true, my_p2psocket, dest, g, Msg.STABILITYINFO, 0, mba, null, 0, -1, true, null);
                        }
                    }
                }

                using (var tmpLockObj = new LockAndElevate(g.GroupFlagsLock)) {
                    g.flags &= ~Group.G_SENDINGSTABILITY;
                    g.CurrentBacklog = 0;
                }
            }
            return true;
        }

        internal class ssInfo {
            internal Address dest;

            internal Group g;

            internal int vid;

            internal int msgid;

            internal ssInfo(Address d, Group gr, int v, int m) {
                this.dest = d;
                this.g = gr;
                this.vid = v;
                this.msgid = m;
            }
        }

        internal static int Counter;

        internal static void socketSend(bool p2p, object os, Address dest, Group g, byte type, byte code, byte[] originalBuffer, byte[] bufferAsGiven, int vid, int MsgID, bool localSender, Action dcb) {
            bool isGroupAddress = (type == Msg.MULTICAST || type == Msg.RAWMULTICAST || type == Msg.UNORDERED) && (Group.doLookup(dest) != null || Group.TrackingProxyLookup(dest) != null);
            if (isGroupAddress && g != null) {
                g.LastSendAt = Vsync.NOW;
            }

            if (os == null) {
                throw new VsyncException("null socket in Vsync socketSend");
            }

            Type sType = os.GetType();
            Address gaddr;
            int minStable = -1;
            if (g == null || type == Msg.ISPUREP2P) {
                gaddr = Vsync.NULLADDRESS;
            }
            else {
                gaddr = g.gaddr;
                if (g.HasFirstView) {
                    // Reliable FIFO multicast carries stability to all members...
                    using (var tmpLockObj = new LockAndElevate(g.ViewLock)) {
                        if (g.theView.viewid == vid || type == Msg.STABILITYINFO) {
                            minStable = g.theView.minStable;
                            vid = g.theView.viewid;
                            if (minStable != -1 && (type == Msg.MULTICAST || type == Msg.STABILITYINFO)) {
                                g.theView.lastStabilitySent = minStable;
                                g.SentStableAt = Vsync.NOW;
                            }
                        }
                    }
                }
            }

            if (type == Msg.STABILITYINFO && minStable == -1) {
                return;
            }

            int myCounter;

            using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                myCounter = ++Counter;
            }

            if (g != null) {
                using (var tmpLockObj = new LockAndElevate(g.SIFListLock)) {
                    if (g.SIFList != null) {
                        g.SIFList.Add(new[] { p2p, os, dest, g, type, code, originalBuffer, vid, MsgID, localSender, dcb, isGroupAddress, sType, gaddr, minStable, myCounter });
                        return;
                    }
                }
            }

            if (originalBuffer.Length > Vsync.VSYNC_MUSTFRAGMENT && (code & SENTBYFRAGGER) == 0) {
                if (!Vsync.BigTimeouts && originalBuffer.Length > 500000) {
                    Vsync.BigTimeouts = true;
                    Vsync.VSYNC_DEFAULTTIMEOUT = Vsync.VSYNC_DEFAULTTIMEOUT * 2;
                }

                if (p2p && !localSender) {
                    throw new VsyncException("Calling SendInFrags for a non-local p2p message");
                }

                if (g != null) {
                    using (var tmpLockObj = new LockAndElevate(g.SIFListLock)) {
                        if (g.SIFList != null) {
                            throw new VsyncException("SIFList should be null");
                        }

                        g.SIFList = new List<object[]>();
                    }
                }

                originalBuffer = Group.SendInFrags(p2p, type == Msg.RAWMULTICAST || type == Msg.ISRAWGRPP2P || type == Msg.ISRAWREPLY, dest, g, originalBuffer, bufferAsGiven);
                code |= ISFRAG;
                if (g != null) {
                    List<object[]> toSend;
                    using (var tmpLockObj = new LockAndElevate(g.SIFListLock)) {
                        g.SIFList.Add(new[] { p2p, os, dest, g, type, code, originalBuffer, vid, MsgID, localSender, dcb, isGroupAddress, sType, gaddr, minStable, myCounter });
                        toSend = g.SIFList;
                        g.SIFList = null;
                    }

                    // Send the SIFList fragments without SIFLock
                    new Thread(() => {
                        try {
                            foreach (object[] obs in toSend) {
                                // doSend(p2p, os, dest, g, type, code, originalBuffer, vid, MsgID, localSender, dcb, isGroupAddress, sType, gaddr, minStable, myCounter)
                                socketSendAction((bool)obs[0], obs[1], (Address)obs[2], (Group)obs[3], (byte)obs[4], (byte)obs[5], (byte[])obs[6], (int)obs[7], (int)obs[8], (bool)obs[9], (Action)obs[10], (bool)obs[11], (Type)obs[12], (Address)obs[13], (int)obs[14], (int)obs[15]);
                            }
                        }
                        catch (VsyncShutdownException) {
                            VsyncSystem.CheckLocksHeld();
                        }

                        VsyncSystem.ThreadTerminationMagic();
                    }) { Name = "<" + g.gname + "> SIFList sender", IsBackground = true }.Start();
                    return;
                }
            }

            socketSendAction(p2p, os, dest, g, type, code, originalBuffer, vid, MsgID, localSender, dcb, isGroupAddress, sType, gaddr, minStable, myCounter);
        }

        private static void socketSendAction(bool p2p, object os, Address dest, Group g, byte type, byte code, byte[] originalBuffer, int vid, int MsgID, bool localSender, Action dcb, bool isGroupAddress, Type sType, Address gaddr, int minStable, int myCounter) {
            if (!dest.isGroupAddress() && !dest.isNull()) {
                p2p = true;
            }

            int mbl = FlowControl.Backlog(g);
            if (g != null) {
                g.PreviousBacklog = mbl;
            }

            byte[] buffer = Msg.toBArray(type, code, myCounter, Vsync.my_address, dest, gaddr, minStable, mbl, originalBuffer);
            if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                using (var tmpLockObj = new LockAndElevate(ackInfoLock)) {
                    ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: socketSend " + ((vid != 0 || MsgID != -1) ? " calling " : " skipping ") + " remember for " + dest + "::" + vid + ":" + MsgID + Environment.NewLine);
                }
            }

            if ((vid != 0 || MsgID != -1) && type != Msg.ISRAWGRPP2P && type != Msg.ISRAWREPLY && type != Msg.RAWMULTICAST) {
                Remember(p2p, dest, g, type, code, buffer, vid, MsgID, localSender, isGroupAddress, myCounter, dcb);
            }

            if (type != Msg.ISPING && (VsyncSystem.Debug & VsyncSystem.MESSAGELAYER) != 0) {
                Vsync.WriteLine("Send preparing to " + (p2p ? "send pt-to-pt" : "multicast") + " outgoming msg: type " + type + ", seqn" + myCounter + ", sender " + Vsync.my_address + ", dest " + dest + ", gaddr " + gaddr + ", minStable " + minStable + ", buffer len " + buffer.Length);
            }

            if (dest != null && (dest.isMyAddress() || (!p2p && Group.doLookup(dest) != null))) {
                // Loop a copy back to myself because the ReliableSender ignores messages from me to me.  Lacking this,
                // if the SendTo fails at the sender side, the message won't loop back and the system will hang
                AddToReceiveBB(buffer, false);
            }

            if ((type != Msg.MULTICAST && type != Msg.RAWMULTICAST && type != Msg.UNORDERED) || p2p) {
                if (p2p && isGroupAddress) {
                    throw new VsyncException("Using UNICAST logic to send a multicast to group " + dest + " but should have been a member of that group! (p2p=true, type=" + type + ", group by name=<" + g.gname + ">");
                }

                if (!dest.isMyAddress()) {
                    IPEndPoint remoteEP = new IPEndPoint(dest.home, dest.p2pPort);
                    try {
                        if (os.GetType() == typeof(Socket)) {
                            int bs;
                            ReliableSender.CheckLenAndRate(buffer);
                            if (!Vsync.VSYNC_INFINIBAND || (bs = IB.ib_send(RECVBB, dest, buffer)) == -1) {
                                bs = ((Socket)os).SendTo(buffer, remoteEP);
                            }

                            if (bs == 0) {
                                Vsync.WriteLine("WARNING: Vsync/SocketSend SendTo returned bs=0");
                            }

                            if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                                using (var tmpLockObj = new LockAndElevate(ackInfoLock)) {
                                    ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: Primary Send to " + remoteEP + " for " + dest + Environment.NewLine);
                                }
                            }

                            if (os != my_acksocket) {
                                using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                    VsyncSystem.RTS.UDPBsent += bs;
                                    VsyncSystem.RTS.UDPsent++;
                                }
                            }
                        }
                        else if (!Vsync.VSYNC_UNICAST_ONLY && !((MCMDSocket)os).UseUnicast()) {
                            ((MCMDSocket)os).SendTo(buffer);
                        }
                        else {
                            if (!g.HasFirstView) {
                                return;
                            }

                            Multicast(g, buffer);
                        }
                    }
                    catch (Exception) {
                    }
                }

                return;
            }

            if ((VsyncSystem.Debug & VsyncSystem.MESSAGELAYER) != 0) {
                Vsync.WriteLine("SocketSend CAST: " + buffer.Length + " bytes");
            }

            int lcount = 0;
            bool again = true;
            while (again) {
                again = false;
                if (!Vsync.VSYNC_UNICAST_ONLY && (sType != typeof(MCMDSocket) || !((MCMDSocket)os).UseUnicast()) && g != null && g.myPhysIPAddr != MCMDSocket.USEUNICAST) {
                    if (sType == typeof(Socket)) {
                        ReliableSender.CheckLenAndRate(buffer);
                        int bs;
                        if (!Vsync.VSYNC_INFINIBAND || (bs = IB.ib_send(RECVBB, dest, buffer)) == -1) {
                            bs = ((Socket)os).SendTo(buffer, g.my_socket.GetRemoteEP());
                        }

                        if (os != my_acksocket) {
                            using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                VsyncSystem.RTS.UDPBsent += bs;
                                VsyncSystem.RTS.UDPsent++;
                            }
                        }
                    }
                    else {
                        try {
                            // Could throw an MCMD exception if we switch to Unicast mode just at this instant
                            ((MCMDSocket)os).SendTo(buffer);
                        }
                        catch (MCMDException e) {
                            if (lcount++ == 0) {
                                again = true;
                                continue;
                            }

                            throw new VsyncException("Stuck looping on UseUnicast", e);
                        }
                    }
                }
                else if (g.gname.Equals("ORACLE", StringComparison.Ordinal) && !g.HasFirstView && Vsync.VSYNC_HOSTS_IPADDRS != null) {
                    if (Vsync.VSYNC_HOSTS_IPADDRS == null) {
                        throw new VsyncException("Unable to contact ORACLE: In USEUNICAST/TCP_ONLY mode, VSYNC_HOSTS must list locations where ORACLE servers are running");
                    }

                    // Boostrap via p2p rendezvous with the hosts in VSYNC_HOSTS
                    foreach (IPAddress ipa in Vsync.VSYNC_HOSTS_IPADDRS) {
                        IPEndPoint remoteEP;
                        if (Vsync.VSYNC_UNICAST_ONLY) {
                            remoteEP = new IPEndPoint(ipa, Vsync.VSYNC_DEFAULT_PORTNOp);
                        }
                        else {
                            remoteEP = MCMDSocket.GetIPEndPoint(ipa);
                        }

                        ReliableSender.CheckLenAndRate(buffer);
                        int bs;
                        if (!Vsync.VSYNC_INFINIBAND || (bs = IB.ib_send(RECVBB, dest, buffer)) == -1) {
                            try {
                                bs = my_p2psocket.SendTo(buffer, remoteEP);
                            }
                            catch (SocketException) {
                                throw new VsyncException("Unable to connect to VSYNC_HOSTS={" + Vsync.VSYNC_HOSTS + "}");
                            }
                        }

                        using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                            VsyncSystem.RTS.UDPBsent += bs;
                            VsyncSystem.RTS.UDPsent++;
                        }
                    }
                }
                else {
                    if (!g.HasFirstView) {
                        return;
                    }

                    Multicast(g, buffer);
                }
            }
        }

        internal static void AddToReceiveBB(byte[] buffer, bool nonBlocking) {
            RecvBB.put(buffer, nonBlocking);
        }

        internal static void Multicast(Group g, byte[] buffer) {
            View theView;
            using (var tmpLockObj = new LockAndElevate(g.ViewLock)) {
                theView = g.theView;
            }

            if (theView.members.Length > Vsync.VSYNC_MAXDIRECTSENDS) {
                Vsync.VSYNCMEMBERS.IPMCTunnel(g.gaddr, buffer);
                return;
            }

            try {
                foreach (Address dest in theView.members) {
                    if (dest.isMyAddress()) {
                        continue;
                    }

                    IPEndPoint remoteEP = new IPEndPoint(dest.home, dest.p2pPort);
                    ReliableSender.CheckLenAndRate(buffer);
                    int bs;
                    if (!Vsync.VSYNC_INFINIBAND || (bs = IB.ib_send(RECVBB, dest, buffer)) == -1) {
                        bs = my_p2psocket.SendTo(buffer, remoteEP);
                    }

                    using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                        VsyncSystem.RTS.UDPBsent += bs;
                        VsyncSystem.RTS.UDPsent++;
                    }
                }
            }
            catch (SocketException) {
            }
            catch (ObjectDisposedException) {
            }
        }

        private static void Remember(bool p2p, Address dest, Group g, byte type, byte code, byte[] buffer, int vid, int MsgID, bool localSender, bool isGroupAddress, int UID, Action dcb) {
            activeMsg am = null;
            if (dest.isMyAddress() || (p2p && !localSender)) {
                return;
            }

            if (localSender && g != null && (g.flags & Group.G_ISLARGE) != 0) {
                am = new activeMsg(g, vid, MsgID);
            }

            int cnt = 0;
            using (var tmpLockObj = new LockAndElevate(Group.GroupRIPLock)) {
                if ((!p2p && g != null && Group.GroupRIPList.Contains(g.gaddr)) || (isGroupAddress && Group.GroupRIPList.Contains(dest))) {
                    return;
                }
            }

            while (g != null && !p2p && !g.HasFirstView) {
                Vsync.Sleep(1000);
                if (++cnt == 60) {
                    throw new VsyncException("Remember: group <" + g.gname + "> lacks first view");
                }
            }

            if (g != null && !g.GroupOpen && (!p2p || !localSender)) {
                return;
            }

            int rtdelay = 250;
            if ((code & ISFRAG) != 0) {
                rtdelay += (int)(5 * (buffer.Length / Vsync.VSYNC_FRAGLEN));
            }

            if (p2p) {
                using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                    if (dest != null && !isGroupAddress) {
                        using (var tmpLockObj1 = new LockAndElevate(Vsync.RIPLock)) {
                            if (!Vsync.RIPList.Contains(dest)) {
                                if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                                    using (var tmpLockObj2 = new LockAndElevate(ackInfoLock)) {
                                        ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: Remember appending to P2PPendingSendBuffer " + dest + "::" + vid + ":" + MsgID + Environment.NewLine);
                                    }
                                }

                                LinkedListNode<MsgDesc> mdnode = P2PPendingSendBuffer.Last;
                                while (mdnode != null && mdnode.Value.UID > UID) {
                                    mdnode = mdnode.Previous;
                                }

                                MsgDesc md = new MsgDesc(type, Vsync.VSYNC_MAXRETRIES, null, dest, true, false, UID, buffer, vid, MsgID, rtdelay, 1, 1, localSender, dcb, am);
                                if (am != null) {
                                    am.SentCnt++;
                                }

                                if (mdnode != null) {
                                    P2PPendingSendBuffer.AddAfter(mdnode, md);
                                }
                                else {
                                    P2PPendingSendBuffer.AddFirst(md);
                                }

                                dcb = null;
                            }
                        }
                    }
                }

                if (dcb != null) {
                    dcb();
                }

                if (am != null) {
                    using (var tmpLockObj = new LockAndElevate(activeMsgLock)) {
                        activeMsgs.Add(am);
                    }
                }

                if (!dest.isNull()) {
                    using (var tmpLockObj = new LockAndElevate(P2PSequencer.PSListLock)) {
                        P2PSequencer p2ps;
                        if (P2PSequencer.PSIndex.TryGetValue(dest, out p2ps)) {
                            p2ps.nonrawSeqn = p2ps.outSeqn;
                        }
                    }
                }

                return;
            }

            if (g == null) {
                if (!p2p) {
                    throw new VsyncException("Remember: g=null but !p2p");
                }

                if (dcb != null) {
                    dcb();
                }

                return;
            }

            View v = g.theView;
            if ((g.flags & Group.G_ISLARGE) != 0) {
                using (var tmpLockObj = new LockAndElevate(Group.GroupRIPLock)) {
                    if (Group.GroupRIPList.Contains(g.gaddr)) {
                        return;
                    }
                }

                if (type == Msg.MULTICAST || type == Msg.RAWMULTICAST || type == Msg.UNORDERED) {
                    if ((VsyncSystem.Debug & (VsyncSystem.TOKENLOGIC | VsyncSystem.FLUSHING)) != 0) {
                        Vsync.WriteLine("Add to LgPending Send Buffer: msgid=" + MsgID);
                    }

                    using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                        if (g.GroupOpen || !g.WasOpen) {
                            LgPendingSendBuffer.AddLast(new MsgDesc(type, 5, g, g.gaddr, false, true, MsgID, buffer, vid, MsgID, rtdelay * 10, 1, 5, localSender, dcb, am));
                        }
                    }

                    if ((VsyncSystem.Debug & VsyncSystem.TOKENSTABILITY) != 0) {
                        Vsync.WriteLine("large-group remember ADDED to lgPendingSendQueue: " + (p2p ? "p2p" : "multicast") + " is of type=" + type + ", group=<" + g.gname + ">, MsgID=" + MsgID + ", rtdelay=" + (rtdelay * 3));
                    }

                    return;
                }

                if (dcb != null) {
                    dcb();
                }

                if ((VsyncSystem.Debug & VsyncSystem.TOKENSTABILITY) != 0) {
                    Vsync.WriteLine("large-group remember DIDN'T ADD to lgPendingSendQueue: " + (p2p ? "p2p" : "multicast") + " is of type=" + type + ", group=<" + g.gname + ">, MsgID=" + MsgID + ", rtdelay=" + (rtdelay * 3));
                }

                return;
            }

            if ((VsyncSystem.Debug & VsyncSystem.MESSAGELAYER) != 0) {
                Vsync.WriteLine("PendingSendBuffer.Add: sender=" + Vsync.my_address + ", msgid=" + vid + ":" + MsgID + ", ACKID " + UID + ", theView.vid=" + v.viewid + ", dests=" + Address.VectorToString(v.members));
            }

            Address[] dests = v.members;
            using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                LinkedListNode<MsgDesc> mdnode = PendingSendBuffer.Last;
                while (mdnode != null && mdnode.Value.UID > UID) {
                    mdnode = mdnode.Previous;
                }

                using (var tmpLockObj1 = new LockAndElevate(Vsync.RIPLock)) {
                    for (int i = 0; i < dests.Length; i++) {
                        Address d = dests[i];
                        if (d.isMyAddress() || v.hasFailed[i]) {
                            continue;
                        }

                        bool seemsHealthy = !Vsync.RIPList.Contains(dest);
                        if (seemsHealthy) {
                            if (!Vsync.RIPList.Contains(d)) {
                                MsgDesc md = new MsgDesc(type, Vsync.VSYNC_MAXRETRIES, g, d, false, false, UID, buffer, vid, MsgID, 250, 1, dests.Length, localSender, dcb, am);
                                if (am != null) {
                                    am.SentCnt++;
                                }

                                if (mdnode != null) {
                                    PendingSendBuffer.AddAfter(mdnode, md);
                                }
                                else {
                                    PendingSendBuffer.AddFirst(md);
                                }
                            }
                            else if (dcb != null) {
                                dcb();
                            }
                        }
                    }
                }
            }

            if (am != null) {
                using (var tmpLockObj = new LockAndElevate(activeMsgLock)) {
                    activeMsgs.Add(am);
                }
            }
        }

        /*private static void TunnelMsg(bool p2p, Address dest, byte[] buffer, Address gaddr)
        {
            if ((VsyncSystem.Debug & VsyncSystem.TUNNELING) != 0)
            {
                Vsync.WriteLine(
                    "TunnelMsg: p2p=" + p2p + ", dest=" + dest + ", gaddr=" + gaddr + ", buffer length = "
                    + buffer.Length);
            }

            if (p2p)
            {
                if (dest.isMyAddress())
                {
                    ReliableSender.AddToReceiveBB(buffer, true);
                    return;
                }
            }

            if (Vsync.VSYNCMEMBERS == null)
            {
                // Only happens for the very first few seconds during startup, just drop the message
                return;
            }

            if (p2p)
            {
                Vsync.VSYNCMEMBERS.UDPTunnel(dest, buffer, 0);
            }
            else
            {
                Vsync.VSYNCMEMBERS.IPMCTunnel(gaddr, buffer);
            }
        }*/

        private delegate void RDel(byte type, byte code, int seqn, Address sender, Address dest, Address gaddr, int minStable, int myBacklog, byte[] buf);

        internal static bool recieverRunning = false;

        internal static void SReceive(object os) {
            while (!VsyncSystem.VsyncActive) {
                Vsync.Sleep(250);
            }

            if (!recieverRunning) {
                recieverRunning = true;
                RecvBB = new BoundedBuffer("BB:P2P", 1024, ILock.LLP2PB, 0, 1);
                new Thread(() => {
                    while (VsyncSystem.VsyncActive) {
                        VsyncSystem.RTS.ThreadCntrs[21]++;
                        try {
                            ILock.NoteThreadState("P2P.Receive");
                            byte[] buffer = RecieveOne(os);
                            AddToReceiveBB(buffer, true);
                        }
                        catch (VsyncShutdownException) {
                            VsyncSystem.CheckLocksHeld();
                        }
                        catch (Exception e) {
                            if (VsyncSystem.VsyncActive) {
                                throw new VsyncException("Dedicated receiver thread threw Exception: " + e.Message, e);
                            }
                        }
                        finally {
                            ILock.NoteThreadState(null);
                        }
                    }

                    VsyncSystem.ThreadTerminationMagic();
                }) { Name = "Dedicated P2P receiver thread", Priority = ThreadPriority.Highest, IsBackground = true }.Start();
            }

            doReceive(os, null);
        }

        // Sorry about the slightly tortured control flow here.  Added this dedicated high-speed receive thread for the p2p socket
        // and the AckSocket when we saw a few cases of severe packet loss associated with minor scheduling delays.  
        private static byte[] RecieveOne(object os) {
            byte[] buffer = new byte[Vsync.VSYNC_MAXMSGLEN + 1024];
            int len;
            do {
                try {
                    len = ((Socket)os).Receive(buffer);
                }
                catch (SocketException) {
                    len = 0;
                }
                catch (IOException) {
                    len = 0;
                }

                VsyncSystem.RTS.ThreadCntrs[30]++;
            }
            while (!Msg.VerifySignature(buffer, 0, len));
            VsyncSystem.RTS.ThreadCntrs[31]++;

            using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                VsyncSystem.RTS.UDPrcvd++;
                VsyncSystem.RTS.UDPBrcvd += len;
            }

            VsyncSystem.RTS.check();
            if (len > Vsync.VSYNC_MAXMSGLEN) {
                Vsync.WriteLine("WARNING(a): MAXMSGLEN set to " + Vsync.VSYNC_MAXMSGLEN + ", but received length=" + len);
            }

            if (len != Vsync.VSYNC_MAXMSGLEN) {
                Vsync.ArrayResize(ref buffer, len);
            }

            if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                using (var tmpLockObj = new LockAndElevate(ackInfoLock)) {
                    IPEndPoint remoteEP = new IPEndPoint(Vsync.my_address.home, Vsync.my_address.p2pPort);
                    ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: Receive(" + (((Socket)os == my_p2psocket) ? "p2p-socket" : "group-socket") + "): my IP " + remoteEP + " my addr " + Vsync.my_address + Environment.NewLine);
                }
            }

            return buffer;
        }

        internal static void Receive(Group g) {
            doReceive(g.my_socket, g);
        }

        internal static BoundedBuffer RecvBB;

        internal static void TCPTunnelSetup() {
            RecvBB = new BoundedBuffer("TCP:P2P", 1024, ILock.LLP2PB, 0, 1);
            AckBB = new BoundedBuffer("TCP:Ack", 128, ILock.LLACKB, 0, 1);
        }

        internal class MReplayMe {
            internal byte type;

            internal Address sender;

            internal Address gaddr;

            internal int minStable;

            internal Msg msg;

            internal MReplayMe(byte t, Address s, Address g, int ms, Msg m) {
                this.type = t;
                this.sender = s;
                this.gaddr = g;
                this.minStable = ms;
                this.msg = m;
            }
        }

        internal static void doReceive(object os, Group g) {
            byte[] buffer;
            Vsync.receiveThread = Thread.CurrentThread;
            if (g == null) {
                using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                    VsyncSystem.RTS.rcvProcessingBeganAt = 0;
                }
            }

            if (os.GetType() == typeof(Socket)) {
                if (os == my_p2psocket) {
                    buffer = (byte[])RecvBB.get();
                }
                else {
                    buffer = RecieveOne(os);
                }

                if (buffer == null || (!VsyncSystem.VsyncActive && VsyncSystem.VsyncWasActive)) {
                    return;
                }
            }
            else if ((buffer = ((MCMDSocket)os).Receive()) == null) {
                if (g == null) {
                    using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                        VsyncSystem.RTS.rcvProcessingBeganAt = 0;
                    }
                }

                Vsync.Sleep(20);
                return;
            }

            if (g == null) {
                using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                    if (VsyncSystem.RTS.rcvProcessingBeganAt != 0) {
                        throw new VsyncException("Receive thread: more than one caller has g=null");
                    }

                    VsyncSystem.RTS.rcvProcessingBeganAt = Vsync.NOW;
                }
            }

            // buffer = Msg.toBArray(type, code, myCounter, Vsync.my_address, dest, gaddr, minStable, myBacklog, buffer);
            try {
                long before = Vsync.NOW;
                Msg.InvokeFromBArray(buffer, new RDel((type, code, UID, sender, dest, gaddr, minStable, remoteBacklog, buf) => {
                    // Vsync.WriteLine("RecvBB.Get: type=" + type + ", code=" + code + ", UID=" + UID + ", sender=" + sender + ", dest=" + dest + ", gaddr=" + gaddr + " minStable=" + minStable + ", remoteBacklog=" + remoteBacklog + ", buf.len=" + buf.Length);
                    ReliableSender.noteRemoteBacklog(sender, remoteBacklog);
                    if (sender == null || dest == null || gaddr == null || buf == null || (g != null && !g.GroupOpen && g.WasOpen)) {
                        using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                            VsyncSystem.RTS.Discarded++;
                            if (g == null) {
                                VsyncSystem.RTS.rcvProcessingBeganAt = 0;
                            }
                        }

                        if (g != null && (g.GroupOpen || !g.WasOpen)) {
                            SendAck(g, sender, UID);
                        }

                        return;
                    }

                    if (type != Msg.ISPING) {
                        if ((VsyncSystem.Debug & VsyncSystem.MESSAGELAYER) != 0) {
                            Vsync.WriteLine("Receive successfully parsed incoming msg (phys len " + buffer.Length + "): type " + type + ", seqn" + UID + ", sender " + sender + ", dest " + dest + ", gaddr " + gaddr + ", buffer len " + buf.Length);
                        }
                    }

                    bool fnd = false;
                    using (var tmpLockObj = new LockAndElevate(Vsync.RIPLock)) {
                        if (Vsync.RIPList != null && Vsync.RIPList.Contains(sender)) {
                            fnd = true;
                        }
                    }

                    if (fnd) {
                        SendPoison(sender, Vsync.my_address + " found you on the recently deceased process list");
                        return;
                    }

                    justHeardFrom(sender);
                    if ((code & (ISCOMP | ISFRAG)) == ISCOMP) {
                        buf = DeCompress(buf);
                    }

                    Msg m = new Msg(buf);
                    if ((m.flags & Msg.CIPHER) != 0) {
                        if (g != null && (g.flags & Group.G_SECURE) != 0 && (type == Msg.ISGRPP2P || type == Msg.ISRAWGRPP2P || type == Msg.MULTICAST || type == Msg.UNORDERED)) {
                            g.decipherMsg(m);
                        }
                        else {
                            using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                VsyncSystem.RTS.Discarded++;
                                if (g == null) {
                                    VsyncSystem.RTS.rcvProcessingBeganAt = 0;
                                }
                            }

                            return;
                        }
                    }

                    if (m.sender == sender) {
                        // Need to be careful here: sometimes a message shows up via a relay through some other source.  It would use its own (sender,UID) when sending to us.
                        // Idea, though, is that upon "original receipt" we note the UID the sender used, and then we can later forward this with the UID pre-filled in (the sender
                        // itself won't do so because it picks the UID only after creating the out-form byte[] representation).  Then can use it to ack to the sender as a way to
                        // let it know that yes, I do have his message x:y with UID abc.... 
                        m.UID = UID;
                    }

                    if ((code & ISFRAG) != 0) {
                        m.flags |= Msg.FRAGGED;
                    }

                    List<MReplayMe> mae = (g == null) ? null : g.MsgArrivedEarly;
                    m.offWire = buffer;
                    if (g == null && VsyncSystem.RTS.rcvProcessingBeganAt > 0 && (Vsync.NOW - VsyncSystem.RTS.rcvProcessingBeganAt) > 2500) {
                        Vsync.WriteLine("WARNING: In receive thread needed " + (Vsync.NOW - VsyncSystem.RTS.rcvProcessingBeganAt) + " ms to extract message!");
                    }

                    if (GotIncoming(type, gaddr, sender, minStable, m, g == null)) {
                        if (type != Msg.ISRAWGRPP2P && type != Msg.ISRAWREPLY && type != Msg.RAWMULTICAST) {
                            // Ack unless it was discarded
                            if (g == null) {
                                using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                    VsyncSystem.RTS.rcvProcessingBeganAt = 0;
                                }
                            }

                            if (sender.isMyAddress()) {
                                GotAnAck(sender, UID);
                            }
                            else {
                                if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                                    using (var tmpLockObj = new LockAndElevate(ackInfoLock)) {
                                        ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: Send Ack " + sender + "::" + m.vid + ":" + m.msgid + " -- UID " + UID + ", type=" + type + Environment.NewLine);
                                    }
                                }

                                SendAck(g, sender, UID);
                            }
                        }
                    }
                    else {
                        if (g == null) {
                            using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                VsyncSystem.RTS.rcvProcessingBeganAt = 0;
                            }
                        }

                        if (mae != null) {
                            mae.Add(new MReplayMe(type, sender, gaddr, minStable, m));
                        }
                    }

                    if ((VsyncSystem.Debug & VsyncSystem.DELAYS) != 0 && g == null && VsyncSystem.RTS.rcvProcessingBeganAt > 0 && (Vsync.NOW - VsyncSystem.RTS.rcvProcessingBeganAt) > 5000) {
                        Vsync.WriteLine("WARNING: In receive thread needed " + (Vsync.NOW - VsyncSystem.RTS.rcvProcessingBeganAt) + " ms to extract message!");
                    }
                }));
                if (g == null) {
                    using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                        VsyncSystem.RTS.rcvProcessingBeganAt = 0;
                    }
                }

                if ((VsyncSystem.Debug & VsyncSystem.DELAYS) != 0 && (Vsync.NOW - before) > 500) {
                    Vsync.WriteLine("WARNING: LONG DELAY while processing an incoming message (" + (Vsync.NOW - before) + "ms)");
                }
            }
            catch (VsyncException) {
                if ((VsyncSystem.Debug & VsyncSystem.DISCARDS) != 0) {
                    Vsync.WriteLine("Instantly discarding an incoming multicast: misformatted");
                }

                using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                    VsyncSystem.RTS.Discarded++;
                    VsyncSystem.RTS.rcvProcessingBeganAt = 0;
                }

                Vsync.Sleep(20);
            }
        }

        internal class LoopBackInf {
            internal byte lbtype;

            internal Address lbgaddr;

            internal Address lbsender;

            internal int lbminStable;

            internal Msg lbMsg;

            internal LoopBackInf(byte type, Address gaddr, Address sender, int minStable, Msg m) {
                this.lbtype = type;
                this.lbgaddr = gaddr;
                this.lbsender = sender;
                this.lbminStable = minStable;
                this.lbMsg = m;
            }
        }

        internal static Thread lbThread;

        internal static BoundedBuffer lbBB;

        internal static LockObject lbBufferLock = new LockObject("lbBufferLock", ThreadPriority.Highest);

        internal static void LoopBack(byte type, Address gaddr, Address sender, int minStable, Msg m) {
            if ((VsyncSystem.Debug & VsyncSystem.LOOPBACK) != 0) {
                Vsync.WriteLine("LoopBack: type=" + type + ", gaddr=" + gaddr + ", " + sender + "::" + m.vid + ":" + m.msgid + ", minStable=" + minStable + Environment.NewLine + "  " + m);
            }

            using (var tmpLockObj = new LockAndElevate(lbBufferLock)) {
                if (lbThread == null) {
                    lbBB = new BoundedBuffer("Loopback", 1024, ILock.LLLB, -1, -1);
                    lbThread = new Thread(() => {
                        try {
                            while (VsyncSystem.VsyncActive || !VsyncSystem.VsyncWasActive) {
                                VsyncSystem.RTS.ThreadCntrs[22]++;
                                LoopBackInf lbi = (LoopBackInf)lbBB.get();
                                if (lbi == null) {
                                    break;
                                }

                                if ((VsyncSystem.Debug & VsyncSystem.LOOPBACK) != 0) {
                                    Vsync.WriteLine("LoopBack calling GotIncoming: type=" + lbi.lbtype + ", sender=" + lbi.lbsender + ", minStable=" + lbi.lbminStable + ":  " + lbi.lbMsg);
                                }

                                GotIncoming(lbi.lbtype, lbi.lbgaddr, lbi.lbsender, lbi.lbminStable, lbi.lbMsg, false);
                            }
                        }
                        catch (VsyncShutdownException) {
                            VsyncSystem.CheckLocksHeld();
                        }

                        VsyncSystem.ThreadTerminationMagic();
                    }) { Name = "Loopback thread", Priority = ThreadPriority.AboveNormal, IsBackground = true };
                    lbThread.Start();
                }
            }

            lbBB.put(new LoopBackInf(type, gaddr, sender, minStable, m));
        }

        internal static int LBBcnt() {
            return BoundedBuffer.FullSlots(lbBB);
        }

        internal static bool GotIncoming(byte type, Address gaddr, Address sender, int minStable, Msg m, bool trackEvents) {
            if ((type == Msg.MULTICAST || type == Msg.UNORDERED) && gaddr.isNull()) {
                gaddr = m.dest;
            }

            Group g = Group.doLookup(gaddr);
            if (g == null || (g.flags & Group.G_ISLARGE) == 0) {
                m.offWire = null;
            }

            return doGotIncoming(type, gaddr, sender, minStable, m, g, trackEvents);
        }

        internal static LockObject workersLock = new LockObject("workersLock");

        internal static List<Address> knownWorkers = new List<Address>();

        internal static List<Address> savedWorkers = new List<Address>();

        internal static void ReplaySavedWorkers() {
            using (var tmpLockObj = new LockAndElevate(workersLock)) {
                foreach (Address worker in savedWorkers) {
                    if (!knownWorkers.Contains(worker)) {
                        knownWorkers.Add(worker);
                        VsyncSystem.MasterCallBack(worker);
                    }
                }

                savedWorkers = null;
            }
        }

        internal static bool doGotIncoming(byte type, Address gaddr, Address sender, int minStable, Msg m, Group g, bool trackEvents) {
            if (!VsyncSystem.VsyncActive && VsyncSystem.VsyncWasActive) {
                return false;
            }

            switch (type) {
                default:
                    Vsync.WriteLine("WARNING: Received a message with unknown type: " + type);
                    break;

                case Msg.ISPUREP2P:
                    P2PSequencer.P2PCBWhenReady(m.sender, m, P2P.DeliverP2P);
                    break;

                case Msg.ISGRPP2P:
                case Msg.ISRAWGRPP2P:
                    if (g != null) {
                        g.isStable(sender, minStable);
                        g.CheckForFutureViews(m);

                        // This special field is used to ensure that a P2P message in a group won't be delivered until the group 
                        // reaches the correct view id number
                        m.theGroup = g;
                        P2PSequencer.P2PCBWhenReady(m.sender, m, g.enqueueForGroupDelivery);
                    }
                    else {
                        P2PSequencer.P2PCBWhenReady(m.sender, m, null);
                        bool stashIt = false;
                        using (var tmpLockObj = new LockAndElevate(Group.GroupRIPLock)) {
                            if (!Group.GroupRIPList.Contains(gaddr)) {
                                stashIt = true;
                            }
                        }

                        if (stashIt) {
                            // Tuck away for replay after the group gets created
                            Group.stashMsg(sender, gaddr, minStable, m);
                            return false;
                        }
                    }

                    break;

                case Msg.ISPING:
                case Msg.ISFILLER:
                    P2PSequencer.P2PCBWhenReady(m.sender, m, null);
                    break;

                case Msg.ISREPLY:
                case Msg.ISRAWREPLY:
                    P2PSequencer.P2PCBWhenReady(m.sender, m, AwaitReplies.gotReply);
                    break;

                case Msg.ISTOKEN:
                    P2PSequencer.P2PCBWhenReady(m.sender, m, ReliableSender.gotToken);
                    break;

                case Msg.ISLOOPBACK:
                case Msg.REDELIVERY:
                    g = Group.doLookup(gaddr);
                    if (g != null) {
                        g.CheckForFutureViews(m);
                        if ((VsyncSystem.Debug & VsyncSystem.DELIVERY) != 0) {
                            Vsync.WriteLine("<" + g.gname + ">: loopback delivering " + m);
                        }

                        g.doDeliveryCallbacks(m, "Looped Back from SortThenDeliverInOrder", type);
                    }
                    else {
                        if ((VsyncSystem.Debug & VsyncSystem.DISCARDS) != 0) {
                            Vsync.WriteLine("Discarding a looped-back message: this member no longer belongs to the group");
                        }

                        using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                            VsyncSystem.RTS.Discarded++;
                        }
                    }

                    break;

                case Msg.STABILITYINFO:
                    using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                        VsyncSystem.RTS.StabilityRcvd++;
                    }

                    if (g != null && ((g.flags & Group.G_ISLARGE) == 0 || g.HasFirstView)) {
                        g.isStable(sender, minStable);
                    }
                    else {
                        if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.DISCARDS)) != 0) {
                            Vsync.WriteLine("Discarding an incoming STABILITYINFO message: I'm not a member of group " + gaddr);
                        }

                        using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                            VsyncSystem.RTS.Discarded++;
                        }

                        return false;
                    }

                    break;

                case Msg.MULTICAST:
                case Msg.RAWMULTICAST:
                case Msg.UNORDERED:
                    if (!VsyncSystem.VsyncRestarting) {
                        using (var tmpLockObj = new LockAndElevate(Group.GroupRIPLock)) {
                            if (Group.GroupRIPList.Contains(gaddr)) {
                                if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.DISCARDS)) != 0) {
                                    Vsync.WriteLine("doGotIncoming discarding " + m.sender + "::" + m.vid + ":" + m.msgid + ", because GroupRIPList=[" + Address.VectorToString(Group.GroupRIPList.ToArray()) + "] contains " + gaddr);
                                }

                                return true;
                            }
                        }
                    }

                    if (g != null && ((g.flags & Group.G_ISLARGE) == 0 || g.HasFirstView)) {
                        // Process it, unless I'm not yet ready to do so.  The regular group logic can handle "early" messages, but the
                        // large-group code lacks an equivalent mechanism; it can't handle messages until it knows the first view and builds
                        // the first local token (g.theView.theToken).  But large groups don't ack messages in the same way as
                        // regular ones.  Thus for a regular group, we can pass in an early message; for a large group, we can discard
                        // it safely at this stage, knowing that the token-driven retransmission logic will kick in and resend the
                        // missing one, thus filling the gap (if needed -- after all, early messages might not even be for the view
                        // to which I'll end up belonging
                        ++g.rcvdMcastsCnt;
                        g.isStable(sender, minStable);
                        if ((g.flags & Group.G_SECURE) != 0) {
                            g.decipherMsg(m);
                        }

                        g.CheckForFutureViews(m);
                        m.type = type;
                        return g.GotAMsg(m, type, "doGotIncoming");
                    }

                    if ((VsyncSystem.Debug & (VsyncSystem.MESSAGELAYER | VsyncSystem.DISCARDS)) != 0) {
                        Vsync.WriteLine("Discarding an incoming CAST: I'm not a member of group " + gaddr + ", message was " + m);
                    }

                    using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                        VsyncSystem.RTS.Discarded++;
                    }

                    return false;

                case Msg.RUNASWORKER:
                    P2PSequencer.P2PCBWhenReady(m.sender, m, null);
                    if (!Vsync.WORKER_MODE) {
                        ReliableSender.SendP2P(Msg.YOURMASTERIS, m.sender, null, new byte[0], true);
                        using (var tmpLockObj = new LockAndElevate(workersLock)) {
                            if (VsyncSystem.MasterCallBack == null) {
                                savedWorkers.Add(sender);
                            }
                            else if (!knownWorkers.Contains(sender)) {
                                knownWorkers.Add(sender);
                                VsyncSystem.MasterCallBack(sender);
                            }
                        }
                    }

                    break;

                case Msg.YOURMASTERIS:
                    Vsync.heardFromMaster = true;
                    if (Vsync.WORKER_MODE && Vsync.MY_MASTER != m.sender) {
                        var oldMaster = Vsync.MY_MASTER;
                        Vsync.MY_MASTER = m.sender;
                        Vsync.MY_OLD_MASTER = oldMaster;
                        ReliableSender.P2PSequencer.FixUp(Vsync.MY_OLD_MASTER, Vsync.MY_MASTER);
                        Group.FixUp(Vsync.MY_OLD_MASTER, Vsync.MY_MASTER);
                    }

                    P2PSequencer.P2PCBWhenReady(m.sender, m, null);
                    break;
            }

            return true;
        }

        internal static void SendAck(Group g, Address dest, int AckID) {
            if (g != null) {
                if ((g.flags & Group.G_ISLARGE) != 0 && g.theView != null && g.theView.members.Length > Group.tokenInfo.RINGSIZE) {
                    if ((VsyncSystem.Debug & VsyncSystem.MESSAGELAYER) != 0) {
                        Vsync.WriteLine("SendAck: Inhibiting ack: Group is large");
                    }

                    return;
                }

                g.interesting = true;
            }

            int minUID = AckID;
            int maxUID = AckID;
            List<int> oamList = new List<int> { AckID };
            List<Group> igc = Group.VsyncGroupsClone();
            foreach (Group gr in igc) {
                if ((gr.flags & Group.G_ISLARGE) != 0) {
                    continue;
                }

                using (var tmpLockObj = new LockAndElevate(gr.UnstableLock)) {
                    if (gr.Unstable.Count > 0 && Math.Abs(gr.Unstable.First().UID - AckID) > 32) {
                        break;
                    }

                    foreach (Msg m in gr.Unstable) {
                        if (m.sender == dest) {
                            minUID = Math.Min(minUID, m.UID);
                            maxUID = Math.Max(maxUID, m.UID);
                            oamList.Add(m.UID);
                        }
                    }
                }
            }

            int len = maxUID - minUID + 1;
            byte[] acked = new byte[(len >> 3) + 1];
            foreach (int uid in oamList) {
                acked[(uid - minUID) >> 3] |= (byte)(1 << ((uid - minUID) & 7));
            }

            if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                string ids = " ";
                foreach (int uid in oamList) {
                    ids += uid + " ";
                }

                using (var tmpLockObj = new LockAndElevate(ackInfoLock)) {
                    ackInfo.Add("Sending ack: to " + dest + " ids = {" + ids + "}");
                }
            }

            try {
                if ((VsyncSystem.Debug & VsyncSystem.MESSAGELAYER) != 0) {
                    Vsync.WriteLine("Sending an Ack: dest=" + dest + ", AckID=" + AckID);
                }

                doSendAckPkt(dest, minUID, acked);
            }
            catch (ObjectDisposedException) {
            }
            catch (SocketException) {
            }
        }

        private static void doSendAckPkt(Address dest, int minUID, byte[] acked) {
            if (acked.Length + Vsync.VSYNC_BAOVERHEAD >= Vsync.VSYNC_MAXMSGLEN) {
                byte[] halfOfAcked = new byte[(acked.Length / 2) + 1];
                Buffer.BlockCopy(acked, 0, halfOfAcked, 0, Buffer.ByteLength(halfOfAcked));
                doSendAckPkt(dest, minUID, halfOfAcked);
                Buffer.BlockCopy(acked, halfOfAcked.Length, halfOfAcked, 0, Buffer.ByteLength(acked) - Buffer.ByteLength(halfOfAcked));
                doSendAckPkt(dest, minUID + (halfOfAcked.Length * 8), halfOfAcked);
                return;
            }

            byte[] b = Msg.toBArray(Vsync.VSYNC_HDR, Vsync.my_address, minUID, acked);
            if (b.Length - acked.Length > Vsync.VSYNC_BAOVERHEAD) {
                Vsync.WriteLine("WARNING: The value of VSYNC_BAOVERHEAD is too small! It should be at least " + (b.Length - acked.Length));
            }

            IPEndPoint remoteEP = new IPEndPoint(dest.home, dest.ackPort);
            ReliableSender.CheckLenAndRate(b);
            if (!Vsync.VSYNC_INFINIBAND || IB.ib_send(ACKBB, dest, b) == -1) {
                my_acksocket.SendTo(b, remoteEP);
            }

            using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                VsyncSystem.RTS.ACKsent++;
            }
        }

        internal class SentNack {
            internal long when;

            internal Address SentTo;

            internal Address MsgGroup;

            internal Address MsgSender;

            internal int MsgVid;

            internal int MsgMsgid;

            internal SentNack(Address SentTo, Address MsgGroup, Address MsgSender, int MsgVid, int MsgMsgid) {
                this.when = Vsync.NOW;
                this.SentTo = SentTo;
                this.MsgGroup = MsgGroup;
                this.MsgSender = MsgSender;
                this.MsgVid = MsgVid;
                this.MsgMsgid = MsgMsgid;
            }
        }

        internal class SentP2PNack {
            internal long when;

            internal Address SentTo;

            internal int p2pseqn;

            internal SentP2PNack(Address SentTo, int p2pseqn) {
                this.when = Vsync.NOW;
                this.SentTo = SentTo;
                this.p2pseqn = p2pseqn;
            }
        }

        internal static List<SentNack> SentNacksTo = new List<SentNack>();

        internal static List<SentP2PNack> SentP2PNacksTo = new List<SentP2PNack>();

        internal static LockObject SentNacksLock = new LockObject("SendNacksLock", ThreadPriority.Highest);

        // Currently unused, but we may resume calls to it in the future...
        internal static void SendNack(Group g, Address SendTo, Address MsgSender, int MsgVid, int MsgMsgid) {
            if (g == null) {
                return;
            }

            using (var tmpLockObj = new LockAndElevate(Vsync.RIPLock)) {
                if (Vsync.RIPList.Contains(SendTo)) {
                    return;
                }
            }

            using (var tmpLockObj = new LockAndElevate(SentNacksLock)) {
                foreach (SentNack sn in SentNacksTo) {
                    if (sn.MsgGroup == g.gaddr && sn.SentTo == SendTo && sn.MsgSender == MsgSender && sn.MsgVid == MsgVid && sn.MsgMsgid == MsgMsgid) {
                        return;
                    }
                }

                SentNacksTo.Add(new SentNack(SendTo, g.gaddr, MsgSender, MsgVid, MsgMsgid));
            }

            if ((VsyncSystem.Debug & VsyncSystem.NACKS) != 0) {
                Vsync.WriteLine("Sending a Nack: Group <" + g.gname + ">, sending a retransmit request to " + SendTo + " for Msg from sender=" + MsgSender + ", id " + MsgVid + ":" + MsgMsgid);
            }

            if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                using (var tmpLockObj = new LockAndElevate(ackInfoLock)) {
                    ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: Send NACK to " + SendTo + " nacking " + Vsync.my_address + "::" + MsgVid + ":" + MsgMsgid + Environment.NewLine);
                }
            }

            byte[] b = Msg.toBArray(Vsync.VSYNC_HDR, Vsync.my_address, g.gaddr, MsgSender, MsgVid, MsgMsgid);
            using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                VsyncSystem.RTS.NACKsent++;
            }

            P2PSend(SendTo, SendTo.ackPort, b, ACKBB);
        }

        internal static void SendP2PNack(Address sender, int p2pseqn) {
            using (var tmpLockObj = new LockAndElevate(Vsync.RIPLock)) {
                if (Vsync.RIPList.Contains(sender)) {
                    return;
                }
            }

            using (var tmpLockObj = new LockAndElevate(SentNacksLock)) {
                foreach (SentP2PNack sn in SentP2PNacksTo) {
                    if (sn.SentTo == sender && sn.p2pseqn == p2pseqn && Vsync.NOW - sn.when < 50) {
                        return;
                    }
                }

                SentP2PNacksTo.Add(new SentP2PNack(sender, p2pseqn));
            }

            if ((VsyncSystem.Debug & VsyncSystem.MESSAGELAYER) != 0) {
                Vsync.WriteLine("Sending a P2P Nack to " + sender + " for Msg with p2p seqn=" + p2pseqn);
            }

            if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                using (var tmpLockObj = new LockAndElevate(ackInfoLock)) {
                    ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: Send P2PNACK to " + sender + " nacking " + p2pseqn + Environment.NewLine);
                }
            }

            byte[] b = Msg.toBArray(Vsync.VSYNC_HDR, Vsync.my_address, sender, p2pseqn);
            P2PSend(sender, sender.ackPort, b, ACKBB);
        }

        internal static void CleanSentNack() {
            using (var tmpLockObj = new LockAndElevate(SentNacksLock)) {
                List<SentNack> newSNList = new List<SentNack>();
                foreach (SentNack sn in SentNacksTo) {
                    if ((Vsync.NOW - sn.when) < 1500) {
                        newSNList.Add(sn);
                    }
                }

                SentNacksTo = newSNList;
                List<SentP2PNack> newP2PSNList = new List<SentP2PNack>();
                foreach (SentP2PNack sn in SentP2PNacksTo) {
                    if ((Vsync.NOW - sn.when) < 1500) {
                        newP2PSNList.Add(sn);
                    }
                }

                SentP2PNacksTo = newP2PSNList;
            }
        }

        internal static void SendPoison(Address dest, string why) {
            if (!VsyncSystem.VsyncActive) {
                throw new VsyncShutdownException("Vsync inactive");
            }

            if ((VsyncSystem.Debug & VsyncSystem.MESSAGELAYER) != 0) {
                Vsync.WriteLine("Sending POISON: dest=" + dest + ", reason=" + why);
            }

            byte[] b = Msg.toBArray(Vsync.VSYNC_HDR, Vsync.NULLADDRESS, -1, why);
            P2PSend(dest, dest.ackPort, b, ACKBB);
            using (var tmpLockObj = new LockAndElevate(HeardFromLock)) {
                if (HeardFrom.ContainsKey(dest)) {
                    HeardFrom.Remove(dest);
                }
            }
        }

        internal static BoundedBuffer AckBB;

        internal class AckInfoItem {
            internal Address who;

            internal int id;

            internal AckInfoItem(Address s, int uid) {
                this.who = s;
                this.id = uid;
            }
        }

        internal class NackInfoItem {
            internal Address from;

            internal Address gaddr;

            internal Address msgsender;

            internal int viewid;

            internal int msgid;

            internal NackInfoItem(Address s, Address ga, Address ms, int vid, int mid) {
                this.from = s;
                this.gaddr = ga;
                this.msgsender = ms;
                this.viewid = vid;
                this.msgid = mid;
            }
        }

        internal static Dictionary<Address, SlidingBitBucket> ackHash = new Dictionary<Address, SlidingBitBucket>(5000);

        internal static LockObject ackHashLock = new LockObject("ackHashLock", ThreadPriority.Highest);

        internal static void AckNoteFailure(Address who) {
            using (var tmpLockObj = new LockAndElevate(ackHashLock)) {
                if (ackHash.ContainsKey(who)) {
                    ackHash.Remove(who);
                }
            }
        }

        internal static void AckSocketReader(object os) {
            while (!VsyncSystem.VsyncActive) {
                Vsync.Sleep(250);
            }

            AckBB = new BoundedBuffer("BB:Ack", 512, ILock.LLACKB, 0, 1);
            Socket s = (Socket)os;
            if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                using (var tmpLockObj = new LockAndElevate(ackInfoLock)) {
                    ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: {Creating ack thread at time " + Vsync.MsToSecs(Vsync.NOW) + "}" + Environment.NewLine);
                }
            }

            new Thread(() => {
                int len = 0;
                try {
                    if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                        using (var tmpLockObj = new LockAndElevate(ackInfoLock)) {
                            ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: {Ack thread running at time " + Vsync.MsToSecs(Vsync.NOW) + "}" + Environment.NewLine);
                        }
                    }

                    while (VsyncSystem.VsyncActive) {
                        VsyncSystem.RTS.ThreadCntrs[23]++;
                        byte[] b = null;
                        try {
                            List<AckInfoItem> p2pNackList = new List<AckInfoItem>();
                            List<NackInfoItem> nackList = new List<NackInfoItem>();
                            int cnt;
                            using (var tmpLockObj = new LockAndElevate(AckBB.Lock)) {
                                cnt = Math.Min(Math.Max(1, AckBB.fullSlots), 256);
                            }

                            while (cnt-- > 0) {
                                object next = AckBB.get();
                                if (next == null) {
                                    break;
                                }

                                b = (byte[])next;
                                len = b.Length;
                                object[] obs;
                                try {
                                    obs = Msg.BArrayToObjects(b);
                                }
                                catch {
                                    if ((VsyncSystem.Debug & VsyncSystem.DISCARDS) != 0) {
                                        Vsync.WriteLine("Ignoring a malformed message (could't extract the fields)");
                                    }

                                    continue;
                                }

                                int idx = 0;
                                if (Msg.CheckTypes(obs, typeof(byte[]), typeof(Address), typeof(int), typeof(string))) {
                                    // Poison
                                    byte[] hdr = (byte[])obs[idx++];
                                    Address sender = (Address)obs[idx++];
                                    int AckID = (int)obs[idx++];
                                    if (!chkhdr(hdr) || sender != Vsync.NULLADDRESS || AckID != -1) {
                                        if ((VsyncSystem.Debug & VsyncSystem.DISCARDS) != 0) {
                                            Vsync.WriteLine("Ignoring a malformed POISON message");
                                        }

                                        using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                            VsyncSystem.RTS.Discarded++;
                                        }
                                    }
                                    else {
                                        string why = (string)obs[idx++];
                                        VsyncSystem.GotPoison(why);
                                    }
                                }

                                if (Msg.CheckTypes(obs, typeof(byte[]), typeof(Address), typeof(int), typeof(byte[]))) {
                                    // Normal Ack
                                    byte[] hdr = (byte[])obs[idx++];
                                    if (!chkhdr(hdr)) {
                                        continue;
                                    }

                                    Address sender = (Address)obs[idx++];
                                    int minUID = (int)obs[idx++];
                                    byte[] ackedIds = (byte[])obs[idx];
                                    int maxUID = minUID + (ackedIds.Length << 3);
                                    justHeardFrom(sender);
                                    if (sender == Vsync.NULLADDRESS) {
                                        VsyncSystem.GotPoison("(unsure)");
                                    }

                                    SlidingBitBucket sbb;
                                    using (var tmpLockObj = new LockAndElevate(ackHashLock)) {
                                        if (!ackHash.TryGetValue(sender, out sbb)) {
                                            ackHash.Add(sender, sbb = new SlidingBitBucket(minUID, maxUID));
                                        }
                                        else {
                                            sbb.reset(minUID, maxUID, "GotAck(" + minUID + ":" + maxUID + ")");
                                        }
                                    }

                                    for (int bit = 0; bit < ackedIds.Length * 8; bit++) {
                                        if ((ackedIds[bit >> 3] & (byte)(1 << (bit & 7))) != 0) {
                                            sbb.Set(bit + minUID);
                                        }
                                    }

                                    if (sbb.hi - sbb.lo > 50) {
                                        cnt = 0;
                                    }

                                    if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                                        string ids = " ";
                                        for (int bit = 0; bit < ackedIds.Length; bit++) {
                                            if ((ackedIds[bit >> 3] & (byte)(1 << (bit & 7))) != 0) {
                                                ids += (bit + minUID) + " ";
                                            }
                                        }

                                        using (var tmpLockObj = new LockAndElevate(ackInfoLock)) {
                                            ackInfo.Add("Ack from " + sender + " ids = {" + ids + "}");
                                        }

                                        ids = " ";
                                        using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                                            foreach (MsgDesc md in P2PPendingSendBuffer) {
                                                if (md.dest == sender) {
                                                    ids += md.UID + " ";
                                                }
                                            }

                                            foreach (MsgDesc md in PendingSendBuffer) {
                                                if (md.dest == sender) {
                                                    ids += md.UID + " ";
                                                }
                                            }
                                        }

                                        using (var tmpLockObj = new LockAndElevate(ackInfoLock)) {
                                            ackInfo.Add("... need: " + sender + " ids = {" + ids + "}");
                                        }
                                    }

                                    using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                        ++VsyncSystem.RTS.ACKrcvd;
                                    }
                                }
                                else if (Msg.CheckTypes(obs, typeof(byte[]), typeof(Address), typeof(Address), typeof(Address), typeof(int), typeof(int))) {
                                    // Nack for a missing packet
                                    byte[] hdr = (byte[])obs[idx++];
                                    if (!chkhdr(hdr)) {
                                        continue;
                                    }

                                    Address from = (Address)obs[idx++];
                                    Address gaddr = (Address)obs[idx++];
                                    Address msgsender = (Address)obs[idx++];
                                    int viewid = (int)obs[idx++];
                                    int msgid = (int)obs[idx];
                                    bool fnd = false;
                                    foreach (NackInfoItem nai in nackList) {
                                        if (nai.from == from && nai.gaddr == gaddr && nai.msgsender == msgsender && nai.viewid == viewid && nai.msgid == msgid) {
                                            fnd = true;
                                        }
                                    }

                                    if (!fnd) {
                                        nackList.Add(new NackInfoItem(from, gaddr, msgsender, viewid, msgid));
                                    }

                                    using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                        ++VsyncSystem.RTS.NACKrcvd;
                                    }
                                }
                                else if (Msg.CheckTypes(obs, typeof(byte[]), typeof(Address), typeof(Address), typeof(int))) {
                                    // Nack for a missing P2P packet
                                    byte[] hdr = (byte[])obs[idx++];
                                    if (!chkhdr(hdr)) {
                                        continue;
                                    }

                                    Address requestedBy = (Address)obs[idx++];
                                    Address originalSender = (Address)obs[idx++];
                                    if (!originalSender.isMyAddress()) {
                                        throw new VsyncException("Unexpectedly received NACK for a p2p packet originating at " + originalSender);
                                    }

                                    int p2pseqn = (int)obs[idx];
                                    bool fnd = false;
                                    foreach (AckInfoItem p2pi in p2pNackList) {
                                        if (p2pi.who == requestedBy && p2pi.id == p2pseqn) {
                                            fnd = true;
                                            break;
                                        }
                                    }

                                    if (!fnd) {
                                        p2pNackList.Add(new AckInfoItem(requestedBy, p2pseqn));
                                    }

                                    using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                        ++VsyncSystem.RTS.ACKrcvd;
                                    }
                                }
                                else {
                                    if ((VsyncSystem.Debug & VsyncSystem.DISCARDS) != 0) {
                                        string tsig = " ";
                                        foreach (object o in obs) {
                                            tsig += o.GetType() + " ";
                                        }

                                        Vsync.WriteLine("WARNING: Discarding an ack/nack because its type signature didn't match any known signature!  TS={" + tsig + "}");
                                    }

                                    using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                        VsyncSystem.RTS.Discarded++;
                                    }
                                }
                            }

                            if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                                using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                    string acks = " ";
                                    using (var tmpLockObj1 = new LockAndElevate(ackHashLock)) {
                                        foreach (KeyValuePair<Address, SlidingBitBucket> kvp in ackHash) {
                                            for (int uid = kvp.Value.lo + 1; uid <= kvp.Value.hi; uid++) {
                                                if (kvp.Value.Test(uid)) {
                                                    acks += kvp.Key + "::" + uid + " ";
                                                }
                                            }
                                        }
                                    }

                                    using (var tmpLockObj1 = new LockAndElevate(ackInfoLock)) {
                                        ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: Got acks for " + acks + Environment.NewLine);
                                    }
                                }
                            }

                            using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                VsyncSystem.RTS.ackProcessingBeganAt = Vsync.NOW;
                            }

                            // Acks are common, so process as a list.  Nacks and P2P nacks are rare and often an Ack renders the action unneeded by the time we see the Nack
                            Dictionary<Address, SlidingBitBucket> oldackHash;
                            using (var tmpLockObj = new LockAndElevate(ackHashLock)) {
                                oldackHash = ackHash;
                                ackHash = new Dictionary<Address, SlidingBitBucket>(5000);
                            }

                            GotAnAck(oldackHash);
                            foreach (AckInfoItem p2pi in p2pNackList) {
                                GotP2PNack(p2pi.who, p2pi.id);
                            }

                            foreach (NackInfoItem nacki in nackList) {
                                GotNack(nacki.from, nacki.gaddr, nacki.msgsender, nacki.viewid, nacki.msgid);
                            }

                            using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                VsyncSystem.RTS.ackProcessingBeganAt = 0;
                            }
                        }
                        catch (Exception e) {
                            try {
                                object[] obs = Msg.BArrayToObjects(b);
                                string ts = string.Empty;
                                for (int o = 0; o < obs.Length; o++) {
                                    ts += " " + obs[o].GetType() + " ";
                                }

                                Vsync.WriteLine("AckSocketReader threw exception " + e + " on Vsync Message with type signature {" + ts + "}... IGNORING IT");
                            }
                            catch (Exception ie) {
                                VsyncSystem.Shutdown("AckSocketReader threw exception " + e + " then inner " + ie + ": len was " + len);
                            }
                        }
                    }
                }
                catch (VsyncShutdownException) {
                    VsyncSystem.CheckLocksHeld();
                }

                if (VsyncSystem.VsyncActive) {
                    throw new VsyncException("ackProcessingThread has failed");
                }

                VsyncSystem.ThreadTerminationMagic();
            }) { Name = "Ack processing thread", Priority = ThreadPriority.Highest, IsBackground = true }.Start();
            try {
                while (!VsyncSystem.VsyncActive) {
                    Vsync.Sleep(250);
                }

                Thread.CurrentThread.Priority = ThreadPriority.Highest;
                while (VsyncSystem.VsyncActive) {
                    VsyncSystem.RTS.ThreadCntrs[24]++;
                    byte[] b = new byte[Vsync.VSYNC_MAXMSGLEN + 1024];
                    int rlen;
                    do {
                        try {
                            ILock.NoteThreadState("Ack.Receive");
                            rlen = s.Receive(b);
                        }
                        catch (IOException) {
                            rlen = 0;
                        }
                        catch (SocketException) {
                            rlen = 0;
                        }
                        finally {
                            ILock.NoteThreadState(null);
                        }

                        VsyncSystem.RTS.ThreadCntrs[0]++;
                    }
                    while (!Msg.VerifySignature(b, 0, rlen));
                    VsyncSystem.RTS.ThreadCntrs[1]++;

                    if (rlen > Vsync.VSYNC_MAXMSGLEN) {
                        Vsync.WriteLine("WARNING (b): MAXMSGLEN set to " + Vsync.VSYNC_MAXMSGLEN + ", but received length=" + rlen);
                    }

                    if (rlen > 4) {
                        Vsync.ArrayResize(ref b, rlen);
                        using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                            VsyncSystem.RTS.ackedAt = Vsync.NOW;
                            if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                                using (var tmpLockObj1 = new LockAndElevate(ackInfoLock)) {
                                    ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: Receive(ack-socket)" + Environment.NewLine);
                                }
                            }
                        }

                        AckBB.put(b, true);
                        VsyncSystem.RTS.check();
                        using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                            VsyncSystem.RTS.ackedAt = 0;
                        }
                    }
                }
            }
            catch (VsyncShutdownException) {
                VsyncSystem.CheckLocksHeld();
            }

            if (VsyncSystem.VsyncActive) {
                throw new VsyncException("ack receiver thread has failed");
            }
        }

        private static bool chkhdr(byte[] hdr) {
            bool noMatch = false;
            if (hdr.Length != Vsync.VSYNC_HDR.Length) {
                noMatch = true;
            }

            for (int i = 0; i < hdr.Length && noMatch; i++) {
                if (hdr[i] != Vsync.VSYNC_HDR[i]) {
                    noMatch = true;
                }
            }

            if (!noMatch) {
                return true;
            }

            if ((VsyncSystem.Debug & VsyncSystem.DISCARDS) != 0) {
                Vsync.WriteLine("WARNING: discarding an ack/nack because it didn't have the correct Vsync header");
            }

            using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                VsyncSystem.RTS.Discarded++;
            }

            return false;
        }

        internal static Dictionary<Address, long> HeardFrom = new Dictionary<Address, long>(100);

        internal static LockObject HeardFromLock = new LockObject("HeardFromLock", ThreadPriority.Highest);

        internal static string HeardFromState() {
            string s = "Heard from recently: {";
            using (var tmpLockObj = new LockAndElevate(HeardFromLock)) {
                foreach (KeyValuePair<Address, long> kvp in HeardFrom) {
                    string t = kvp.Value > Vsync.NOW ? "<GRACE PERIOD>" : Vsync.MsToSecs(kvp.Value);
                    s += kvp.Key + "@" + t + " ";
                }
            }

            return s + "}" + Environment.NewLine;
        }

        internal static bool HeardFromRecently(Address who) {
            long when;

            // During startup be slow to detect failures....
            if (Vsync.NOW < 30000) {
                return true;
            }

            using (var tmpLockObj = new LockAndElevate(HeardFromLock)) {
                HeardFrom.TryGetValue(who, out when);
            }

            return (Vsync.NOW - when) < Vsync.VSYNC_DEFAULTTIMEOUT;
        }

        internal static void justHeardFrom(Address who) {
            using (var tmpLockObj = new LockAndElevate(HeardFromLock)) {
                if (HeardFrom.ContainsKey(who)) {
                    HeardFrom.Remove(who);
                }

                HeardFrom.Add(who, Vsync.NOW);
            }
        }

        internal static void nodeInStartup(Address who) {
            // Special case: give 20 seconds of grace, because C# class loader can lock out I/O during the startup period
            using (var tmpLockObj = new LockAndElevate(HeardFromLock)) {
                HeardFrom[who] = Vsync.NOW + Vsync.GRACEPERIOD;
            }
        }

        internal class SIDPair {
            internal Address Who;

            internal int ID;

            internal SIDPair(Address w, int i) {
                this.Who = w;
                this.ID = i;
            }
        }

        internal class SlidingBitBucket {
            internal int lo = int.MaxValue;

            internal int hi = int.MinValue;

            internal byte[] bytes;

            internal SlidingBitBucket() {
            }

            internal SlidingBitBucket(int initLo, int initHi) {
                this.reset(initLo, initHi, string.Empty);
            }

            internal void reset(int newLo, int newHi, string from) {
                int newLoRnd = Math.Min(this.lo, newLo & ~7), newHiRnd = Math.Max(this.hi, ((newHi + 8) & ~7) - 1);
                int nb = ((newHiRnd - newLoRnd) >> 3) + 1;
                if (this.bytes == null) {
                    this.lo = newLoRnd;
                    this.hi = newHiRnd;
                    VsyncSystem.RTS.ThreadCntrs[33]++;
                    this.bytes = new byte[nb];
                    return;
                }

                if (this.lo <= newLoRnd && this.hi >= newHiRnd) {
                    return;
                }

                VsyncSystem.RTS.ThreadCntrs[33]++;
                byte[] newBits = new byte[nb];
                Buffer.BlockCopy(this.bytes, 0, newBits, (this.lo - newLoRnd) >> 3, Buffer.ByteLength(this.bytes));
                this.bytes = newBits;
                this.lo = newLoRnd;
                this.hi = newHiRnd;
            }

            internal void singleSet(int bit) {
                VsyncSystem.RTS.ThreadCntrs[34]++;
                this.lo = bit & ~7;
                this.hi = this.lo + 7;
                if (this.bytes == null) {
                    this.bytes = new byte[1];
                }

                this.bytes[0] = (byte)(1 << (bit - this.lo));
            }

            internal void Set(int bit) {
                VsyncSystem.RTS.ThreadCntrs[34]++;
                if (this.bytes == null) {
                    this.reset(bit, bit, "Set(" + bit + ")");
                }
                else {
                    this.reset(Math.Min(this.lo, bit), Math.Max(this.hi, bit), "Set(" + bit + ")");
                }

                int bn = bit - this.lo;
                this.bytes[bn >> 3] |= (byte)(1 << (bn & 7));
            }

            internal bool Test(int bit) {
                VsyncSystem.RTS.ThreadCntrs[35]++;
                if (bit < this.lo || bit > this.hi || this.bytes == null) {
                    return false;
                }

                int bn = bit - this.lo;
                return (this.bytes[bn >> 3] & (byte)(1 << (bn & 7))) != 0;
            }

            public override string ToString() {
                if (this.bytes == null) {
                    return "SBB: unitialized";
                }

                string bs = " ";
                for (int bit = this.lo; bit <= this.hi; bit++) {
                    bs += this.Test(bit) ? "1" : "0";
                }

                bs += " ";
                return "SBB: lo=" + this.lo + ", hi=" + this.hi + ", bits.Length=" + this.bytes.Length + ", bits={" + bs + "}";
            }
        }

        internal static List<string> ackInfo = ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) ? new List<string>() : null;

        internal static LockObject ackInfoLock = new LockObject("ackInfoLock");

        internal static List<object> toResend = new List<object>();

        internal static Semaphore toResendSema = new Semaphore(0, int.MaxValue);

        internal static LockObject toResendLock = new LockObject("toResendLock");

        internal static bool resenderRunning = false;

        internal static Thread ackNackResenderThread = null;

        internal static LockObject AckLock = new LockObject("AckLock", ThreadPriority.Highest);

        internal static LockObject SingletonLock = new LockObject("SingletonLock", ThreadPriority.Highest);

        internal static SlidingBitBucket sbb = new SlidingBitBucket();

        internal static Dictionary<Address, SlidingBitBucket> singleton = new Dictionary<Address, SlidingBitBucket>(1);

        internal static void GotAnAck(Address sender, int AckID) {
            using (var tmpLockObj = new LockAndElevate(SingletonLock)) {
                sbb.singleSet(AckID);
                singleton.Add(sender, sbb);
                GotAnAck(singleton);
                singleton.Remove(sender);
            }
        }

        internal static void GotAnAck(Dictionary<Address, SlidingBitBucket> alist) {
            List<MsgDesc> toRemove = new List<MsgDesc>();
            using (var tmpLockObj = new LockAndElevate(PendingSendBufferLock)) {
                PendingSendBuffer = PSBApplyAck(alist, toRemove, PendingSendBuffer);
                P2PPendingSendBuffer = PSBApplyAck(alist, toRemove, P2PPendingSendBuffer);
            }

            if (toRemove.Count > 0) {
                int cnt = toRemove.Count;
                foreach (MsgDesc md in toRemove) {
                    md.done = true;
                    mdRemove(md, "md.GotAnAck", --cnt == 0);
                }
            }

            TickleResenderThread();
        }

        private static LinkedList<MsgDesc> PSBApplyAck(Dictionary<Address, SlidingBitBucket> alist, List<MsgDesc> toRemove, LinkedList<MsgDesc> psb) {
            LinkedList<MsgDesc> newPSB = new LinkedList<MsgDesc>();
            Address cachedOwner = null;
            SlidingBitBucket cachedsbb = null;
            foreach (MsgDesc md in psb) {
                SlidingBitBucket sbb;
                if (cachedOwner != null && cachedOwner == md.dest) {
                    sbb = cachedsbb;
                }
                else if (alist.TryGetValue(md.dest, out sbb)) {
                    cachedOwner = md.dest;
                    cachedsbb = sbb;
                }

                if (sbb != null && md.UID >= sbb.lo && md.UID <= sbb.hi && sbb.Test(md.UID)) {
                    toRemove.Add(md);
                }
                else {
                    newPSB.AddLast(md);
                }
            }

            return newPSB;
        }

        private static string GetName(Address gaddr) {
            Group g;
            if (gaddr == null || (g = Group.doLookup(gaddr)) == null) {
                return "<null>";
            }

            return g.gname;
        }

        internal static void GotNack(Address from, Address gaddr, Address MsgSender, int MsgVid, int MsgMsgid) {
            bool launchThread = false;
            using (var tmpLockObj = new LockAndElevate(toResendLock)) {
                if (!resenderRunning) {
                    resenderRunning = true;
                    launchThread = true;
                }
            }

            if (launchThread) {
                ackNackResenderThread = new Thread(() => {
                    try {
                        while (!VsyncSystem.VsyncActive) {
                            Vsync.Sleep(250);
                        }

                        while (VsyncSystem.VsyncActive) {
                            VsyncSystem.RTS.ThreadCntrs[25]++;
                            object o;
                            ILock.NoteThreadState("toResendSema.WaitOne()");
                            toResendSema.WaitOne();
                            ILock.NoteThreadState(null);
                            using (var tmpLockObj = new LockAndElevate(toResendLock)) {
                                if (toResend.Count == 0) {
                                    if (!VsyncSystem.VsyncActive) {
                                        VsyncSystem.ThreadTerminationMagic();
                                        return;
                                    }

                                    throw new VsyncException("toResend shouldn't be empty");
                                }

                                o = toResend.First();
                                toResend.Remove(o);
                            }

                            if (o.GetType() == typeof(MsgDesc)) {
                                MsgDesc md = (MsgDesc)o;
                                if (md.done) {
                                    continue;
                                }

                                if (md.isP2POrGroup) {
                                    if (md.dest.isMyAddress()) {
                                        Vsync.WriteLine("ack/nack resender: sending to self");
                                    }

                                    IPEndPoint target = new IPEndPoint(md.dest.home, md.dest.p2pPort);
                                    ReliableSender.CheckLenAndRate(md.theBytes);
                                    int bs;
                                    if (!Vsync.VSYNC_INFINIBAND || (bs = IB.ib_send(RECVBB, md.dest, md.theBytes)) == -1) {
                                        bs = my_p2psocket.SendTo(md.theBytes, target);
                                    }

                                    using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                        VsyncSystem.RTS.UDPBsent += bs;
                                        VsyncSystem.RTS.UDPsent++;
                                    }
                                }
                                else if (md.isLarge) {
                                    lgReMulticast(md);
                                }
                                else if (Resend(md)) {
                                    ++md.retryCnt;
                                }
                            }
                            else if (o.GetType() == typeof(Msg)) {
                                Msg m = (Msg)o;
                                Group theGroup = Group.doLookup(m.gaddr);
                                if (theGroup != null) {
                                    ReliableSender.SendP2P(m.type, from, theGroup, ResendForm(m), false);
                                }
                            }
                        }
                    }
                    catch (VsyncShutdownException) {
                        VsyncSystem.CheckLocksHeld();
                    }
                    VsyncSystem.ThreadTerminationMagic();
                }) { Name = "Ack/Nack resender thread", Priority = ThreadPriority.Highest, IsBackground = true };
                ackNackResenderThread.Start();
            }

            using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                VsyncSystem.RTS.NACKrcvd++;
            }

            Group g = Group.doLookup(gaddr);
            if (g == null) {
                return;
            }

            using (var tmpLockObj = new LockAndElevate(AckLock)) {
                if ((VsyncSystem.Debug & VsyncSystem.NACKS) != 0) {
                    Vsync.WriteLine("Received a NACK from " + from + " for group <" + (g == null ? "null" : g.gname) + ">, for Msg from Sender=" + MsgSender + " with msgid=" + MsgVid + ":" + MsgMsgid);
                }

                if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                    using (var tmpLockObj1 = new LockAndElevate(ackInfoLock)) {
                        ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: Got nack from " + from + " requesting " + MsgSender + "::" + MsgVid + ":" + MsgMsgid + Environment.NewLine);
                    }
                }

                if ((g.flags & Group.G_ISLARGE) == 0) {
                    MsgDesc mdfnd = null;
                    if (MsgSender.isMyAddress()) {
                        using (var tmpLockObj1 = new LockAndElevate(ReliableSender.PendingSendBufferLock)) {
                            foreach (MsgDesc md in P2PPendingSendBuffer) {
                                if (md.dest == from && md.MsgVid == MsgVid && md.MsgId == MsgMsgid) {
                                    mdfnd = md;
                                    break;
                                }
                            }

                            if (mdfnd == null) {
                                foreach (MsgDesc md in PendingSendBuffer) {
                                    if (md.dest == from && md.MsgVid == MsgVid && md.MsgId == MsgMsgid) {
                                        mdfnd = md;
                                        break;
                                    }
                                }
                            }
                        }

                        if (mdfnd != null) {
                            using (var tmpLockObj1 = new LockAndElevate(toResendLock)) {
                                if (!toResend.Contains(mdfnd)) {
                                    toResend.Add(mdfnd);
                                    toResendSema.Release();
                                }
                            }

                            return;
                        }
                    }

                    List<Msg> resendList = new List<Msg>();
                    using (var tmpLockObj1 = new LockAndElevate(g.UnstableLock)) {
                        foreach (Msg m in g.Unstable) {
                            if (m.sender == MsgSender && ((g.flags & Group.G_ISLARGE) != 0 || m.vid == MsgVid) && m.msgid == MsgMsgid) {
                                resendList.Add(m);
                            }
                        }
                    }

                    if (resendList.Count == 0) {
                        if ((VsyncSystem.Debug & VsyncSystem.NACKS) != 0) {
                            Vsync.WriteLine("WARNING: Didn't find NACKED packet on the unstable list!");
                        }

                        return;
                    }

                    foreach (Msg mtrs in resendList) {
                        mtrs.gaddr = g.gaddr;
                        using (var tmpLockObj1 = new LockAndElevate(toResendLock)) {
                            if (!toResend.Contains(mtrs)) {
                                toResend.Add(mtrs);
                                toResendSema.Release();
                            }
                        }
                    }

                    return;
                }

                // Large group case: Messages identified ONLY by msgid here (vid may have a nonsense value) and will be found on the LgPendingSendBuffer list
                MsgDesc theLgMd = null;
                using (var tmpLockObj1 = new LockAndElevate(ReliableSender.PendingSendBufferLock)) {
                    foreach (MsgDesc lgmd in LgPendingSendBuffer) {
                        if (lgmd.MsgId == MsgMsgid) {
                            theLgMd = lgmd;
                            break;
                        }
                    }
                }

                if (theLgMd != null) {
                    using (var tmpLockObj1 = new LockAndElevate(toResendLock)) {
                        if (!toResend.Contains(theLgMd)) {
                            toResend.Add(theLgMd);
                            toResendSema.Release();
                        }
                    }
                }
                else if ((VsyncSystem.Debug & VsyncSystem.NACKS) != 0) {
                    Vsync.WriteLine("WARNING: Didn't find NACKED packet on the LgPendingSendBuffer list!");
                }
            }

            TickleResenderThread();
        }

        internal static Msg ResendForm(Msg m) {
            return m.asReceived ?? m;
        }

        internal static void GotP2PNack(Address requestedBy, int p2pseqn) {
            using (var tmpLockObj = new LockAndElevate(AckLock)) {
                MsgDesc md = null;
                using (var tmpLockObj1 = new LockAndElevate(PendingSendBufferLock)) {
                    foreach (MsgDesc psmd in P2PPendingSendBuffer) {
                        if (psmd.dest == requestedBy && psmd.UID == p2pseqn) {
                            md = psmd;
                            break;
                        }
                    }
                }

                if ((VsyncSystem.Debug & VsyncSystem.LOWLEVELMSGS) != 0) {
                    using (var tmpLockObj1 = new LockAndElevate(ackInfoLock)) {
                        ackInfo.Add("[" + Vsync.MsToSecs(Vsync.NOW) + "]: Received a P2P NACK from " + requestedBy + " for p2pSeqn = " + p2pseqn + Environment.NewLine);
                    }
                }

                if ((VsyncSystem.Debug & VsyncSystem.NACKS) != 0) {
                    if (md == null) {
                        Vsync.WriteLine("WARNING: Received a P2P NACK from " + requestedBy + " but didn't find packet with p2pseqn=" + p2pseqn);
                    }
                    else {
                        Vsync.WriteLine("Received a P2P NACK from " + requestedBy + " for message with p2pseqn=" + p2pseqn + "(msg id " + md.MsgVid + ":" + md.MsgId + "), found it and will resend");
                    }
                }

                if (md == null && genFiller(requestedBy, p2pseqn)) {
                    if ((VsyncSystem.Debug & VsyncSystem.NACKS) != 0) {
                        Vsync.WriteLine("Generating Msg.ISFILLER for " + requestedBy + ", seqn=" + p2pseqn);
                    }

                    byte[] newMsgBytes = Msg.NewMsgAsBArray(Vsync.my_address, Vsync.NULLADDRESS, 0, p2pseqn, 0L, 0, p2pseqn, 0, new byte[0]);
                    byte[] buffer = Msg.toBArray(Msg.ISFILLER, (byte)0, p2pseqn, Vsync.my_address, requestedBy, Vsync.NULLADDRESS, 0, 0, newMsgBytes);
                    md = new MsgDesc(Msg.ISFILLER, 1, null, requestedBy, true, false, p2pseqn, buffer, 0, 0, 0, 0, 1, true, null, null);
                }

                if (md != null) {
                    using (var tmpLockObj1 = new LockAndElevate(toResendLock)) {
                        if (!toResend.Contains(md)) {
                            toResend.Add(md);
                            toResendSema.Release();
                        }
                    }
                }
            }

            TickleResenderThread();
        }

        /*
         * This code is capable of generating a "fake" retransmission of a message that is, in fact, completely missing.
         * It isn't intended for real use but can be a useful tool when debugging certain kinds of low-level problems in the system.
         * Currently commented out because technically speaking, filling a gap with a no-op message this way is a mistake!
         * */

        internal static bool genFiller(Address who, int seqn) {
            /*using (var tmpLockObj = new LockAndElevate(P2PSequencer.PSListLock))
            {
                foreach (P2PSequencer p2ps in P2PSequencer.PSList)
                {
                    if (p2ps.dest == who && p2ps.remoteBacklog > 100 && p2ps.outSeqn-seqn > 100)
                    {
                        return true;
                    }
                }
            }*/

            return false;
        }

        // Because zero-bytes are so common, this does run-length encoding for runs of zeros (but not other values)
        // The true buffer length is stored at the very end of the compressed object
        internal static byte[] Compress(byte[] raw) {
            if (Vsync.VSYNC_DONT_COMPRESS || raw.Length < 128) {
                return null;
            }

            byte[] compressed = new byte[raw.Length];
            int idx = 0;
            for (int b = 0; b < raw.Length; b++) {
                if ((compressed[idx++] = raw[b]) == 0) {
                    ushort count = 0;
                    while (b < raw.Length - 1 && raw[b + 1] == 0 && count != 0x7FFF) {
                        ++count;
                        ++b;
                    }

                    if (count <= 0x7F) {
                        compressed[idx++] = (byte)count;
                    }
                    else {
                        compressed[idx++] = (byte)(((count >> 8) & 0x7F) | 0x80);
                        compressed[idx++] = (byte)(count & 0xFF);
                    }
                }

                if (idx > (raw.Length * 2) / 3) {
                    return null;
                }
            }

            compressed[idx++] = (byte)((raw.Length >> 24) & 0xFF);
            compressed[idx++] = (byte)((raw.Length >> 16) & 0xFF);
            compressed[idx++] = (byte)((raw.Length >> 8) & 0xFF);
            compressed[idx++] = (byte)(raw.Length & 0xFF);
            Vsync.ArrayResize(ref compressed, idx);
            return compressed;
        }

        internal static byte[] DeCompress(byte[] raw) {
            int expectedLen = (raw[raw.Length - 4] << 24) + (raw[raw.Length - 3] << 16) + (raw[raw.Length - 2] << 8) + raw[raw.Length - 1];
            byte[] decompressed = new byte[expectedLen];
            int idx = 0;
            for (int b = 0; b < raw.Length - 4; b++) {
                if ((decompressed[idx++] = raw[b]) == 0) {
                    uint len = raw[++b];
                    if ((len & 0x80) != 0) {
                        len = ((len & 0x7F) << 8) | raw[++b];
                    }

                    for (int a = 0; a < len; a++) {
                        decompressed[idx++] = 0;
                    }
                }
            }

            if (idx != expectedLen) {
                throw new VsyncException("Decompression failed");
            }

            return decompressed;
        }
    }

    // I'm using this myself, but outside Vsync users should only do P2P
    // communication in the context of some group for now.
    internal class P2P {
        internal static void Send(Address dest, params object[] obs) {
            byte[] buffer = Msg.toBArray(obs);
            if (dest.isMyAddress()) {
                Msg m = new Msg { payload = buffer };
                m.sender = m.dest = dest;
                DeliverP2P(m);
                return;
            }

            ReliableSender.SendP2P(Msg.ISPUREP2P, dest, null, buffer, true);
        }

        internal static void DeliverP2P(Msg m) {
            if (!Vsync.ORACLE.isTrackingProxy) {
                Vsync.ORACLE.enqueueForGroupDelivery(m);
            }
            else {
                // Special for OOB transfer of initial views
                while (Vsync.VSYNCMEMBERS == null) {
                    Vsync.Sleep(100);
                }

                Vsync.VSYNCMEMBERS.enqueueForGroupDelivery(m);
            }
        }
    }

    /// <summary>
    /// The Vsync.Msg class defines the wire-representation of messages used by the Vsync system.  
    /// </summary>
    /// <remarks>
    /// End users will normally not need
    /// direct access to this type of object, but the various C# scoping rules compell us to make it public, and there are static
    /// methods that the end user does need to call, for example to register a new data type that Vsync will transport (<see cref="Msg.RegisterType"/>).
    /// </remarks>
    public class Msg : IComparable, IComparable<Msg>, IEquatable<Msg>, ISelfMarshalled {
        /// <summary>
        /// Vsync.Address of the sender of this message
        /// </summary>
        public Address sender;

        /// <summary>
        /// Vsync.Address of the destination of this message
        /// </summary>
        public Address dest;

        /// <summary>
        /// Vsync.Address of the group within which this message was sent
        /// </summary>
        internal Address gaddr; // Used only while on Unstable list

        /// <summary>
        /// Value of a viewid before Msg has a specified vid
        /// </summary>
        public const int UNINITIALIZED = -1;

        /// <summary>
        /// Viewid of the group at the time this message was sent
        /// </summary>
        public int vid = UNINITIALIZED;

        /// <summary>
        /// Sequence number unique to this sender for the message.  But other senders may use the same number
        /// for their own messages, so must treat as a pair: (msgid,sender-id) using sender-id to break ties.
        /// </summary>
        public int msgid = 0;

        /// <summary>
        /// Used for the logging ID, if the logging service is active
        /// </summary>
        public long Lid = 0;

        /// <summary>
        /// If we've been sending RAW messages, this gives a count of how many were
        /// sent prior to the current message.  Since those can be dropped in the network
        /// and won't be retransmitted, the receiver shouldn't delay this one if it follows a
        /// gap of size nRaw (or fewer) missing messages.  The algorithm is surprisingly subtle
        /// although it may look simple.  A further (major) complication arises because we treat
        /// subset multicasts (e.g. for DHTOrderedSend) as a form of raw multicast.  The multicast
        /// layer sees such messages as being entirely raw because we use a multicast msgid number but 
        /// in fact send the "multicast" purely via P2P messages in this case.  The P2P layer,
        /// however, encapsulates the subset multicast and sends it, reliably, using a P2P protocol
        /// over sequenced, reliable, P2P channels with nRaw=0 for the outer capsule messages.
        /// The idea is to "explain" to the multicast layer why it will see seemingly missing
        /// multicasts in the multicast sequence numbering.  Anyhow, all of this makes nRaw subtle.
        /// </summary>
        public int nRaw = 0;

        /// <summary>
        /// Set by the original sender, gives the UID by which the message should be acknowledged
        /// </summary>
        public int UID = 0;

        /// <summary>
        /// The body of the message, encoded into a byte array
        /// </summary>
        public byte[] payload;

        internal byte[] cipherPayload; // Non-null if a cipher copy of the payload is available

        internal Msg asReceived;

        // Non-null for the first fragment of a fragmented message so that p2p retransmission off unstable list will work
        internal byte[] offWire; // As it came off the wire

        internal Group.CompletionTag ct; // Non-null for a safe message being delivered

        internal List<Address> destList; // Used to relay the List<Address> or QueryKey argument, if any, to doTheSend

        // Cached, for speed
        internal volatile object[] myObs;

        internal Address wasForwardedTo;

        internal bool ordered;

        internal long toDoTime = 0;

        internal LockObject Lock = new LockObject("Msg.Lock");

        internal byte type; // Value 0 (uninitialized) when message is on the wire or recently loaded

        // Type values
        internal const byte ISREPLY = 1;

        internal const byte MULTICAST = 2;

        internal const byte UNORDERED = 3;

        internal const byte ISPUREP2P = 4;

        internal const byte ISGRPP2P = 5;

        internal const byte ISTOKEN = 6;

        internal const byte ISLOOPBACK = 7;

        internal const byte ISPING = 8;

        internal const byte ISPOISON = 9;

        internal const byte STABILITYINFO = 10;

        internal const byte RUNASWORKER = 11;

        internal const byte ISRAWGRPP2P = 12;

        internal const byte ISRAWREPLY = 13;

        internal const byte RAWMULTICAST = 14;

        internal const byte REDELIVERY = 15;

        internal const byte ISFILLER = 16;

        internal const byte YOURMASTERIS = 17;

        internal static string[] mtypes = { "type unknown", "reply", "multicast", "unordered multicast", "pure p2p", "p2p in a group", "token", "loopback", "ping", "poison", "stability-info", "run as worker", "raw (unreliable) p2p in a group", "raw (unreliable) reply", "raw (unreliable) multicast", "redelivery in orderedsend/safesend", "gap filler", "your master is" };

        // Flag and associated values
        internal byte flags;

        internal const byte NEEDSREPLY = 0x01;

        internal const byte SENTBYORACLE = 0x02;

        internal const byte DEFRAGGED = 0x04;

        internal const byte HASREPLY = 0x08;

        internal const byte FRAGGED = 0x10;

        internal const byte TOKEN = 0x20;

        internal const byte CIPHER = 0x40;

        internal const byte ENCIPHEREDREPLY = 0x80;

        internal static string pflags(int f) {
            string fs = " ";
            if ((f & NEEDSREPLY) != 0) {
                fs += "needs-reply ";
            }

            if ((f & SENTBYORACLE) != 0) {
                fs += "sent-by-oracle ";
            }

            if ((f & DEFRAGGED) != 0) {
                fs += "defragged ";
            }

            if ((f & FRAGGED) != 0) {
                fs += "fragged ";
            }

            if ((f & TOKEN) != 0) {
                fs += "token ";
            }

            if ((f & CIPHER) != 0) {
                fs += "enciphered ";
            }

            if ((f & ENCIPHEREDREPLY) != 0) {
                fs += "needs-enciphered-reply ";
            }

            return fs;
        }

        /// <summary>
        /// Encodes an Vsync.Msg object as a byte array.  Not normally needed by Vsync end-users, but public to satisfy a C# scoping requirement.
        /// </summary>
        /// <returns>The byte[] representation of the given message, suitable for transmission</returns>
        public byte[] toBArray() {
            if ((this.flags & Msg.CIPHER) != 0) {
                return Msg.NewMsgAsBArray(this.sender, this.dest, this.vid, this.msgid, this.Lid, this.nRaw, this.UID, this.flags, this.cipherPayload);
            }

            return Msg.NewMsgAsBArray(this.sender, this.dest, this.vid, this.msgid, this.Lid, this.nRaw, this.UID, this.flags, this.payload);
        }

        /// <summary>
        /// Creates a new Vsync.Msg object with a null payload.  Not normally needed by Vsync end-users, but public to satisfy a C# scoping requirement.
        /// </summary>
        public Msg() {
        }

        /// <summary>
        /// Creates a new Vsync.Msg object from a byte vector encoding a message
        /// </summary>
        /// <param name="ba">the byte[] representation of an encoded message</param>
        public Msg(byte[] ba) {
            object[] obs = BArrayToObjects(ba, typeof(Address), typeof(Address), typeof(int), typeof(int), typeof(long), typeof(int), typeof(int), typeof(byte), typeof(byte[]));
            int idx = 0;
            this.sender = (Address)obs[idx++];
            this.dest = (Address)obs[idx++];
            this.vid = (int)obs[idx++];
            this.msgid = (int)obs[idx++];
            this.Lid = (long)obs[idx++];
            this.nRaw = (int)obs[idx++];
            this.UID = (int)obs[idx++];
            this.flags = (byte)obs[idx++];
            if ((this.flags & CIPHER) == 0) {
                this.payload = (byte[])obs[idx];
            }
            else {
                this.cipherPayload = (byte[])obs[idx];
            }

            if (Vsync.MY_OLD_MASTER != null && Vsync.MY_OLD_MASTER.Equals(this.sender)) {
                this.sender = Vsync.MY_MASTER;
            }
        }

        /// <summary>
        /// Creates a new Vsync.Msg object that encodes the given object vector.  Not normally needed by Vsync end-users, but public to satisfy a C# scoping requirement.
        /// </summary>
        /// <param name="obs">The new message object</param>
        public Msg(params object[] obs) {
            this.sender = Vsync.my_address;
            this.dest = Vsync.NULLADDRESS;
            this.payload = toBArray(obs);
        }

        /// <summary>
        /// Converts an Vsync.Msg object to a string representation for printing.  Not normally needed by Vsync end-users, but must be public to satisfy a C# scoping requirement
        /// </summary>
        /// <returns>String representation of the message</returns>
        public override string ToString() {
            using (var tmpLockObj = new LockAndElevate(this.Lock)) {
                return "Msg<" + this.sender + "::" + this.vid + ":" + this.msgid + (this.nRaw == 0 ? string.Empty : (", nRaw=" + this.nRaw)) + ((this.flags & SENTBYORACLE) == 0 ? string.Empty : " as ORACLE") + ", dest=" + this.dest + (this.gaddr == null ? string.Empty : (", gaddr=" + this.gaddr)) + (this.Lid <= 0 ? string.Empty : (", Logging-id=" + this.Lid)) + ", flags = {" + Msg.pflags(this.flags) + "}" + ((VsyncSystem.Debug & VsyncSystem.PPAYLOADS) != 0 ? ", Payload=" + PPayload(this.payload) : string.Empty) + ">";
            }
        }

        // Makes an effort to print the payload of a message
        internal static string PPayload(byte[] thePayload) {
            if ((VsyncSystem.Debug & VsyncSystem.PPAYLOADS) == 0) {
                return string.Empty;
            }

            object[] obs;
            try {
                obs = Msg.BArrayToObjects(thePayload);
            }
            catch {
                return "byte[" + thePayload.Length + "]";
            }

            string s = "  [ ";
            if (obs != null && obs.Length > 0) {
                if (Msg.CheckTypes(obs, typeof(Address), typeof(Address), typeof(int), typeof(int), typeof(long), typeof(int), typeof(byte), typeof(byte[]))) {
                    s += new Msg(thePayload).ToString();
                }
                else if (Msg.CheckTypes(obs, typeof(byte), typeof(byte), typeof(int), typeof(Address), typeof(Address), typeof(Address), typeof(int), typeof(byte[]))) {
                    // type, code, myCounter, Vsync.my_address, dest, gaddr, minStable, originalBuffer
                    s += "<" + Msg.mtypes[(byte)obs[0]] + ": dest " + (Address)obs[4] + ", gaddr " + (Address)obs[5] + ":: " + PPayload((byte[])obs[7]) + " > ";
                }
                else {
                    foreach (object o in obs) {
                        s += o.ToString() + " ";
                    }
                }
            }

            return s + "]";
        }

        internal long key(int flags) {
            if ((flags & Group.G_ISLARGE) != 0) {
                return this.msgid;
            }

            return (((long)this.vid) << 32) + this.msgid;
        }

        /// <exclude></exclude>
        public static bool operator <(Msg first, Msg second) {
            return Compare(first, second) < 0;
        }

        /// <exclude></exclude>
        public static bool operator >(Msg first, Msg second) {
            return Compare(first, second) > 0;
        }

        /// <exclude></exclude>
        public static bool operator <=(Msg first, Msg second) {
            return Compare(first, second) <= 0;
        }

        /// <exclude></exclude>
        public static bool operator >=(Msg first, Msg second) {
            return Compare(first, second) >= 0;
        }

        /// <exclude></exclude>
        public static bool operator ==(Msg first, Msg second) {
            return Compare(first, second) == 0;
        }

        /// <exclude></exclude>
        public static bool operator !=(Msg first, Msg second) {
            return Compare(first, second) != 0;
        }

        /// <summary>
        /// For implementation of the IComparable API
        /// </summary>
        public static int Compare(Msg first, Msg second) {
            if (object.ReferenceEquals(first, second)) {
                return 0;
            }

            if (object.ReferenceEquals(first, null)) {
                return -1;
            }

            if (object.ReferenceEquals(second, null)) {
                return 1;
            }

            int comparison = first.vid.CompareTo(second.vid);
            if (comparison != 0) {
                return comparison;
            }

            comparison = first.msgid.CompareTo(second.msgid);
            if (comparison != 0) {
                return comparison;
            }

            comparison = first.sender.GetHashCode().CompareTo(second.sender.GetHashCode());
            return comparison;
        }

        /// <summary>
        /// For implementation of the IComparable API
        /// </summary>
        public int CompareTo(object other) {
            return Compare(this, other as Msg);
        }

        /// <summary>
        /// For implementation of the IComparable API
        /// </summary>
        public int CompareTo(Msg other) {
            return Compare(this, other);
        }

        /// <summary>
        /// For implementation of the IEquatable API
        /// </summary>
        public override bool Equals(object other) {
            return Compare(this, other as Msg) == 0;
        }

        /// <summary>
        /// For implementation of the IEquatable API
        /// </summary>
        public bool Equals(Msg other) {
            return Compare(this, other) == 0;
        }

        /// <summary>
        /// For implementation of the IComparable API
        /// </summary>
        public override int GetHashCode() {
            return this.sender.GetHashCode() + (this.vid * 37) + (this.msgid * 11) + ((this.flags & SENTBYORACLE) * 7);
        }

        internal const byte ADDRESS = 0xFF;

        internal const byte ADDRESSA = 0xFE;

        internal const byte INT16 = 0xFD;

        internal const byte INT16A = 0xFC;

        internal const byte INT32 = 0xFB;

        internal const byte INT32A = 0xFA;

        internal const byte INT2D = 0xF9;

        internal const byte INT64 = 0xF8;

        internal const byte INT64A = 0xF7;

        internal const byte BYTE = 0xF6;

        internal const byte BYTEA = 0xF5;

        internal const byte BOOL = 0xF4;

        internal const byte BOOLA = 0xF3;

        internal const byte STRING = 0xF2;

        internal const byte STRINGA = 0xF1;

        internal const byte FLOAT = 0xF0;

        internal const byte FLOATA = 0xEF;

        internal const byte FLOAT2D = 0xEE;

        internal const byte DOUBLE = 0xED;

        internal const byte DOUBLEA = 0xEC;

        internal const byte DOUBLE2D = 0xEB;

        internal const byte CHAR = 0xEA;

        internal const byte CHARA = 0xE9;

        internal const byte UINT16 = 0xE8;

        internal const byte UINT16A = 0xE7;

        internal const byte UINT32 = 0xE6;

        internal const byte UINT32A = 0xE5;

        internal const byte UINT64 = 0xE4;

        internal const byte UINT64A = 0xE3;

        internal const byte MESSAGE = 0xE2;

        internal const byte VIEW = 0xE1;

        internal const byte VIEWDELTA = 0xE0;

        internal const byte NESTED = 0xDF;

        internal const byte NESTED0 = 0xDE;

        internal const byte NULL = 0xDD;

        internal const byte UNSTABLE = 0xDC;

        internal const byte TOKENINFO = 0xDB;

        internal const byte GRPAIR = 0xDA;

        internal const byte FLSHAGGKEY = 0xD0;

        internal const byte BVS = 0xD9;

        internal const byte LOCKINFO = 0xD7;

        internal const byte KEYVALUEP = 0xD6;

        internal const byte LIST = 0xD5;

        internal const byte QUERYKEY = 0xD4;

        internal const byte DHTITEM = 0xD3;

        internal const byte OSSPQ = 0xD2;

        internal const byte LISTO = 0xD1;

        internal const byte OOBREPINFO = 0xCF;

        internal const byte LOCKREQ = 0xCE;

        internal const byte IPADDR = 0xCD;

        internal const byte IPADDRA = 0xCC;

        internal const byte UNDEF = 0xCB;

        // Larger than SYSTEM reserved
        internal const byte SYSTEM = 0xCF;

        internal static Dictionary<Type, byte> UserDefinedTypesList;

        internal static UDT[] UserDefinedTypesTable = new UDT[0xFF];

        internal static LockObject UDTLock = new LockObject("UDTLock");

        internal static void Initialize() {
            if (UserDefinedTypesList != null) {
                return;
            }

            // Initializes the myTypes table and registers "Msg" as a user-defined type
            UserDefinedTypesList = new Dictionary<Type, byte>(256);

            // These types support value, vector and 2-D arrays
            UserDefinedTypesList[typeof(int)] = INT32;
            UserDefinedTypesList[typeof(int[])] = INT32A;
            UserDefinedTypesList[typeof(int[,])] = INT2D;
            UserDefinedTypesList[typeof(float)] = FLOAT;
            UserDefinedTypesList[typeof(float[])] = FLOATA;
            UserDefinedTypesList[typeof(float[,])] = FLOAT2D;
            UserDefinedTypesList[typeof(double)] = DOUBLE;
            UserDefinedTypesList[typeof(double[])] = DOUBLEA;
            UserDefinedTypesList[typeof(double[,])] = DOUBLE2D;

            // These support just values and vectors
            UserDefinedTypesList[typeof(short)] = INT16;
            UserDefinedTypesList[typeof(short[])] = INT16A;
            UserDefinedTypesList[typeof(long)] = INT64;
            UserDefinedTypesList[typeof(long[])] = INT64A;
            UserDefinedTypesList[typeof(byte)] = BYTE;
            UserDefinedTypesList[typeof(byte[])] = BYTEA;
            UserDefinedTypesList[typeof(bool)] = BOOL;
            UserDefinedTypesList[typeof(bool[])] = BOOLA;
            UserDefinedTypesList[typeof(string)] = STRING;
            UserDefinedTypesList[typeof(string[])] = STRINGA;
            UserDefinedTypesList[typeof(char)] = CHAR;
            UserDefinedTypesList[typeof(char[])] = CHARA;
            UserDefinedTypesList[typeof(ushort)] = UINT16;
            UserDefinedTypesList[typeof(ushort[])] = UINT16A;
            UserDefinedTypesList[typeof(uint)] = UINT32;
            UserDefinedTypesList[typeof(uint[])] = UINT32A;
            UserDefinedTypesList[typeof(ulong)] = UINT64;
            UserDefinedTypesList[typeof(ulong[])] = UINT64A;
            UserDefinedTypesList[typeof(Address)] = ADDRESS;
            UserDefinedTypesList[typeof(Address[])] = ADDRESSA;
            UserDefinedTypesList[typeof(byte[][])] = BVS;
            UserDefinedTypesList[typeof(IPAddress)] = IPADDR;

            // System-defined Message type
            doRegisterType<Msg>(MESSAGE);
            doRegisterType<View>(VIEW);
        }

        static Msg() {
            Initialize();
        }

        internal class UDT {
            internal MarshallingMechanism mechanism;

            internal Type theType;

            internal MethodInfo theMarshaller;

            internal ConstructorInfo theConstructor;

            internal FieldInfo[] theFields;

            internal int index;

            internal UDT(MarshallingMechanism m, Type t, MethodInfo mi, ConstructorInfo ci, FieldInfo[] flds, int idx) {
                this.mechanism = m;
                this.theType = t;
                this.theMarshaller = mi;
                this.theConstructor = ci;
                this.theFields = flds;
                this.index = idx;
            }
        }

        /// <summary>
        /// Registers a user-defined class to be marshalled into and out of byte vectors for transmission.
        /// </summary>
        /// <remarks>
        /// A user defined type must be register itself with Vsync via a call to Msg.RegisterType prior to the first use.  
        /// There are three subcases.  If the class has an [AutoMarshalled] attribute then Vsync will automatically scan the object
        /// instance, creating a vector of objects from the public fields, and then invoking <see cref="Msg.toBArray()"/>.
        /// For incoming data, Vsync uses <see cref="Msg.BArrayToObjects(byte[])"/> to decode the byte[] representation into an object
        /// vector, then assigns the objects to the corresponding public fields, in order.
        /// In the second case, if the class has a [ProtoContract] attribute then Google's Protocol Buffers via protobuf-net will be used.
        /// See the following for documentation:
        /// <see url="http://code.google.com/p/protobuf-net/wiki/GettingStarted">protobuf-net: Getting Started</see>
        /// <see url="http://www.codeproject.com/Articles/642677/Protobuf-net-the-unofficial-manual">protobuf-net: the unofficial manual</see>
        /// The third case instead implements the ISelfMarshalled interface in the the user defined type.
        ///       public byte[] toBArray():       converts "this" to a byte array, perhaps using Msg.toBArray(list of objects) for help
        ///       public class-name(object[] obs): a constructor that, given an object vector, converts it back to an instance of class-name
        /// </remarks>
        ///       
        /// <seealso cref="Msg.toBArray(object[])"/> and <seealso cref="Msg.BArrayToObjects(byte[])"/>
        /// <param name="TID">The type ID.</param>
        /// <typeparam name="T">The type.</typeparam>
        public static void RegisterType<T>(byte TID) {
            if (TID >= SYSTEM) {
                throw new ArgumentOutOfRangeException("TID", "Msg.RegisterType: Invalid TID.");
            }

            doRegisterType<T>(TID);
        }

        /// <summary>
        /// Registers a user-defined class to be marshalled into and out of byte vectors for transmission.
        /// </summary>
        /// <remarks>
        /// A user defined type must be register itself with Vsync via a call to Msg.RegisterType prior to the first use.  
        /// There are three subcases.  If the class has an [AutoMarshalled] attribute then Vsync will automatically scan the object
        /// instance, creating a vector of objects from the public fields, and then invoking <see cref="Msg.toBArray()"/>.
        /// For incoming data, Vsync uses <see cref="Msg.BArrayToObjects(byte[])"/> to decode the byte[] representation into an object
        /// vector, then assigns the objects to the corresponding public fields, in order.
        /// In the second case, if the class has a [ProtoContract] attribute then Google's Protocol Buffers via protobuf-net will be used.
        /// See the following for documentation:
        /// <see url="http://code.google.com/p/protobuf-net/wiki/GettingStarted">protobuf-net: Getting Started</see>
        /// <see url="http://www.codeproject.com/Articles/642677/Protobuf-net-the-unofficial-manual">protobuf-net: the unofficial manual</see>
        /// The third case instead implements the ISelfMarshalled interface in the the user defined type.
        ///       public byte[] toBArray():       converts "this" to a byte array, perhaps using Msg.toBArray(list of objects) for help
        ///       public class-name(object[] obs): a constructor that, given an object vector, converts it back to an instance of class-name
        /// </remarks>
        ///       
        /// <seealso cref="Msg.toBArray(object[])"/> and <seealso cref="Msg.BArrayToObjects(byte[])"/>
        /// <param name="type">The type.</param>
        /// <param name="TID">The type ID.</param>
        public static void RegisterType(Type type, byte TID) {
            if (TID >= SYSTEM) {
                throw new ArgumentOutOfRangeException("TID", "Msg.RegisterType: Invalid TID.");
            }

            doRegisterType(type, TID);
        }

        internal static void doRegisterType<T>(byte TID) {
            doRegisterType(typeof(T), TID);
        }

        internal static void doRegisterType(Type type, byte TID) {
            using (var tmpLockObj = new LockAndElevate(UDTLock)) {
                if (UserDefinedTypesTable[TID] != null) {
                    throw new VsyncException("Attempt to re-register Vsync.Types[" + TID + "] as type " + type);
                }

                if (typeof(ISelfMarshalled).IsAssignableFrom(type)) {
                    ConstructorInfo constructorInfo = type.GetConstructor(new[] { typeof(byte[]) });
                    if (constructorInfo == null || !constructorInfo.IsPublic) {
                        throw new VsyncException("Msg.RegisterType: Can't find public constructor for " + type + "(byte[])");
                    }

                    MethodInfo methodInfo = type.GetMethod("toBArray", BindingFlags.Instance | BindingFlags.Public);
                    UserDefinedTypesTable[TID] = new UDT(MarshallingMechanism.SelfMarshalled, type, methodInfo, constructorInfo, null, TID);
                }
                else {
                    MarshallingMechanism marshallingMechanism = MarshallingMechanism.None;
                    object[] attributes = type.GetCustomAttributes(true);
                    foreach (object attribute in attributes) {
                        if (attribute is AutoMarshalledAttribute) {
                            marshallingMechanism = MarshallingMechanism.AutoMarshalled;
                            break;
                        }
#if PROTOCOL_BUFFERS

                        if (attribute is ProtoContractAttribute)
                        {
                            marshallingMechanism = MarshallingMechanism.ProtocolBuffers;
                            break;
                        }
#endif
                    }

                    // We need to work out which method we are marshalling via and handle this appropriately here...
                    switch (marshallingMechanism) {
                        case MarshallingMechanism.None:
                            throw new VsyncException("Msg.RegisterType: Type " + type + " is not annotated with the AutoMarshalled or ProtoContract attribute, nor does it implement ISelfMarshalled.");
                        case MarshallingMechanism.AutoMarshalled:
                            ConstructorInfo theConstructor = type.GetConstructor(Type.EmptyTypes);
                            if (theConstructor == null || !theConstructor.IsPublic) {
                                throw new VsyncException("Msg.RegisterType: Can't find public constructor for auto-marshalled type with signature " + type + "()");
                            }

                            FieldInfo[] fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public);
                            if (fields.Length == 0) {
                                throw new VsyncException("Msg.RegisterType: Class " + type + " has no public instance fields.");
                            }

                            UserDefinedTypesTable[TID] = new UDT(marshallingMechanism, type, null, theConstructor, fields, TID);
                            break;
                        case MarshallingMechanism.ProtocolBuffers:
                            UserDefinedTypesTable[TID] = new UDT(marshallingMechanism, type, null, null, null, TID);
                            break;
                        default:
                            throw new VsyncException("Unexpected marshalling mechanism.");
                    }
                }

                UserDefinedTypesList[type] = TID;
            }
        }

        internal static bool CheckTypes(object[] objs, params Type[] types) {
            if (objs.Length != types.Length) {
                return false;
            }

            for (int idx = 0; idx < objs.Length; idx++) {
                if (objs[idx].GetType() != types[idx]) {
                    return false;
                }
            }

            return true;
        }

        internal static void ConfirmRegistered(Type T) {
            if (T.IsArray) {
                T = T.GetElementType();
            }
            else if (T.IsGenericType) {
                T = T.GetGenericTypeDefinition();
            }

            if (UserDefinedTypesList.ContainsKey(T)) {
                return;
            }

            throw new VsyncException("Aggregator<" + T + ">: type must be serializable via Vsync.Msg (did you forget to call Vsync.Msg.RegisterType?)");
        }

        internal static bool IsAscii(string s) {
            foreach (char c in s) {
                int asInt = c;
                if (asInt < 1 || asInt > 127) {
                    return false;
                }
            }

            return true;
        }

        internal static bool IsAscii(byte[] bv, int off, int len) {
            for (int idx = off; len-- > 0; idx++) {
                byte b = bv[idx];
                if (b < 1 || b > 127) {
                    return false;
                }
            }

            return true;
        }

        internal static byte[] StringToBytes(string s) {
            if (IsAscii(s)) {
                return Encoding.ASCII.GetBytes(s);
            }

            return Encoding.Unicode.GetBytes(s);
        }

        internal static string BytesToString(byte[] b, int off, int len) {
            if (IsAscii(b, off, len)) {
                return Encoding.ASCII.GetString(b, off, len);
            }

            return Encoding.Unicode.GetString(b, off, len);
        }

        // Used to preserve strong typing "to the last step"
        internal static byte[] NewMsgAsBArray(Address sender, Address gaddr, int vid, int msgid, long Lid, int nRaw, int UID, byte flag, byte[] buffer) {
            return toBArray(sender, gaddr, vid, msgid, Lid, nRaw, UID, flag, buffer);
        }

        /// <summary>
        /// Marshalls a vector of objects into a byte[] vector for storage or transmission
        /// </summary>
        /// <param name="obs">the vector of objects</param>
        /// <returns>a byte[] vector containing a concise encoding of the objects</returns>
        public static byte[] toBArray(params object[] obs) {
            return _toBArray(true, true, obs);
        }

        internal static byte[] ReplyToBArray(params object[] obs) {
            return _toBArray(true, false, obs);
        }

        private static byte[] _toBArray(bool topLevel, object[] obs) {
            return _toBArray(topLevel, true, obs);
        }

        // At top level, signs the byte[] array; for inner-level leaves zeros.
        private static byte[] _toBArray(bool topLevel, bool unpackInner, object[] obs) {
            if (unpackInner && obs.Length == 1 && obs[0].GetType() == typeof(object[])) {
                obs = (object[])obs[0];
            }

            List<byte[]> contents = new List<byte[]>();
            int payloadLen = 0;
            int ctindex = 0;
            byte[] ctypes = new byte[obs.Length];
            foreach (object o in obs) {
                if (o == null) {
                    throw new VsyncException("Vsync unable to mashall object to byte stream (null reference: lacks type information)");
                }

                Type t = o.GetType();
                Type gt = t.IsGenericType ? t.GetGenericTypeDefinition() : null;
                bool isArray = false;
                byte code = UNDEF;
                if (o == null) {
                    code = NULL;
                }
                else if (gt != null) {
                    if (gt == typeof(KeyValuePair<,>)) {
                        code = KEYVALUEP;
                    }
                    else if (gt == typeof(List<>)) {
                        code = LIST;
                    }
                    else if (gt == typeof(QueryKey<>)) {
                        code = QUERYKEY;
                    }
                    else if (t.GetInterfaces().Any(it => it.IsGenericType && it.GetGenericTypeDefinition() == typeof(IEnumerable<>))) {
                        Vsync.WriteLine("WARNING: Vsync can't serialize IEnumerable<T>; use List<T> or Array<T> instead");
                    }
                }
                else {
                    UserDefinedTypesList.TryGetValue(t, out code);
                }

                switch (code) {
                    case NULL: {
                            byte[] nb = new byte[4];
                            ctypes[ctindex++] = NULL;
                            contents.Add(nb);
                            payloadLen += 4;
                            continue;
                        }

                    case INT16: {
                            short value = (short)o;
                            byte[] ba = new byte[2];
                            int index = 0;
                            ba[index++] = (byte)((value >> 8) & 0xFF);
                            ba[index] = (byte)(value & 0xFF);
                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = INT16;
                            continue;
                        }

                    case INT16A: {
                            short[] values = (short[])o;
                            byte[] ba = new byte[2 * values.Length];
                            int index = 0;
                            foreach (short value in values) {
                                ba[index++] = (byte)((value >> 8) & 0xFF);
                                ba[index++] = (byte)(value & 0xFF);
                            }

                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = INT16A;
                            continue;
                        }

                    case UINT16: {
                            ushort value = (ushort)o;
                            byte[] ba = new byte[2];
                            int index = 0;
                            ba[index++] = (byte)((value >> 8) & 0xFF);
                            ba[index] = (byte)(value & 0xFF);
                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = UINT16;
                            continue;
                        }

                    case UINT16A: {
                            ushort[] values = (ushort[])o;
                            byte[] ba = new byte[2 * values.Length];
                            int index = 0;
                            foreach (ushort value in values) {
                                ba[index++] = (byte)((value >> 8) & 0xFF);
                                ba[index++] = (byte)(value & 0xFF);
                            }

                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = UINT16A;
                            continue;
                        }

                    case INT32: {
                            int value = (int)o;
                            byte[] ba = new byte[4];
                            int index = 0;
                            ba[index++] = (byte)((value >> 24) & 0xFF);
                            ba[index++] = (byte)((value >> 16) & 0xFF);
                            ba[index++] = (byte)((value >> 8) & 0xFF);
                            ba[index] = (byte)(value & 0xFF);
                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = INT32;
                            continue;
                        }

                    case INT32A: {
                            int[] values = (int[])o;
                            byte[] ba = new byte[4 * values.Length];
                            int index = 0;
                            foreach (int value in values) {
                                ba[index++] = (byte)((value >> 24) & 0xFF);
                                ba[index++] = (byte)((value >> 16) & 0xFF);
                                ba[index++] = (byte)((value >> 8) & 0xFF);
                                ba[index++] = (byte)(value & 0xFF);
                            }

                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = INT32A;
                            continue;
                        }

                    case UINT32: {
                            uint value = (uint)o;
                            byte[] ba = new byte[4];
                            int index = 0;
                            ba[index++] = (byte)((value >> 24) & 0xFF);
                            ba[index++] = (byte)((value >> 16) & 0xFF);
                            ba[index++] = (byte)((value >> 8) & 0xFF);
                            ba[index] = (byte)(value & 0xFF);
                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = UINT32;
                            continue;
                        }

                    case UINT32A: {
                            uint[] values = (uint[])o;
                            byte[] ba = new byte[4 * values.Length];
                            int index = 0;
                            foreach (uint value in values) {
                                ba[index++] = (byte)((value >> 24) & 0xFF);
                                ba[index++] = (byte)((value >> 16) & 0xFF);
                                ba[index++] = (byte)((value >> 8) & 0xFF);
                                ba[index++] = (byte)(value & 0xFF);
                            }

                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = UINT32A;
                            continue;
                        }

                    case INT2D: {
                            int[,] Ivalues = (int[,])o;
                            using (MemoryStream memStream = new MemoryStream(100)) {
                                BinaryFormatter myBf = new BinaryFormatter();
                                myBf.Serialize(memStream, Ivalues);
                                memStream.Seek(0, SeekOrigin.Begin);
                                byte[] ba = new byte[memStream.Length];
                                memStream.Read(ba, 0, (int)memStream.Length);
                                memStream.SetLength(0);
                                contents.Add(ba);
                                payloadLen += ba.Length;
                            }

                            ctypes[ctindex++] = INT2D;
                            continue;
                        }

                    case INT64: {
                            long value = (long)o;
                            byte[] ba = new byte[8];
                            int index = 0;
                            ba[index++] = (byte)((value >> 56) & 0xFF);
                            ba[index++] = (byte)((value >> 48) & 0xFF);
                            ba[index++] = (byte)((value >> 40) & 0xFF);
                            ba[index++] = (byte)((value >> 32) & 0xFF);
                            ba[index++] = (byte)((value >> 24) & 0xFF);
                            ba[index++] = (byte)((value >> 16) & 0xFF);
                            ba[index++] = (byte)((value >> 8) & 0xFF);
                            ba[index] = (byte)(value & 0xFF);
                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = INT64;
                            continue;
                        }

                    case INT64A: {
                            long[] values = (long[])o;
                            byte[] ba = new byte[8 * values.Length];
                            int index = 0;
                            foreach (long value in values) {
                                ba[index++] = (byte)((value >> 56) & 0xFF);
                                ba[index++] = (byte)((value >> 48) & 0xFF);
                                ba[index++] = (byte)((value >> 40) & 0xFF);
                                ba[index++] = (byte)((value >> 32) & 0xFF);
                                ba[index++] = (byte)((value >> 24) & 0xFF);
                                ba[index++] = (byte)((value >> 16) & 0xFF);
                                ba[index++] = (byte)((value >> 8) & 0xFF);
                                ba[index++] = (byte)(value & 0xFF);
                            }

                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = INT64A;
                            continue;
                        }

                    case UINT64: {
                            ulong value = (ulong)o;
                            byte[] ba = new byte[8];
                            int index = 0;
                            ba[index++] = (byte)((value >> 56) & 0xFF);
                            ba[index++] = (byte)((value >> 48) & 0xFF);
                            ba[index++] = (byte)((value >> 40) & 0xFF);
                            ba[index++] = (byte)((value >> 32) & 0xFF);
                            ba[index++] = (byte)((value >> 24) & 0xFF);
                            ba[index++] = (byte)((value >> 16) & 0xFF);
                            ba[index++] = (byte)((value >> 8) & 0xFF);
                            ba[index] = (byte)(value & 0xFF);
                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = UINT64;
                            continue;
                        }

                    case UINT64A: {
                            ulong[] values = (ulong[])o;
                            byte[] ba = new byte[8 * values.Length];
                            int index = 0;
                            foreach (ulong value in values) {
                                ba[index++] = (byte)((value >> 56) & 0xFF);
                                ba[index++] = (byte)((value >> 48) & 0xFF);
                                ba[index++] = (byte)((value >> 40) & 0xFF);
                                ba[index++] = (byte)((value >> 32) & 0xFF);
                                ba[index++] = (byte)((value >> 24) & 0xFF);
                                ba[index++] = (byte)((value >> 16) & 0xFF);
                                ba[index++] = (byte)((value >> 8) & 0xFF);
                                ba[index++] = (byte)(value & 0xFF);
                            }

                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = UINT64A;
                            continue;
                        }

                    case BYTE: {
                            byte[] ba = { (byte)o };
                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = BYTE;
                            continue;
                        }

                    case BYTEA: {
                            contents.Add((byte[])o);
                            payloadLen += ((byte[])o).Length;
                            ctypes[ctindex++] = BYTEA;
                            continue;
                        }

                    case BOOL: {
                            byte[] ba = { ((bool)o) ? (byte)0x1 : (byte)0x0 };
                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = BOOL;
                            continue;
                        }

                    case BOOLA: {
                            bool[] value = (bool[])o;
                            byte[] ba = BitsToBytes(value);
                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = BOOLA;
                            continue;
                        }

                    case CHAR: {
                            byte[] ba = { (byte)((char)o) };
                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = CHAR;
                            continue;
                        }

                    case CHARA: {
                            char[] value = (char[])o;
                            byte[] ba = new byte[value.Length + 1];
                            for (int i = 0; i < value.Length; i++) {
                                ba[i] = (byte)value[i];
                            }

                            ba[value.Length] = 0x00;
                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = CHARA;
                            continue;
                        }

                    case STRING: {
                            byte[] ba = StringToBytes((string)o);
                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = STRING;
                            continue;
                        }

                    case STRINGA: {
                            int len = 0;
                            int index = 0;
                            string[] values = (string[])o;
                            foreach (string value in values) {
                                if (value == null) {
                                    len += 1;
                                }
                                else {
                                    len += value.Length + 1;
                                }
                            }

                            byte[] ba = new byte[len];
                            foreach (string value in values) {
                                if (value != null) {
                                    for (int i = 0; i < value.Length; i++) {
                                        ba[index++] = (byte)value[i];
                                    }
                                }

                                ba[index++] = 0x00;
                            }

                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = STRINGA;
                            continue;
                        }

                    case FLOAT: {
                            float f = (float)o;
                            using (MemoryStream memStream = new MemoryStream(100)) {
                                BinaryFormatter myBf = new BinaryFormatter();
                                myBf.Serialize(memStream, f);
                                memStream.Seek(0, SeekOrigin.Begin);
                                byte[] ba = new byte[memStream.Length];
                                memStream.Read(ba, 0, (int)memStream.Length);
                                memStream.SetLength(0);
                                contents.Add(ba);
                                payloadLen += ba.Length;
                            }

                            ctypes[ctindex++] = FLOAT;
                            continue;
                        }

                    case FLOATA: {
                            float[] Fvalues = (float[])o;
                            using (MemoryStream memStream = new MemoryStream(100)) {
                                BinaryFormatter myBf = new BinaryFormatter();
                                myBf.Serialize(memStream, Fvalues);
                                memStream.Seek(0, SeekOrigin.Begin);
                                byte[] ba = new byte[memStream.Length];
                                memStream.Read(ba, 0, (int)memStream.Length);
                                memStream.SetLength(0);
                                contents.Add(ba);
                                payloadLen += ba.Length;
                            }

                            ctypes[ctindex++] = FLOATA;
                            continue;
                        }

                    case FLOAT2D: {
                            float[,] Fvalues = (float[,])o;
                            using (MemoryStream memStream = new MemoryStream(100)) {
                                BinaryFormatter myBf = new BinaryFormatter();
                                myBf.Serialize(memStream, Fvalues);
                                memStream.Seek(0, SeekOrigin.Begin);
                                byte[] ba = new byte[memStream.Length];
                                memStream.Read(ba, 0, (int)memStream.Length);
                                memStream.SetLength(0);
                                contents.Add(ba);
                                payloadLen += ba.Length;
                            }

                            ctypes[ctindex++] = FLOAT2D;
                            continue;
                        }

                    case DOUBLE: {
                            double f = (double)o;
                            using (MemoryStream memStream = new MemoryStream(100)) {
                                BinaryFormatter myBf = new BinaryFormatter();
                                myBf.Serialize(memStream, f);
                                byte[] ba = new byte[memStream.Length];
                                memStream.Seek(0, SeekOrigin.Begin);
                                memStream.Read(ba, 0, (int)memStream.Length);
                                memStream.SetLength(0);
                                contents.Add(ba);
                                payloadLen += ba.Length;
                            }

                            ctypes[ctindex++] = DOUBLE;
                            continue;
                        }

                    case DOUBLEA: {
                            double[] Fvalues = (double[])o;
                            using (MemoryStream memStream = new MemoryStream(100)) {
                                BinaryFormatter myBf = new BinaryFormatter();
                                myBf.Serialize(memStream, Fvalues);
                                memStream.Seek(0, SeekOrigin.Begin);
                                byte[] ba = new byte[memStream.Length];
                                memStream.Read(ba, 0, (int)memStream.Length);
                                memStream.SetLength(0);
                                contents.Add(ba);
                                payloadLen += ba.Length;
                            }

                            ctypes[ctindex++] = DOUBLEA;
                            continue;
                        }

                    case DOUBLE2D: {
                            double[,] Dvalues = (double[,])o;
                            using (MemoryStream memStream = new MemoryStream(100)) {
                                BinaryFormatter myBf = new BinaryFormatter();
                                myBf.Serialize(memStream, Dvalues);
                                memStream.Seek(0, SeekOrigin.Begin);
                                byte[] ba = new byte[memStream.Length];
                                memStream.Read(ba, 0, (int)memStream.Length);
                                memStream.SetLength(0);
                                contents.Add(ba);
                                payloadLen += ba.Length;
                            }

                            ctypes[ctindex++] = DOUBLE2D;
                            continue;
                        }

                    case ADDRESS: {
                            byte[] ba = ((Address)o).toBArray();
                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = ADDRESS;
                            continue;
                        }

                    case ADDRESSA: {
                            byte[] ba = Address.toBArray((Address[])o);
                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = ADDRESSA;
                            continue;
                        }

                    case BVS: {
                            int[] lens = new int[((byte[][])o).Length];
                            int idx = 0;
                            int totalBytes = 0;
                            foreach (byte[] bv in (byte[][])o) {
                                totalBytes += lens[idx++] = bv.Length;
                            }

                            byte[] bvs = new byte[totalBytes];
                            idx = 0;
                            foreach (byte[] bv in (byte[][])o) {
                                Buffer.BlockCopy(bv, 0, bvs, idx, Buffer.ByteLength(bv));
                                idx += bv.Length;
                            }

                            byte[] ba = _toBArray(false, new object[] { lens, bvs });
                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = BVS;
                            continue;
                        }

                    case IPADDR: {
                            byte[] ba = ((IPAddress)o).GetAddressBytes();
                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = IPADDR;
                            continue;
                        }

                    case IPADDRA: {
                            IPAddress[] ipa = (IPAddress[])o;
                            byte[] ba = new byte[4 * ipa.Length];
                            int index = 0;
                            for (int n = 0; n < ipa.Length; n++) {
                                byte[] ipb = ipa[n].GetAddressBytes();
                                ba[index++] = ipb[0];
                                ba[index++] = ipb[1];
                                ba[index++] = ipb[2];
                                ba[index++] = ipb[3];
                            }

                            contents.Add(ba);
                            payloadLen += ba.Length;
                            ctypes[ctindex++] = IPADDRA;
                            continue;
                        }

                    case KEYVALUEP: {
                            object key = o.GetType().GetMethod("get_Key").Invoke(o, new object[0]);
                            object value = o.GetType().GetMethod("get_Value").Invoke(o, new object[0]);
                            byte[] nb = _toBArray(false, false, new[] { key, value });
                            ctypes[ctindex++] = KEYVALUEP;
                            contents.Add(nb);
                            payloadLen += nb.Length;
                            continue;
                        }

                    case QUERYKEY: {
                            byte[] nb = ((QKD)o).ToBArray();
                            ctypes[ctindex++] = QUERYKEY;
                            contents.Add(nb);
                            payloadLen += nb.Length;
                            continue;
                        }

                    case LIST: {
                            List<byte[]> tmp = new List<byte[]>();
                            Type it = o.GetType().GetGenericArguments()[0];
                            byte[] nb;
                            bool empty = true;
                            foreach (object x in (IEnumerable)o) {
                                tmp.Add(_toBArray(false, false, new[] { x }));
                                empty = false;
                            }

                            if (!empty || it == typeof(object)) {
                                nb = _toBArray(false, false, new object[] { tmp.ToArray() });
                            }
                            else {
                                UserDefinedTypesList.TryGetValue(it, out code);
                                if (code == UNDEF || code == 0) {
                                    throw new VsyncException("Vsync is unable to marshall zero-length lists of type " + it + " @ " + Vsync.ExtractStackTrace());
                                }

                                nb = new[] { code };
                            }

                            ctypes[ctindex++] = it == typeof(object) ? LISTO : LIST;
                            contents.Add(nb);
                            payloadLen += nb.Length;
                            continue;
                        }

                    default: {
                            if (t.IsArray) {
                                isArray = true;
                                do {
                                    t = t.GetElementType();
                                }
                                while (t.IsArray);
                            }

                            UDT udt = null;
                            byte which;
                            bool fndT = false;
                            if (UserDefinedTypesList.TryGetValue(t, out which)) {
                                fndT = true;
                                udt = UserDefinedTypesTable[which];
                            }

                            if (fndT) {
                                // A type registered with Vsync
                                if (!isArray && udt != null) {
                                    MethodInfo mi = udt.theMarshaller;
                                    object[] args = new object[0];
                                    if ((VsyncSystem.Debug & VsyncSystem.CALLBACKS) != 0) {
                                        Group.ReportCb(t, o);
                                    }

                                    byte[] ba;
                                    switch (udt.mechanism) {
                                        case MarshallingMechanism.AutoMarshalled:
                                            // Generates a byte[] from the full set of public fields of the object
                                            FieldInfo[] theFields = UserDefinedTypesTable[which].theFields;
                                            object[] objects = new object[theFields.Length];
                                            int idx = 0;
                                            foreach (FieldInfo fi in theFields) {
                                                objects[idx++] = fi.GetValue(o);
                                            }

                                            ba = _toBArray(false, objects);
                                            break;
                                        case MarshallingMechanism.SelfMarshalled:
                                            ba = (byte[])mi.Invoke(o, args);
                                            break;
#if PROTOCOL_BUFFERS
                                        case MarshallingMechanism.ProtocolBuffers:
                                            using (MemoryStream memoryStream = new MemoryStream())
                                            {
                                                Serializer.NonGeneric.Serialize(memoryStream, o);
                                                ba = memoryStream.ToArray();
                                            }

                                            break;
#endif
                                        default:
                                            throw new VsyncException("Unexpected marshalling mechanism.");
                                    }

                                    contents.Add(ba);
                                    payloadLen += ba.Length;
                                    ctypes[ctindex++] = which;
                                    break;
                                }
                                else {
                                    // An array (easy) or an array of arrays (requires recursion)
                                    byte[] ba;
                                    if (((object[])o).Length > 0) {
                                        object[] objs = new object[((object[])o).Length];
                                        for (int i = 0; i < objs.Length; i++) {
                                            objs[i] = ((object[])o)[i];
                                        }

                                        ba = _toBArray(false, objs);
                                        contents.Add(ba);
                                        payloadLen += ba.Length;
                                        ctypes[ctindex++] = NESTED;
                                        break;
                                    }

                                    // Special case: a 0-length vector of a user-defined object type
                                    ctypes[ctindex++] = NESTED0;
                                    ba = new[] { which };
                                    contents.Add(ba);
                                    payloadLen += 1;
                                    break;
                                }
                            }

                            throw new VsyncException("Msg.toBArray is unable to marshall object of type " + o.GetType() + " (did you remember to call Msg.RegisterType?)");
                        }
                }
            }

            int payloadIdx = (ctypes.Length * 5) + 4;

            // The byte array is padded with a single-byte null, then length rounded up to a multiple of 8
            // the last byte will be incremented by Resend() each time it resends a serialized message, just to change the message
            // slightly
            int pln = 4 + payloadIdx + payloadLen + Vsync.VSYNC_MSGPADDING;
            pln = (pln + 7) & ~7;
            byte[] payload = new byte[pln];
            int off = 0;
            int coff = 0;
            payload[off] = (byte)((ctypes.Length >> 24) & 0xFF);
            ++off;
            payload[off] = (byte)((ctypes.Length >> 16) & 0xFF);
            ++off;
            payload[off] = (byte)((ctypes.Length >> 8) & 0xFF);
            ++off;
            payload[off] = (byte)(ctypes.Length & 0xFF);
            ++off;
            foreach (byte[] pbs in contents) {
                int len = pbs.Length;
                payload[off] = ctypes[coff];
                ++off;
                ++coff;
                payload[off] = (byte)((len >> 24) & 0xFF);
                ++off;
                payload[off] = (byte)((len >> 16) & 0xFF);
                ++off;
                payload[off] = (byte)((len >> 8) & 0xFF);
                ++off;
                payload[off] = (byte)(len & 0xFF);
                ++off;
                for (int i = 0; i < len; i++) {
                    payload[payloadIdx++] = pbs[i];
                }
            }

            if (Vsync.VSYNC_SIGS && topLevel) {
                using (MemoryStream ms = new MemoryStream(payload, 0, pln - Vsync.VSYNC_MSGPADDING))
                using (HMAC hm = new HMACSHA256(new byte[] { 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11 }))
                using (var tmpLockObj = new LockAndElevate(VerifyLock)) {
                    byte[] hash = hm.ComputeHash(ms);
                    if (Vsync.VSYNC_AES != null) {
                        hash = sign(hash);
                    }

                    if (hash.Length != Vsync.VSYNC_MSGPADDING) {
                        throw new VsyncException("signature len");
                    }

                    payloadIdx = payload.Length - hash.Length;
                    for (int i = 0; i < hash.Length; i++) {
                        payload[payloadIdx++] = hash[i];
                    }
                }
            }

            return payload;
        }

        /// <summary>
        /// InvokeFromBArrays first demarshalls the given byte vectors to create a single new vector,
        /// each entry in which is a vector of objects (<seealso cref="MsgToObjects(Msg, Type[])"/>).  It then sorts and merges these to produce one vector per object type,
        /// and finally invokes the method specified by the delegate argument, after checking that the types of the object vectors match the types of the parameters to the method.
        /// 
        /// For example, if you have 4 messages, each containing an int and a double, your delegate will be involked with two arguments, the first being a vector of four ints,
        /// and the second a vector of 4 doubles. Throws an VsyncException if any mismatch is detected. 
        /// </summary>
        /// <param name="barrays">byte[] vectors from which to extract objects</param>
        /// <param name="del">delegate to a method that has vector parameters matching those of the expected objects</param>
        public static void InvokeFromBArrays(List<byte[]> barrays, Delegate del) {
            if ((VsyncSystem.Debug & VsyncSystem.MESSAGELAYER) != 0) {
                Vsync.WriteLine("InvokeFromBArrays(byte[" + barrays.Count + "][] delegate " + del);
            }

            Type[] types = GetTypes(del);
            doInvokeArray(del, barrays, types);
        }

        internal static void BArrayToVals(object[] resRefs, byte[] barray) {
            object[] obs = Msg.BArrayToObjects(barray);
            if (obs.Length != resRefs.Length) {
                if (resRefs.Length == 0) {
                    // Special case: we allow the caller to ignore replies if he just isn't interested
                    return;
                }

                throw new VsyncException("Vsync.BArrayToVals: response has different number of objects than expected");
            }

            for (int j = 0; j < obs.Length; j++) {
                if (obs[j] != null && obs[j].GetType() != resRefs[j].GetType()) {
                    throw new VsyncException("Vsync.BArrayToVals: " + j + "'th object is of type type " + obs[j].GetType() + " but expected " + resRefs[j].GetType());
                }

                if (obs[j] != null) {
                    ((Array)resRefs[j]).SetValue(obs[j], 0);
                }
            }
        }

        internal static void BArraysToLists(object[] resRefs, List<byte[]> barrays) {
            for (int i = 0; i < barrays.Count; i++) {
                object[] obs = Msg.BArrayToObjects(barrays[i]);

                // This garish code snippet compensates for a C# "feature" (aka bug) that causes g.Reply(myClass[]) to be treated like g.Reply(myClass0, myClass1, ...) 
                Type gat = null;
                if (resRefs.Length == 1) {
                    Type[] ga = resRefs[0].GetType().GetGenericArguments();
                    if (ga != null && ga.Length == 1) {
                        gat = ga[0];
                    }
                }

                if (obs.Length != resRefs.Length || (obs.Length > 0 && gat != null && !obs[0].GetType().IsArray && gat.IsArray)) {
                    Type t;
                    if (obs.Length > 0 && resRefs.Length == 1 && AllHaveSameType(obs, out t)) {
                        // This is the case C# (deliberately) misreports to Vsync; change the thing back into a vector.
                        object[] newobs = (object[])Array.CreateInstance(t, obs.Length);
                        int idx = 0;
                        foreach (object o in obs) {
                            newobs[idx++] = o;
                        }

                        obs = new object[] { newobs };
                    }
                    else
                        throw new VsyncException("Vsync Reply() had the wrong number of objects (expected " + resRefs.Length + " but found " + obs.Length + ")");
                }

                for (int j = 0; j < obs.Length; j++) {
                    if (obs[j] != null) {
                        try {
                            ((IList)resRefs[j]).Add(obs[j]);
                        }
                        catch (ArgumentException) {
                            throw new VsyncException("Vsync Reply() types didn't match expected types (List was of type " + resRefs[j].GetType() + " but reply type was " + obs[j].GetType() + ")");
                        }
                    }
                }
            }
        }

        internal static string typesAsString(object[] obs) {
            string str = "{ ";
            return str + "}";
        }

        internal static bool AllHaveSameType(object[] obs, out Type t) {
            t = null;
            bool allHaveSameType = true;
            foreach (object o in obs) {
                if (t == null) {
                    t = o.GetType();
                }
                else if (!(allHaveSameType = t == o.GetType())) {
                    break;
                }
            }

            return allHaveSameType;
        }

        /// <summary>
        /// InvokeFromBArray first demarshalls the given byte vector into a vector of objects (<seealso cref="MsgToObjects(Msg, Type[])"/>) and then 
        /// invokes the method specified by the delegate argument, after checking that the types of the objects match the types of the parameters to the method.
        /// Throws an VsyncException if any mismatch is detected
        /// </summary>
        /// <param name="barray"></param>
        /// <param name="del"></param>
        /// <returns>True on success, false for mismatched types</returns>
        public static bool InvokeFromBArray(byte[] barray, Delegate del) {
            Type[] types = GetTypes(del);
            return doInvokeSingle(del, barray, types);
        }

        /// <summary>
        /// When involked for Vsync.Msg m, m.InvokeFromMsgs(Msg[] msgs, delegate) demarshalls the payloads of the vector of messages msgs to create
        /// a vector, each entry in which is a vector of objects (<seealso cref="MsgToObjects(Msg, Type[])"/>).  It then generates one vector per object type,
        /// and finally invokes the method specified by the delegate argument, after checking that the types of the object vectors match the types of the parameters to the method.
        /// 
        /// For example, if you have 4 messages, each containing an int and a double, your delegate will be involked with two arguments, the first being a vector of four ints,
        /// and the second a vector of 4 doubles. Throws an VsyncException if any mismatch is detected. 
        /// </summary>
        /// <param name="msgs"></param>
        /// <param name="del"></param>
        public static void InvokeFromMsgs(Msg[] msgs, Delegate del) {
            Type[] types = GetTypes(del);
            List<byte[]> barrays = new List<byte[]>();
            for (int i = 0; i < msgs.Length; i++) {
                barrays[i] = msgs[i].payload;
            }

            doInvokeArray(del, barrays, types);
        }

        /// <summary>
        /// When involked for Vsync.Msg m, m.InvokeFromMsg(delegate) demarshalls the payload of m into a vector of objects (<seealso cref="MsgToObjects(Msg, Type[])"/>) and then 
        /// invokes the method specified by the delegate argument, after checking that the types of the objects match the types of the parameters to the method.
        /// Throws an VsyncException if any mismatch is detected
        /// </summary>
        /// <param name="del"></param>
        public void InvokeFromMsg(Delegate del) {
            Type[] types = GetTypes(del);
            doInvokeSingle(del, this.payload, types);
        }

        internal static Type[] GetTypes(Delegate d) {
            ParameterInfo[] pi = d.Method.GetParameters();
            Type[] types = new Type[pi.Length];
            for (int i = 0; i < pi.Length; i++) {
                types[i] = pi[i].ParameterType;
            }

            return types;
        }

        internal static bool doInvokeSingle(Delegate del, byte[] barray, Type[] types) {
            object[] theObs = new object[types.Length];
            object[] obs = BArrayToObjects(true, barray, types);
            Callable cb = new Callable(del);

            if (theObs.Length != obs.Length) {
                return false;
            }

            for (int j = 0; j < obs.Length; j++) {
                if (obs[j] != null && obs[j].GetType() != types[j]) {
                    return false;
                }
            }

            if ((VsyncSystem.Debug & VsyncSystem.CALLBACKS) != 0) {
                Group.ReportCb(cb, obs);
            }

            cb.doUpcall(obs);
            return true;
        }

        internal static void doInvokeArray(Delegate del, List<byte[]> barrays, Type[] types) {
            Callable cb = new Callable(del);
            object[] theObs = new object[types.Length];
            for (int i = 0; i < types.Length; i++) {
                if (types[i].IsArray) {
                    theObs[i] = Array.CreateInstance(types[i].GetElementType(), barrays.Count);
                }
                else {
                    throw new VsyncException(types[i] + " is a unit (array required)");
                }
            }

            for (int i = 0; i < barrays.Count; i++) {
                object[] obs = BArrayToObjects(barrays[i]);
                for (int j = 0; j < obs.Length; j++) {
                    if (obs[j] != null && obs[j].GetType() != types[j].GetElementType()) {
                        throw new VsyncException("Vsync.doInvokeArray: " + j + "'th object in BArray " + i + " is of type type " + obs[j].GetType() + " but expected " + types[j]);
                    }

                    if (obs[j] != null) {
                        ((Array)theObs[j]).SetValue(obs[j], i);
                    }
                }
            }

            if ((VsyncSystem.Debug & VsyncSystem.CALLBACKS) != 0) {
                Group.ReportCb(cb, theObs);
            }

            cb.doUpcall(theObs);
        }

        /// <summary>
        /// Given an Vsync Msg object, converts its payload to a vector of objects, checking that they have the given types,
        /// and returns that vector.  <seealso cref="Msg.BArrayToObjects(byte[], Type[])"/>
        /// </summary>
        /// <param name="m">Message from which to extract objects</param>
        /// <param name="types">Vector of types expected</param>
        /// <returns></returns>
        public static object[] MsgToObjects(Msg m, params Type[] types) {
            using (var tmpLockObj = new LockAndElevate(m.Lock)) {
                object[] obs = m.myObs ?? BArrayToObjects(m.payload);
                if (obs.Length != types.Length) {
                    throw new VsyncException("Msg.BArrayToObjects: BArray encodes wrong number of objects (found " + obs.Length + ", expected " + types.Length + ")");
                }

                for (int i = 0; i < obs.Length; i++) {
                    if (obs[i] != null && obs[i].GetType() != types[i]) {
                        throw new VsyncException("Msg.BArrayToObjects: " + i + "'th object is of type type " + obs[i].GetType() + " but expected " + types[i]);
                    }
                }

                m.myObs = obs;
                return obs;
            }
        }

        /// <summary>
        /// Given an Vsync Msg object, converts its payload to a vector of objects and returns that vector.  <seealso cref="Msg.BArrayToObjects(byte[])"/>
        /// </summary>
        /// <param name="m">Message from which to extract objects</param>
        /// <returns></returns>
        public static object[] MsgToObjects(Msg m) {
            using (var tmpLockObj = new LockAndElevate(m.Lock)) {
                if (m.myObs != null) {
                    return m.myObs;
                }

                return m.myObs = BArrayToObjects(m.payload);
            }
        }

        /// <summary>
        /// Given a byte[] vector and an array of types, returns an object[] array by demarshalling the byte vector and checks
        /// to confirm that the types match properly.  Throws an VsyncException if the number of objects encoded by the byte vector
        /// is incorrect, or if the types don't have an exact, one-to-one match, with the requested types.  This last point
        /// can be a bit of a surprise: subtyping relationships aren't supported in this interface, so the types must be exact
        /// matches or are considered to be unmatched.  For example, if the class Dog extends class Animal, and the byte[] encodes
        /// a Dog object, you must extract it as a Dog object, not as an Animal object, or a general object.
        /// 
        /// An overload is available for demarshalling vectors containing object types that can't be predicted before the demarshalling
        /// is performed.  However, even those types do need to be known to Vsync, either as built-in types Vsync supports, or by registering them.
        /// <seealso cref="Msg.RegisterType"/>
        /// </summary>
        /// <param name="payload">byte[] vector from which to extract object</param>
        /// <param name="types">Types expected</param>
        /// <returns></returns>
        public static object[] BArrayToObjects(byte[] payload, params Type[] types) {
            return BArrayToObjects(false, payload, types);
        }

        internal static object[] BArrayToObjects(bool inhibitException, byte[] payload, params Type[] types) {
            object[] obs = BArrayToObjects(payload);
            if (obs.Length != types.Length || (types.Length == 1 && types[0].IsArray && obs.Length == 1 && !obs[0].GetType().IsArray)) {
                if (types.Length == 1 && types[0].IsArray) {
                    bool allSame = true;
                    foreach (object o in obs) {
                        if (o.GetType() != types[0].GetElementType()) {
                            allSame = false;
                            break;
                        }
                    }

                    if (allSame) {
                        object o = Array.CreateInstance(types[0].GetElementType(), obs.Length);
                        for (int i = 0; i < obs.Length; i++) {
                            ((Array)o).SetValue(obs[i], i);
                        }

                        return new[] { o };
                    }
                }

                if (inhibitException) {
                    return new object[0];
                }

                string ts = string.Empty, tts = string.Empty;
                foreach (object o in obs) {
                    ts += " " + o.GetType() + " ";
                }

                foreach (Type t in types) {
                    tts += " " + t + " ";
                }

                throw new VsyncException("Msg.BArrayToObjects: BArray encodes wrong number of objects (found " + obs.Length + " { " + ts + " }, expected " + types.Length + "{ " + tts + " })");
            }

            for (int i = 0; i < obs.Length; i++) {
                if (obs[i] != null && obs[i].GetType() != types[i]) {
                    if (inhibitException) {
                        return new object[0];
                    }

                    throw new VsyncException("Msg.BArrayToObjects: " + i + "'th object is of type type " + obs[i].GetType() + " but expected " + types[i]);
                }
            }

            return obs;
        }

        /// <summary>
        /// Given a byte[] vector, computes an object[] vector by demarshalling the contents.  The types must all be known to Vsync, either
        /// as built-in types Vsync supports, or by registering them.  <seealso cref="Msg.RegisterType"/>
        /// </summary>
        /// <param name="payload">byte[] vector from which to extract objects</param>
        /// <returns></returns>
        public static object[] BArrayToObjects(byte[] payload) {
            if (payload == null) {
                return new object[0];
            }

            return NestedBArrayToObjects(payload, 0, payload.Length);
        }

        private static readonly LockObject cacheLock = new LockObject(false, "cacheLock");

        private static byte[] lastPayloadArg;

        private static int lastPayloadLen;

        // Takes advantage of the fact that a ciphered object is ALWAYS larger than a deciphered one
        private static int lastStart;

        private static int lastLen;

        private static object[] lastObs;

        internal static Type doGetType(byte[] payload, int start, int len) {
            int index = start + 1;
            byte conv = payload[index];
            if (UserDefinedTypesTable[conv] != null) {
                return UserDefinedTypesTable[conv].theType;
            }

            return null;
        }

        // If payload apparently encodes a single message object, return it.  Else return null.
        internal static Msg InnerMsg(byte[] payload) {
            byte[] expected = { 0, 0, 0, 1, MESSAGE, 0, 0, 0, INT64, 0, 0, 0, 9, ADDRESS, 0, 0, 0, 16, ADDRESS, 0, 0, 0, 16, INT32, 0, 0, 0, 4, INT32, 0, 0, 0, 4, INT64, 0, 0, 0, 8, INT32, 0, 0, 0, 4, INT32, 0, 0, 0, 4, BYTE, 0, 0, 0, 1, BYTEA };
            if (payload.Length < 119) {
                return null;
            }

            for (int i = 0; i < expected.Length; i++) {
                if (payload[i] != expected[i]) {
                    return null;
                }
            }

            try {
                return (Msg)Msg.BArrayToObjects(payload, typeof(Msg))[0];
            }
            catch {
                return null;
            }
        }

        private static object[] NestedBArrayToObjects(byte[] payload, int start, int len) {
            if (payload.Length < start + len) {
                return new object[0];
            }

            using (var tmpLockObj = new LockAndElevate(cacheLock)) {
                if (lastPayloadArg == payload && lastPayloadLen == payload.Length && lastStart == start && lastLen == len) {
                    return lastObs;
                }
            }

            if (payload == null || len == 0) {
                return new object[0];
            }

            int index = start;
            int nobs = payload[index++];
            nobs = (nobs << 8) | payload[index++];
            nobs = (nobs << 8) | payload[index++];
            nobs = (nobs << 8) | payload[index++];
            if (nobs < 0 || nobs > len) {
                throw new VsyncException("corrupted message (NestedBArrayToObjects)");
            }

            object[] obs = new object[nobs];
            int off = start + 4 + (nobs * 5);
            for (int n = 0; n < nobs; n++) {
                int idx;
                byte conv = payload[index++];
                int plen = payload[index++];
                plen = (plen << 8) | payload[index++];
                plen = (plen << 8) | payload[index++];
                plen = (plen << 8) | payload[index++];
                switch (conv) {
                    case NULL: {
                            off += 4;
                            obs[n] = null;
                            continue;
                        }

                    case INT16: {
                            int thei16Value = payload[off++];
                            thei16Value = (thei16Value << 8) + payload[off++];
                            short i16value = (short)thei16Value;
                            obs[n] = i16value;
                            break;
                        }

                    case INT16A: {
                            short[] i16avalue = new short[plen / 2];
                            idx = 0;
                            for (int k = 0; k < plen; k += 2) {
                                int thei16Value = payload[off++];
                                thei16Value = (thei16Value << 8) + payload[off++];
                                i16avalue[idx++] = (short)thei16Value;
                            }

                            obs[n] = i16avalue;
                            break;
                        }

                    case UINT16: {
                            int theui16Value = payload[off++];
                            theui16Value = (theui16Value << 8) + payload[off++];
                            ushort ui16value = (ushort)theui16Value;
                            obs[n] = ui16value;
                            break;
                        }

                    case UINT16A: {
                            ushort[] ui16avalue = new ushort[plen / 2];
                            idx = 0;
                            for (int k = 0; k < plen; k += 2) {
                                int theui16Value = payload[off++];
                                theui16Value = (theui16Value << 8) + payload[off++];
                                ui16avalue[idx++] = (ushort)theui16Value;
                            }

                            obs[n] = ui16avalue;
                            break;
                        }

                    case INT32: {
                            int thei32Value = (payload[off] << 24) + (payload[off + 1] << 16) + (payload[off + 2] << 8) + payload[off + 3];
                            off += 4;
                            int i32value = thei32Value;
                            obs[n] = i32value;
                            break;
                        }

                    case INT32A: {
                            int[] i32avalue = new int[plen / 4];
                            idx = 0;
                            for (int k = 0; k < plen; k += 4) {
                                int thei32Value = (payload[off] << 24) + (payload[off + 1] << 16) + (payload[off + 2] << 8) + payload[off + 3];
                                off += 4;
                                int i32value = thei32Value;
                                i32avalue[idx++] = i32value;
                            }

                            obs[n] = i32avalue;
                            break;
                        }

                    case UINT32: {
                            uint theui32Value = ((uint)payload[off] << 24) + ((uint)payload[off + 1] << 16) + ((uint)payload[off + 2] << 8) + payload[off + 3];
                            off += 4;
                            obs[n] = theui32Value;
                            break;
                        }

                    case UINT32A: {
                            uint[] ui32avalue = new uint[plen / 4];
                            idx = 0;
                            for (int k = 0; k < plen; k += 4) {
                                uint theui32Value = ((uint)payload[off] << 24) + ((uint)payload[off + 1] << 16) + ((uint)payload[off + 2] << 8) + payload[off + 3];
                                off += 4;
                                ui32avalue[idx++] = theui32Value;
                            }

                            obs[n] = ui32avalue;
                            break;
                        }

                    case INT2D: {
                            using (MemoryStream memStream = new MemoryStream(100)) {
                                BinaryFormatter myBf = new BinaryFormatter();
                                memStream.Write(payload, off, plen);
                                memStream.Seek(0, SeekOrigin.Begin);
                                off += plen;
                                int[,] ia = (int[,])myBf.Deserialize(memStream);
                                memStream.SetLength(0);
                                obs[n] = ia;
                            }

                            break;
                        }

                    case INT64: {
                            long thei64Value = ((long)payload[off] << 56) + ((long)payload[off + 1] << 48) + ((long)payload[off + 2] << 40) + ((long)payload[off + 3] << 32);
                            off += 4;
                            thei64Value += ((long)payload[off] << 24) + ((long)payload[off + 1] << 16) + ((long)payload[off + 2] << 8) + payload[off + 3];
                            off += 4;
                            obs[n] = thei64Value;
                            break;
                        }

                    case INT64A: {
                            long[] i64avalue = new long[plen / 8];
                            idx = 0;
                            for (int k = 0; k < plen; k += 8) {
                                long thei64Value = ((long)payload[off] << 56) + ((long)payload[off + 1] << 48) + ((long)payload[off + 2] << 40) + ((long)payload[off + 3] << 32);
                                off += 4;
                                thei64Value += ((long)payload[off] << 24) + ((long)payload[off + 1] << 16) + ((long)payload[off + 2] << 8) + payload[off + 3];
                                off += 4;
                                i64avalue[idx++] = thei64Value;
                            }

                            obs[n] = i64avalue;
                            break;
                        }

                    case UINT64: {
                            ulong theui64Value = ((ulong)payload[off] << 56) + ((ulong)payload[off + 1] << 48) + ((ulong)payload[off + 2] << 40) + ((ulong)payload[off + 3] << 32);
                            off += 4;
                            theui64Value += ((ulong)payload[off] << 24) + ((ulong)payload[off + 1] << 16) + ((ulong)payload[off + 2] << 8) + payload[off + 3];
                            off += 4;
                            obs[n] = theui64Value;
                            break;
                        }

                    case UINT64A: {
                            ulong[] ui64avalue = new ulong[plen / 8];
                            idx = 0;
                            for (int k = 0; k < plen; k += 8) {
                                ulong theui64Value = ((ulong)payload[off] << 56) + ((ulong)payload[off + 1] << 48) + ((ulong)payload[off + 2] << 40) + ((ulong)payload[off + 3] << 32);
                                off += 4;
                                theui64Value += ((ulong)payload[off] << 24) + ((ulong)payload[off + 1] << 16) + ((ulong)payload[off + 2] << 8) + payload[off + 3];
                                off += 4;
                                ui64avalue[idx++] = theui64Value;
                            }

                            obs[n] = ui64avalue;
                            break;
                        }

                    case BYTE: {
                            byte thebValue = payload[off++];
                            obs[n] = thebValue;
                            break;
                        }

                    case BYTEA: {
                            byte[] bavalue = new byte[plen];
                            idx = 0;
                            for (int k = 0; k < plen; k++) {
                                bavalue[idx++] = payload[off++];
                            }

                            obs[n] = bavalue;
                            break;
                        }

                    case CHAR: {
                            char thecValue = (char)payload[off++];
                            obs[n] = thecValue;
                            break;
                        }

                    case CHARA: {
                            char[] cavalue = new char[plen];
                            idx = 0;
                            for (int k = 0; k < plen; k++) {
                                cavalue[idx++] = (char)payload[off++];
                            }

                            obs[n] = cavalue;
                            break;
                        }

                    case BOOL: {
                            bool theboValue = payload[off++] == 1;
                            obs[n] = theboValue;
                            break;
                        }

                    case BOOLA: {
                            byte[] bavalue = new byte[plen];
                            idx = 0;
                            for (int k = 0; k < plen; k++) {
                                bavalue[idx++] = payload[off++];
                            }

                            obs[n] = BytesToBits(bavalue);
                            break;
                        }

                    case STRING: {
                            string thestValue = BytesToString(payload, off, plen);
                            off += plen;
                            obs[n] = thestValue;
                            break;
                        }

                    case STRINGA: {
                            int ns = 0;
                            for (int k = 0; k < plen; k++) {
                                if (payload[off + k] == 0) {
                                    ++ns;
                                }
                            }

                            string[] thestavalue = new string[ns];
                            if (ns > 0) {
                                idx = 0;
                                thestavalue[0] = string.Empty;
                                for (int k = 0; k < plen; k++) {
                                    if (payload[off] == 0) {
                                        ++off;
                                        if (++idx != ns) {
                                            thestavalue[idx] = string.Empty;
                                        }
                                    }
                                    else {
                                        thestavalue[idx] += (char)payload[off++];
                                    }
                                }
                            }

                            obs[n] = thestavalue;
                            break;
                        }

                    case FLOAT: {
                            using (MemoryStream memStream = new MemoryStream(100)) {
                                BinaryFormatter myBf = new BinaryFormatter();
                                memStream.Write(payload, off, plen);
                                memStream.Seek(0, SeekOrigin.Begin);
                                off += plen;
                                float f = (float)myBf.Deserialize(memStream);
                                memStream.SetLength(0);
                                obs[n] = f;
                            }

                            break;
                        }

                    case FLOATA: {
                            using (MemoryStream memStream = new MemoryStream(100)) {
                                BinaryFormatter myBf = new BinaryFormatter();
                                memStream.Write(payload, off, plen);
                                memStream.Seek(0, SeekOrigin.Begin);
                                off += plen;
                                float[] flts = (float[])myBf.Deserialize(memStream);
                                memStream.SetLength(0);
                                obs[n] = flts;
                            }

                            break;
                        }

                    case FLOAT2D: {
                            using (MemoryStream memStream = new MemoryStream(100)) {
                                BinaryFormatter myBf = new BinaryFormatter();
                                memStream.Write(payload, off, plen);
                                memStream.Seek(0, SeekOrigin.Begin);
                                off += plen;
                                float[,] fa = (float[,])myBf.Deserialize(memStream);
                                memStream.SetLength(0);
                                obs[n] = fa;
                            }

                            break;
                        }

                    case DOUBLE: {
                            using (MemoryStream memStream = new MemoryStream(100)) {
                                BinaryFormatter myBf = new BinaryFormatter();
                                memStream.Write(payload, off, plen);
                                memStream.Seek(0, SeekOrigin.Begin);
                                off += plen;
                                double d = (double)myBf.Deserialize(memStream);
                                memStream.SetLength(0);
                                obs[n] = d;
                            }

                            break;
                        }

                    case DOUBLEA: {
                            using (MemoryStream memStream = new MemoryStream(100)) {
                                BinaryFormatter myBf = new BinaryFormatter();
                                memStream.Write(payload, off, plen);
                                memStream.Seek(0, SeekOrigin.Begin);
                                off += plen;
                                double[] dbls = (double[])myBf.Deserialize(memStream);
                                memStream.SetLength(0);
                                obs[n] = dbls;
                            }

                            break;
                        }

                    case DOUBLE2D: {
                            using (MemoryStream memStream = new MemoryStream(100)) {
                                BinaryFormatter myBf = new BinaryFormatter();
                                memStream.Write(payload, off, plen);
                                memStream.Seek(0, SeekOrigin.Begin);
                                off += plen;
                                double[,] da = (double[,])myBf.Deserialize(memStream);
                                memStream.SetLength(0);
                                obs[n] = da;
                            }

                            break;
                        }

                    case ADDRESS: {
                            Address a = new Address(payload, off);
                            off += plen;
                            obs[n] = a;
                            break;
                        }

                    case ADDRESSA: {
                            Address[] av = Address.ToAddresses(payload, off, plen);
                            off += plen;
                            obs[n] = av;
                            break;
                        }

                    case BVS: {
                            byte[] barray = new byte[plen];
                            Buffer.BlockCopy(payload, off, barray, 0, plen);
                            object[] objs = Msg.BArrayToObjects(barray, typeof(int[]), typeof(byte[]));
                            int[] lens = (int[])objs[0];
                            byte[] bvs = (byte[])objs[1];
                            byte[][] res = new byte[lens.Length][];
                            int offset = 0;
                            for (int i = 0; i < lens.Length; i++) {
                                res[i] = new byte[lens[i]];
                                Buffer.BlockCopy(bvs, offset, res[i], 0, lens[i]);
                                offset += lens[i];
                            }

                            obs[n] = res;
                            off += plen;
                            break;
                        }

                    case IPADDR: {
                            byte[] barray = new byte[plen];
                            Buffer.BlockCopy(payload, off, barray, 0, plen);
                            obs[n] = new IPAddress(barray);
                            off += plen;
                            break;
                        }

                    case IPADDRA: {
                            IPAddress[] ipa = new IPAddress[plen / 4];
                            byte[] barray = new byte[4];
                            for (int i = 0; i < ipa.Length; i++) {
                                Buffer.BlockCopy(payload, off + (i * 4), barray, 0, 4);
                                ipa[i] = new IPAddress(barray);
                            }

                            obs[n] = ipa;
                            off += plen;
                            continue;
                        }

                    case NESTED: {
                            object[] nested = Msg.NestedBArrayToObjects(payload, off, plen);
                            if (nested.Length > 0) {
                                obs[n] = Array.CreateInstance(nested[0].GetType(), nested.Length);
                                for (int k = 0; k < nested.Length; k++) {
                                    ((object[])obs[n])[k] = nested[k];
                                }
                            }
                            else {
                                obs[n] = Array.CreateInstance(Msg.doGetType(payload, off, plen), 0);
                            }

                            off += plen;
                        }

                        break;

                    case NESTED0: {
                            byte userType = payload[off++];
                            obs[n] = Array.CreateInstance(UserDefinedTypesTable[userType].theType, 0);
                            break;
                        }

                    case KEYVALUEP: {
                            object[] nested = Msg.NestedBArrayToObjects(payload, off, plen);
                            obs[n] = Activator.CreateInstance(typeof(KeyValuePair<,>).MakeGenericType(new[] { nested[0].GetType(), nested[1].GetType() }), nested);
                            off += plen;
                        }

                        continue;

                    case QUERYKEY: {
                            object[] nested = Msg.NestedBArrayToObjects(payload, off, plen);

                            // Has List<KT> keys, initiator, uid, includeInitator
                            obs[n] = Activator.CreateInstance(typeof(QueryKey<>).MakeGenericType(new[] { nested[0].GetType().GetGenericArguments()[0] }), nested);
                            off += plen;
                        }

                        continue;

                    case LIST:
                    case LISTO: {
                            object list = null;
                            if (plen != 1) {
                                object[] nested = Msg.NestedBArrayToObjects(payload, off, plen);
                                List<object> tmp = new List<object>();
                                Type theType = typeof(object);
                                foreach (object obj in (IEnumerable)(dynamic)nested[0]) {
                                    object[] innerObjs = BArrayToObjects((byte[])obj);
                                    if (innerObjs.Length == 1) {
                                        theType = innerObjs[0].GetType();
                                        tmp.Add(innerObjs[0]);
                                    }
                                    else {
                                        throw new VsyncException("internal error: BArrayToObjects<LIST>");
                                    }
                                }

                                list = Activator.CreateInstance(typeof(List<>).MakeGenericType(new[] { conv == LISTO ? typeof(object) : theType }));
                                MethodInfo mi = list.GetType().GetMethod("Add");
                                foreach (object o in tmp) {
                                    mi.Invoke(list, new[] { o });
                                }
                            }
                            else {
                                foreach (KeyValuePair<Type, byte> sdt in UserDefinedTypesList) {
                                    if (sdt.Value == payload[off]) {
                                        list = Activator.CreateInstance(typeof(List<>).MakeGenericType(new[] { sdt.Key }));
                                        break;
                                    }
                                }

                                if (list == null) {
                                    throw new VsyncException("List<T>: failed to reconstruct type for code=" + payload[off] + " @ " + Vsync.ExtractStackTrace());
                                }
                            }

                            obs[n] = list;
                            off += plen;
                        }

                        continue;

                    default: {
                            if (UserDefinedTypesTable[conv] == null) {
                                string pcnts = " ";
                                foreach (byte b in payload) {
                                    pcnts += b.ToString("X2") + " ";
                                }

                                Vsync.WriteLine("WARNING: Msg.BArrayToObjects was unable to demarshall a byte array... Payload.len = " + payload.Length + ", contents = [" + pcnts + "], start=" + start + ", len=" + len);
                                Vsync.WriteLine("Called from " + Vsync.ExtractStackTrace());
                                return new object[0];
                            }

                            // Note: no need to retain the lock; it functions as a barrier in this case because the table entry is write-once
                            byte[] ba = new byte[plen];
                            for (int k = 0; k < plen; k++) {
                                ba[k] = payload[off++];
                            }

                            switch (UserDefinedTypesTable[conv].mechanism) {
                                case MarshallingMechanism.AutoMarshalled:
                                    FieldInfo[] theFields = UserDefinedTypesTable[conv].theFields;
                                    obs[n] = UserDefinedTypesTable[conv].theConstructor.Invoke(new object[0]);
                                    object[] values = Msg.BArrayToObjects(ba);
                                    for (int k = 0; k < theFields.Length; k++) {
                                        theFields[k].SetValue(obs[n], values[k]);
                                    }

                                    break;
                                case MarshallingMechanism.SelfMarshalled:
                                    if ((VsyncSystem.Debug & VsyncSystem.CALLBACKS) != 0) {
                                        Group.ReportCb(UserDefinedTypesTable[conv].theType, ba);
                                    }

                                    obs[n] = UserDefinedTypesTable[conv].theConstructor.Invoke(new object[] { ba });
                                    break;
#if PROTOCOL_BUFFERS
                                case MarshallingMechanism.ProtocolBuffers:
                                    using (MemoryStream memoryStream = new MemoryStream(ba, false))
                                    {
                                        obs[n] = Serializer.NonGeneric.Deserialize(UserDefinedTypesTable[conv].theType, memoryStream);
                                    }

                                    break;
#endif
                                default:
                                    throw new VsyncException("Unexpected marshalling mechanism.");
                            }

                            break;
                        }
                }
            }

            using (var tmpLockObj = new LockAndElevate(cacheLock)) {
                lastPayloadArg = payload;
                lastStart = start;
                lastLen = len;
                lastObs = obs;
                lastPayloadLen = payload.Length;
            }

            return obs;
        }

        private static byte[] sign(byte[] hash) {
            int nb = Vsync.VSYNC_AES.BlockSize >> 3;
            byte[] IV = new byte[nb];
            Vsync.VSYNC_AESSEED.GetBytes(IV);
            for (int i = 0; i < nb; i++) {
                IV[i] = (byte)i;
            }

            return Group.encipher(null, Vsync.VSYNC_AES, Vsync.VSYNC_AES_LOCK, IV, hash);
        }

        private static byte[] recomputeSignature(byte[] IV, byte[] hash) {
            return Group.encipher(null, Vsync.VSYNC_AES, Vsync.VSYNC_AES_LOCK, IV, hash);
        }

        internal static LockObject VerifyLock = new LockObject("VerifyLock", ThreadPriority.Highest);

        internal Group theGroup;

        internal static bool VerifySignature(byte[] payload, int start, int len) {
            if (len == 0)
                return false;
            if (Vsync.VSYNC_SIGS && (len - start) > Vsync.VSYNC_MSGPADDING) {
                using (MemoryStream ms = new MemoryStream(payload, start, len - Vsync.VSYNC_MSGPADDING))
                using (HMAC hm = new HMACSHA256(new byte[] { 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11, 56, 78, 9, 23, 10, 87, 33, 11 }))
                using (var tmpLockObj = new LockAndElevate(VerifyLock)) {
                    int x = start + len - Vsync.VSYNC_MSGPADDING;
                    byte[] hash = hm.ComputeHash(ms);
                    if (Vsync.VSYNC_AES != null) {
                        int nb = Vsync.VSYNC_AES.BlockSize >> 3;
                        byte[] IV = new byte[nb];
                        for (int i = 0; i < nb; i++) {
                            IV[i] = payload[x + i];
                        }

                        hash = recomputeSignature(IV, hash);
                    }

                    if (hash.Length != Vsync.VSYNC_MSGPADDING) {
                        if ((VsyncSystem.Debug & VsyncSystem.DISCARDS) != 0) {
                            Vsync.WriteLine("Rejecting a message: hash length is incorrect");
                        }

                        return false;
                    }

                    for (int i = 0; i < hash.Length; i++) {
                        if (payload[x++] != hash[i]) {
                            if ((VsyncSystem.Debug & VsyncSystem.DISCARDS) != 0) {
                                Vsync.WriteLine("Rejecting a message: signature verification failed");
                            }

                            return false;
                        }
                    }
                }
            }

            return true;
        }

        private static byte[] BitsToBytes(bool[] ba) {
            int len = 0;
            if (ba != null) {
                len = ba.Length;
            }

            byte[] bv = new byte[4 + ((len + 7) >> 3)];
            if (ba == null) {
                len = -1;
            }

            bv[0] = (byte)((len >> 24) & 0xFF);
            bv[1] = (byte)((len >> 16) & 0xFF);
            bv[2] = (byte)((len >> 8) & 0xFF);
            bv[3] = (byte)(len & 0xFF);
            if (len <= 0) {
                return bv;
            }

            byte[] bits = { 1, 2, 4, 8, 16, 32, 64, 128 };
            for (int i = 0; i < len; i++) {
                if (ba[i]) {
                    bv[(i >> 3) + 4] |= bits[i & 0x7];
                }
            }

            return bv;
        }

        private static bool[] BytesToBits(byte[] bv) {
            int bl = (bv[0] << 24) + (bv[1] << 16) + (bv[2] << 8) + bv[3];
            if (bl == -1) {
                return null;
            }

            bool[] ba = new bool[bl];
            byte[] bits = { 1, 2, 4, 8, 16, 32, 64, 128 };
            for (int i = 0; i < bl; i++) {
                ba[i] = (bv[4 + (i >> 3)] & bits[i & 0x7]) != 0;
            }

            return ba;
        }

        // Checks that the view in the group this P2P message is associated with (if any) has 
        // reached or surpassed the viewid mentioned in the message itself
        internal static bool checkView(Msg m) {
            if (m.theGroup == null || m.theGroup.theView == null) {
                return true;
            }

            using (var tmpLockObj = new LockAndElevate(m.theGroup.ViewLock)) {
                return m.theGroup.theView.viewid >= m.vid;
            }
        }
    }

    /// <exclude></exclude>
    [SuppressUnmanagedCodeSecurity]
    internal static class NativeMethods {
        private const string IBDLL = "ib.dll";

        /// <exclude></exclude>
        [StructLayout(LayoutKind.Sequential)]
        internal struct rlimit64 {
            /// <exclude></exclude>
            internal ulong rlim_curr;

            /// <exclude></exclude>
            internal ulong rlim_hard;
        }

#if __MonoCS__
        /// <exclude></exclude>
        [DllImport("libc.so")]
        internal static extern int getrlimit64(int resource, out rlimit64 rlp);

#endif
        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern int ib_maxqpgroups();

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern int init_resources(int nrcvbf, int nsndbf);

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern byte ib_readAt(IntPtr ptr);

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern IntPtr ib_malloc(int n);

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern void ib_free(IntPtr ptr);

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern void ib_saveAt(byte b, IntPtr ptr);

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern IntPtr ib_dpAt(IntPtr ptr, int k);

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern int ib_statusAt(IntPtr ptr, int k);

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern int ib_wait_for_completion(int group, int timeout);

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern int ib_lenAt(IntPtr ptr, int k);

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern int get_qp_num(int qp);

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern int create_qp(int group, int maxsends, int maxrcvs);

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern int ib_connect(int qp, int rqp_num, int lid);

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern int ib_clen(IntPtr ptr);

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern int ib_getlid();

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern void destroy_qp(int qp);

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern IntPtr ib_register(IntPtr buffer, int nbytes);

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern void ib_unregister(IntPtr key);

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern int post_send(int qpnum, IntPtr buffer, IntPtr key, int nbytes);

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern int post_recv(int groupnum, IntPtr buffer, IntPtr key, int nbytes);

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern IntPtr ib_poll_completedrcvs(int group);

        /// <exclude></exclude>
        [DllImport(IBDLL, ExactSpelling = true)]
        internal static extern IntPtr ib_poll_completedsends(int group);
    }

    /// <exclude></exclude>
    public sealed class IB : IDisposable {
        // All of these methods actually live in a C DLL that we won't
        // import unless we see that there is an IB adaptor on this machine
        // and decide we want to use it.
        // DLLImport uses the PATH environment variable to find the dll

        // Be sure to set LD_LIBRARY_PATH=/x/y/z:$LD_LIBRARY_PATH to point Mono to the location of ib.dll
        internal static object lock_object = new object();

        internal static int IB_maxqpgroups() {
            if (!Vsync.VSYNC_INFINIBAND) {
                return 0;
            }

            lock (lock_object) {
                return NativeMethods.ib_maxqpgroups();
            }
        }

        internal static Semaphore ibcntr;

        internal static LockObject ibgrouplock = new LockObject("ibgrouplock");

        internal static bool[] ibgroupnos = null;

        /// <summary>
        /// Initializes the IB library
        /// </summary>
        internal static int IB_init_resources(int nrcvbf, int nsndbf) {
            if (!Vsync.VSYNC_INFINIBAND) {
                return 0;
            }

            lock (lock_object) {
                return NativeMethods.init_resources(nrcvbf, nsndbf);
            }
        }

        /// <summary>
        /// Uses the C malloc routine to allocate a byte array, returns a pointer
        /// </summary>s
        internal static IntPtr IB_malloc(int n) {
            if (!Vsync.VSYNC_INFINIBAND) {
                return IntPtr.Zero;
            }

            lock (lock_object) {
                return NativeMethods.ib_malloc(n);
            }
        }

        /// <summary>
        /// Frees a a memory region allocated with ib_malloc
        /// </summary>
        internal static void IB_free(IntPtr ptr) {
            if (!Vsync.VSYNC_INFINIBAND) {
                return;
            }

            lock (lock_object) {
                NativeMethods.ib_free(ptr);
            }
        }

        /// <summary>
        /// Read a byte (in fact, within a buffer, but this property isn't checked)
        /// </summary>
        internal static byte IB_readAt(IntPtr ptr) {
            if (!Vsync.VSYNC_INFINIBAND) {
                return 0;
            }

            lock (lock_object) {
                return NativeMethods.ib_readAt(ptr);
            }
        }

        /// <summary>
        /// Read a byte (in fact, within a buffer, but this property isn't checked)
        /// </summary>
        internal static void IB_saveAt(byte b, IntPtr ptr) {
            if (!Vsync.VSYNC_INFINIBAND) {
                return;
            }

            lock (lock_object) {
                NativeMethods.ib_saveAt(b, ptr);
            }
        }

        /// <summary>
        /// Retrieve a data pointer from a vector of completion records
        /// </summary>
        internal static IntPtr IB_dpAt(IntPtr ptr, int k) {
            if (!Vsync.VSYNC_INFINIBAND) {
                return IntPtr.Zero;
            }

            lock (lock_object) {
                return NativeMethods.ib_dpAt(ptr, k);
            }
        }

        /// <summary>
        /// Retrieve a data pointer from a vector of completion records
        /// </summary>
        internal static int IB_statusAt(IntPtr ptr, int k) {
            if (!Vsync.VSYNC_INFINIBAND) {
                return 0;
            }

            lock (lock_object) {
                return NativeMethods.ib_statusAt(ptr, k);
            }
        }

        internal const int WC_UNKNOWN = -2;
        internal const int WC_SUCCESS = 0;
        internal const int WC_ERROR = -1;
        internal const int WC_TIMEOUT = 1;

        /// <summary>
        /// Check for completions that we could process
        /// </summary>
        internal static int IB_wait_for_completion(int group, int timeout) {
            if (!Vsync.VSYNC_INFINIBAND) {
                return WC_SUCCESS;
            }

            // Don't lock the lock_object or deadlock will occur
            return NativeMethods.ib_wait_for_completion(group, timeout);
        }

        /// <summary>
        /// Retrieve a length from a vector of completion records
        /// </summary>
        internal static int IB_lenAt(IntPtr ptr, int k) {
            if (!Vsync.VSYNC_INFINIBAND) {
                return 0;
            }

            lock (lock_object) {
                return NativeMethods.ib_lenAt(ptr, k);
            }
        }

        /// <summary>
        /// Obtains the length of that vector
        /// </summary>
        internal static int IB_clen(IntPtr ptr) {
            if (!Vsync.VSYNC_INFINIBAND || ptr == IntPtr.Zero) {
                return 0;
            }

            lock (lock_object) {
                return NativeMethods.ib_clen(ptr);
            }
        }

        /// <summary>
        /// Returns the IB lid for this node
        /// </summary>
        internal static int IB_getlid() {
            if (!Vsync.VSYNC_INFINIBAND) {
                return 0;
            }

            lock (lock_object) {
                return NativeMethods.ib_getlid();
            }
        }

        /// <summary>
        /// Returns the qp number for a locally active qp
        /// </summary>
        internal static int IB_get_qp_num(int qp) {
            if (!Vsync.VSYNC_INFINIBAND) {
                return 0;
            }

            lock (lock_object) {
                return NativeMethods.get_qp_num(qp);
            }
        }

        /// <summary>
        /// Creates a new qp, specifies how many sends/rcvs might be posted and the recieve buffer pool
        /// </summary>
        internal static int IB_create_qp(int group, int maxsends, int maxrcvs) {
            if (!Vsync.VSYNC_INFINIBAND) {
                return 0;
            }

            lock (lock_object) {
                return NativeMethods.create_qp(group, maxsends, maxrcvs);
            }
        }

        /// <summary>
        /// Establish a reliable IB connection
        /// </summary>
        internal static int IB_connect(int qp, int rqp_num, int lid) {
            if (!Vsync.VSYNC_INFINIBAND) {
                return 0;
            }

            lock (lock_object) {
                return NativeMethods.ib_connect(qp, rqp_num, lid);
            }
        }

        internal class cinfo {
            internal int rqp_num;

            internal int lid;

            internal cinfo(int r, int l) {
                this.rqp_num = r;
                this.lid = l;
            }
        }

        internal static Dictionary<int, cinfo> cmap = new Dictionary<int, cinfo>();

        internal static LockObject cmapLock = new LockObject("cmapLock");

        internal static int make_ib_connection(int qp, int rqp_num, int lid) {
            if (!Vsync.VSYNC_INFINIBAND) {
                return 0;
            }

            int rv;
            using (var tmpLockObj = new LockAndElevate(cmapLock)) {
                if (cmap.ContainsKey(qp)) {
                    cmap.Remove(qp);
                }

                rv = IB_connect(qp, rqp_num, lid);
                if (rv == 0) {
                    cmap.Add(qp, new cinfo(rqp_num, lid));
                }
            }

            return rv;
        }

        /// <summary>
        /// Destroys a qp.
        /// </summary>
        internal static void IB_destroy_qp(int qp) {
            if (!Vsync.VSYNC_INFINIBAND) {
                return;
            }

            lock (lock_object) {
                NativeMethods.destroy_qp(qp);
            }
        }

        /// <summary>
        /// Register a buffer, obtaining a local key
        /// </summary>
        internal static IntPtr IB_register(IntPtr buffer, int nbytes) {
            if (!Vsync.VSYNC_INFINIBAND) {
                return IntPtr.Zero;
            }

            lock (lock_object) {
                return NativeMethods.ib_register(buffer, nbytes);
            }
        }

        /// <summary>
        /// Register a buffer, obtaining a local key
        /// </summary>
        internal static void IB_unregister(IntPtr key) {
            if (!Vsync.VSYNC_INFINIBAND) {
                return;
            }

            lock (lock_object) {
                NativeMethods.ib_unregister(key);
            }
        }

        /// <summary>
        /// Posts a send to the target qp/lid; it will complete asynchronously
        /// </summary>
        internal static int IB_post_send(int qpnum, IntPtr buffer, IntPtr key, int nbytes) {
            if (!Vsync.VSYNC_INFINIBAND) {
                return 0;
            }

            lock (lock_object) {
                return NativeMethods.post_send(qpnum, buffer, key, nbytes);
            }
        }

        /// <summary>
        /// Posts a receive, it will complete asynchronously
        /// </summary>
        internal static int IB_post_recv(int groupnum, IntPtr buffer, IntPtr key, int nbytes) {
            if (!Vsync.VSYNC_INFINIBAND) {
                return 0;
            }

            lock (lock_object) {
                return NativeMethods.post_recv(groupnum, buffer, key, nbytes);
            }
        }

        /// <summary>
        /// Tells how many posted receives are done, and for them, the buffer addresses and lengths
        /// </summary>
        internal static IntPtr IB_poll_completedrcvs(int group) {
            if (!Vsync.VSYNC_INFINIBAND) {
                return IntPtr.Zero;
            }

            lock (lock_object) {
                return NativeMethods.ib_poll_completedrcvs(group);
            }
        }

        /// <summary>
        /// Returns a vector of buffer addresses from post_send for completed send operations
        /// </summary>
        internal static IntPtr IB_poll_completedsends(int group) {
            if (!Vsync.VSYNC_INFINIBAND) {
                return IntPtr.Zero;
            }

            lock (lock_object) {
                return NativeMethods.ib_poll_completedsends(group);
            }
        }

        internal const int P2PQ = 0;

        internal const int ACKQ = 1;

        internal const int OOBBASE = 2;

        internal const int BOTH = 0;

        internal static int[] remoteP2Pqps;

        internal static int[] remoteACKqps;

        internal static int[] remotelids;

        internal static bool[] connected;

        internal static View mostRecentView;

        internal static volatile bool pools_allocated;

        internal const int NIBBUFS = 1024;

        internal static bool init() {
            if (!Vsync.VSYNC_INFINIBAND) {
                return false;
            }

            if (TestConfig() == false) {
                if ((VsyncSystem.Debug & VsyncSystem.IBDB) != 0) {
                    Vsync.WriteLine("WARNING: INFINIBAND=true but this system lacks the minimal required kernal resources.");
                }

                Vsync.VSYNC_INFINIBAND = false;
                return false;
            }

            int max = IB_maxqpgroups();
            ibcntr = new Semaphore(max - 2, max);
            if (IB_init_resources(NIBBUFS, NIBBUFS) != 0) {
                if ((VsyncSystem.Debug & VsyncSystem.IBDB) != 0) {
                    Vsync.WriteLine("WARNING: INFINIBAND=true but Vsync was unable to initialize IB resources. Using IP on IB only.");
                }

                Vsync.VSYNC_INFINIBAND = false;
                return false;
            }

            ibgroupnos = new bool[IB_maxqpgroups()];
            ibgroupnos[0] = ibgroupnos[1] = true;
            new Thread(() => {
                while (Vsync.VSYNCMEMBERS == null) {
                    Vsync.Sleep(100);
                }

                Vsync.VSYNCMEMBERS.ViewHandlers += v => {
                    // Be careful not to do anything here that might delay on a lock before the view-specific objects used by the IB code are updated
                    if (mostRecentView != null && v.leavers.Length > 0) {
                        foreach (Address address in v.leavers) {
                            int rank = mostRecentView.GetRankOf(address);
                            if (rank != -1) {
                                IB_destroy_qp(remoteP2Pqps[rank]);
                                IB_destroy_qp(remoteACKqps[rank]);
                                remoteP2Pqps[rank] = 0;
                                remoteACKqps[rank] = 0;
                            }
                        }

                        for (int r = 0; r < v.members.Length; r++) {
                            int oldRank = mostRecentView.GetRankOf(v.members[r]);
                            if (oldRank != -1) {
                                // Note that r <= oldRank
                                connected[r] = connected[oldRank];
                                remotelids[r] = remotelids[oldRank];
                                remoteP2Pqps[r] = remoteP2Pqps[oldRank];
                                remoteACKqps[r] = remoteACKqps[oldRank];
                            }
                            else {
                                connected[r] = false;
                                remotelids[r] = 0;
                                remoteP2Pqps[r] = 0;
                                remoteACKqps[r] = 0;
                            }
                        }

                        // Note that the new size is (definitely) smaller than the old one
                        Vsync.ArrayResize(ref remotelids, v.members.Length);
                        Vsync.ArrayResize(ref connected, v.members.Length);
                        Vsync.ArrayResize(ref remoteP2Pqps, v.members.Length);
                        Vsync.ArrayResize(ref remoteACKqps, v.members.Length);
                    }
                    else {
                        if (v.joiners.Contains(Vsync.my_address)) {
                            int r = v.GetMyRank();
                            remotelids = v.remotelids;
                            Vsync.ArrayResize(ref remotelids, v.members.Length);
                            connected = new bool[v.members.Length];
                            remoteACKqps = new int[v.members.Length];
                            remoteP2Pqps = new int[v.members.Length];
                            if ((remotelids[r] = Vsync.VSYNC_LID) == 0) {
                                throw new VsyncException("IB: mylid was still 0 when newview was first called");
                            }
                        }
                        else {
                            Vsync.ArrayResize(ref remotelids, v.members.Length);
                            Vsync.ArrayResize(ref connected, v.members.Length);
                            Vsync.ArrayResize(ref remoteP2Pqps, v.members.Length);
                            Vsync.ArrayResize(ref remoteACKqps, v.members.Length);
                        }
                    }

                    mostRecentView = v;

                    if ((VsyncSystem.Debug & VsyncSystem.IBDB) != 0) {
                        Vsync.WriteLine("IB new view -- " + v);
                    }
                };
                while ((VsyncSystem.VsyncActive || !VsyncSystem.VsyncWasActive) && !IBSetupDone.WaitOne(500)) {
                }

                IBSetupDone.Release();

                while (VsyncSystem.VsyncActive || !VsyncSystem.VsyncWasActive) {
                    AcceptCompletedRcvs(P2PQ, ReliableSender.RecvBB);
                    FinalizeCompletedSends(P2PQ);
                    AcceptCompletedRcvs(ACKQ, ReliableSender.AckBB);
                    FinalizeCompletedSends(ACKQ);
                    int rv;
                    if ((rv = IB.IB_wait_for_completion(BOTH, 250)) != IB.WC_SUCCESS) {
                        if (rv == IB.WC_ERROR) {
                            Vsync.WriteLine("Vsync/IB: WARNING, ib_wait_for_completion failed!");
                        }
                    }
                }
            }) { Name = "IB receiver thread", Priority = ThreadPriority.Highest, IsBackground = true }.Start();
            return true;
        }

#if __MonoCS__
        private static ulong getTotalMemory()
        {
            using (PerformanceCounter pc = new PerformanceCounter("Mono Memory", "Total Physical Memory"))
            {
                return (ulong)pc.RawValue;
            }
        }

        private static ulong getPageSize()
        {
            return (ulong)Environment.SystemPageSize;
        }

        /// <remarks>returns 0xffffffffffff</remarks>
        private static ulong getMaxLockedMemory()
        {
#if GETRLIMIT64
            NativeMethods.rlimit64 rlp;
            if (NativeMethods.getrlimit64(8 /* RLIMIT_MEMLOCK */, out rlp) == 0)
            {
                return rlp.rlim_hard;
            }

            Console.WriteLine("Could not read memory lock limit.");
#endif
            return getTotalMemory();
        }

        private static ulong readModuleParamForIB(string file, ulong defaultValue)
        {
            try
            {
                string contents = File.ReadAllText(file);
                return ulong.Parse(contents);
            }
            catch (DirectoryNotFoundException)
            {
                return defaultValue;
            }
            catch (FileNotFoundException)
            {
                return defaultValue;
            }
            catch (FormatException)
            {
                Console.WriteLine("Error parsing " + file + ": contents are not a valid integer.");
                return defaultValue;
            }
            catch (OverflowException)
            {
                Console.WriteLine("Error parsing " + file + ": value is out of range.");
                return defaultValue;
            }
        }
#endif

        internal static bool TestConfig() {
#if __MonoCS__

            if (IB.IB_maxqpgroups() < 2)
            {
                return false;
            }

            // Based on OpenMPI 1.8's calculate_max_reg(void) in btl_openlib.c:635
            ulong mtts_per_seg = 1;
            ulong num_mtt = 1 << 19;
            ulong reserved_mtt = 0;
            ulong max_reg;
            ulong max_lock = getMaxLockedMemory();
            ulong mem_total = getTotalMemory();

            if (Directory.Exists("/sys/module/mlx5_core"))
            {
                /* mlx5 means that we have ofed 2.0 and it can always register 2xmem_total for any mlx hca */
                max_reg = 2 * mem_total;
            }
            else if (Directory.Exists("/sys/module/mlx4_core/parameters"))
            {
                mtts_per_seg = 1UL << (int)readModuleParamForIB("/sys/module/mlx4_core/parameters/log_mtts_per_seg", 1);
                num_mtt = 1UL << (int)readModuleParamForIB("/sys/module/mlx4_core/parameters/log_num_mtt", 20);
                if (1 == num_mtt)
                {
                    /* NTH: is 19 a minimum? when log_num_mtt is set to 0 use 19 */
                    num_mtt = 1 << 20;
                }

                max_reg = (num_mtt - reserved_mtt) * getPageSize() * mtts_per_seg;
            }
            else if (Directory.Exists("/sys/module/ib_mthca/parameters"))
            {
                mtts_per_seg = 1UL << (int)readModuleParamForIB("/sys/module/ib_mthca/parameters/log_mtts_per_seg", 1);
                num_mtt = readModuleParamForIB("/sys/module/ib_mthca/parameters/num_mtt", 1 << 20);
                reserved_mtt = readModuleParamForIB("/sys/module/ib_mthca/parameters/fmr_reserved_mtts", 0);

                max_reg = (num_mtt - reserved_mtt) * getPageSize() * mtts_per_seg;
            }
            else
            {
                Vsync.WriteLine("Unable to determine amount of memory reserved for Infiniband on this configuration.");
                max_reg = mem_total;
            }

            if (max_reg < mem_total * 3 / 4)
            {
                Vsync.WriteLine("Warning: Infinband is able to register about " + (max_reg >> 30) + "GB of memory which is less than 75% of the total system memory." + Environment.NewLine + "Please refer to " + "https://www.open-mpi.org/faq/?category=openfabrics#ib-low-reg-mem" + " to resolve this issue.");

                return false;
            }
            else if (max_lock < mem_total / 2)
            {
                Vsync.WriteLine("Warning: Only able to lock about " + (max_lock >> 30) + "GB of memory which is less than 50% of the total system memory." + Environment.NewLine + "Please refer to " + "https://www.open-mpi.org/faq/?category=openfabrics#ib-locked-pages-user" + " to resolve this issue.");

                return false;
            }
            else
            {
                return true;
            }
#else
            return false;
#endif
        }

        private static void AcceptCompletedRcvs(int which, BoundedBuffer bb) {
            IntPtr dpa = IB_poll_completedrcvs(which);
            if (dpa != IntPtr.Zero) {
                int nc = IB_clen(dpa);
                if ((VsyncSystem.Debug & VsyncSystem.IBDB) != 0 && nc > 0) {
                    Vsync.WriteLine("IB " + (which == P2PQ ? "P2P" : "ACK") + " poll -- nc=" + nc);
                }

                for (int k = 0; k < nc; k++) {
                    IntPtr dp = IB_dpAt(dpa, k), key;
                    int nb = IB_lenAt(dpa, k);
                    byte[] ba = new byte[nb];
                    for (int b = 0; b < nb; b++) {
                        ba[b] = IB_readAt(dp + b);
                    }

                    using (var tmpLockObj = new LockAndElevate(IBMapLock)) {
                        key = BTK[dp];
                    }

                    IB_post_recv(which, dp, key, (int)Vsync.VSYNC_MAXMSGLEN);
                    if ((VsyncSystem.Debug & VsyncSystem.IBDB) != 0) {
                        Vsync.WriteLine("----> IB " + (which == P2PQ ? "P2P" : "ACK") + " received " + ba.Length + " bytes");
                    }

                    Vsync.VSYNC_USERDMA = true;
                    using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                        VsyncSystem.RTS.IBrcvd++;
                        VsyncSystem.RTS.IBBrcvd += ba.Length;
                    }

                    bb.put(ba);
                }

                IB_free(dpa);
            }
        }

        private static void FinalizeCompletedSends(int which) {
            IntPtr dpa = IB_poll_completedsends(which);
            if (dpa != IntPtr.Zero) {
                int nc = IB_clen(dpa);
                if ((VsyncSystem.Debug & VsyncSystem.IBDB) != 0 && nc > 0) {
                    Vsync.WriteLine("IB " + (which == P2PQ ? "P2P" : "ACK") + " completed sends -- nc=" + nc);
                }

                for (int k = 0; k < nc; k++) {
                    IntPtr copy, key;
                    int status = IB_statusAt(dpa, k);
                    Address dest;
                    using (var tmpLockObj = new LockAndElevate(IBMapLock)) {
                        key = BTK[copy = IB_dpAt(dpa, k)];
                        BTK.Remove(copy);
                        dest = BTA[copy];
                        BTA.Remove(copy);
                    }

                    IB_unregister(key);
                    IB_free(copy);
                    if (status == -1) {
                        Vsync.NodeHasFailed(dest, "IB connection broke", false);
                    }
                }

                IB_free(dpa);
            }
        }

        internal static LockObject IBMapLock = new LockObject("IBMapLock", ThreadPriority.Highest);

        internal static Dictionary<IntPtr, IntPtr> BTK = new Dictionary<IntPtr, IntPtr>();

        internal static Dictionary<IntPtr, Address> BTA = new Dictionary<IntPtr, Address>();

        internal static Semaphore IBSetupDone = new Semaphore(0, 1);

        internal static bool IBActive;

        internal static void Setup() {
            bool success = true;
            View theView;
            using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.ViewLock)) {
                theView = Vsync.VSYNCMEMBERS.theView;
            }

            remoteP2Pqps = new int[theView.members.Length];
            remoteACKqps = new int[theView.members.Length];
            if (remotelids == null) {
                remotelids = new int[theView.members.Length];
            }

            connected = new bool[theView.members.Length];
            for (int n = 0; n < theView.members.Length; n++) {
                if (!theView.members[n].isMyAddress()) {
                    remoteP2Pqps[n] = IB_create_qp(P2PQ, NIBBUFS, NIBBUFS);
                    remoteACKqps[n] = IB_create_qp(ACKQ, NIBBUFS, NIBBUFS);
                }
            }

            AllocateIBPool();
            if (theView.members.Length > 1) {
                int[] rqps = new int[theView.members.Length], aqps = new int[theView.members.Length];
                for (int n = 0; n < theView.members.Length; n++) {
                    rqps[n] = IB_get_qp_num(remoteP2Pqps[n]);
                    aqps[n] = IB_get_qp_num(remoteACKqps[n]);
                }

                List<int> p2pqpns = new List<int>(), aqpns = new List<int>();
                List<Address> who = new List<Address>();
                Vsync.VSYNCMEMBERS.Query(Group.ALL, new Timeout(Vsync.VSYNC_DEFAULTTIMEOUT, Timeout.TO_FAILURE), Vsync.IBADDRS, Vsync.my_address, theView.members, rqps, aqps, Vsync.VSYNC_LID, Group.EOL, who, p2pqpns, aqpns);

                // By now the view may have changed...
                using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.ViewLock)) {
                    theView = Vsync.VSYNCMEMBERS.theView;
                    for (int n = 0; n < who.Count; n++) {
                        if (!who[n].isMyAddress()) {
                            int r = theView.GetRankOf(who[n]);
                            if (make_ib_connection(remoteP2Pqps[r], p2pqpns[n], remotelids[r]) == 0 && make_ib_connection(remoteACKqps[r], aqpns[n], remotelids[r]) == 0) {
                                connected[r] = true;
                            }
                            else {
                                success = false;
                                Vsync.WriteLine("WARNING: ib_connect failed (1)");
                            }
                        }
                    }
                }

                Vsync.VSYNCMEMBERS.Send(who, Vsync.IBADDRS, Vsync.my_address, success);
            }

            if ((VsyncSystem.Debug & VsyncSystem.IBDB) != 0) {
                Vsync.WriteLine("IB Setup -- done.  Success=" + success);
            }

            IBActive = true;
            IBSetupDone.Release();
        }

        internal static string GetState() {
            if (!IBActive) {
                return string.Empty;
            }

            using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.ViewLock)) {
                if (Vsync.VSYNCMEMBERS.theView.members.Length == 1) {
                    return string.Empty;
                }

                string ibinfo = string.Empty;
                ibinfo += "IB State for member list: " + Address.VectorToString(Vsync.VSYNCMEMBERS.theView.members) + Environment.NewLine;
                for (int rank = 0; rank < Vsync.VSYNCMEMBERS.theView.members.Length; rank++) {
                    if (connected[rank]) {
                        ibinfo += "   [" + rank + "]: " + Vsync.VSYNCMEMBERS.theView.members[rank] + ", lid=" + remotelids[rank] + ", P2PQPS=" + remoteP2Pqps[rank] + ", AckQPS=" + remoteACKqps[rank] + Environment.NewLine;
                    }
                }

                return ibinfo;
            }
        }

        internal static void noteRemoteIB(Address who, Address[] rmembers, int p2pqp, int ackqp, int lid) {
            if (!Vsync.VSYNC_INFINIBAND) {
                throw new VsyncException("The ORACLE is in INFINIBAND mode but this member was configured with VSYNC_INFINIBAND=false.");
            }

            if (who.isMyAddress()) {
                Vsync.VSYNCMEMBERS.NullReply();
                return;
            }

            AllocateIBPool();
            int p2p = IB_create_qp(P2PQ, NIBBUFS, NIBBUFS);
            int ack = IB_create_qp(ACKQ, NIBBUFS, NIBBUFS);

            using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.ViewLock)) {
                int rank;
                if (!Vsync.VSYNCMEMBERS.HasFirstView || (rank = Vsync.VSYNCMEMBERS.GetRankOf(who)) == -1) {
                    throw new VsyncException("Can't note remote IB info: " + who + " is not yet listed in VSYNCMEMBERS view");
                }

                remotelids[rank] = lid;
                remoteP2Pqps[rank] = p2p;
                remoteACKqps[rank] = ack;
            }

            Vsync.VSYNCMEMBERS.Reply(Vsync.my_address, IB_get_qp_num(p2p), IB_get_qp_num(ack));
            if (make_ib_connection(p2p, p2pqp, lid) != 0 || make_ib_connection(ack, ackqp, lid) != 0) {
                Vsync.WriteLine("WARNING: ib_connect failed (2)");
            }
        }

        internal static void noteRemoteIB(Address who, bool outcome) {
            if (!outcome) {
                Vsync.WriteLine("WARNING: ib_connect failed (3)");
            }
            else {
                using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.ViewLock)) {
                    int rank = Vsync.VSYNCMEMBERS.GetRankOf(who);
                    connected[rank] = true;
                }
            }
        }

        private static void AllocateIBPool() {
            if (pools_allocated) {
                return;
            }

            pools_allocated = true;
            for (int n = 0; n < NIBBUFS; n++) {
                IntPtr buf = IB_malloc((int)Vsync.VSYNC_MAXMSGLEN);
                IntPtr key = IB_register(buf, (int)Vsync.VSYNC_MAXMSGLEN);
                using (var tmpLockObj = new LockAndElevate(IBMapLock)) {
                    BTK[buf] = key;
                }

                IB_post_recv(P2PQ, buf, key, (int)Vsync.VSYNC_MAXMSGLEN);
                buf = IB_malloc((int)Vsync.VSYNC_MAXMSGLEN);
                key = IB_register(buf, (int)Vsync.VSYNC_MAXMSGLEN);
                using (var tmpLockObj = new LockAndElevate(IBMapLock)) {
                    BTK[buf] = key;
                }

                IB_post_recv(ACKQ, buf, key, (int)Vsync.VSYNC_MAXMSGLEN);
            }
        }

        internal static int ib_send(int which, Address dest, byte[] ba) {
            if (!IBActive || Vsync.VSYNCMEMBERS == null || !Vsync.VSYNCMEMBERS.HasFirstView || dest.isNull() || dest.isMyAddress() || !Vsync.VSYNC_USERDMA) {
                return -1;
            }

            // Make sure setup has finished
            ILock.NoteThreadState("IBSetupDone.WaitOne()");
            IBSetupDone.WaitOne();
            ILock.NoteThreadState(null);
            IBSetupDone.Release();

            using (var tmpLockObj = new LockAndElevate(Vsync.VSYNCMEMBERS.ViewLock)) {
                int r = Vsync.VSYNCMEMBERS.theView.GetRankOf(dest);
                if (remotelids == null || connected == null || r == -1 || r >= remotelids.Length || remotelids[r] == 0 || !connected[r]) {
                    return -1;
                }

                if ((VsyncSystem.Debug & VsyncSystem.IBDB) != 0) {
                    Vsync.WriteLine("====> IB send group=" + which + ", dest=" + dest + ", ba.Length=" + ba.Length);
                }

                using (var tmpLockObj1 = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                    VsyncSystem.RTS.IBsent++;
                    VsyncSystem.RTS.IBBsent += ba.Length;
                }

                IntPtr copy = IB_malloc(ba.Length);
                for (int b = 0; b < ba.Length; b++) {
                    IB_saveAt(ba[b], copy + b);
                }

                int qp = which == ReliableSender.ACKBB ? remoteACKqps[r] : remoteP2Pqps[r];
                IntPtr key = IB_register(copy, ba.Length);
                using (var tmpLockObj1 = new LockAndElevate(IBMapLock)) {
                    BTK[copy] = key;
                    BTA[copy] = dest;
                }

                if (IB_post_send(qp, copy, key, ba.Length) != 0) {
                    if ((VsyncSystem.Debug & VsyncSystem.IBDB) != 0) {
                        Vsync.WriteLine("====> IB send FAILED to group=" + which + ", dest=" + dest + ", ba.Length=" + ba.Length);
                    }

                    Vsync.NodeHasFailed(dest, "IB send failed", false);
                }
            }

            return ba.Length;
        }

        /// <exclude></exclude>
        public void Dispose() {
            this.Dispose(true);
        }

        private bool disposed;

        /// <exclude></exclude>
        private void Dispose(bool disposing) {
            if (this.disposed) {
                return;
            }

            this.disposed = true;
            if (IBSetupDone != null) {
                IBSetupDone.Dispose();
            }
        }
    }

    // Currently only needs (and hence offers) a subset of the true Socket interface
    internal class MCMDSocket {
        internal const int VIRTUAL = 0;

        internal const int PHYSICAL = 1;

        internal const int UNKNOWN = -1;

        internal const int USEUNICAST = -2;

        internal int mySlot = -1;

        internal bool isTrackingProxy;

#if PROTOCOL_BUFFERS
        [ProtoContract(SkipConstructor = true)]
#else
        [AutoMarshalled]
#endif
        public class GRPair {
            [ProtoMember(1)]
            public Address gaddr;

            [ProtoMember(2)]
            public int rate;

#if !PROTOCOL_BUFFERS
            public GRPair() {
            }
#endif

            internal GRPair(Address ga, int r) {
                this.gaddr = ga;
                this.rate = r;
            }
        }

        internal static void Setup(Group g) {
            g.doRegisterAggregator((int key, GRPair[] left, GRPair[] down) => {
                if ((VsyncSystem.Debug & VsyncSystem.MCMD) != 0) {
                    string ll, dl;
                    ll = string.Empty;
                    dl = string.Empty;
                    foreach (GRPair grp in left) {
                        ll += " (" + grp.gaddr + "::" + grp.rate + ") ";
                    }

                    foreach (GRPair grp in down) {
                        ll += " (" + grp.gaddr + "::" + grp.rate + ") ";
                    }

                    Vsync.WriteLine("GRAggregator(key=" + key + "): left list = <" + ll + ">, downlist = <" + dl + ">");
                }

                List<GRPair> Agg = new List<GRPair>();
                int leftIdx = 0;
                int downIdx = 0;
                while (leftIdx < left.Length && downIdx < down.Length) {
                    Address la = left[leftIdx].gaddr, da = down[downIdx].gaddr;
                    switch (Math.Sign(la.CompareTo(da))) {
                        case -1:
                            if ((VsyncSystem.Debug & VsyncSystem.MCMD) != 0) {
                                Vsync.WriteLine("GRAggregator Retain left=(" + left[leftIdx].gaddr + "::" + left[leftIdx].rate + ")");
                            }

                            Agg.Add(left[leftIdx++]);
                            break;
                        case 0:

                            // Unclear here if it really is best to take max this way, as opposed to min or
                            // some kind of average.  Technically speaking, everyone is measuring the same thing.
                            // In fact technically speaking, new values are better than old ones.  But for inner
                            // level, which is fresher: left, or down?  In the end I decided to just use max.
                            if ((VsyncSystem.Debug & VsyncSystem.MCMD) != 0) {
                                Vsync.WriteLine("GRAggregator Compute new pair=(" + down[downIdx].gaddr + "::" + Math.Max(left[leftIdx].rate, down[downIdx].rate) + ")");
                            }

                            Agg.Add(new GRPair(la, Math.Max(left[leftIdx++].rate, down[downIdx++].rate)));
                            break;
                        case 1:
                            if ((VsyncSystem.Debug & VsyncSystem.MCMD) != 0) {
                                Vsync.WriteLine("GRAggregator Retain down=(" + down[downIdx].gaddr + "::" + down[downIdx].rate + ")");
                            }

                            Agg.Add(down[downIdx++]);
                            break;
                    }
                }

                while (leftIdx < left.Length) {
                    if ((VsyncSystem.Debug & VsyncSystem.MCMD) != 0) {
                        Vsync.WriteLine("GRAggregator Retain extra left=(" + left[leftIdx].gaddr + "::" + left[leftIdx].rate + ")");
                    }

                    Agg.Add(left[leftIdx++]);
                }

                while (downIdx < down.Length) {
                    if ((VsyncSystem.Debug & VsyncSystem.MCMD) != 0) {
                        Vsync.WriteLine("GRAggretaor Retain  extra down=(" + down[downIdx].gaddr + "::" + down[downIdx].rate + ")");
                    }

                    Agg.Add(down[downIdx++]);
                }

                return Agg.ToArray();
            });
        }

        internal static Thread ReMappingThread;

        internal static void RunMappingTask() {
            ReMappingThread = new Thread(() => {
                try {
                    while (!VsyncSystem.VsyncWasActive) {
                        Vsync.Sleep(1000);
                    }

                    while (VsyncSystem.VsyncActive) {
                        RemapDelay();
                        GRPair[] grp = WaitForAggRate(Vsync.MapperEpochId);
                        if (grp != null) {
                            Vsync.ORACLE.Send(Vsync.REMAP, Vsync.MapperEpochId, grp);
                        }

                        VsyncSystem.RTS.ThreadCntrs[26]++;
                        Vsync.MapperEpochId++;
                    }
                }
                catch (VsyncShutdownException) {
                    VsyncSystem.CheckLocksHeld();
                }

                VsyncSystem.ThreadTerminationMagic();
            }) { Name = "MCMD Remapping task", IsBackground = true };
            ReMappingThread.Start();
        }

        private static void RemapDelay() {
            long waiting = 0;
            while (VsyncSystem.VsyncActive) {
                Vsync.Sleep(1000);
                if ((waiting += 1000) > Vsync.VSYNC_REMAPDELAY) {
                    break;
                }

                if (Vsync.ORACLE == null || Vsync.VSYNCMEMBERS == null || !Vsync.ORACLE.HasFirstView || !Vsync.VSYNCMEMBERS.HasFirstView) {
                    continue;
                }

                WaitForAggRate(Vsync.MapperEpochId++);
            }
        }

        internal static volatile bool mapInitializationRunning = false;

        internal static void InitializeMap(Address who, string[] gnames, Address[] gaddrs) {
            if (mapInitializationRunning) {
                return;
            }

            mapInitializationRunning = true;
            while (Vsync.VSYNCMEMBERS == null || !Vsync.VSYNCMEMBERS.HasFirstView) {
                Vsync.Sleep(25);
            }

            Address[] jlist = Vsync.Expand(new[] { who });
            foreach (Address j in jlist) {
                Vsync.VSYNCMEMBERS.doP2PSend(j, true, Vsync.REMAP, MCMDvirtual.GetMapList(gnames, gaddrs));
            }
        }

        internal class MCMDvirtual {
            internal int VirtIPAddr;

            internal int PhysIPAddr;

            internal BoundedBuffer inBuf;

            internal int outBufPtr;

            internal MCMDvirtual(int v, int p, BoundedBuffer bb, int lo) {
                this.VirtIPAddr = v;
                this.PhysIPAddr = p;
                this.inBuf = bb;
                this.outBufPtr = lo;
            }

            internal int[] GetMap() {
                return new[] { this.VirtIPAddr, this.PhysIPAddr };
            }

            internal static int[,] GetMapAll() {
                int[,] theMap = new int[MappingLen, 2];
                int n = 0;
                using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                    for (int i = 0; i < MappingLen; i++) {
                        if (theMapping[i] != null) {
                            theMap[n, MCMDSocket.VIRTUAL] = theMapping[i].VirtIPAddr;
                            theMap[n, MCMDSocket.PHYSICAL] = theMapping[i].PhysIPAddr;
                            ++n;
                        }
                    }
                }

                if (n < MappingLen) {
                    // This is because my version of Resize only works for 1-dimensional objects
                    int[,] theCopy = new int[n, 2];
                    for (int i = 0; i < n; i++) {
                        theCopy[i, 0] = theMap[i, 0];
                        theCopy[i, 1] = theMap[i, 1];
                    }

                    return theCopy;
                }

                return theMap;
            }

            internal static int[,] GetMapList(string[] gnames, Address[] gaddrs) {
                int[] theVirtAddrs = new int[Math.Max(gnames.Length, gaddrs.Length)];
                int next = 0;
                foreach (string gn in gnames) {
                    Group tpg = Group.TrackingProxyLookup(gn);
                    if (tpg == null) {
                        continue;
                    }

                    bool fnd = false;
                    for (int i = 0; i < next && !fnd; i++) {
                        if (theVirtAddrs[i] == tpg.myVirtIPAddr) {
                            fnd = true;
                        }
                    }

                    if (fnd) {
                        continue;
                    }

                    theVirtAddrs[next++] = tpg.myVirtIPAddr;
                }

                foreach (Address ga in gaddrs) {
                    Group tpg = Group.TrackingProxyLookup(ga);
                    if (tpg == null) {
                        continue;
                    }

                    bool fnd = false;
                    for (int i = 0; i < next && !fnd; i++) {
                        if (theVirtAddrs[i] == tpg.myVirtIPAddr) {
                            fnd = true;
                        }
                    }

                    if (fnd) {
                        continue;
                    }

                    theVirtAddrs[next++] = tpg.myVirtIPAddr;
                }

                if (next < theVirtAddrs.Length) {
                    Vsync.ArrayResize(ref theVirtAddrs, next);
                }

                int[,] theMap = new int[theVirtAddrs.Length, 2];
                next = 0;
                using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                    for (int i = 0; i < MappingLen; i++) {
                        for (int j = 0; j < theVirtAddrs.Length; j++) {
                            if (theMapping[i] != null && theMapping[i].VirtIPAddr == theVirtAddrs[j]) {
                                theMap[next, MCMDSocket.VIRTUAL] = theMapping[i].VirtIPAddr;
                                theMap[next, MCMDSocket.PHYSICAL] = theMapping[i].PhysIPAddr;
                                ++next;
                                break;
                            }
                        }
                    }
                }

                return theMap;
            }
        }

        internal class MCMDphysical {
            internal int PhysIPAddr;

            internal int refCount;

            internal BoundedBuffer outBuf;

            internal IPAddress outIP;

            internal Thread outThread;

            internal Thread inThread;

            internal MCMDphysical(int pip, BoundedBuffer bb, IPAddress ipa) {
                this.PhysIPAddr = pip;
                this.refCount = 1;
                this.outBuf = bb;
                this.outIP = ipa;
            }
        }

        internal static int MappingLen = 0;

        internal static int MapArrayLen = 10;

        internal static int MapUID = 0;

        internal static MCMDvirtual[] theMapping = new MCMDvirtual[MapArrayLen];

        internal static LockObject MappingLock = new LockObject("MappingLock", ThreadPriority.Highest);

        internal static int nOutBufs = 0;

        internal static MCMDphysical[] outBufs = new MCMDphysical[0];

        internal static string GetState() {
            string s = GetMCMDMap() + Environment.NewLine + "MCMD VIRTUAL SLOTS" + Environment.NewLine;
            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                for (int i = 0; i < theMapping.Length; i++) {
                    if (theMapping[i] != null) {
                        s += "Virtual socket[" + i + "]:  (" + PMCAddr(theMapping[i].VirtIPAddr) + ":" + PMCAddr(theMapping[i].PhysIPAddr) + "), physical-slot [" + theMapping[i].outBufPtr + "], backlog " + theMapping[i].inBuf.fullSlots + Environment.NewLine;
                    }
                }

                s += "MCMD PHYSICAL SLOTS" + Environment.NewLine;
                for (int i = 0; i < outBufs.Length; i++) {
                    if (outBufs[i] != null && outBufs[i].inThread != null && outBufs[i].outThread != null) {
                        s += "Physical socket[" + i + "]: " + PMCAddr(outBufs[i].PhysIPAddr) + ", refcount=" + outBufs[i].refCount + Environment.NewLine + "  in-thread <" + (outBufs[i].inThread.Name ?? "<Unnamed user thread>") + ">" + Environment.NewLine + "  out-thread <" + (outBufs[i].outThread.Name ?? "<Unnamed user thread>") + ">, backlog " + outBufs[i].outBuf.fullSlots + Environment.NewLine;
                    }
                }
            }

            return s;
        }

        internal static void Shutdown() {
            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                if (theMapping == null) {
                    return;
                }

                for (int i = 0; i < theMapping.Length; i++) {
                    MCMDvirtual mv = theMapping[i];
                    theMapping[i] = null;
                    if (mv != null && mv.inBuf != null) {
                        BoundedBuffer.unregister(mv.inBuf);
                    }
                }

                MappingLen = 0;
                foreach (MCMDphysical mp in outBufs) {
                    if (mp != null && mp.outBuf != null) {
                        mp.outBuf.put(null, true);
                    }
                }
            }
        }

        // Used when INITIALVIEW is learned in the ORACLE
        internal static void AssignMapInfo(int[,] mms) {
            AssignMapInfo(Group.VsyncGroups, Group.VsyncGroupsLock, mms);
            AssignMapInfo(Group.TPGroups, Group.TPGroupsLock, mms);
            UpdateMCMDMapping(mms);
        }

        private static void UpdateMCMDMapping(int[,] mms) {
            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                foreach (MCMDvirtual item in theMapping) {
                    if (item != null && item.PhysIPAddr == UNKNOWN) {
                        for (int j = 0; j < mms.GetLength(0); j++) {
                            if (mms[j, VIRTUAL] == item.VirtIPAddr) {
                                item.PhysIPAddr = mms[j, PHYSICAL];
                                break;
                            }
                        }
                    }
                }
            }
        }

        private static void AssignMapInfo(Dictionary<Address, Group> grps, LockObject lo, int[,] mms) {
            List<int[]> mmList = new List<int[]>();
            using (var tmpLockObj = new LockAndElevate(lo)) {
                foreach (KeyValuePair<Address, Group> kvp in grps) {
                    Group g = kvp.Value;
                    for (int i = 0; i < mms.GetLength(0); i++) {
                        if (g.myVirtIPAddr == 0) {
                            g.myVirtIPAddr = Vsync.CLASSD + Vsync.VSYNC_MCRANGE_LOW + Address.GroupNameHash(g.gname);
                        }

                        if (g.myVirtIPAddr == mms[i, MCMDSocket.VIRTUAL]) {
                            if (g.myPhysIPAddr == mms[i, MCMDSocket.PHYSICAL]) {
                                break;
                            }

                            if (g.isTrackingProxy) {
                                g.myPhysIPAddr = mms[i, MCMDSocket.PHYSICAL];
                                break;
                            }

                            mmList.Add(new[] { mms[i, MCMDSocket.VIRTUAL], mms[i, MCMDSocket.PHYSICAL] });
                            break;
                        }
                    }
                }
            }

            foreach (int[] mm in mmList) {
                SetMap("AssignMapInfo", "AssignMapInfo", false, mm);
            }
        }

        internal static List<int> OOBAllocation = new List<int>();

        internal static int AllocateAddr() {
            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                for (int i = 0; i < Vsync.OOBMAXIPMCADDRS; i++) {
                    if (!OOBAllocation.Contains(Vsync.CLASSD + Vsync.VSYNC_MCRANGE_HIGH + i)) {
                        int theAddr = Vsync.CLASSD + Vsync.VSYNC_MCRANGE_HIGH + i;
                        OOBAllocation.Add(theAddr);
                        return theAddr;
                    }
                }

                throw new VsyncException("MCMD:OODB->AllocateAddr");
            }
        }

        internal static void DeAllocateAddr(int mcaddr) {
            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                OOBAllocation.Remove(mcaddr);
            }
        }

        internal MCMDSocket(string gname, bool isTrackingProxy, int VirtIPAddr) {
            int PhysIPAddr = MCMDSocket.UNKNOWN;
            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                this.isTrackingProxy = isTrackingProxy;
                for (int i = 0; i < MappingLen; i++) {
                    if (theMapping[i] != null && theMapping[i].VirtIPAddr == VirtIPAddr) {
                        this.mySlot = i;
                        return;
                    }
                }
            }

            using (var tmpLockObj = new LockAndElevate(Group.TPGroupsLock)) {
                foreach (KeyValuePair<Address, Group> kvp in Group.TPGroups) {
                    if (kvp.Value.myVirtIPAddr == VirtIPAddr) {
                        PhysIPAddr = kvp.Value.myPhysIPAddr;
                        break;
                    }
                }
            }

            SetMap("MCMDSocket(1)", gname, isTrackingProxy, new[] { VirtIPAddr, PhysIPAddr });
        }

        internal MCMDSocket(string gname, bool isTrackingProxy, int VirtIPAddr, int PhysIPAddr) {
            this.isTrackingProxy = isTrackingProxy;
            SetMap("MCMDSocket(2)", gname, isTrackingProxy, new[] { VirtIPAddr, PhysIPAddr });
            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                for (int i = 0; i < MappingLen; i++) {
                    if (theMapping[i].VirtIPAddr == VirtIPAddr) {
                        this.mySlot = i;
                    }
                }
            }
        }

        // Looks up the physical IP address to use for a given slot in the mapping table
        internal IPEndPoint GetRemoteEP() {
            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                IPAddress physIP = new IPAddress(theMapping[this.mySlot].PhysIPAddr & 0xFFFFFFFFL);
                return MCMDSocket.GetIPEndPoint(physIP);
            }
        }

        // Looks up the physical IP address to use for a given virtual IP address
        // Same information is available in g.myPhysIPAddr
        internal static IPEndPoint GetRemoteEP(Address gaddr) {
            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                int i = MCMDLookup(gaddr);
                if (i >= 0) {
                    IPAddress physIP = new IPAddress(theMapping[i].PhysIPAddr & 0xFFFFFFFFL);
                    return MCMDSocket.GetIPEndPoint(physIP);
                }
            }

            throw new VsyncException("GetRemoteEP: Missing the mapping for virtual address of group " + gaddr);
        }

        private static int MCMDLookup(Address gaddr) {
            byte[] hb = gaddr.home.GetAddressBytes();
            long v = (hb[0] << 24) | (hb[1] << 16) | (hb[2] << 8) | hb[3];
            for (int i = 0; i < MappingLen; i++) {
                if (theMapping[i] != null && theMapping[i].VirtIPAddr == v) {
                    return i;
                }
            }

            return -1;
        }

        internal static int nextPhysIPAddr = 0;

        internal static void SetMap(string where, string gname, bool isTrackingProxy, int[] mMap) {
            int VirtIPAddr = mMap[VIRTUAL], PhysIPAddr = mMap[PHYSICAL], firstUnusedSlot = -1;
            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                int ListeningOn = -1;
                int mySlot = -1;
                for (int i = 0; i < MappingLen; i++) {
                    if (theMapping[i] == null) {
                        firstUnusedSlot = i;
                        continue;
                    }

                    if (theMapping[i].VirtIPAddr == VirtIPAddr) {
                        if ((theMapping[i].PhysIPAddr == PhysIPAddr || PhysIPAddr == UNKNOWN) && theMapping[i].outBufPtr != -1) {
                            return;
                        }

                        if (mySlot == -1) {
                            mySlot = i;
                        }
                        else {
                            throw new VsyncException("SetMap: barf(1)");
                        }
                    }

                    if (theMapping[i].PhysIPAddr == PhysIPAddr && theMapping[i].outBufPtr != -1) {
                        ListeningOn = theMapping[i].outBufPtr;
                    }
                }

                // At this point, we know which mapping slot this group is using, and if there is any physical listener, we know the listener too
                if (mySlot == -1) {
                    // Needs a new mapping slot, allocate one.  If we noticed a free slot can use that, else extend the table
                    if ((VsyncSystem.Debug & VsyncSystem.MCMDMAP) != 0) {
                        Vsync.WriteLine("SetMap(" + where + "): Installing a new MCMD mapping: " + PMCAddr(VirtIPAddr) + " to " + PMCAddr(PhysIPAddr));
                    }

                    mySlot = firstUnusedSlot;
                    if (mySlot == -1) {
                        if (MappingLen == MapArrayLen) {
                            MapArrayLen += 10;
                            Vsync.ArrayResize(ref theMapping, MapArrayLen);
                        }

                        mySlot = MappingLen++;
                    }

                    if (isTrackingProxy) {
                        ListeningOn = -1;
                    }

                    theMapping[mySlot] = new MCMDvirtual(VirtIPAddr, PhysIPAddr, new BoundedBuffer(gname + ":MCMD", Vsync.VSYNC_MCMDBBSIZE, ILock.LLBBIN, -1, -1), ListeningOn);
                    if (ListeningOn != -1) {
                        outBufs[ListeningOn].refCount++;
                        return;
                    }
                }
                else if (theMapping[mySlot].PhysIPAddr != PhysIPAddr) {
                    // SetMap can change UNKNOWN to some known address and we'll ignore known to UNKNOWN
                    if (PhysIPAddr == UNKNOWN) {
                        return;
                    }

                    // Shouldn't be called to switch a known address to some other different mapping (ReMap cleans up first)
                    if (theMapping[mySlot].PhysIPAddr != UNKNOWN && theMapping[mySlot].PhysIPAddr != PhysIPAddr) {
                        throw new VsyncException("In setMap virtual IP addr " + PMCAddr(VirtIPAddr) + " was mapped to " + PMCAddr(theMapping[mySlot].PhysIPAddr) + " remapped to " + PMCAddr(PhysIPAddr));
                    }

                    theMapping[mySlot].PhysIPAddr = PhysIPAddr;
                }

                if (isTrackingProxy) {
                    // When mapping on behalf of a tracking proxy, no need to actually listen to the group
                    return;
                }

                if (theMapping[mySlot].outBufPtr == -1 && ListeningOn != -1) {
                    // Add reference to some existing output mapping
                    theMapping[mySlot].outBufPtr = ListeningOn;
                    outBufs[ListeningOn].refCount++;
                    return;
                }

                // We reach this point if there is no existing output mapping for this (virt:phys) pair and the group is real
                for (int i = 0; i < outBufs.Length; i++) {
                    if (outBufs[i] != null && outBufs[i].PhysIPAddr == PhysIPAddr) {
                        Vsync.WriteLine("WARNING: In SetMap " + PMCAddr(VirtIPAddr) + ":" + PMCAddr(PhysIPAddr) + "... group <" + gname + "> wasn't initialized");
                        return;
                    }
                }

                if (PhysIPAddr != USEUNICAST && PhysIPAddr != UNKNOWN) {
                    StartMCMDThreads(where, PhysIPAddr, mySlot);
                }
            }
        }

        // Called while holding lock on theMapping
        private static void StartMCMDThreads(string where, int PhysIPAddr, int mySlot) {
            int myOutbufSlot;
            string mcaddr;
            if (Vsync.VSYNC_UNICAST_ONLY) {
                return;
            }

            if ((VsyncSystem.Debug & VsyncSystem.MCMDMAP) != 0) {
                Vsync.WriteLine("SetMap(" + where + "): Starting an MCMD Socket reader and writer for PhysIP " + PMCAddr(PhysIPAddr));
            }

            IPAddress physIP = Vsync.LastIPv4(mcaddr = PMCAddr(PhysIPAddr));

            bool fnd = false;
            for (myOutbufSlot = 0; myOutbufSlot < nOutBufs; myOutbufSlot++) {
                if (outBufs[myOutbufSlot] == null) {
                    fnd = true;
                    break;
                }
            }

            if (!fnd) {
                myOutbufSlot = nOutBufs;
                nOutBufs += 10;
                Vsync.ArrayResize(ref outBufs, nOutBufs);
            }

            // Creates an outbuf and sets reference count to 1
            outBufs[myOutbufSlot] = new MCMDphysical(PhysIPAddr, new BoundedBuffer("MCMD-outgoing:" + PMCAddr(PhysIPAddr), Vsync.VSYNC_MCMDBBSIZE, ILock.LLBBOUT, -1, -1), physIP);
            theMapping[mySlot].outBufPtr = myOutbufSlot;
            Socket theSocket = MCMDSockSetup(physIP);
            outBufs[myOutbufSlot].outThread = new Thread(() => {
                BoundedBuffer bb = outBufs[myOutbufSlot].outBuf;
                try {
                    // Sender side
                    while (!VsyncSystem.VsyncActive) {
                        Vsync.Sleep(250);
                    }

                    IPEndPoint remoteEP = MCMDSocket.GetIPEndPoint(physIP);
                    while (VsyncSystem.VsyncActive) {
                        VsyncSystem.RTS.ThreadCntrs[27]++;
                        byte[] buffer = (byte[])bb.get();
                        if (buffer == null) {
                            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                                outBufs[myOutbufSlot] = null;
                            }

                            break;
                        }

                        ReliableSender.CheckLenAndRate(buffer);
                        long before = Vsync.NOW;
                        int bs = 0;
                        try {
                            bs = theSocket.SendTo(buffer, remoteEP);
                        }
                        catch (IOException) {
                        }
                        catch (SocketException) {
                        }

                        long after = Vsync.NOW;
                        if ((VsyncSystem.Debug & VsyncSystem.WARNIFSLOW) != 0 && (after - before) > 250) {
                            Vsync.WriteLine("WARNING: Sending an IPMC took " + Vsync.MsToSecs(after - before) + "s");
                        }

                        using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                            VsyncSystem.RTS.IPMCBsent += bs;
                            VsyncSystem.RTS.IPMCsent++;
                        }
                    }
                }
                catch (VsyncShutdownException) {
                    VsyncSystem.CheckLocksHeld();
                }

                if (VsyncSystem.VsyncActive) {
                    if (theSocket != null) {
                        try {
                            theSocket.Close();
                        }
                        catch (Exception) {
                        }
                    }

                    BoundedBuffer.unregister(bb);
                }

                VsyncSystem.ThreadTerminationMagic();
            }) { Name = "VSYNC MCMD: send-to " + mcaddr, Priority = ThreadPriority.AboveNormal, IsBackground = true };
            outBufs[myOutbufSlot].outThread.Start();

            outBufs[myOutbufSlot].inThread = new Thread(() => {
                try {
                    while (!VsyncSystem.VsyncActive) {
                        Vsync.Sleep(250);
                    }

                    int failedReceiveCount = 0;

                    // Receiver side
                    while (VsyncSystem.VsyncActive) {
                        VsyncSystem.RTS.ThreadCntrs[28]++;
                        int[] myVSocks = null;
                        using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                            if (MapUID != -1) {
                                if ((myVSocks = setVSocks(PhysIPAddr)) == null) {
                                    break;
                                }
                            }
                        }

                        byte[] buffer = new byte[Vsync.VSYNC_MAXMSGLEN + 1024];
                        int len;
                        try {
                            len = theSocket.Receive(buffer);
                            VsyncSystem.RTS.ThreadCntrs[32]++;
                            using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                VsyncSystem.RTS.IPMCBrcvd += len;
                                VsyncSystem.RTS.IPMCrcvd++;
                            }

                            failedReceiveCount = 0;
                        }
                        catch (IOException) {
                            len = 0;
                        }
                        catch (SocketException) {
                            len = 0;
                        }
                        catch {
                            if (failedReceiveCount++ > 10) {
                                break;
                            }

                            len = 0;
                        }

                        if (len > Vsync.VSYNC_MAXMSGLEN) {
                            Vsync.WriteLine("WARNING (c): MAXMSGLEN set to " + Vsync.VSYNC_MAXMSGLEN + ", but received length=" + len);
                        }

                        if (len > 4) {
                            int VAddr = 0;
                            for (int i = 0; i < 4; i++) {
                                VAddr = (VAddr << 8) | buffer[len - 4 + i];
                            }

                            if (len != Vsync.VSYNC_MAXMSGLEN) {
                                Vsync.ArrayResize(ref buffer, len);
                            }

                            if (!AcceptIncoming(myVSocks, buffer, VAddr)) {
                                Group g;
                                List<byte[]> ae;
                                if ((g = Group.Lookup(VAddr)) != null && (ae = g.IPMCArrivedEarly) != null) {
                                    ae.Add(buffer);
                                }
                                else {
                                    if ((VsyncSystem.Debug & VsyncSystem.DISCARDS) != 0) {
                                        Vsync.WriteLine("WARNING: Dr. Multicast filtering a incoming multicast: not a member of VirtIP=" + PMCAddr(VAddr));
                                    }

                                    using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                                        VsyncSystem.RTS.Discarded++;
                                    }
                                }
                            }
                        }
                    }
                }
                catch (VsyncShutdownException) {
                    VsyncSystem.CheckLocksHeld();
                }

                if (VsyncSystem.VsyncActive) {
                    if (outBufs[myOutbufSlot] != null && outBufs[myOutbufSlot].outIP != null) {
                        if ((VsyncSystem.Debug & VsyncSystem.MCMD) != 0) {
                            if (Vsync.InterfaceIds == null || Vsync.InterfaceIds.Count != 1) {
                                try {
                                    if (outBufs[myOutbufSlot] != null) {
                                        theSocket.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.DropMembership, new MulticastOption(outBufs[myOutbufSlot].outIP));

                                        // Leave multicast group
                                    }
                                }
                                catch (IOException) {
                                    /* Just in case */
                                }
                                catch (ObjectDisposedException) {
                                }
                            }
                            else {
                                foreach (int id in Vsync.InterfaceIds) {
                                    try {
                                        if ((VsyncSystem.Debug & VsyncSystem.INTERFACES) != 0) {
                                            Vsync.WriteLine("EXPERIMENTAL CODE: LEAVE MULTICAST INTERFACE " + id);
                                        }

                                        if (outBufs[myOutbufSlot] != null) {
                                            theSocket.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.DropMembership, new MulticastOption(outBufs[myOutbufSlot].outIP, id));

                                            // Leave multicast group
                                        }
                                    }
                                    catch (IOException e) {
                                        Vsync.WriteLine("IP_DropMembership failed: " + e); /* Just in case */
                                    }
                                    catch (ObjectDisposedException) {
                                    }
                                }
                            }
                        }
                    }
                }

                VsyncSystem.ThreadTerminationMagic();
            }) { Name = "VSYNC MCMD: receive-on " + mcaddr, Priority = ThreadPriority.Highest, IsBackground = true };
            outBufs[myOutbufSlot].inThread.Start();
        }

        private static bool AcceptIncoming(int[] myVSocks, byte[] buffer, int VAddr) {
            BoundedBuffer bb = null;
            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                for (int j = 0; j < myVSocks.Length && bb == null; j++) {
                    if (theMapping[myVSocks[j]] != null && VAddr == theMapping[myVSocks[j]].VirtIPAddr) {
                        using (var tmpLockObj1 = new LockAndElevate(Group.VsyncGroupsLock)) {
                            foreach (KeyValuePair<Address, Group> kvp in Group.VsyncGroups) {
                                if (kvp.Value.myVirtIPAddr == VAddr) {
                                    // Found a reverse-mapping slot and confirmed that I'm (still) a member of the group
                                    if (theMapping[myVSocks[j]] != null) {
                                        bb = theMapping[myVSocks[j]].inBuf;
                                    }

                                    break;
                                }
                            }
                        }
                    }
                }
            }

            if (bb != null) {
                bb.put(buffer);
                return true;
            }

            return false;
        }

        internal static void drainIPMCArrivedEarly(List<byte[]> ae) {
            if (ae == null) {
                return;
            }

            int[] AllVsocks = new int[theMapping.Length];
            for (int i = 0; i < theMapping.Length; i++) {
                AllVsocks[i] = i;
            }

            foreach (byte[] bb in ae) {
                int VAddr = 0;
                for (int i = 0; i < 4; i++) {
                    VAddr = (VAddr << 8) | bb[bb.Length - 4 + i];
                }

                AcceptIncoming(AllVsocks, bb, VAddr);
            }
        }

        internal static void DeleteMapping(int VirtIPAddr, int PhysIPAddr) {
            int fndIdx = -1;
            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                for (int i = 0; i < MappingLen; i++) {
                    if (theMapping[i] != null && theMapping[i].VirtIPAddr == VirtIPAddr) {
                        fndIdx = i;
                        break;
                    }
                }
            }

            if (fndIdx != -1) {
                MCMDDisposeMapping(fndIdx);
                CheckOutBufs();
            }
        }

        // Caller holds the MappingLock
        internal static int[] setVSocks(int PhysIPAddr) {
            int cnt = 0;
            for (int i = 0; i < MappingLen; i++) {
                if (theMapping[i] != null && theMapping[i].PhysIPAddr == PhysIPAddr) {
                    cnt++;
                }
            }

            if (cnt > 0) {
                int[] myVSocks = new int[cnt];
                cnt = 0;
                for (int i = 0; i < MappingLen; i++) {
                    if (theMapping[i] != null && theMapping[i].PhysIPAddr == PhysIPAddr) {
                        myVSocks[cnt++] = i;
                    }
                }

                return myVSocks;
            }

            return null;
        }

        internal bool UseUnicast() {
            if (this.mySlot == -1) {
                return true;
            }

            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                return theMapping[this.mySlot] == null || theMapping[this.mySlot].PhysIPAddr == USEUNICAST;
            }
        }

        internal static void GotMCMDReport(Msg m) {
            object[] obs = Msg.BArrayToObjects(m.payload, typeof(Address[]), typeof(int[]));
            Address[] gaddrs = (Address[])obs[0];
            int[] rates = (int[])obs[1];
            for (int idx = 0; idx < obs.Length; idx++) {
                Group g = Group.TrackingProxyLookup(gaddrs[idx]);
                if (g != null) {
                    Vsync.WriteLine("GotMCMDReport, setting group " + g.gaddr + " rate to " + rates[idx]);
                    g.rcvdMcastsRate = rates[idx];
                }
            }
        }

        internal static void ComputeMCMDMapping(int epochId, GRPair[] grprs) {
            if (!Vsync.VSYNC_UNICAST_ONLY) {
                if (epochId > Vsync.MapperEpochId) {
                    Vsync.MapperEpochId = epochId;
                    using (var tmpLockObj = new LockAndElevate(Group.TPGroupsLock)) {
                        foreach (KeyValuePair<Address, Group> kvp in Group.TPGroups) {
                            Group g = kvp.Value;
                            bool fnd = false;
                            foreach (GRPair gpr in grprs) {
                                if (g.gaddr == gpr.gaddr) {
                                    if ((VsyncSystem.Debug & VsyncSystem.MCMD) != 0) {
                                        Vsync.WriteLine("MCMD: ComputeMCMDMapping setting group multicast for tracking proxy of <" + g.gname + "> multicast rate to " + gpr.rate);
                                    }

                                    g.rcvdMcastsRate = gpr.rate;
                                    fnd = true;
                                    break;
                                }
                            }

                            if (!fnd) {
                                Vsync.WriteLine("WARNING: MCMD ComputeMCMDMapping: No rate found for group " + g.gname);
                            }
                        }
                    }

                    Group[] tpgs;
                    using (var tmpLockObj = new LockAndElevate(Group.TPGroupsLock)) {
                        tpgs = Group.TPGroups.Values.ToArray();
                    }

                    // Groups that asked us to use IPMC will seem to have "infinite" rates hence will bubble to the top
                    // Groups that asked to use Unicast will have "-infinite" rate and will be at the bottom
                    SortByRateTimesSize(tpgs);
                    MergeSimilarGroups(tpgs);
                    AllocateMCResources(tpgs);
                    Vsync.AnnounceMCMDMapping();
                    if ((VsyncSystem.Debug & VsyncSystem.MCMDMAP) != 0) {
                        Vsync.WriteLine("Computed new MCMD Mapping: " + GetMCMDMap());
                    }
                }
            }
        }

        internal class RSInfo : IComparable, IComparable<RSInfo>, IEquatable<RSInfo> {
            internal readonly int rateTimesSize;

            internal readonly Group gr;

            internal RSInfo(int r, Group g) {
                if (g == null) {
                    throw new ArgumentNullException("g");
                }

                this.rateTimesSize = r;
                this.gr = g;
            }

            public static bool operator <(RSInfo first, RSInfo second) {
                return Compare(first, second) < 0;
            }

            public static bool operator >(RSInfo first, RSInfo second) {
                return Compare(first, second) > 0;
            }

            public static bool operator <=(RSInfo first, RSInfo second) {
                return Compare(first, second) <= 0;
            }

            public static bool operator >=(RSInfo first, RSInfo second) {
                return Compare(first, second) >= 0;
            }

            public static bool operator ==(RSInfo first, RSInfo second) {
                return Compare(first, second) == 0;
            }

            public static bool operator !=(RSInfo first, RSInfo second) {
                return Compare(first, second) != 0;
            }

            public static int Compare(RSInfo first, RSInfo second) {
                if (object.ReferenceEquals(first, second)) {
                    return 0;
                }

                if (object.ReferenceEquals(first, null)) {
                    return -1;
                }

                if (object.ReferenceEquals(second, null)) {
                    return 1;
                }

                int comparison = second.rateTimesSize.CompareTo(first.rateTimesSize);
                if (comparison != 0) {
                    return comparison;
                }

                comparison = first.gr.CompareTo(second.gr);
                return comparison;
            }

            public int CompareTo(object other) {
                return Compare(this, other as RSInfo);
            }

            public int CompareTo(RSInfo other) {
                return Compare(this, other);
            }

            public override bool Equals(object other) {
                return Compare(this, other as RSInfo) == 0;
            }

            public bool Equals(RSInfo other) {
                return Compare(this, other) == 0;
            }

            public override int GetHashCode() {
                return this.rateTimesSize.GetHashCode() ^ this.gr.GetHashCode();
            }
        }

        internal static void SortByRateTimesSize(Group[] groups) {
            RSInfo[] rsi = new RSInfo[groups.Length];
            for (int i = 0; i < groups.Length; i++) {
                Group g = groups[i];
                int rate = g.rcvdMcastsRate;
                if (rate != int.MaxValue && rate != int.MinValue) {
                    rate = g.rcvdMcastsRate * ((g.theView == null) ? 0 : g.theView.members.Length);
                }

                rsi[i] = new RSInfo(rate, g);
            }

            Array.Sort(rsi);
            for (int i = 0; i < groups.Length; i++) {
                groups[i] = rsi[i].gr;
            }
        }

        internal static void MergeSimilarGroups(Group[] tpgs) {
            int startAt = 0;
            int forcedCnt = 0;
            List<Group> gotLucky = new List<Group>();
            bool smallSet = tpgs.Length <= Vsync.VSYNC_MAXIPMCADDRS;
            foreach (Group tpg in tpgs) {
                tpg.sameAs = null;
                if (forcedCnt < Vsync.VSYNC_MAXIPMCADDRS && ((tpg.flags & Group.G_USEIPMC) != 0 || smallSet) && ((tpg.flags & Group.G_USEUNICAST) == 0)) {
                    ++forcedCnt;
                    tpg.getsMCADDR = true;
                }
                else {
                    tpg.getsMCADDR = false;
                }
            }

            int sCnt = 0;
            do {
                // Gives up after looking at top 10% unless we're getting 50% or better compression.  Stop at end, or at
                // first group that asked us to UseUnicast (hence: those are just not considered at all)
                int endAt = Math.Min(startAt + (tpgs.Length / 10), tpgs.Length - 1);
                while (endAt > startAt && tpgs[endAt].rcvdMcastsRate == int.MinValue) {
                    --endAt;
                }

                if (endAt - startAt < 2) {
                    break;
                }

                for (int i = startAt; i < endAt; i++) {
                    foreach (Group lg in gotLucky) {
                        if (closeEnough(tpgs[i], lg)) {
                            ++sCnt;
                            tpgs[i].sameAs = lg;
                            break;
                        }
                    }

                    if (tpgs[i].sameAs == null) {
                        tpgs[i].getsMCADDR = true;
                        gotLucky.Add(tpgs[i]);
                    }
                    else {
                        tpgs[i].getsMCADDR = false;
                    }
                }

                startAt = endAt;
            }
            while (sCnt > tpgs.Length / 20 && startAt < tpgs.Length);
        }

        // Check for a 50% or better match....
        internal static bool closeEnough(Group a, Group b) {
            if (a == b) {
                return true;
            }

            View va, vb;
            using (var tmpLockObj = new LockAndElevate(a.ViewLock)) {
                va = a.theView;
            }

            using (var tmpLockObj = new LockAndElevate(b.ViewLock)) {
                vb = b.theView;
            }

            if (va == null || vb == null) {
                return false;
            }

            if (va.members.Length > 5) {
                // Quick rule of thumb: if we'll be getting a 50% match, odds are that 5 randomly picked members have at least 2 matches
                // So check that property and don't do a careful check on the full membership lists (could be very long) unless this simple
                // test is a success.  We do run a risk of failing to merge groups that are actually similar but we save a lot of time this way
                int cnt5 = 0;
                for (int i = 0; i < 5 && cnt5 < 2; i++) {
                    if (vb.GetRawRankOf(va.members[i]) != -1) {
                        ++cnt5;
                    }
                }

                if (cnt5 < 2) {
                    return false;
                }
            }

            // Oh well, no choice now except to grind out the full check.  But stop early if we get lucky and hit the 50% threshold quickly
            int cntMatch = 0;
            int threshold = Math.Max(va.members.Length, vb.members.Length) / 2;
            for (int i = 0; i < va.members.Length && cntMatch < threshold; i++) {
                if (va.GetRawRankOf(va.members[i]) != -1) {
                    ++cntMatch;
                }
            }

            // Merge these groups if they have > 50% common members, else don't
            return cntMatch >= threshold;
        }

        // Allocate new IPMC addresses (not previously used) to at most VSYNC_MAXIPMCADDRS groups
        // WARNING: During the switch-over twice VSYNC_MAXIPMCADDRS will temporarily be in use
        internal static void AllocateMCResources(Group[] tpgs) {
            using (var tmpLockObj = new LockAndElevate(Group.TPGroupsLock)) {
                foreach (KeyValuePair<Address, Group> kvp in Group.TPGroups) {
                    Group g = kvp.Value;
                    g.hasPhysMapping = false;
                    g.myPhysIPAddr = USEUNICAST;
                }

                Vsync.nPhysAddrsInUse = 0;
                for (int gn = 0; gn < tpgs.Length && Vsync.nPhysAddrsInUse < Vsync.VSYNC_MAXIPMCADDRS; gn++) {
                    Group ga = null;
                    foreach (KeyValuePair<Address, Group> kvp in Group.TPGroups) {
                        if (kvp.Value.gaddr == tpgs[gn].gaddr) {
                            ga = kvp.Value;
                        }
                    }

                    if (ga != null) {
                        if (ga.getsMCADDR) {
                            ga.hasPhysMapping = true;
                            ga.myPhysIPAddr = nextIPMCAddr(Vsync.VSYNC_MAXIPMCADDRS << 1);
                        }
                        else if (ga.sameAs != null) {
                            ga.myPhysIPAddr = ga.sameAs.myPhysIPAddr;
                        }
                        else {
                            ga.myPhysIPAddr = USEUNICAST;
                        }
                    }
                }
            }

            if ((VsyncSystem.Debug & VsyncSystem.MCMDMAP) != 0) {
                Vsync.WriteLine("After AllocateMCResources " + GetMCMDMap());
            }
        }

        private static int nextIPMCAddr(int limit) {
            if (Vsync.VSYNC_UNICAST_ONLY) {
                return USEUNICAST;
            }

            if (nextPhysIPAddr == 0) {
                nextPhysIPAddr = Vsync.CLASSD + Vsync.VSYNC_MCRANGE_LOW + 1;
            }

            List<int> inUse = new List<int> { Vsync.ORACLE.myPhysIPAddr };
            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                foreach (int a in OOBAllocation) {
                    inUse.Add(a);
                }

                for (int i = 0; i < MappingLen; i++) {
                    if (theMapping[i] != null && !inUse.Contains(theMapping[i].PhysIPAddr)) {
                        inUse.Add(theMapping[i].PhysIPAddr);
                    }
                }
            }

            using (var tmpLockObj = new LockAndElevate(Group.TPGroupsLock)) {
                foreach (KeyValuePair<Address, Group> kvp in Group.TPGroups) {
                    Group g = kvp.Value;
                    if (g.myPhysIPAddr != UNKNOWN && g.myPhysIPAddr != USEUNICAST && !inUse.Contains(g.myPhysIPAddr)) {
                        inUse.Add(g.myPhysIPAddr);
                    }
                }
            }

            for (int a = Vsync.CLASSD + Vsync.VSYNC_MCRANGE_LOW; a < nextPhysIPAddr; a++) {
                if (!inUse.Contains(a)) {
                    IPMCReport(inUse, "successfully assigned", a);
                    return a;
                }
            }

            if (Vsync.nPhysAddrsInUse == limit) {
                IPMCReport(inUse, "all slots are inuse, hit limit, returning ", USEUNICAST);
                return USEUNICAST;
            }

            nextPhysIPAddr++;
            Vsync.nPhysAddrsInUse++;
            IPMCReport(inUse, "all slots are inuse, allocated new address ", nextPhysIPAddr);
            if (nextPhysIPAddr == Vsync.CLASSD + Vsync.VSYNC_MCRANGE_HIGH) {
                nextPhysIPAddr = Vsync.CLASSD + Vsync.VSYNC_MCRANGE_LOW;
            }

            return nextPhysIPAddr;
        }

        private static void IPMCReport(List<int> inUse, string s, int a) {
            if ((VsyncSystem.Debug & VsyncSystem.MCMDMAP) != 0) {
                string inuse = " ";
                foreach (int x in inUse) {
                    inuse += PMCAddr(x) + " ";
                }

                Vsync.WriteLine("nextIPMCAddr: InUse { " + inuse + " }, " + s + "  " + PMCAddr(a));
            }
        }

        private static string GetMCMDMap() {
            List<Group> mapList = Group.VsyncAllGroupsClone(true);
            string res = "MCMD Mapping:" + Environment.NewLine;
            foreach (Group g in mapList) {
                res += "    Group [" + g.gname + "]: rate = " + g.rcvdMcastsRate + "    VirtIPAddr=" + PMCAddr(g.myVirtIPAddr) + ", ";
                if (g.getsMCADDR) {
                    res += "has a physical IP multicast address: " + PMCAddr(g.myPhysIPAddr);
                }
                else if (g.sameAs != null) {
                    res += "shares physical IP multicast address: " + PMCAddr(g.myPhysIPAddr) + " with group [" + g.sameAs.gname + "]";
                }
                else {
                    res += "mapped to " + PMCAddr(g.myPhysIPAddr);
                }

                res += Environment.NewLine;
            }

            return res;
        }

        internal static string PMCAddr(int theAddr) {
            if (theAddr == USEUNICAST) {
                return "<UNICAST>";
            }

            if (theAddr == UNKNOWN) {
                return "<UNKNOWN>";
            }

            return ((theAddr >> 24) & 0xFF).ToString(CultureInfo.InvariantCulture) + "." + ((theAddr >> 16) & 0xFF).ToString(CultureInfo.InvariantCulture) + "." + ((theAddr >> 8) & 0xFF).ToString(CultureInfo.InvariantCulture) + "." + (theAddr & 0xFF).ToString(CultureInfo.InvariantCulture);
        }

        internal static string PMCAddr(byte[] theAddr) {
            return theAddr[0].ToString(CultureInfo.InvariantCulture) + "." + theAddr[1].ToString(CultureInfo.InvariantCulture) + "." + theAddr[2].ToString(CultureInfo.InvariantCulture) + "." + theAddr[3].ToString(CultureInfo.InvariantCulture);
        }

        internal static IPEndPoint GetIPEndPoint(IPAddress ipa) {
            return new IPEndPoint(ipa, Vsync.VSYNC_GROUPPORT + Math.Abs(ipa.GetHashCode()) % 1000);
        }

        internal static Socket MCMDSockSetup(IPAddress theIPAddr) {
            if (Vsync.VSYNC_UNICAST_ONLY) {
                throw new VsyncException("Attempt to do an MCMD SockSetup from " + Vsync.ExtractStackTrace());
            }

            Socket theSocket = null;
            try {
                theSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
                IPEndPoint localEndPoint = new IPEndPoint(IPAddress.Any, Vsync.VSYNC_GROUPPORT + Math.Abs(theIPAddr.GetHashCode()) % 1000);
                theSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, 1);

                // Allows sharing of this socket by multiple processes on this machine
                theSocket.Bind(localEndPoint);
                theSocket.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.MulticastTimeToLive, Vsync.VSYNC_TTL);

                // Sets TTL (default: to LAN only)
                if (Vsync.VSYNC_UDPCHKSUM) {
                    theSocket.SetSocketOption(SocketOptionLevel.Udp, SocketOptionName.ChecksumCoverage, 1);
                }

                if ((VsyncSystem.Debug & VsyncSystem.MCMD) != 0) {
                    Vsync.WriteLine("Physical subscribe to IP address " + theIPAddr);
                }

                if (Vsync.InterfaceIds == null || Vsync.InterfaceIds.Count == 0) {
                    theSocket.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.AddMembership, new MulticastOption(theIPAddr));
                }
                else if (Vsync.InterfaceIds.Count > 1) {
                    theSocket.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.AddMembership, new MulticastOption(theIPAddr));
                }
                else {
                    foreach (int id in Vsync.InterfaceIds) {
                        try {
                            if ((VsyncSystem.Debug & VsyncSystem.INTERFACES) != 0) {
                                Vsync.WriteLine("JOIN MULTICAST INTERFACE " + id);
                            }

                            theSocket.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.AddMembership, new MulticastOption(theIPAddr, id)); // Join multicast group
                        }
                        catch (IOException e) {
                            Vsync.WriteLine("IP_AddMembership failed: " + e); /* Just in case */
                        }
                        catch (ObjectDisposedException) {
                        }
                    }
                }

                try {
                    theSocket.ReceiveBufferSize = (int)Math.Min(128 * Vsync.VSYNC_MAXMSGLEN, int.MaxValue);
                    theSocket.SendBufferSize = (int)Math.Min(32 * Vsync.VSYNC_MAXMSGLEN, int.MaxValue);
                    theSocket.ReceiveTimeout = 1000;
                }
                catch (Exception e) {
                    Vsync.WriteLine("MCMD SockSetup unable to set send/recieve/ReceiveTimeout: " + e);
                }

                return theSocket;
            }
            catch (Exception e) {
                if (theSocket != null) {
                    theSocket.Close();
                }

                throw new VsyncException("MCMD SockSetup failed: error <" + e + "> " + GetMCMDMap());
            }
        }

        internal static int[] GetMap(Address gaddr, bool allocateMapIfUnknown) {
            int v;
            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                v = AddressToVirtual(gaddr);
                for (int i = 0; i < MappingLen; i++) {
                    if (theMapping[i] != null && theMapping[i].VirtIPAddr == v && theMapping[i].PhysIPAddr != UNKNOWN) {
                        if ((VsyncSystem.Debug & VsyncSystem.MCMDMAP) != 0) {
                            Vsync.WriteLine("GetMap: MCMD mapping was already known: " + PMCAddr(v) + " to " + PMCAddr(theMapping[i].PhysIPAddr));
                        }

                        return theMapping[i].GetMap();
                    }
                }
            }

            Group g = Group.TrackingProxyLookup(gaddr);
            if (!g.hasPhysMapping) {
                using (var tmpLockObj = new LockAndElevate(Group.TPGroupsLock)) {
                    foreach (KeyValuePair<Address, Group> kvp in Group.TPGroups) {
                        Group gb = kvp.Value;
                        if (gb.hasPhysMapping && closeEnough(g, gb)) {
                            g.hasPhysMapping = true;
                            g.myPhysIPAddr = gb.myPhysIPAddr;
                            if ((VsyncSystem.Debug & VsyncSystem.MCMDMAP) != 0) {
                                Vsync.WriteLine("GetMap: Reusing an existing MCMD mapping: " + PMCAddr(v) + " to " + PMCAddr(g.myPhysIPAddr));
                            }

                            return new[] { v, g.myPhysIPAddr };
                        }

                        if ((VsyncSystem.Debug & VsyncSystem.MCMDMAP) != 0) {
                            Vsync.WriteLine("GetMap: don't compare against " + gb.gname + ": (g == gp)=" + (g == gb) + ", gb.hasPhysMapping=" + gb.hasPhysMapping + ", closeEnough(g, gb)=" + (g != gb && gb.hasPhysMapping ? "false" : "not tested"));
                        }
                    }
                }

                if (allocateMapIfUnknown) {
                    g.hasPhysMapping = true;
                    g.myPhysIPAddr = nextIPMCAddr(Vsync.VSYNC_MAXIPMCADDRS);
                    if ((VsyncSystem.Debug & VsyncSystem.MCMDMAP) != 0) {
                        Vsync.WriteLine("GetMap: Creating a new MCMD mapping: " + PMCAddr(v) + " to " + PMCAddr(g.myPhysIPAddr));
                    }
                }
            }

            return new[] { v, g.myPhysIPAddr };
        }

        private static int AddressToVirtual(Address gaddr) {
            byte[] hb = gaddr.home.GetAddressBytes();
            int v = (hb[0] << 24) | (hb[1] << 16) | (hb[2] << 8) | hb[3];
            return v;
        }

        internal static int[,] GetMap(Address[] gaddrs) {
            int[,] mms = new int[gaddrs.Length, 2];
            for (int i = 0; i < gaddrs.Length; i++) {
                int[] mm = GetMap(gaddrs[i], false);
                mms[i, VIRTUAL] = mm[VIRTUAL];
                mms[i, PHYSICAL] = mm[PHYSICAL];
            }

            if ((VsyncSystem.Debug & VsyncSystem.MCMDMAP) != 0) {
                Vsync.WriteLine("GetMap[,]: Returning a new MCMD mapping table:");
                for (int i = 0; i < mms.GetLength(0); i++) {
                    Vsync.WriteLine("   Map virtual address " + PMCAddr(mms[i, VIRTUAL]) + " to physical address " + PMCAddr(mms[i, PHYSICAL]));
                }
            }

            return mms;
        }

        internal static void ReMap(int epochId, int[,] mms) {
            bool disposed = false;
            int mmsLen = mms.GetLength(0);
            if ((VsyncSystem.Debug & VsyncSystem.MCMDMAP) != 0) {
                Vsync.WriteLine("Received a new MCMD mapping table for epoch(" + epochId + "):");
                for (int i = 0; i < mms.GetLength(0); i++) {
                    Vsync.WriteLine("   Map virtual address " + PMCAddr(mms[i, VIRTUAL]) + " to physical address " + PMCAddr(mms[i, PHYSICAL]));
                }
            }

            // Clean the mms mapping to eliminate entries that aren't relevant to this process
            int newLen = 0;
            for (int i = 0; i < mms.GetLength(0); i++) {
                bool fnd = false;
                using (var tmpLockObj = new LockAndElevate(Group.VsyncGroupsLock)) {
                    foreach (KeyValuePair<Address, Group> kvp in Group.VsyncGroups) {
                        if (kvp.Value.myVirtIPAddr == mms[i, VIRTUAL] && (kvp.Value != Vsync.ORACLE || Vsync.ClientOf == null)) {
                            fnd = true;
                        }
                    }
                }

                if (fnd) {
                    mms[newLen, VIRTUAL] = mms[i, VIRTUAL];
                    mms[newLen, PHYSICAL] = mms[i, PHYSICAL];
                    ++newLen;
                }
            }

            if (newLen != mmsLen) {
                int[,] newMMS = new int[newLen, 2];
                for (int i = 0; i < newLen; i++) {
                    newMMS[i, VIRTUAL] = mms[i, VIRTUAL];
                    newMMS[i, PHYSICAL] = mms[i, PHYSICAL];
                }

                mms = newMMS;
                mmsLen = newLen;
            }

            Dictionary<int, int> QuickMap = new Dictionary<int, int>(64);
            for (int i = 0; i < mmsLen; i++) {
                // Make a quick note of the mapping for each virtual address
                QuickMap.Add(mms[i, VIRTUAL], mms[i, PHYSICAL]);
            }

            // Use lists to avoid calls from inside the locked code block
            List<int> disposeEm = new List<int>();
            List<int[]> mapEm = new List<int[]>();
            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                // Install the new map, then get everyone to switch to it
                for (int i = 0; i < MappingLen; i++) {
                    if (theMapping[i] != null && QuickMap.ContainsKey(theMapping[i].VirtIPAddr)) {
                        break;
                    }

                    disposed = true;
                    disposeEm.Add(i);
                }

                for (int i = 0; i < mmsLen; i++) {
                    for (int j = 0; j < MappingLen; j++) {
                        int vaddr;
                        if (theMapping[j] != null && QuickMap.TryGetValue(theMapping[j].VirtIPAddr, out vaddr) && vaddr == mms[i, VIRTUAL]) {
                            if (theMapping[j].PhysIPAddr != mms[i, PHYSICAL]) {
                                if (theMapping[j].PhysIPAddr != UNKNOWN && theMapping[j].PhysIPAddr != USEUNICAST) {
                                    disposed = true;
                                    disposeEm.Add(j);
                                }

                                mapEm.Add(new[] { mms[i, VIRTUAL], mms[i, PHYSICAL] });
                            }

                            break;
                        }
                    }
                }
            }

            foreach (int i in disposeEm) {
                MCMDDisposeMapping(i);
            }

            if (disposed) {
                CheckOutBufs();
            }

            foreach (int[] mm in mapEm) {
                SetMap("ReMap", "ReMap", false, mm);
            }

            if (epochId == -1) {
                return;
            }

            using (var tmpLockObj = new LockAndElevate(Group.VsyncGroupsLock)) {
                foreach (KeyValuePair<Address, Group> kvp in Group.VsyncGroups) {
                    Group g = kvp.Value;
                    int paddr;
                    QuickMap.TryGetValue(g.myVirtIPAddr, out paddr);
                    g.myPhysIPAddr = paddr;
                }
            }

            GRPair[] myGRPairs = Group.GroupRates();
            if ((VsyncSystem.Debug & VsyncSystem.MCMD) != 0) {
                string ll;
                ll = string.Empty;
                foreach (GRPair grp in myGRPairs) {
                    ll += " (" + grp.gaddr + "::" + grp.rate + ") ";
                }

                Vsync.WriteLine("MCMD: Setting GRAggregator(key=" + epochId + "): list = <" + ll + ">)");
            }

            Vsync.VSYNCMEMBERS.SetAggregatorValue(epochId, myGRPairs);
        }

        internal static GRPair[] WaitForAggRate(int epochId) {
            GRPair[] grprs;
            try {
                if ((VsyncSystem.Debug & VsyncSystem.MCMD) != 0) {
                    Vsync.WriteLine("MCMD: WaitForAggRate(key=" + epochId + ")");
                }

                grprs = Vsync.VSYNCMEMBERS.GetAggregatorResult<int, GRPair[]>(epochId);
                if (grprs == null) {
                    return null;
                }
            }
            catch (AggregationFailedException) {
                if ((VsyncSystem.Debug & VsyncSystem.MCMD) != 0) {
                    Vsync.WriteLine("MCMD: Rate aggregator failed.");
                }

                return null;
            }

            if ((VsyncSystem.Debug & VsyncSystem.MCMD) != 0) {
                string ll;
                ll = string.Empty;
                foreach (GRPair grp in grprs) {
                    ll += " (" + grp.gaddr + "::" + grp.rate + ") ";
                }

                Vsync.WriteLine("MCMD: After wait, obtained GRAggregator(key=" + epochId + "): list = <" + ll + ">)");
            }

            return grprs;
        }

        private static void MCMDDisposeMapping(int n) {
            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                // Dispose of the mapping entry and associated input buffer
                if (theMapping[n] == null) {
                    return;
                }

                BoundedBuffer.unregister(theMapping[n].inBuf);
                if (theMapping[n].outBufPtr != -1) {
                    outBufs[theMapping[n].outBufPtr].refCount--;
                }

                theMapping[n] = null;
            }
        }

        private static void CheckOutBufs() {
            // This reduced the number of references to the associated output
            // buffer.  Dispose of it if this was the last reference
            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                for (int i = 0; i < nOutBufs; i++) {
                    if (outBufs[i] != null) {
                        outBufs[i].refCount = 0;
                    }
                }

                for (int i = 0; i < MappingLen; i++) {
                    if (theMapping[i] != null && theMapping[i].outBufPtr != -1) {
                        outBufs[theMapping[i].outBufPtr].refCount++;
                    }
                }

                for (int i = 0; i < nOutBufs; i++) {
                    if (outBufs[i] != null && outBufs[i].refCount == 0) {
                        outBufs[i].outBuf.put(null);
                    }
                }
            }
        }

        internal static void UnMap(Address[] gaddrs) {
            bool disposed = false;

            // Close listed groups, terminate their mappings
            foreach (Address gaddr in gaddrs) {
                int i;
                if ((i = MCMDLookup(gaddr)) != -1) {
                    disposed = true;
                    MCMDDisposeMapping(i);
                }
            }

            if (disposed) {
                CheckOutBufs();
            }
        }

        internal bool NBSendTo(byte[] buffer) {
            return this.SendTo(buffer, false);
        }

        internal bool SendTo(byte[] buffer) {
            return this.SendTo(buffer, true);
        }

        internal bool SendTo(byte[] buffer, bool OkToBlock) {
            long v;
            int n = buffer.Length;
            ReliableSender.CheckLenAndRate(buffer, false);
            BoundedBuffer bb;
            int[] mm = null;
            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                if (theMapping[this.mySlot] == null) {
                    return false;
                }

                if (theMapping[this.mySlot].outBufPtr == -1) {
                    mm = new[] { theMapping[this.mySlot].VirtIPAddr, theMapping[this.mySlot].PhysIPAddr };
                }
            }

            if (mm != null) {
                SetMap("SendTo", "SendTo", false, mm);
            }

            using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                if (theMapping[this.mySlot] == null || theMapping[this.mySlot].outBufPtr == -1) {
                    if ((VsyncSystem.Debug & VsyncSystem.MCMD) != 0) {
                        Vsync.WriteLine("WARNING: Discarding an outgoing message in SendTo: slot " + this.mySlot + " has no mapping");
                    }

                    return false;
                }

                v = theMapping[this.mySlot].VirtIPAddr;
                bb = outBufs[theMapping[this.mySlot].outBufPtr].outBuf;
            }

            // Before sending, append 4-byte virtual address as a trailer
            Vsync.ArrayResize(ref buffer, n + 4);
            for (int i = 0; i < 4; i++) {
                buffer[n + 3 - i] = (byte)(v & 0xFF);
                v >>= 8;
            }

            if (!OkToBlock && bb.putWillBlock(1)) {
                return false;
            }

            bb.put(buffer);
            return true;
        }

        internal byte[] Receive() {
            while (!VsyncSystem.VsyncActive) {
                Vsync.Sleep(250);
            }

            while (VsyncSystem.VsyncActive) {
                BoundedBuffer bb;
                VsyncSystem.RTS.ThreadCntrs[29]++;
                using (var tmpLockObj = new LockAndElevate(MappingLock)) {
                    if (theMapping[this.mySlot] == null) {
                        // Race condition can arise when starting up and unsure if I'll be an ORACLE member or not...
                        Vsync.Sleep(50);
                        return null;
                    }

                    bb = theMapping[this.mySlot].inBuf;
                }

                byte[] buffer = (byte[])bb.get();
                if (buffer != null) {
                    // Strip trailer, then pass up
                    Vsync.ArrayResize(ref buffer, buffer.Length - 4);
                    if (!Msg.VerifySignature(buffer, 0, buffer.Length)) {
                        Vsync.Sleep(50);
                        continue;
                    }
                }

                return buffer;
            }

            throw new VsyncShutdownException("Vsync Inactive");
        }
    }

    internal sealed class ILock : IDisposable {
        internal static Dictionary<Thread, string> ThreadStates = new Dictionary<Thread, string>();

        internal static LockObject TSLock = new LockObject("TSLock");

        internal class LockInfo {
            internal LockInfo Next;

            internal int LockLevel;

            internal int LockId;

            internal bool WaitingFor = false;

            internal bool ReLocked = false;

            internal LockInfo(int ll, int li) {
                this.LockLevel = ll;
                this.LockId = li;
            }

            internal LockInfo(int ll, int li, bool wf) {
                this.LockLevel = ll;
                this.LockId = li;
                this.WaitingFor = wf;
            }

            public override string ToString() {
                return PLock(this.LockLevel, this.LockId) + (this.ReLocked ? "(relocked)" : string.Empty);
            }
        }

        internal class LockInfoHead {
            internal LockInfo First;

            internal volatile string Tname;

            internal LockInfoHead(string name) {
                this.Tname = name;
            }
        }

        internal class PWaitInfo {
            internal Address gaddr;

            internal Address[] plist;

            internal PWaitInfo(Address g, Address[] p) {
                this.gaddr = g;
                this.plist = p;
            }
        }

        internal class IdAndCtr {
            internal int Id;

            internal int Cntr;

            internal IdAndCtr(int i) {
                this.Id = i;
                this.Cntr = 1;
            }
        }

        private static int LILEN = 100;

        private static readonly LockObject LInfoLock = new LockObject(false, "LInfoLock");

        private static int next;

        private static LockInfoHead[] LInfo = new LockInfoHead[LILEN];

        private static PWaitInfo[] ProcessWait = new PWaitInfo[LILEN];

        private static readonly LockObject ProcessWaitLock = new LockObject("ProcessWaitLock");

        private static Semaphore[] Barriers = new Semaphore[LILEN];

        private static readonly LockObject BarriersLock = new LockObject("BarriersLock");

        public const int LLBRIEF = 0;

        public const int LLENTRY = 1;

        public const int LLWAIT = 2;

        public const int LLWAITG = 3;

        public const int LLREPLY = 4;

        public const int LLINITV = 5;

        public const int LLLB = 6;

        public const int LLBBOUT = 7;

        public const int LLBBIN = 8;

        public const int LLLARGE = 9;

        public const int LLLARGEBW = 10;

        public const int LLACKB = 11;

        public const int LLP2PB = 12;

        public const int LLFRAG = 13;

        public const int LLIPMC = 14;

        public const int LLDELIVERY = 15;

        public const int LLTCP = 16;

        private const int NLEVELS = 17;

        /* Sub-ids used with LLWAIT */

        public const int LCLIENTOF = 0;

        public const int LGVEUPDATE = 1;

        public const int LCOMMIT = 2;

        public const int LFLUSH = 3;

        public const int LFLOWCNTRL = 4;

        public const int LFLOWCNTRLB = 5;

        public const int LJOINB = 6;

        private static readonly Semaphore[][] Semaphores = new Semaphore[NLEVELS][];

        internal static LockObject SemaphoresLock = new LockObject(false, "SemaphoresLock");

        private static readonly bool[][] isBarrier = new bool[NLEVELS][];

        private static readonly int[][] nWaiters = new int[NLEVELS][];

        private static readonly int[][] Holding = new int[NLEVELS][];

        private static readonly Dictionary<int, IdAndCtr>[] LockIds = new Dictionary<int, IdAndCtr>[NLEVELS];

        private static readonly LockObject LockIdsLock = new LockObject("LockIdsLock", ThreadPriority.Highest);

        private static readonly string[] levels = { "brief", "entry", "general wait", "join-wait", "reply-wait with ilock barrier", "needs initial view", "barrier", "bb-out", "bb-in", "large", "largebw", "ackb", "p2pB", "frag", "ipmc", "delivery", "tcp" };

        private static readonly string[] sls = { "client-of", "gveupdate", "commit", "flush", "flow-control (local backlog)", "flow-control (remote backlog)", "waiting for a join to complete" };

        internal static void NoteThreadState(string s) {
            if (Vsync.VSYNC_TRACKTHREADWAITS) {
                using (var tmpLockObj = new LockAndElevate(TSLock)) {
                    if (s != null) {
                        ThreadStates[Thread.CurrentThread] = s;
                    }
                    else {
                        ThreadStates.Remove(Thread.CurrentThread);
                    }
                }
            }
        }

        internal static string GetThreadStates() {
            if (Vsync.VSYNC_TRACKTHREADWAITS) {
                string s = string.Empty;
                using (var tmpLockObj = new LockAndElevate(TSLock))
                    foreach (var kvp in ThreadStates)
                        if (kvp.Value != null) {
                            s += "  Thread <" + (kvp.Key.Name ?? "(unnamed)") + ">: " + kvp.Value + Environment.NewLine;
                        }

                return string.IsNullOrEmpty(s) ? s : ("THREAD WAITS:" + Environment.NewLine + s);
            }
            else {
                return String.Empty;
            }
        }

        internal static string PLock(ILock il) {
            if (il == null) {
                return "<null>";
            }

            return PLock(il.level, il.lockId);
        }

        internal static string PLock(int level, int sublevel) {
            if (level < 0 || level >= levels.Length) {
                return "<Unknown level: " + level + ">";
            }

            string sl = null;
            if (level == LLWAIT) {
                if (sublevel < 0 || sublevel >= sls.Length) {
                    sl = "<" + sublevel + ">";
                }
                else {
                    sl = sls[sublevel];
                }
            }
            else if (level != LLREPLY && level != LLLB && level != LLBBOUT && level != LLBBIN) {
                if (LockIds[level] != null) {
                    foreach (KeyValuePair<int, IdAndCtr> kvp in LockIds[level]) {
                        if (kvp.Value.Id == sublevel) {
                            using (var tmpLockObj = new LockAndElevate(Group.VsyncGroupsLock)) {
                                foreach (KeyValuePair<Address, Group> gkvp in Group.VsyncGroups) {
                                    if (gkvp.Value.gaddr.GetHashCode() == kvp.Key) {
                                        sl = gkvp.Value.gname;
                                        break;
                                    }
                                }
                            }

                            if (sl != null) {
                                break;
                            }

                            using (var tmpLockObj = new LockAndElevate(Group.TPGroupsLock)) {
                                foreach (KeyValuePair<Address, Group> gkvp in Group.TPGroups) {
                                    if (gkvp.Value.gaddr.GetHashCode() == kvp.Key) {
                                        sl = gkvp.Value.gname;
                                        break;
                                    }
                                }
                            }

                            break;
                        }
                    }
                }

                if (sl == null) {
                    sl = sublevel.ToString(CultureInfo.InvariantCulture);
                }
            }
            else {
                sl = sublevel.ToString(CultureInfo.InvariantCulture);
            }

            return "[" + levels[level] + ":" + sl + "]";
        }

        internal static void Shutdown() {
            using (var tmpLockObj = new LockAndElevate(SemaphoresLock)) {
                for (int i = 0; i < Semaphores.Length; i++) {
                    if (Semaphores[i] != null) {
                        for (int j = 0; j < Semaphores[i].Length; j++) {
                            if (Semaphores[i][j] != null) {
                                if ((VsyncSystem.Debug & VsyncSystem.LOCKSTATE) != 0) {
                                    Vsync.WriteLine("Vsync.Shutdown releasing-all for semaphore[" + i + "][" + j + "]");
                                }

                                int nr = Math.Max(nWaiters[i][j], 1);
                                Semaphores[i][j].Release(nr);
                            }
                        }
                    }
                }
            }
        }

        public static string GetState() {
            string s = LockObject.GetState() + "THREAD ILOCK STATE:" + Environment.NewLine;
            using (var tmpLockObj = new LockAndElevate(VsyncSystem.RTS.Lock)) {
                if (VsyncSystem.RTS.ackProcessingBeganAt > 0) {
                    s += "  Thead[*](Ack-processing thread) is processing a received ack/nack for " + Vsync.MsToSecs(Vsync.NOW - VsyncSystem.RTS.ackProcessingBeganAt) + " secs" + Environment.NewLine;
                }
                else {
                    s += "  Thead[*](Ack-processing thread) is waiting to remove an object from AckBB" + Environment.NewLine;
                }

                if (VsyncSystem.RTS.rcvProcessingBeganAt > 0) {
                    s += "  Thead[*](Receive-processing thread) has been running for " + Vsync.MsToSecs(Vsync.NOW - VsyncSystem.RTS.rcvProcessingBeganAt) + " secs" + Environment.NewLine;
                }
                else {
                    s += "  Thead[*](Receive-processing thread) is waiting to remove an object on RecvBB" + Environment.NewLine;
                }
            }

            using (var tmpLockObj = new LockAndElevate(SemaphoresLock)) {
                for (int id = 0; id < LILEN; id++) {
                    using (var tmpLockObj1 = new LockAndElevate(LInfoLock)) {
                        if (LInfo[id] == null) {
                            continue;
                        }

                        LockInfo li = LInfo[id].First;
                        if (li == null) {
                            continue;
                        }

                        s += "  Thread[" + id + "] (" + (LInfo[id].Tname ?? "Unnamed user-created thread") + ")";
                        if (li.WaitingFor) {
                            s += ": Waiting for " + li;
                            li = li.Next;
                        }

                        if (ProcessWait[id] != null) {
                            if (ProcessWait[id].gaddr != null) {
                                s += "; while watching Group " + ProcessWait[id].gaddr + ", members ";
                            }

                            s += Address.VectorToString(ProcessWait[id].plist);
                        }

                        if (li != null) {
                            s += "; Holding ";
                            while (li != null) {
                                s += "{" + li + "}";
                                li = li.Next;
                            }
                        }
                    }

                    s += Environment.NewLine;
                }

                s += "SEMAPHORE STATE:" + Environment.NewLine;
                for (int l = 0; l < NLEVELS; l++) {
                    if (Semaphores[l] != null) {
                        for (int id = 0; id < Semaphores[l].Length; id++) {
                            string h = string.Empty;
                            if (nWaiters[l][id] == 0 && Holding[l][id] == 0) {
                                continue;
                            }

                            if (isBarrier[l][id]) {
                                s += "  (barrier)";
                            }
                            else if (l == LLLB || l == LLBBOUT || l == LLBBIN) {
                                s += "  (bounded buffer)";
                            }
                            else if (Holding[l][id] != 0) {
                                h = ", Nholding " + Holding[l][id];
                            }

                            s += "  " + PLock(l, id) + ", Nwaiters = " + nWaiters[l][id];
                            s += h + Environment.NewLine;
                        }
                    }
                }
            }

            return s;
        }

        internal static void ScanPWaits() {
            List<int> toWake = new List<int>();
            using (var tmpLockObj = new LockAndElevate(Group.GroupRIPLock)) {
                for (int id = 0; id < ProcessWait.Length; id++) {
                    if (ProcessWait[id] != null && Group.GroupRIPList.Contains(ProcessWait[id].gaddr)) {
                        toWake.Add(id);
                    }
                }
            }

            foreach (int id in toWake) {
                using (var tmpLockObj = new LockAndElevate(BarriersLock)) {
                    if (Barriers[id] != null) {
                        if ((VsyncSystem.Debug & VsyncSystem.LOCKSTATE) != 0) {
                            Vsync.WriteLine("ScanPWaits doing a Barrier Release(1) on Semaphore associated with Barrier[" + id + "]");
                        }

                        Barriers[id].Release();
                    }
                }
            }
        }

        private static readonly Dictionary<int, int> Waiting = new Dictionary<int, int>(100);

        internal int level;

        internal int lockId;

        private int myIndex = -1;

        // Value meaningful only on ILock and ILockref, which have one owner -- NOT used for barriers and bounded buffers...
        private static long quickPick;

        // Track whether Dispose has been called.
        private bool disposed;

        // This class constructor is used only to create an ILockRef.
        private ILock(int level, int lockId, bool grabLock) {
            this.SInit(level, lockId, 1);
            if (grabLock) {
                this.Lock();
            }
        }

        // ... and this one is used only from the barrier code
        private ILock(int level, int lockId, bool grabLock, int init) {
            this.SInit(level, lockId, init);
            if (grabLock) {
                this.Lock();
            }
        }

        // Used only in "using(new ILock(...)) statements.  In such cases the lock release
        // occurs on Dispose, which involves some slightly special handling
        private readonly bool insideUsing;

        internal ILock(int level, Address gaddr) {
            if (gaddr != null) {
                int myHashCode = gaddr.GetHashCode();
                int lockId = GetLockId(level, myHashCode);
                this.SInit(level, lockId, 1);
                this.insideUsing = true;
                this.Lock();
            }

            if ((VsyncSystem.Debug & VsyncSystem.LOCKCHECK) != 0) {
                this.QuickCheck();
            }
        }

        // Again, used only from the barrier logic
        private ILock(int level, Address gaddr, bool grabLock, int init) {
            if (gaddr != null) {
                int myHashCode = gaddr.GetHashCode();
                int lockId = GetLockId(level, myHashCode);
                this.SInit(level, lockId, init);
                if (grabLock) {
                    this.Lock();
                }
            }
        }

        // Checks for lock cycles but slow for large systems so needs to be eliminated eventually
        private void QuickCheck() {
            bool[,] hflag = new bool[16, 4096];

            using (var tmpLockObj = new LockAndElevate(SemaphoresLock)) {
                for (int id = 0; id < LILEN; id++) {
                    using (var tmpLockObj1 = new LockAndElevate(LInfoLock)) {
                        if (LInfo[id] == null) {
                            continue;
                        }

                        LockInfo li = LInfo[id].First;
                        if (li == null) {
                            continue;
                        }

                        while (li != null) {
                            int l = li.LockLevel;
                            int k = li.LockId;
                            if (!li.ReLocked && !li.WaitingFor) {
                                if (!hflag[l, k]) {
                                    hflag[l, k] = true;
                                }
                                else {
                                    throw new VsyncException("Double locked lock!!! Lock id is (" + l + "," + k + ")" + VsyncSystem.GetState());
                                }
                            }

                            li = li.Next;
                        }
                    }
                }
            }
        }

        private void SInit(int level, int lockId, int init) {
            if (level < 0 || level > NLEVELS) {
                throw new ArgumentOutOfRangeException("level", "ILock");
            }

            this.level = level;
            this.lockId = lockId;
            using (var tmpLockObj = new LockAndElevate(SemaphoresLock)) {
                int n = 1;
                while (n <= lockId) {
                    n <<= 1;
                }

                if (Semaphores[level] == null) {
                    Semaphores[level] = new Semaphore[n];
                    nWaiters[level] = new int[n];
                    Holding[level] = new int[n];
                    isBarrier[level] = new bool[n];
                }
                else if (Semaphores[level].Length <= n) {
                    Vsync.ArrayResize(ref Semaphores[level], n);
                    Vsync.ArrayResize(ref isBarrier[level], n);
                    Vsync.ArrayResize(ref nWaiters[level], n);
                    Vsync.ArrayResize(ref Holding[level], n);
                }

                if (Semaphores[level][lockId] == null) {
                    Semaphores[level][lockId] = new Semaphore(init, int.MaxValue);
                }
            }
        }

        internal static ILock IlockRef(int level, int lockId) {
            return new ILock(level, lockId, false);
        }

        internal static ILock IlockRef(int level, Address gaddr) {
            return new ILock(level, gaddr, false, 0);
        }

        internal static ILock IlockResetAndRef(int level, int lockId, bool grabLock, int init) {
            using (var tmpLockObj = new LockAndElevate(SemaphoresLock)) {
                if (level >= Semaphores.Length || lockId == -1) {
                    throw new VsyncException("IlockResetAndRef(" + level + ", " + lockId + ", " + grabLock + ", " + init + "): len too large or id<0!");
                }

                if (Semaphores[level] != null && Semaphores[level].Length > lockId) {
                    Semaphores[level][lockId] = null;
                }
            }

            return new ILock(level, lockId, grabLock, init);
        }

        internal static int NILocks(int level) {
            if (Semaphores[level] != null) {
                return Semaphores[level].Length;
            }

            return 32;
        }

        internal static ILock Barrier(int level, int lockID) {
            ILock bl = new ILock(level, lockID, false, 0);
            isBarrier[bl.level][bl.lockId] = true;
            return bl;
        }

        internal static ILock Barrier(int level, Address gaddr) {
            ILock bl = new ILock(level, gaddr, false, 0);
            isBarrier[bl.level][bl.lockId] = true;
            return bl;
        }

        internal void BBDecCntr() {
            int theIndex = this.LookupMyIndex();
            LockInfo li = new LockInfo(this.level, this.lockId, true);
            using (var tmpLockObj = new LockAndElevate(LInfoLock)) {
                li.Next = LInfo[theIndex].First;
                LInfo[theIndex].First = li;
            }

            Semaphore theSema;
            using (var tmpLockObj = new LockAndElevate(SemaphoresLock)) {
                theSema = Semaphores[this.level][this.lockId];
                ++nWaiters[this.level][this.lockId];
            }

            if ((VsyncSystem.Debug & VsyncSystem.LOCKSTATE) != 0) {
                Vsync.WriteLine("BBDecCntr acquiring semaphore[" + this.level + "][" + this.lockId + "]");
            }

            try {
                if (theSema != null) {
                    while ((VsyncSystem.VsyncActive || !VsyncSystem.VsyncWasActive) && !theSema.WaitOne(2500)) {
                    }
                }
            }
            finally {
                if (!VsyncSystem.VsyncActive && !VsyncSystem.shuttingDown) {
                    throw new VsyncShutdownException("Vsync Inactive");
                }

                using (var tmpLockObj = new LockAndElevate(SemaphoresLock)) {
                    if (Semaphores[this.level][this.lockId] == theSema) {
                        --nWaiters[this.level][this.lockId];
                    }
                }

                using (var tmpLockObj = new LockAndElevate(LInfoLock)) {
                    LInfo[theIndex].First = li.Next;
                }
            }
        }

        internal void BBIncCntr() {
            if ((VsyncSystem.Debug & VsyncSystem.LOCKSTATE) != 0) {
                Vsync.WriteLine("BBIncCntr releasing semaphore[" + this.level + "][" + this.lockId + "]");
            }

            try {
                Semaphores[this.level][this.lockId].Release();
            }
            catch (Exception) {
            }
        }

        internal void Lock() {
            this.LockIt(true);
        }

        private void LockIt(bool willHold) {
            if (this.myIndex == -1) {
                this.myIndex = this.LookupMyIndex();
            }

            LockInfo nli;
            using (var tmpLockObj = new LockAndElevate(LInfoLock)) {
                LockInfo li = LInfo[this.myIndex].First;
                nli = new LockInfo(this.level, this.lockId);
                if (li != null && li.LockLevel >= this.level) {
                    bool cycle = false;

                    if (li.LockLevel > this.level) {
                        cycle = true;
                    }
                    else {
                        if (li.LockId == this.lockId && !isBarrier[this.level][this.lockId]) {
                            nli.ReLocked = true;
                        }
                        else {
                            if (li.LockId > this.lockId) {
                                cycle = true;
                            }
                        }
                    }

                    if (cycle) {
                        // Possible cycle but before crying wolf, double check to make sure this isn't a relock request
                        LockInfo tmp;
                        for (tmp = li.Next; tmp != null; tmp = tmp.Next) {
                            if (tmp.LockId == this.lockId && tmp.LockLevel == this.level) {
                                nli.ReLocked = true;
                                cycle = false;
                                break;
                            }
                        }

                        if (cycle) {
                            throw new VsyncException("Lock cycle: Thread <" + Thread.CurrentThread.Name + "> index [" + this.myIndex + "] requested " + this.level + "/" + this.lockId + " while holding " + li + Environment.NewLine + ILock.GetState());
                        }
                    }
                }

                nli.WaitingFor = !nli.ReLocked;
                nli.Next = li;
                LInfo[this.myIndex].First = nli;
            }

            if (!nli.ReLocked) {
                if ((VsyncSystem.Debug & VsyncSystem.LOCKSTATE) != 0) {
                    Vsync.WriteLine("Semaphore wait: [" + this.level + "][" + this.lockId + "]");
                }

                using (var tmpLockObj = new LockAndElevate(SemaphoresLock)) {
                    ++nWaiters[this.level][this.lockId];
                }

                try {
                    Semaphores[this.level][this.lockId].WaitOne();
                }
                finally {
                    if (!VsyncSystem.VsyncActive) {
                        throw new VsyncShutdownException("Vsync Inactive");
                    }

                    using (var tmpLockObj = new LockAndElevate(SemaphoresLock)) {
                        if ((VsyncSystem.Debug & VsyncSystem.LOCKSTATE) != 0) {
                            Vsync.WriteLine("After semaphore wait: [" + this.level + "][" + this.lockId + "]");
                        }

                        --nWaiters[this.level][this.lockId];
                        using (var tmpLockObj1 = new LockAndElevate(LInfoLock)) {
                            nli.WaitingFor = false;
                            if (willHold) {
                                ++Holding[this.level][this.lockId];
                            }
                            else {
                                if (LInfo[this.myIndex].First == nli) {
                                    LInfo[this.myIndex].First = nli.Next;
                                }
                                else {
                                    throw new VsyncException("Error when unwinding lock-state stack!");
                                }
                            }
                        }
                    }
                }

                if ((VsyncSystem.Debug & VsyncSystem.LOCKSTATE) != 0) {
                    Vsync.WriteLine("Semaphore acquired: [" + this.level + "][" + this.lockId + "]");
                }
            }
            else if (willHold) {
                using (var tmpLockObj = new LockAndElevate(SemaphoresLock)) {
                    ++Holding[this.level][this.lockId];
                }
            }
            else if ((VsyncSystem.Debug & VsyncSystem.LOCKSTATE) != 0) {
                Vsync.WriteLine("No need to wait (re-acquire): [" + this.level + "][" + this.lockId + "]");
            }
        }

        internal static int GetLockId(int level, int hashcode) {
            int rval;
            using (var tmpLockObj = new LockAndElevate(LockIdsLock)) {
                if (LockIds[level] == null) {
                    LockIds[level] = new Dictionary<int, IdAndCtr>(100);
                }

                IdAndCtr idc;
                if (LockIds[level].TryGetValue(hashcode, out idc)) {
                    rval = idc.Id;
                    ++idc.Cntr;
                }
                else {
                    rval = 0;
                    if (quickPick != -1) {
                        long b = 1;
                        while ((quickPick & b) != 0) {
                            b <<= 1;
                            ++rval;
                        }
                    }
                    else {
                        bool fnd = true;
                        rval = 64;
                        while (fnd) {
                            fnd = false;
                            foreach (KeyValuePair<int, IdAndCtr> kvp in LockIds[level]) {
                                if (kvp.Value.Id == rval) {
                                    fnd = true;
                                    ++rval;
                                }
                            }
                        }
                    }

                    if (rval < 64) {
                        quickPick |= 1L << rval;
                    }

                    LockIds[level].Add(hashcode, new IdAndCtr(rval));
                }
            }

            return rval;
        }

        private int LookupMyIndex() {
            int theIndex;
            using (var tmpLockObj = new LockAndElevate(LInfoLock)) {
                int id = Thread.CurrentThread.ManagedThreadId;
                if (Waiting.TryGetValue(id, out theIndex) && theIndex >= 0 && theIndex < LInfo.Length) {
                    if (LInfo[theIndex].Tname != Thread.CurrentThread.Name) {
                        // Thread id got recycled by the runtime system
                        if (LInfo[theIndex].First != null) {
                            string list = string.Empty;
                            for (LockInfo lio = LInfo[theIndex].First; lio != null; lio = lio.Next) {
                                list += " [" + lio.LockLevel + "][" + lio.LockId + "] ";
                            }

                            throw new VsyncException("VSYNC: Thread " + LInfo[theIndex].Tname + " terminated while holding locks {" + list + "}!");
                        }

                        LInfo[theIndex].Tname = Thread.CurrentThread.Name;
                    }
                }
                else {
                    // New thread id I haven't seen previously
                    if (next == LILEN) {
                        LILEN <<= 1;
                        Vsync.ArrayResize(ref LInfo, LILEN);
                        Vsync.ArrayResize(ref ProcessWait, LILEN);
                        Vsync.ArrayResize(ref Barriers, LILEN);
                    }

                    Waiting[id] = theIndex = next++;
                    string name = Thread.CurrentThread.Name;
                    LInfo[theIndex] = new LockInfoHead(name);
                }
            }

            return theIndex;
        }

        internal void Release() {
            if (!VsyncSystem.VsyncActive) {
                return;
            }

            using (var tmpLockObj = new LockAndElevate(SemaphoresLock)) {
                int nw = nWaiters[this.level][this.lockId];
                if (nw > 0 || Holding[this.level][this.lockId] > 0) {
                    if (--Holding[this.level][this.lockId] < 0) {
                        throw new VsyncException("Vsync lock " + this.level + "/" + this.lockId + " released more times than it was locked");
                    }

                    if ((VsyncSystem.Debug & VsyncSystem.LOCKSTATE) != 0) {
                        Vsync.WriteLine("Lock Release for lock[" + this.level + "][" + this.lockId + "]");
                    }

                    using (var tmpLockObj1 = new LockAndElevate(LInfoLock)) {
                        if (this.myIndex == -1) {
                            throw new VsyncException("Release: release what?");
                        }

                        LockInfo li = LInfo[this.myIndex].First;
                        if (li == null) {
                            throw new VsyncException("Release: release what?");
                        }

                        LInfo[this.myIndex].First = li.Next;
                        if (!li.ReLocked) {
                            Semaphores[this.level][this.lockId].Release();
                        }
                    }
                }
            }
        }

        internal void BarrierWait() {
            if ((VsyncSystem.Debug & VsyncSystem.LOCKSTATE) != 0) {
                Vsync.WriteLine("Enter BarrierWait: simple case [" + this.level + "][" + this.lockId + "]");
            }

            int theIndex = this.LookupMyIndex();
            using (var tmpLockObj = new LockAndElevate(BarriersLock)) {
                Barriers[theIndex] = Semaphores[this.level][this.lockId];
            }

            this.LockIt(false);
            using (var tmpLockObj = new LockAndElevate(BarriersLock)) {
                Barriers[theIndex] = null;
            }

            if ((VsyncSystem.Debug & VsyncSystem.LOCKSTATE) != 0) {
                Vsync.WriteLine("After BarrierWait: simple case [" + this.level + "][" + this.lockId + "]");
            }
        }

        internal void BarrierWait(Group g) {
            this.BarrierWait(g, g.getLiveMembers());
        }

        internal void BarrierWait(Group g, Address[] waitingFor) {
            if ((VsyncSystem.Debug & VsyncSystem.LOCKSTATE) != 0) {
                Vsync.WriteLine("Enter BarrierWait: [" + this.level + "][" + this.lockId + "] group " + g.gname + ", Waiting for " + Address.VectorToString(waitingFor));
            }

            int theIndex = this.LookupMyIndex();
            using (var tmpLockObj = new LockAndElevate(BarriersLock)) {
                Barriers[theIndex] = Semaphores[this.level][this.lockId];
            }

            using (var tmpLockObj = new LockAndElevate(ProcessWaitLock)) {
                ProcessWait[theIndex] = new PWaitInfo(g.gaddr, waitingFor);
            }

            this.LockIt(false);
            using (var tmpLockObj = new LockAndElevate(ProcessWaitLock)) {
                ProcessWait[theIndex] = null;
            }

            using (var tmpLockObj = new LockAndElevate(BarriersLock)) {
                Barriers[theIndex] = null;
            }

            if ((VsyncSystem.Debug & VsyncSystem.LOCKSTATE) != 0) {
                Vsync.WriteLine("BarrierWait: [" + this.level + "][" + this.lockId + "] Other side of the barrier! Group " + g + ", Waiting for " + Address.VectorToString(waitingFor));
            }
        }

        internal void BarrierRelease(int cnt) {
            if ((VsyncSystem.Debug & VsyncSystem.LOCKSTATE) != 0) {
                Vsync.WriteLine("Barrier Release: [" + this.level + "][" + this.lockId + "]");
            }

            Semaphores[this.level][this.lockId].Release(cnt);
        }

        // Unlike the other BarrierWait/Release options, ReleaseAll assumes the Waits are done before the Release!
        internal void BarrierReleaseAll() {
            if ((VsyncSystem.Debug & VsyncSystem.LOCKSTATE) != 0) {
                Vsync.WriteLine("Barrier Release All: [" + this.level + "][" + this.lockId + "]");
            }

            int nw;
            using (var tmpLockObj = new LockAndElevate(SemaphoresLock)) {
                nw = nWaiters[this.level][this.lockId];
            }

            if (nw > 0) {
                Semaphores[this.level][this.lockId].Release(nw);
            }
        }

        private static Address RIP;

        internal static void NoteFailed(Address gaddr, Address rip) {
            if (RIP == rip) {
                return;
            }

            RIP = rip;

            using (var tmpLockObj = new LockAndElevate(ProcessWaitLock)) {
                for (int id = 0; id < ProcessWait.Length; id++) {
                    PWaitInfo pwi = ProcessWait[id];
                    int a;
                    if (pwi == null || (pwi.gaddr != null && pwi.gaddr != gaddr) || Barriers[id] == null) {
                        continue;
                    }

                    for (a = 0; a < pwi.plist.Length; a++) {
                        if (pwi.plist[a] == rip) {
                            break;
                        }
                    }

                    if (a == pwi.plist.Length) {
                        continue;
                    }

                    if (pwi.plist.Length == 1) {
                        using (var tmpLockObj1 = new LockAndElevate(BarriersLock)) {
                            if (Barriers[id] != null) {
                                if ((VsyncSystem.Debug & VsyncSystem.LOCKSTATE) != 0) {
                                    Vsync.WriteLine("NoteFail doing a Barrier Release(1) on Semaphore associated with Barrier[" + id + "]");
                                }

                                Barriers[id].Release();
                            }
                        }

                        return;
                    }

                    while (a < pwi.plist.Length - 1) {
                        pwi.plist[a] = pwi.plist[a + 1];
                        a++;
                    }
                }
            }
        }

        public void Dispose() {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing) {
            lock (this) {
                if (!this.disposed) {
                    this.disposed = true;
                    if (disposing) {
                        // Dispose managed resources.
                        using (var tmpLockObj = new LockAndElevate(LockIdsLock)) {
                            if (this.insideUsing) {
                                // This case arises entirely because of the construct "using(new ILock(...)) something
                                // The lock is grabbed, statement is executed, and the dispose that using then invokes triggers release
                                // of the lock.  We do this exactly once, and only in this specific case
                                // In particular, it is a (serious) bug to forget to call Release if you have an ILockRef and then lock it
                                // I could check for this, but it would slow the lock subsystem down, so I don't
                                if ((VsyncSystem.Debug & VsyncSystem.LOCKSTATE) != 0) {
                                    Vsync.WriteLine("Disposing [" + this.level + "][" + this.lockId + "] (Holding[l,id] = " + Holding[this.level][this.lockId] + ")");
                                }

                                this.Release();
                            }
                        }
                    }
                }
            }
        }

        ~ILock() {
            this.Dispose(true);
        }
    }

    /// <summary>
    /// Bounded circular buffer.  By convention, a put(null) will cause any reader thread
    /// to terminate; we use this when disposing of these buffers.  The code can handle
    /// multiple readers but in fact Vsync only has a single reader thread at a time in the
    /// code paths that use these
    /// </summary>
    public class BoundedBuffer {
        internal static List<BoundedBuffer> BBList = new List<BoundedBuffer>();

        internal static LockObject BBListLock = new LockObject(false, "BBListLock");

        internal string name;

        internal volatile bool lockedAgainstPut = false;

        internal int size;

        internal int pNext;

        internal int gNext;

        internal int myLockLevel;

        internal int myPlockId;

        internal int myGlockId;

        internal volatile int fullSlots;

        internal int delayedNotifyCnt;

        internal object[] theBuffer;

        internal LockObject Lock;

        internal ILock puttingLock;

        internal ILock gettingLock;

        internal int LastPushedVID;

        internal int LastDeliveredVID;

        /// <summary>
        /// Constructor for a bounded buffer, uses current thread priority for the locking priority level
        /// </summary>
        /// <param name="s"></param>
        /// <param name="sz"></param>
        /// <param name="lockLevel"></param>
        /// <param name="plockId"></param>
        /// <param name="glockId"></param>
        public BoundedBuffer(string s, int sz, int lockLevel, int plockId, int glockId)
            : this(s, sz, lockLevel, plockId, glockId, Thread.CurrentThread.Priority) {
        }

        /// <summary>
        /// Constructor for a bounded buffer, includes desired locking priority level
        /// </summary>
        /// <param name="s"></param>
        /// <param name="sz"></param>
        /// <param name="lockLevel"></param>
        /// <param name="plockId"></param>
        /// <param name="glockId"></param>
        /// <param name="pri"></param>
        public BoundedBuffer(string s, int sz, int lockLevel, int plockId, int glockId, ThreadPriority pri) {
            using (var tmpLockObj = new LockAndElevate(BBListLock)) {
                if (plockId == -1) {
                    int nILocks = ILock.NILocks(lockLevel) + 2;
                    bool[] inuse = new bool[nILocks];
                    foreach (BoundedBuffer bb in BBList) {
                        if (bb.myLockLevel == lockLevel) {
                            inuse[bb.myPlockId] = inuse[bb.myGlockId] = true;
                        }
                    }

                    for (int lid = 0; lid < nILocks; lid += 2) {
                        if (!inuse[lid] && !inuse[lid + 1]) {
                            plockId = lid;
                            glockId = lid + 1;
                            break;
                        }
                    }
                }

                this.myLockLevel = lockLevel;
                this.myPlockId = plockId;
                this.myGlockId = glockId;
                this.name = s;

                // Leave room for one null, to deal with closing the buffer and to support "putfront"
                this.size = sz + 1;
                this.theBuffer = new object[this.size];

                // When putting a null, won't wait
                this.puttingLock = ILock.IlockResetAndRef(lockLevel, plockId, false, this.size);
                this.gettingLock = ILock.IlockResetAndRef(lockLevel, glockId, false, 0);
                BBList.Add(this);
            }

            this.Lock = new LockObject(this.name + "/BoundedBuffer.Lock", pri);
        }

        /// <summary>
        /// Removes a buffer from the list that will be closed down if Shutdown is called
        /// </summary>
        /// <param name="bb"></param>
        public static void unregister(BoundedBuffer bb) {
            using (var tmpLockObj = new LockAndElevate(BBListLock)) {
                BBList.Remove(bb);
            }

            bb.put(null, true);
        }

        /// <summary>
        /// Used to close down the entire buffering subsystem
        /// </summary>
        public static void ShutDown() {
            using (var tmpLockObj = new LockAndElevate(BBListLock)) {
                foreach (BoundedBuffer bb in BBList) {
                    bb.put(null);
                }
            }
        }

        /// <summary>
        /// Returns a string summarizing the buffer state
        /// </summary>
        /// <returns></returns>
        public static string GetState() {
            string bs = "BOUNDED BUFFERS:" + Environment.NewLine;
            using (var tmpLockObj = new LockAndElevate(BBListLock)) {
                foreach (BoundedBuffer bb in BBList) {
                    using (var tmpLockObj1 = new LockAndElevate(bb.Lock)) {
                        bs += "  <" + bb.name + ">  size=" + (bb.size - 1) + " (" + (bb.fullSlots < bb.size ? bb.fullSlots.ToString(CultureInfo.InvariantCulture) : "all") + " full)" + (bb.lockedAgainstPut ? " locked" : string.Empty) + ", GetLock=" + ILock.PLock(bb.gettingLock) + ", PutLock=" + ILock.PLock(bb.puttingLock);
                        if (bb.delayedNotifyCnt > 0) {
                            bs += ", Delayed Notify Count=" + bb.delayedNotifyCnt;
                        }

                        bs += Environment.NewLine;
                    }
                }
            }

            return bs;
        }

        /// <summary>
        /// Tests to see if the bb has enough room to hold howMany additional objects
        /// </summary>
        /// <param name="howMany"></param>
        /// <returns></returns>
        public bool putWillBlock(int howMany) {
            using (var tmpLockObj = new LockAndElevate(this.Lock)) {
                return this.size < (this.fullSlots + howMany);
            }
        }

        /// <summary>
        /// Returns the number of full slots in the bounded buffer
        /// </summary>
        /// <param name="bb">Buffer to check</param>
        /// <returns>Number of full slots</returns>
        public static int FullSlots(BoundedBuffer bb) {
            if (bb == null) {
                return 0;
            }

            return bb.FullSlots();
        }

        /// <summary>
        /// Returns the number of full slots in the bounded buffer
        /// </summary>
        /// <returns>Number of full slots</returns>
        public int FullSlots() {
            using (var tmpLockObj = new LockAndElevate(this.Lock)) {
                return this.fullSlots;
            }
        }

        /// <summary>
        ///  Puts an object in the buffer if there is room.  If not, waits
        /// </summary>
        /// <param name="o">object to store</param>
        public void put(object o) {
            this.put(o, false);
        }

        /// <summary>
        /// Puts an object in the buffer if there is room.  If not, waits if nonBlocking=false, returns (with no error indication) if nonBlocking=true
        /// </summary>
        /// <param name="o">object to store</param>
        /// <param name="nonBlocking">NonBlocking mode indication</param>
        public void put(object o, bool nonBlocking) {
            using (var tmpLockObj = new LockAndElevate(this.Lock)) {
                if (nonBlocking && this.fullSlots == this.size) {
                    return;
                }
            }

            if (o != null) {
                this.puttingLock.BBDecCntr();
            }

            using (var tmpLockObj = new LockAndElevate(this.Lock)) {
                if (this.lockedAgainstPut) {
                    this.puttingLock.BBIncCntr();
                    return;
                }

                if (o != null && this.LastPushedVID > 0) {
                    Type t = o.GetType();
                    if (t == typeof(View)) {
                        this.LastPushedVID = ((View)o).viewid;
                    }
                    else if (t == typeof(Msg)) {
                        Msg m = (Msg)o;
                        if (m.vid >= 0 && m.vid != this.LastPushedVID) {
                            throw new VsyncException("put: putting a message " + m.sender + "::" + m.vid + ":" + m.msgid + " when " + this.name + " was using viewid=" + this.LastPushedVID);
                        }
                    }
                    else if (t == typeof(List<Msg>)) {
                        foreach (Msg m in (List<Msg>)o) {
                            if (m.vid >= 0 && m.vid != this.LastPushedVID) {
                                throw new VsyncException("put/List: putting a message " + m.sender + "::" + m.vid + ":" + m.msgid + " when " + this.name + " was using viewid=" + this.LastPushedVID);
                            }
                        }
                    }
                }

                this.theBuffer[(this.pNext++) % this.size] = o;
                if (++this.fullSlots > this.size && o != null && !this.lockedAgainstPut) {
                    Vsync.WriteLine("WARNING... BB:put<" + this.name + ">: fullslots overflow");
                }

                if (o == null) {
                    this.lockedAgainstPut = true;
                    this.puttingLock.BBIncCntr();
                }
            }

            this.gettingLock.BBIncCntr();
        }

        /// <summary>
        /// Used (only) from SafeSend and OrderedSend; puts an object on FRONT of the circular buffer.  The idea is to replace the SETORDER message
        /// that was just delivered (previous front of the circular buffer) with a list of the ordered messages that it released for delivery, and in
        /// the order it specified (obviously).  Then those will be delivered one by one.  (Since none of them will be a SETORDER message, all of those
        /// will have been delivered by the time the next SETORDER message is done, hence we don't run the risk of two concurrent putFront events occuring)
        /// </summary>
        /// <param name="o">An object to place in the buffer</param>
        public void putFront(object o) {
            this.puttingLock.BBDecCntr();
            using (var tmpLockObj = new LockAndElevate(this.Lock)) {
                if (this.lockedAgainstPut) {
                    this.puttingLock.BBIncCntr();
                    return;
                }

                if (--this.gNext < 0) {
                    this.gNext += this.size;
                }

                if (o != null && this.LastDeliveredVID != 0) {
                    List<Msg> ml = (List<Msg>)o;
                    foreach (Msg m in ml) {
                        if (m.vid >= 0 && m.vid != this.LastDeliveredVID) {
                            throw new VsyncException("putFront: putting a message " + m.sender + "::" + m.vid + ":" + m.msgid + " when " + this.name + " was using viewid=" + this.LastDeliveredVID);
                        }
                    }
                }

                this.theBuffer[this.gNext % this.size] = o;
                if (++this.fullSlots > this.size && o != null && !this.lockedAgainstPut) {
                    Vsync.WriteLine("WARNING... BB:putFront<" + this.name + ">: fullslots overflow");
                }
            }

            this.gettingLock.BBIncCntr();
        }

        /// <summary>
        /// Get the next object in the buffer
        /// </summary>
        /// <returns>object found.  Blocks if the bb is empty.</returns>
        public object get() {
            object o;
            bool delayedNotify = false;
            int delayednotifies = 0;
            this.gettingLock.BBDecCntr();
            using (var tmpLockObj = new LockAndElevate(this.Lock)) {
                int idx = (this.gNext++) % this.size;
                o = this.theBuffer[idx];
                if (o != null) {
                    Type t = o.GetType();
                    if (t == typeof(View)) {
                        this.LastDeliveredVID = ((View)o).viewid;
                    }
                }

                if (this.fullSlots <= 0) {
                    if (!VsyncSystem.VsyncActive && VsyncSystem.VsyncWasActive) {
                        return null;
                    }

                    if (!this.lockedAgainstPut) {
                        Vsync.WriteLine("WARNING... BB:get<" + this.name + ">: fullslots underflow with gettinglock=" + this.gettingLock.lockId);
                    }

                    for (int i = 0; i < 10; i++) {
                        Vsync.WriteLine("**********************************************************************************************************************");
                    }

                    return null;
                }

                --this.fullSlots;
                this.theBuffer[idx] = null;
                if (this.fullSlots > (this.size * 3) / 4 && o != null && this.myLockLevel != ILock.LLTCP) {
                    delayedNotify = true;
                    ++this.delayedNotifyCnt;
                }
                else {
                    delayednotifies = this.delayedNotifyCnt + 1;
                    this.delayedNotifyCnt = 0;
                }
            }

            while (!delayedNotify && !this.lockedAgainstPut && --delayednotifies >= 0) {
                this.puttingLock.BBIncCntr();
            }

            return o;
        }
    }

    internal class LockingDependencyOrder {
        internal LockObject otherLock;

        internal string stack;

        internal LockingDependencyOrder(LockObject lo, string st) {
            this.otherLock = lo;
            this.stack = st;
        }
    }

    internal class LockObject {
        internal object Info = new object();

        internal ThreadPriority AssociatedPriority;

#if TRACKLOCKINFO
        internal int lockHolderId = 0;

        internal bool TrackOrder = true;

        internal string lastlockedInfo = "???";
#endif

        internal bool isLocked = false;

        internal Thread lockHolder = null;

        internal string lockedBy = "???";

        internal string Name = "???";

        internal long UseCount;

        internal long LockedAt;

        internal List<Thread> WantsMe = new List<Thread>();

        internal List<LockingDependencyOrder> DependencyOrder = new List<LockingDependencyOrder>();

        internal static List<LockObject> LockObjList = new List<LockObject>();

        internal LockObject(bool TrackOrder, string name)
            : this(TrackOrder, name, Thread.CurrentThread.Priority) {
        }

        internal LockObject(string name)
            : this(true, name, Thread.CurrentThread.Priority) {
        }

        internal LockObject(string name, ThreadPriority usePriority)
            : this(true, name, usePriority) {
        }

        internal LockObject(bool TrackOrder, string name, ThreadPriority usePriority) {
            this.Name = name;
            this.AssociatedPriority = usePriority;
#if TRACKLOCKINFO
            lock (LockObjList)
            {
                LockObjList.Add(this);
            }

            this.TrackOrder = TrackOrder;
#endif // TRACKLOCKINFO
        }

        internal LockObject() {
            this.UseCount = 0;
            this.LockedAt = 0;
        }

#if TRACKLOCKINFO
        ~LockObject()
        {
            lock (LockObjList)
            {
                LockObjList.Remove(this);
            }
        }

#endif // TRACKLOCKINFO

        internal static string GetState() {
            return GetState(false);
        }

        internal static string GetState(bool includeCallStack) {
#if TRACKLOCKINFO
            string s = "LOCKED OBJECTS:" + Environment.NewLine;
            if (includeCallStack)
            {
                s += "    .... dump was requested by " + threadInfo() + Environment.NewLine;
            }

            List<LockObject> LockObjListClone = new List<LockObject>();
            lock (LockObjList)
            {
                foreach (LockObject lo in LockObjList)
                {
                    LockObjListClone.Add(lo);
                }
            }

            foreach (LockObject lo in LockObjListClone)
            {
                lock (lo.Info)
                {
                    if (!lo.isLocked)
                    {
                        continue;
                    }

                    string wantedBy = string.Empty;
                    string depinfo = " ";
                    string lockedby = string.Empty;
                    foreach (LockingDependencyOrder ldo in lo.DependencyOrder)
                    {
                        depinfo += ldo.otherLock.Name + " ";
                    }

                    if (lo.lockHolder != null)
                    {
                        lockedby = "locked by Thread[" + lo.lockHolder.Name + "] for " + Vsync.TimeToString(Vsync.NOW - lo.LockedAt) + (wantedBy.Length > 0 ? ("; Wanted by " + wantedBy) : string.Empty);
                    }

                    foreach (Thread t in lo.WantsMe)
                    {
                        wantedBy += "Thread[" + t.ManagedThreadId + "] (" + (t.Name ?? "no name") + " ";
                    }

                    s += "   <" + lo.Name + ">: UseCnt=" + lo.UseCount + "; " + lockedby + Environment.NewLine;
                    if (includeCallStack)
                    {
                        s += "    .... call-stack that acquired lock = " + lo.lockedBy + Environment.NewLine;
                    }
                }
            }

#else // TRACKLOCKINFO
            string s = "LOCKED OBJECTS: NOT TRACKING DETAILED USE" + Environment.NewLine;
#endif // TRACKLOCKINFO
            return s;
        }

        internal static string LocksIHold() {
#if TRACKLOCKINFO
            string lockList = " ";
            lock (LockObjList)
            {
                foreach (LockObject lo in LockObjList)
                {
                    if (lo.lockHolder == Thread.CurrentThread)
                    {
                        lockList += lo.Name + " ";
                    }
                }
            }

            return lockList;
#else // TRACKLOCKINFO
            return "not tracked";
#endif // TRACKLOCKINFO
        }

        internal static void ThreadIsTerminating() {
            List<LockObject> toUnlock = new List<LockObject>();
            lock (LockObjList) {
                foreach (LockObject lo in LockObjList) {
                    lock (lo.Info) {
                        if (lo.lockHolder == Thread.CurrentThread) {
                            toUnlock.Add(lo);
                        }
                    }
                }
            }

            foreach (LockObject lo in toUnlock) {
                lock (lo.Info) {
                    if (lo.lockHolder == Thread.CurrentThread) {
                        if (lo.isLocked) {
                            Monitor.Exit(lo);
                        }

                        lo.lockHolder = null;
                        lo.lockedBy = null;
                        lo.isLocked = false;
                    }
                }
            }

            if (VsyncSystem.VsyncActive) {
                foreach (LockObject lo in toUnlock) {
                    Vsync.WriteLine("************ ThreadIsTerminating unlocked <" + lo.Name + "> on behalf of " + Thread.CurrentThread.Name);
                }
            }
        }

        internal static string threadInfo() {
            return "Thread [" + Thread.CurrentThread.ManagedThreadId + (Thread.CurrentThread.Name == null ? string.Empty : "(" + Thread.CurrentThread.Name) + ")]";
        }
    }

    internal sealed class LockAndElevate : IDisposable {
        internal LockObject LockedObject;

        internal ThreadPriority myPriority;

        internal int lockedCnt = 0;

        private bool disposed;

        internal bool elevated;

        internal static bool disabled;

        internal LockAndElevate(LockObject Lock)
            : this(Lock, false) {
        }

        internal LockAndElevate(LockObject Lock, bool inhibitWARNINGs) {
            if (disabled) {
                return;
            }

#if TRACKLOCKINFO
            string lb = LockObject.threadInfo();
#endif // TRACKLOCKINFO
            lock (Lock.Info) {
#if TRACKLOCKINFO
                if (Lock.lockHolder == Thread.CurrentThread)
                {
                    lock (this)
                    {
                        ++this.lockedCnt;
                    }

                    return;
                }

#endif // TRACKLOCKINFO
                this.LockedObject = Lock;
                this.myPriority = Thread.CurrentThread.Priority;
                if (this.myPriority > Lock.AssociatedPriority) {
                    if (Vsync.NOW > 15000 && Lock.isLocked) {
                        Vsync.WriteLine("WARNING: Elevating priority on Lock <" + Lock.Name + "> from " + Lock.AssociatedPriority + " to " + this.myPriority + " while held by " + Lock.lockedBy);
                    }

                    Lock.AssociatedPriority = this.myPriority;
                }
                else {
                    Thread.CurrentThread.Priority = Lock.AssociatedPriority;
                }
            }

#if TRACKLOCKINFO
            if (!inhibitWARNINGs)
            {
                noteAssociation(Thread.CurrentThread.ManagedThreadId, Lock);
            }

#endif // TRACKLOCKINFO
            bool lockTaken = false;
            long lcount = 0;
            int tout = (Vsync.VSYNC_DEFAULTTIMEOUT * 2) / 5;
            int time;
            for (time = 0; !lockTaken && (VsyncSystem.VsyncActive || !VsyncSystem.VsyncWasActive) && time < 10; time++) {
                Monitor.TryEnter(this.LockedObject, tout, ref lockTaken);
                if (!lockTaken) {
                    if (!VsyncSystem.VsyncActive && VsyncSystem.VsyncWasActive && time == 4) {
                        if (Vsync.VSYNC_SHUTDOWNIFOVERLOADED) {
                            throw new VsyncException("Vsync is shutting down due to extremely long scheduling delays.  Is your computer unusually overloaded?");
                        }

                        throw new VsyncShutdownException("Vsync is shutting down, LockAndElevate timeout");
                    }

                    string name = string.Empty;
                    lock (Lock.Info) {
                        bool newHolder = false;
                        if (lcount != Lock.UseCount) {
                            newHolder = lcount != 0;
                            lcount = Lock.UseCount;
                        }

                        if (newHolder) {
                            name = " ** lock holder changed since last time I looked ** ";
                        }
                        else if (!Lock.isLocked) {
#if TRACKLOCKINFO
                            name = " ** lock isn't locked right now! Usecnt = " + Lock.UseCount + " ** ";
#else // TRACKLOCKINFO
                            name = " ** not tracking lockstate (recompile with TRACKLOCKINFO to enable tracking) ** ";
#endif // TRACKLOCKINFO
                        }
                        else if (Lock.lockHolder != null && Lock.lockHolder.Name != null) {
                            name = " (lock held by " + Lock.lockHolder.Name + ")";
                        }
                    }

                    if ((VsyncSystem.Debug & VsyncSystem.WARNIFSLOW) != 0) {
                        Vsync.WriteLine("WARNING: " + LockObject.threadInfo() + " has waited for " + Lock.Name + " for " + ((time + 1) * tout / 1000) + " secs" + name);
                    }
                }
            }

            if (!lockTaken) {
                if (!VsyncSystem.VsyncActive && VsyncSystem.VsyncWasActive) {
                    return;
                }

                string tname = "<thread has no name>";
                if (Thread.CurrentThread.Name != null) {
                    tname = Thread.CurrentThread.Name;
                }

                if (Vsync.VSYNC_SHUTDOWNIFOVERLOADED) {
                    throw new VsyncException("Vsync is shutting down due to extremely long scheduling delays.  Is your computer unusually overloaded?");
                }

                Vsync.WriteLine("Unable to acquire " + Lock.Name + " for " + tname + " in " + LockObject.GetState());
                string name = string.Empty;
                lock (Lock.Info) {
                    if (!Lock.isLocked) {
                        name = " ** [unknown thread] ** Lock usecnt = " + Lock.UseCount + " ** ";
                    }
                    else if (Lock.lockHolder != null && Lock.lockHolder.Name != null) {
                        name = " (lock held by " + Lock.lockHolder.Name + ")";
                    }
                }

                try {
                    new Thread(() => {
                        try {
                            Vsync.WriteLine("Lock<" + name + "> request failed in state: " + LockObject.GetState());
                        }
                        catch (VsyncShutdownException) {
                            VsyncSystem.CheckLocksHeld();
                        }

                        VsyncSystem.ThreadTerminationMagic();
                    }) { IsBackground = true }.Start();
                }
                catch (Exception) {
                }

                throw new VsyncException("[" + Thread.CurrentThread.Name + "@" + Vsync.MsToSecs(Vsync.NOW) + "]: Vsync was unable to acquire " + Lock.Name + " after waiting " + ((time + 1) * tout / 1000) + " secs" + name + Environment.NewLine + "Failed in state " + VsyncSystem.GetState());
            }

#if TRACKLOCKINFO
            lock (Lock.Info)
            {
                Lock.isLocked = true;
                Lock.lockedBy = lb;
                Lock.LockedAt = Vsync.NOW;
                Lock.lockHolder = Thread.CurrentThread;
                Lock.lockHolderId = Thread.CurrentThread.ManagedThreadId;
                ++Lock.UseCount;
            }
#else
            lock (Lock.Info) {
                Lock.lockHolder = Thread.CurrentThread;
            }

#endif // TRACKLOCKINFO

            this.elevated = true;
        }

        internal static void Disable(bool onOff) {
            disabled = onOff;
        }

        internal static List<LockObject>[] LockList = new List<LockObject>[1000];

        internal static object LockLock = new object();

#if TRACKLOCKINGORDER
        internal static void noteAssociation(int id, LockObject lo)
        {
            if (!VsyncSystem.VsyncActive && VsyncSystem.VsyncWasActive)
            {
                return;
            }

            if (!lo.TrackOrder || (id < 0 && id >= LockList.Length))
            {
                return;
            }

            List<LockObject> theList = new List<LockObject>();
            lock (LockLock)
            {
                if (LockList[id] == null)
                {
                    LockList[id] = new List<LockObject> { lo };

                    return;
                }

                LockList[id].Add(lo);
                foreach (LockObject theLo in LockList[id])
                {
                    theList.Add(theLo);
                }
            }

            foreach (LockObject otherLo in theList)
            {
                if (otherLo != lo && otherLo.TrackOrder)
                {
                    bool fnd = false;
                    lock (otherLo.Info)
                    {
                        if (otherLo.isLocked && otherLo.lockHolder == Thread.CurrentThread)
                        {
                            fnd = true;
                            foreach (LockingDependencyOrder ldo in otherLo.DependencyOrder)
                            {
                                if (ldo.otherLock == lo)
                                {
                                    Vsync.WriteLine("WARNING: sometimes  <" + lo.Name + "> is locked first, then <" + otherLo.Name + ">, but locked <" + otherLo.Name + "> first and then <" + lo.Name + ">!" + Environment.NewLine + "      This thread called at [" + Vsync.ExtractStackTrace() + "]" + Environment.NewLine + "    Saw other dependency at [ " + ldo.stack + "]");
                                }
                            }
                        }
                    }

                    if (!fnd)
                    {
                        continue;
                    }

                    fnd = false;
                    lock (lo.Info)
                    {
                        foreach (LockingDependencyOrder ldo in lo.DependencyOrder)
                        {
                            if (ldo.otherLock == otherLo)
                            {
                                fnd = true;
                                break;
                            }
                        }

                        if (!fnd)
                        {
                            lo.DependencyOrder.Add(new LockingDependencyOrder(otherLo, Vsync.ExtractStackTrace()));
                        }
                    }
                }
            }
        }
#endif // TRACKLOCKINGORDER

        /// <summary>
        /// Cleans up the logging state
        /// </summary>
        public void Dispose() {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing) {
            lock (this) {
                if (!this.disposed) {
                    this.disposed = true;
                    if (this.lockedCnt > 0 || (VsyncSystem.VsyncAlreadyRan && !VsyncSystem.VsyncActive)) {
                        --this.lockedCnt;
                        return;
                    }

                    if (disposing) {
                        if (this.LockedObject != null && this.LockedObject.Info != null && this.LockedObject.lockedBy != null) {
                            string tname = "unknown";
                            Thread lockHolder;
                            lock (this.LockedObject.Info) {
                                lockHolder = this.LockedObject.lockHolder;
                                if (lockHolder != null) {
                                    tname = lockHolder.Name;
                                }

#if TRACKLOCKINFO
                                if (!this.LockedObject.isLocked)
                                {
                                    Vsync.WriteLine("WARNING: In Dispose for " + this.LockedObject.Name + ", yet isLocked = false");
                                }

                                this.LockedObject.lockedBy += " *** In dispose, updating lock info";
                                if (this.LockedObject.TrackOrder)
                                {
                                    lock (LockLock)
                                    {
                                        int id = this.LockedObject.lockHolderId;
                                        if (id > 0 && id < LockList.Length)
                                        {
                                            if (LockList[id] != null)
                                            {
                                                if (!LockList[id].Remove(this.LockedObject))
                                                {
                                                    Vsync.WriteLine("WARNING: Surprised not to find <" + this.LockedObject.Name + "> on LockList[" + id + "] in LockObject.Dispose!");
                                                }

                                                if (LockList[id].Count == 0)
                                                {
                                                    LockList[id] = null;
                                                }
                                            }
                                        }
                                    }
                                }

                                Thread ht = this.LockedObject.lockHolder;
                                if (ht == null)
                                {
                                    Vsync.WriteLine("WARNING: Dispose for Lock " + this.LockedObject.Name + " but lockHolder=null!");
                                }

                                this.LockedObject.lastlockedInfo = "From " + Vsync.TimeToString(this.LockedObject.LockedAt) + " to " + Vsync.TimeToString(Vsync.NOW) + " was locked by " + (ht.Name ?? "unnamed thread");
                                this.LockedObject.lockedBy = "not locked";
                                this.LockedObject.lockHolder = null;
                                this.LockedObject.isLocked = false;
#endif // TRACKLOCKINFO
                            }

                            if (lockHolder != null && lockHolder == Thread.CurrentThread) {
                                try {
                                    Monitor.Exit(this.LockedObject);
                                }
                                catch (Exception e) {
                                    string why = e.Message;
                                    throw new VsyncException("System.Threading.Monitor.Exit threw " + why + " on LockedObject " + this.LockedObject.Name, e);
                                }
                            }
                            else if (VsyncSystem.VsyncActive && Thread.CurrentThread.Name != null && !Thread.CurrentThread.Name.Equals("Finalizer", StringComparison.Ordinal)) {
                                throw new VsyncException("Dispose: called for " + this.LockedObject.Name + " from a thread other than the one that acquired the lock (current thread is < " + Thread.CurrentThread.Name + "> should be <" + tname + ">)");
                            }
                        }
                    }

                    this.LockedObject = null;
                    Thread.CurrentThread.Priority = this.myPriority;
                }
            }
        }

        ~LockAndElevate() {
            this.Dispose(true);
        }
    }
}