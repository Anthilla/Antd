@*
    ///-------------------------------------------------------------------------------------
    ///     Copyright (c) 2014, Anthilla S.r.l. (http://www.anthilla.com)
    ///     All rights reserved.
    ///
    ///     Redistribution and use in source and binary forms, with or without
    ///     modification, are permitted provided that the following conditions are met:
    ///         * Redistributions of source code must retain the above copyright
    ///           notice, this list of conditions and the following disclaimer.
    ///         * Redistributions in binary form must reproduce the above copyright
    ///           notice, this list of conditions and the following disclaimer in the
    ///           documentation and/or other materials provided with the distribution.
    ///         * Neither the name of the Anthilla S.r.l. nor the
    ///           names of its contributors may be used to endorse or promote products
    ///           derived from this software without specific prior written permission.
    ///
    ///     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
    ///     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    ///     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    ///     DISCLAIMED. IN NO EVENT SHALL ANTHILLA S.R.L. BE LIABLE FOR ANY
    ///     DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    ///     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    ///     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ///     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    ///     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    ///     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    ///
    ///     20141110
    ///-------------------------------------------------------------------------------------*@

@inherits Nancy.ViewEngines.Razor.NancyRazorViewBase<dynamic>
@{Layout = "_layout.cshtml";}

@section PageBar {
}

@section MainContent {
    <div id="GaugeGraph" class="border-2-anthilla-gray">
        <h3 class="fg-white" style="margin-left: 10px;">label</h3>
    </div>
    <hr class="bg-2-anthilla-gray" />
    <table class="table">
        <thead>
            <tr>
                <td colspan="2">procs</td>
                <td colspan="4">memory</td>
                <td colspan="2">swap</td>
                <td colspan="2">io</td>
                <td colspan="2">system</td>
                <td colspan="5">cpu</td>
                <td colspan="2">timestamp</td>
            </tr>
            <tr>
                <td>r</td>
                <td>b</td>
                <td>swpd</td>
                <td>free</td>
                <td>buff</td>
                <td>cache</td>
                <td>si</td>
                <td>so</td>
                <td>bi</td>
                <td>bo</td>
                <td>in</td>
                <td>cs</td>
                <td>us</td>
                <td>sy</td>
                <td>id</td>
                <td>wa</td>
                <td>st</td>
                <td>date</td>
                <td>time</td>
            </tr>
        </thead>
        <tbody id="VMSTATS"></tbody>
    </table>
}

@section Scripts {
    <script src="/Scripts/d3.min.js" type="text/javascript"></script>
    <script type="text/javascript">
        // Set Up
        var pi = Math.PI, width = 500, height = 270; var iR = 170; var oR = 110;
        var cur_color = 'limegreen'; var new_color, hold; var max = 180, min = 0, current = 10;
        var arc = d3.svg.arc().innerRadius(iR).outerRadius(oR).startAngle(-90 * (pi / 180)); // Arc Defaults
        // Place svg element
        var svg = d3.select('#GaugeGraph').append('svg').attr('width', width).attr('height', height)
          .append('g').attr('transform', 'translate(' + ((width / 2) - 20) + ',' + ((height / 2) + 40) + ')')
        var background = svg.append('path').datum({ endAngle: 90 * (pi / 180) }).style('fill', '#ddd').attr('d', arc);// Append background arc to svg
        var foreground = svg.append('path').datum({ endAngle: -90 * (pi / 180) }).style('fill', cur_color).attr('d', arc); // Append foreground arc to svg
        var max = svg.append('text').attr('transform', 'translate(' + (iR + ((oR - iR) / 2)) + ',15)') // Display Max value
        .attr('text-anchor', 'middle').text(max) // Set between inner and outer Radius
        // Display Min value
        var min = svg.append('text').attr('transform', 'translate(' + -(iR + ((oR - iR) / 2)) + ',15)') // Set between inner and outer Radius
                    .attr('text-anchor', 'middle').text(min)
        // Display Current value
        var current = svg.append('text').attr('transform', 'translate(0,' + -(iR / 4) + ')') // Push up from center 1/4 of innerRadius
                    .attr('text-anchor', 'middle').style('font-size', '50').text(current)
        // Update every x seconds
        setInterval(function () {
            var num = Math.random() * 180; var numPi = Math.floor(num - 89) * (pi / 180);// Get value
            if (num >= 121) { new_color = 'red'; } else if (num >= 61) { new_color = 'orange'; } else { new_color = 'limegreen'; } // Get new color
            current.transition().text(Math.floor(num));// Text transition
            // Arc Transition
            foreground.transition().duration(750).styleTween('fill', function () { return d3.interpolate(new_color, cur_color); }).call(arcTween, numPi);
            // Set colors for next transition
            hold = cur_color; cur_color = new_color; new_color = hold;
        }, 1500); // Repeat every 1.5s
        function arcTween(transition, newAngle) {
            transition.attrTween('d', function (d) {
                var interpolate = d3.interpolate(d.endAngle, newAngle);
                return function (t) { d.endAngle = interpolate(t); return arc(d); };
            });
        } // Update animation

        //Procs
        //        r: The number of processes waiting for run time.
        //        b: The number of processes in uninterruptible sleep.
        //Memory
        //        swpd: the amount of virtual memory used.
        //        free: the amount of idle memory.
        //        buff: the amount of memory used as buffers.
        //        cache: the amount of memory used as cache.
        //===========================
        //        inact: the amount of inactive memory. (-a option)
        //        active: the amount of active memory. (-a option)
        //Swap
        //        si: Amount of memory swapped in from disk (/s).
        //        so: Amount of memory swapped to disk (/s).
        //IO
        //        bi: Blocks received from a block device (blocks/s).
        //        bo: Blocks sent to a block device (blocks/s).
        //System
        //        in: The number of interrupts per second, including the clock.
        //        cs: The number of context switches per second.
        //CPU
        //    These are percentages of total CPU time.
        //        us: Time spent running non-kernel code. (user time, including nice time)
        //        sy: Time spent running kernel code. (system time)
        //        id: Time spent idle. Prior to Linux 2.5.41, this includes IO-wait time.
        //        wa: Time spent waiting for IO. Prior to Linux 2.5.41, shown as zero.
        //Timestamp

        $(document).ready(function () {
            jQuery.support.cors = true;
            $.ajax({
                url: '/log/websocket/listen',
                type: 'POST'
            });
        });

        $(function () {
            var connection = $.hubConnection();
            var proxy = connection.createHubProxy('DataHub');
            connection.start();

            proxy.on('getData', function (data) {
                //console.log(data);
                var arr = data.trim().split(/ +/);
                var rowContent = "";
                $.each(arr, function (i, value) {
                    if (value.length > 0 && value != '') {
                        rowContent += '<td>' + value + '</td>';
                    }
                });
                var row = '<tr>' + rowContent + '</tr>';
                $('#VMSTATS').append(row);
            });
        });

        //var allTimeSeries = {};
        //var allValueLabels = {};

        //function streamStats() {
        //   //var ws = new ReconnectingWebSocket('ws://' + location.host + '/');
        //    var ws = new ReconnectingWebSocket('ws://10.1.3.193:30333/');
        //    var lineCount;
        //    var colHeadings;

        //    ws.onopen = function () {
        //        console.log('connect');
        //        lineCount = 0;
        //    };

        //    ws.onclose = function () {
        //        console.log('disconnect');
        //    };

        //    ws.onmessage = function (e) {
        //        console.log(e.data);
        //        switch (lineCount++) {
        //            case 0: // ignore first line
        //                break;

        //            case 1: // column headings
        //                colHeadings = e.data.trim().split(/ +/);
        //                break;

        //            default: // subsequent lines
        //                var colValues = e.data.trim().split(/ +/);
        //                var stats = {};
        //                for (var i = 0; i < colHeadings.length; i++) {
        //                    stats[colHeadings[i]] = parseInt(colValues[i]);
        //                }
        //                receiveStats(stats);
        //        }
        //    };
        //}

        //function receiveStats(stats) {
        //    Object.each(stats, function (name, value) {
        //        var timeSeries = allTimeSeries[name];
        //        if (timeSeries) {
        //            timeSeries.append(Date.now(), value);
        //            allValueLabels[name].text(value);
        //        }
        //    });
        //}

        //$(function () {
        //    streamStats();
        //});
    </script>
}